'use strict';

/**
 * Chip item custom element.
 */
JQX('jqx-chip', function (_JQX$ContentElement) {
    babelHelpers.inherits(Chip, _JQX$ContentElement);

    function Chip() {
        babelHelpers.classCallCheck(this, Chip);
        return babelHelpers.possibleConstructorReturn(this, (Chip.__proto__ || Object.getPrototypeOf(Chip)).apply(this, arguments));
    }

    babelHelpers.createClass(Chip, [{
        key: 'template',


        /**
         * Chip's HTML template.
         */
        value: function template() {
            return '<div id="container">\n                    <span id="avatar" class ="jqx-avatar">[[avatar]]</span><!--\n                --><span id="value" class ="jqx-value" inner-h-t-m-l="[[innerHTML]]"><content></content></span><!--\n                --><span id="closeButton" class ="jqx-close-button"></span>\n            </div>';
        }

        /**
        * Updates the Chip when a property is changed.
        * @param {string} propertyName The name of the property.
        * @param {number/string} oldValue The previously entered value.
        * @param {number/string} newValue The new entered value.
        */

    }, {
        key: 'propertyChangedHandler',
        value: function propertyChangedHandler(propertyName, oldValue, newValue) {
            babelHelpers.get(Chip.prototype.__proto__ || Object.getPrototypeOf(Chip.prototype), 'propertyChangedHandler', this).call(this, propertyName, oldValue, newValue);
            var that = this;

            switch (propertyName) {
                case 'disabled':
                case 'unfocusable':
                    that._setFocusable();
                    break;
                case 'avatar':
                    that.itemTemplate ? that._setAvatar(that._customAvatar) : that._setAvatar(that.$.avatar);
                    break;
                case 'itemTemplate':
                    that._applyTemplate();
                    break;
                case 'value':
                    if (that.itemTemplate) {
                        that._applyTemplate();
                    } else {
                        that.$.value.innerHTML = newValue || '';
                    }
                    break;
            }
        }
    }, {
        key: 'ready',
        value: function ready() {
            babelHelpers.get(Chip.prototype.__proto__ || Object.getPrototypeOf(Chip.prototype), 'ready', this).call(this);
            var that = this;

            that.value = that.value ? that.value : that.innerHTML;
            that._applyTemplate();
            that._setFocusable();
        }
    }, {
        key: 'close',
        value: function close() {
            var that = this;

            that.$.fireEvent('close', { 'value': that.value });
            that.parentElement.removeChild(that);
        }
    }, {
        key: '_applyTemplate',
        value: function _applyTemplate() {
            var that = this;
            var template = that.itemTemplate;

            if (!template) {
                that.$.value.innerHTML = that.value;
                that._setAvatar(that.$.avatar);

                return;
            }

            if (!('content' in document.createElement('template'))) {
                that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() }));
                return;
            }

            if (!(template instanceof HTMLTemplateElement)) {
                template = document.getElementById(template);
            }

            if (template === null || !('content' in template)) {
                that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase() }));
                return;
            }

            var templateContent = template.innerHTML;

            that.$.container.innerHTML = templateContent.replace(/{{\s*value\s*}}/g, that.value);
            that._customAvatar = that.$.container.querySelector('.jqx-avatar');
            that._setAvatar(that._customAvatar);
        }
    }, {
        key: '_clickHandler',
        value: function _clickHandler(event) {
            var that = this;

            if (that.disabled) {
                return;
            }

            var target = that.enableShadowDOM ? that.shadowRoot.elementFromPoint(event.pageX, event.pageY) : event.target;

            if (!target.closest || !target.closest('.jqx-close-button')) {
                return;
            }

            that.close();
        }

        /**
         * KeyDown handler.
         */

    }, {
        key: '_keyDownHandler',
        value: function _keyDownHandler(event) {
            var that = this;

            var key = event.key;

            if (that.disabled || that.readonly || key !== 'Delete') {
                return;
            }

            that.close();
        }
    }, {
        key: '_setAvatar',
        value: function _setAvatar(element) {
            if (!element) {
                return;
            }

            var that = this,
                isAvatarImage = /\.(gif|jpg|jpeg|tiff|png)$/i.test(that.avatar);

            element.innerHTML = isAvatarImage ? '<img src="' + that.avatar + '" />' : that.avatar || '';
        }

        /**
        * Set tabIndex.
        */

    }, {
        key: '_setFocusable',
        value: function _setFocusable() {
            var that = this;

            if (that.disabled || that.unfocusable) {
                that.removeAttribute('tabindex');
                return;
            }

            that.tabIndex = that.tabIndex > 0 ? that.tabIndex : 0;
        }
    }], [{
        key: 'properties',

        // Chip item's properties.
        get: function get() {
            return {
                'avatar': {
                    value: null,
                    type: 'string?'
                },
                'closeButton': {
                    value: false,
                    type: 'boolean'
                },
                'itemTemplate': {
                    value: null,
                    type: 'any?',
                    reflectToAttribute: false
                },
                'value': {
                    value: '',
                    type: 'string'
                }
            };
        }

        /**
         * Chip item's event listeners.
         */

    }, {
        key: 'listeners',
        get: function get() {
            return {
                'click': '_clickHandler',
                'keydown': '_keyDownHandler'
            };
        }

        /**
        * CSS files needed for the element (ShadowDOM)
        */

    }, {
        key: 'styleUrls',
        get: function get() {
            return ['jqx.chip.css'];
        }
    }]);
    return Chip;
}(JQX.ContentElement));