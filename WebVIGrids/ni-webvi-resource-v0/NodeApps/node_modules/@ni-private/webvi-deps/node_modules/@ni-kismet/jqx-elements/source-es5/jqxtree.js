'use strict';

/**
 * Tree Item custom element.
 */
JQX('jqx-tree-item', function (_JQX$MenuItem) {
    babelHelpers.inherits(TreeItem, _JQX$MenuItem);

    function TreeItem() {
        babelHelpers.classCallCheck(this, TreeItem);
        return babelHelpers.possibleConstructorReturn(this, (TreeItem.__proto__ || Object.getPrototypeOf(TreeItem)).apply(this, arguments));
    }

    babelHelpers.createClass(TreeItem, [{
        key: 'ready',
        value: function ready() {
            Object.defineProperty(this, 'hasStyleObserver', {
                get: function get() {
                    return false;
                }
            });

            babelHelpers.get(TreeItem.prototype.__proto__ || Object.getPrototypeOf(TreeItem.prototype), 'ready', this).call(this);
        }
    }, {
        key: 'propertyChangedHandler',
        value: function propertyChangedHandler(propertyName, oldValue, newValue) {
            var that = this,
                parentTree = that.menu;

            if (propertyName === 'level') {
                that.level = oldValue;
                return;
            }

            if (propertyName === 'disabled' || propertyName === 'separator' || !parentTree) {
                return;
            }

            var oldContext = parentTree.context;

            parentTree.context = parentTree;

            switch (propertyName) {
                case 'label':
                    {
                        var restoreSorting = parentTree.sorted && parentTree.autoSort;

                        that.firstElementChild.firstElementChild.firstElementChild.innerHTML = newValue;

                        if (restoreSorting) {
                            parentTree._unsortItems(parentTree.$.mainContainer);
                            parentTree._applyGrouping(parentTree.$.mainContainer);
                        }

                        if (parentTree._state.filter) {
                            parentTree._applyFilter(parentTree._state.filter);
                        }

                        break;
                    }
                case 'selected':
                    that.selected = oldValue;

                    if (newValue) {
                        parentTree.select(that);
                    } else {
                        parentTree.unselect(that);
                    }

                    break;
                case 'shortcut':
                    {
                        var shortcutElement = that.firstElementChild.children[1];

                        if (!shortcutElement) {
                            shortcutElement = document.createElement('div');
                            shortcutElement.className = 'jqx-tree-item-shortcut';
                            that.firstElementChild.appendChild(shortcutElement);
                        }

                        shortcutElement.innerHTML = newValue;
                        break;
                    }
                case 'value':
                    if (parentTree.sort && parentTree.sorted && parentTree.autoSort) {
                        parentTree._refreshSorting();
                    }

                    break;
            }

            parentTree.context = oldContext;
        }
    }], [{
        key: 'properties',

        // Tree Item's properties.
        get: function get() {
            return {
                'selected': {
                    value: false,
                    type: 'boolean'
                }
            };
        }
    }]);
    return TreeItem;
}(JQX.MenuItem));

/**
 * Tree Items Group custom element.
 */
JQX('jqx-tree-items-group', function (_JQX$MenuItemsGroup) {
    babelHelpers.inherits(TreeItemsGroup, _JQX$MenuItemsGroup);

    function TreeItemsGroup() {
        babelHelpers.classCallCheck(this, TreeItemsGroup);
        return babelHelpers.possibleConstructorReturn(this, (TreeItemsGroup.__proto__ || Object.getPrototypeOf(TreeItemsGroup)).apply(this, arguments));
    }

    babelHelpers.createClass(TreeItemsGroup, [{
        key: 'ready',
        value: function ready() {
            Object.defineProperty(this, 'hasStyleObserver', {
                get: function get() {
                    return false;
                }
            });

            babelHelpers.get(TreeItemsGroup.prototype.__proto__ || Object.getPrototypeOf(TreeItemsGroup.prototype), 'ready', this).call(this);
        }
    }, {
        key: 'propertyChangedHandler',
        value: function propertyChangedHandler(propertyName, oldValue, newValue) {
            var that = this,
                parentTree = that.menu;

            if (propertyName === 'level') {
                that.level = oldValue;
                return;
            }

            if (propertyName === 'disabled' || propertyName === 'separator' || !parentTree) {
                return;
            }

            var oldContext = parentTree.context;

            parentTree.context = parentTree;

            switch (propertyName) {
                case 'expanded':
                    {
                        that.expanded = oldValue;

                        if (newValue) {
                            parentTree.expandItem(that);
                        } else {
                            parentTree.collapseItem(that);
                        }

                        break;
                    }
                case 'label':
                    {
                        var restoreSorting = parentTree.sorted && parentTree.autoSort;

                        that.firstElementChild.firstElementChild.firstElementChild.innerHTML = newValue;

                        if (restoreSorting) {
                            parentTree._unsortItems(parentTree.$.mainContainer);
                            parentTree._applyGrouping(parentTree.$.mainContainer);
                        }

                        if (parentTree._state.filter) {
                            parentTree._applyFilter(parentTree._state.filter);
                        }

                        break;
                    }
                case 'selected':
                    that.selected = oldValue;

                    if (newValue) {
                        parentTree.select(that);
                    } else {
                        parentTree.unselect(that);
                    }

                    break;
                case 'value':
                    if (parentTree.sort && parentTree.sorted && parentTree.autoSort) {
                        parentTree._refreshSorting();
                    }

                    break;
            }

            parentTree.context = oldContext;
        }
    }], [{
        key: 'properties',

        // Tree Items Group's properties.
        get: function get() {
            return {
                'selected': {
                    value: false,
                    type: 'boolean'
                }
            };
        }
    }]);
    return TreeItemsGroup;
}(JQX.MenuItemsGroup));

/**
 * Tree custom element.
 */
JQX('jqx-tree', function (_JQX$Menu) {
    babelHelpers.inherits(Tree, _JQX$Menu);

    function Tree() {
        babelHelpers.classCallCheck(this, Tree);
        return babelHelpers.possibleConstructorReturn(this, (Tree.__proto__ || Object.getPrototypeOf(Tree)).apply(this, arguments));
    }

    babelHelpers.createClass(Tree, [{
        key: 'template',


        /**
         * Tree's HTML template.
         */
        value: function template() {
            return '<div id="container">\n                    <div class="jqx-tree-filter-input-container">\n                        <input id="filterInput" class="jqx-filter-input" disabled="[[disabled]]" placeholder="[[filterInputPlaceholder]]" type="text" />\n                    </div>\n                    <jqx-repeat-button id="scrollButtonNear" class="jqx-tree-scroll-button jqx-spin-button jqx-scroll-button-near jqx-hidden" animation="[[animation]]" unfocusable>\n                        <div id="arrowNear" class="jqx-arrow jqx-arrow-up"></div>\n                    </jqx-repeat-button>\n                    <jqx-scroll-viewer id="scrollViewer" animation="[[animation]]" horizontal-scroll-bar-visibility="hidden" right-to-left="[[right-to-left]]">\n                        <div id="mainContainer" class="jqx-tree-main-container">\n                            <content></content>\n                        </div>\n                        <input type="text" id="editInput" class="jqx-tree-edit-input jqx-hidden" />\n                    </jqx-scroll-viewer>\n                    <jqx-repeat-button id="scrollButtonFar" class="jqx-tree-scroll-button jqx-spin-button jqx-scroll-button-far jqx-hidden" animation="[[animation]]" unfocusable>\n                        <div id="arrowFar" class="jqx-arrow jqx-arrow-down"></div>\n                    </jqx-repeat-button>\n                    <div id="loadingIndicatorContainer" class="jqx-loader-container jqx-hidden">\n                        <span id="loadingIndicator" class="jqx-loader"></span>\n                        <span id="loadingIndicatorPlaceHolder" class="jqx-loader-label jqx-hidden">[[loadingIndicatorPlaceholder]]</span>\n                    </div>\n                </div>';
        }

        /**
         * Adds an item after another item as a sibling.
         *
         * @param {HTMLElement} item A jqx-tree-item/jqx-tree-items-group to add to the Tree.
         * @param {HTMLElement/String} sibling The jqx-tree-item/jqx-tree-items-group (or its id or numeric path) to add the item after.
         */

    }, {
        key: 'addAfter',
        value: function addAfter(item, sibling) {
            var that = this;

            sibling = that.getItem(sibling);

            if (sibling === undefined) {
                return;
            }

            that.addTo(item, sibling.parentItem, sibling, true);
        }

        /**
         * Adds an item before another item as a sibling.
         *
         * @param {HTMLElement} item A jqx-tree-item/jqx-tree-items-group to add to the Tree.
         * @param {HTMLElement/String} sibling The jqx-tree-item/jqx-tree-items-group (or its id or numeric path) to add the item before.
         */

    }, {
        key: 'addBefore',
        value: function addBefore(item, sibling) {
            var that = this;

            sibling = that.getItem(sibling);

            if (sibling === undefined) {
                return;
            }

            that.addTo(item, sibling.parentItem, sibling);
        }

        /**
         * Adds an item as the last child of a parent item.
         *
         * @param {HTMLElement} item A jqx-tree-item/jqx-tree-items-group to add to the Tree.
         * @param {HTMLElement/String} parent Optional The jqx-tree-items-group (or its id or numeric path) to add the item to.
         */

    }, {
        key: 'addTo',
        value: function addTo(item, parent) {
            var that = this;

            if (!(item instanceof JQX.TreeItem || item instanceof JQX.TreeItemsGroup)) {
                return;
            }

            var level = void 0,
                container = void 0;

            if (parent === undefined) {
                parent = that.$.mainContainer;
                level = 1;
                container = parent;
            } else {
                parent = that.getItem(parent);

                if (parent instanceof JQX.TreeItemsGroup === false) {
                    return;
                }

                level = parent.level + 1;
                container = parent.itemContainer;
            }

            that._createItemHTMLStructure(item, level, parent, container.childElementCount, 0);

            var restoreSorting = that.sorted && that.autoSort,
                filterQuery = that._state.filter,
                oldSelectedIndexes = that.selectedIndexes.slice(0);

            if (restoreSorting) {
                that._unsortItems(that.$.mainContainer);
            }

            if (item instanceof JQX.TreeItemsGroup) {
                that._processHTML(item, level + 1, false);
            }

            var sibling = arguments[2];

            if (sibling && arguments[3]) {
                sibling = sibling.nextElementSibling;
            }

            if (sibling) {
                container.insertBefore(item, sibling);
                that._menuItems = {};
                that._refreshItemPaths(that.$.mainContainer, true, undefined, that.sorted && !that.autoSort);
            } else {
                container.appendChild(item);
            }

            if (restoreSorting) {
                that._applyGrouping(that.$.mainContainer);
            }

            if (filterQuery) {
                that._applyFilter(filterQuery);
            }

            that._checkOverflow();
            that._expandItemsByDefault();

            that.selectedIndexes = [];
            that._applySelection(true, oldSelectedIndexes);
        }

        /**
         * Clears selection.
         */

    }, {
        key: 'clearSelection',
        value: function clearSelection() {
            var that = this,
                oldSelectedIndexes = that.selectedIndexes.slice(0);

            that.selectedIndexes = [];
            that._applySelection(false, oldSelectedIndexes);
        }

        /**
         * Collapses all items.
         *
         * @param {Boolean} animation Optional If set to false, disables collapse animation even if animation is enabled for the element.
         */

    }, {
        key: 'collapseAll',
        value: function collapseAll(animation) {
            var that = this,
                animationType = that.animation,
                restoreAnimation = animation === false && that.hasAnimation;

            if (restoreAnimation) {
                that.animation = 'none';
            }

            that._collapseAll(true);

            if (restoreAnimation) {
                that.animation = animationType;
            }
        }

        /**
         * Makes sure an item is visible by scrolling to it.
         *
         * @param {HTMLElement/String} item jqx-tree-item/jqx-tree-items-group (or its id or numeric path).
         */

    }, {
        key: 'ensureVisible',
        value: function ensureVisible(item) {
            var that = this;

            item = that.getItem(item);

            if (item === undefined || item.hidden) {
                return;
            }

            var animation = false;

            if (item.level > 1 && !that._isBranchExpanded(item)) {
                babelHelpers.get(Tree.prototype.__proto__ || Object.getPrototypeOf(Tree.prototype), 'expandItem', this).call(this, item.parentItem, undefined, false);
                animation = that.hasAnimation;

                if (animation) {
                    that._ensureVisibleOnTransitionend = item;
                }
            }

            if (!animation) {
                that._ensureVisible(item);
            }
        }

        /**
         * Expands all items.
         *
         * @param {Boolean} animation Optional If set to false, disables expand animation even if animation is enabled for the element.
         */

    }, {
        key: 'expandAll',
        value: function expandAll(animation) {
            var that = this,
                animationType = that.animation,
                restoreAnimation = animation === false && that.hasAnimation;
            var level = 1,
                treeItemsGroups = (that.enableShadowDOM ? that.shadowRoot : that).querySelectorAll('jqx-tree-items-group[level="1"]');

            if (restoreAnimation) {
                that.animation = 'none';
            }

            while (treeItemsGroups.length > 0) {
                for (var i = 0; i < treeItemsGroups.length; i++) {
                    var currentTreeItemsGroup = treeItemsGroups[i];

                    if (currentTreeItemsGroup.expanded) {
                        continue;
                    }

                    that._menuItemsGroupSelectionHandler(currentTreeItemsGroup, { target: currentTreeItemsGroup, type: 'expand' });
                }

                level++;
                treeItemsGroups = (that.enableShadowDOM ? that.shadowRoot : that).querySelectorAll('jqx-tree-items-group[level="' + level + '"]');
            }

            if (restoreAnimation) {
                that.animation = animationType;
            }
        }

        /**
         * Expands an item.
         *
         * @param {HTMLElement/String} item jqx-tree-item/jqx-tree-items-group (or its id or numeric path).
         * @param {Boolean} animation Optional If set to false, disables expand animation even if animation is enabled for the element.
         */

    }, {
        key: 'expandItem',
        value: function expandItem(item, animation) {
            var that = this;

            item = that.getItem(item);

            if (item === undefined || item instanceof JQX.TreeItemsGroup === false || that._isContainerOpened(item.container.level, item.container)) {
                return;
            }

            var restoreAnimation = animation === false && that.hasAnimation,
                animationType = that.animation;

            if (restoreAnimation) {
                that.animation = 'none';
            }

            that._discardKeyboardHover();

            that._menuItemsGroupSelectionHandler(item, { target: item, type: 'expand' }, arguments[2]);

            if (restoreAnimation) {
                that.animation = animationType;
            }
        }

        /**
         * Filters the Tree.
         *
         * @param {String} filterQuery Filter query.
         */

    }, {
        key: 'filter',
        value: function filter(filterQuery) {
            var that = this;

            if (that.filterable) {
                that._applyFilter(filterQuery);
                that.$.filterInput.value = filterQuery;
            }
        }

        /**
         * Gets the Tree's state.
         */

    }, {
        key: 'getState',
        value: function getState() {
            return JSON.parse(JSON.stringify(this._state));
        }

        /**
         * Inserts an item at the given position.
         * 
         * @param {HTMLElement/Object} item A jqx-tree-item/jqx-tree-items-group (or an Object to create an item from) to add to the Tree.
         * @param {String} path Optional The path to insert the item at.
         */

    }, {
        key: 'insert',
        value: function insert(item, path) {
            var that = this;
            var element = void 0;

            function createTreeItem(item) {
                var subItems = item[that.itemsMember] || [],
                    tagName = item.tagName === 'jqx-tree-items-group' || subItems.length > 0 ? 'jqx-tree-items-group' : 'jqx-tree-item',
                    element = document.createElement(tagName);

                if (item.disabled) {
                    element.disabled = true;
                }

                if (item[that.displayMember]) {
                    element.label = item[that.displayMember];
                }

                if (item.separator) {
                    element.separator = true;
                }

                if (item[that.valueMember]) {
                    element.value = item[that.valueMember];
                }

                if (tagName === 'jqx-tree-items-group') {
                    if (item.expanded) {
                        element.expanded = true;
                    }

                    for (var i = 0; i < subItems.length; i++) {
                        element.appendChild(createTreeItem(subItems[i]));
                    }
                } else if (item.shortcut) {
                    element.shortcut = item.shortcut;
                }

                return element;
            }

            if (item instanceof JQX.TreeItem || item instanceof JQX.TreeItemsGroup) {
                if (that.contains(item)) {
                    return;
                }

                element = item;
            } else if ((typeof item === 'undefined' ? 'undefined' : babelHelpers.typeof(item)) === 'object' && item.constructor === Object) {
                element = createTreeItem(item);
            } else {
                return;
            }

            if (path === undefined) {
                that.addTo(element);
                return;
            }

            if (typeof path === 'number') {
                path = path.toString();
            } else if (path instanceof JQX.TreeItem || path instanceof JQX.TreeItemsGroup) {
                if (!that.contains(path)) {
                    return;
                }

                path = path.path;
            } else if (typeof path !== 'string') {
                return;
            }

            var pathParts = path.split('.');
            var parent = void 0,
                sibling = void 0;

            if (pathParts.length === 1) {
                sibling = that._menuItems[pathParts[0]];

                if (!sibling) {
                    that.addTo(element);
                } else {
                    that.addBefore(element, sibling);
                }
            } else {
                sibling = that._menuItems[path];
                parent = that._menuItems[pathParts.slice(0, pathParts.length - 1).join('.')];

                if (sibling) {
                    that.addBefore(element, sibling);
                } else if (parent && parent instanceof JQX.TreeItemsGroup) {
                    that.addTo(element, parent);
                }
            }
        }

        /**
         * Loads the Tree's state.
         *
         * @param {Object} state Optional An object returned by one of the methods getState or saveState.
         */

    }, {
        key: 'loadState',
        value: function loadState(state) {
            var that = this,
                oldSelectedIndexes = that.selectedIndexes.slice(0),
                selectedIndexes = [];

            if (!state) {
                if (!that.id) {
                    that.warn(that.localize('noId'));
                    return;
                }

                state = window.localStorage.getItem('jqxTree' + that.id);
            }

            if (typeof state === 'string') {
                state = JSON.parse(state);
            }

            if (state.filter && !that.filterable) {
                state.filter = '';
            }

            var filteringChanged = state.filter !== that._state.filter,
                sortingChanged = state.sorted !== that.sorted;

            if (sortingChanged) {
                that.sorted = state.sorted;
                that._updateState('sorted', that.sorted);

                if (state.sorted) {
                    that._applyGrouping(that.$.mainContainer);
                } else {
                    that._unsortItems(that.$.mainContainer);
                }

                if (state.filter || filteringChanged) {
                    that._applyFilter(state.filter);
                    that.$.filterInput.value = state.filter;
                }
            } else if (filteringChanged) {
                that._applyFilter(state.filter);
                that.$.filterInput.value = state.filter;
            }

            that._menuItemsGroupsToExpand = [];

            for (var i = 0; i < state.expanded.length; i++) {
                var originallyExpandedItem = that.getItem(state.expanded[i]);

                if (originallyExpandedItem) {
                    that._menuItemsGroupsToExpand.push(originallyExpandedItem);
                }
            }

            that._expandItemsByDefault(true);

            for (var _i = 0; _i < state.selected.length; _i++) {
                var originallySelectedItem = that.getItem(state.selected[_i]);

                if (originallySelectedItem) {
                    selectedIndexes.push(originallySelectedItem.path);
                }
            }

            that.selectedIndexes = selectedIndexes;
            that._applySelection(false, oldSelectedIndexes);
        }

        /**
         * Moves an item down relative to its siblings.
         *
         * @param {HTMLElement/String} item The jqx-tree-item/jqx-tree-items-group (or its id or numeric path) to remove.
         */

    }, {
        key: 'moveDown',
        value: function moveDown(item) {
            var that = this;

            item = that.getItem(item);

            var nextSibling = item.nextElementSibling;

            if (item === undefined || !nextSibling || that.sorted) {
                return;
            }

            that._moveTreeItem(item, nextSibling, 2, [that]);

            if (that.filterable && that._state.filter) {
                that._applyFilter(that._state.filter);
            }
        }

        /**
         * Moves an item up relative to its siblings.
         *
         * @param {HTMLElement/String} item The jqx-tree-item/jqx-tree-items-group (or its id or numeric path) to remove.
         */

    }, {
        key: 'moveUp',
        value: function moveUp(item) {
            var that = this;

            item = that.getItem(item);

            var previousSibling = item.previousElementSibling;

            if (item === undefined || !previousSibling || that.sorted) {
                return;
            }

            that._moveTreeItem(item, previousSibling, 0, [that]);

            if (that.filterable && that._state.filter) {
                that._applyFilter(that._state.filter);
            }
        }

        /**
         * Refreshes the layout of the Tree
         */

    }, {
        key: 'refresh',
        value: function refresh() {
            this._checkOverflow();
        }

        /**
         * Removes an item.
         *
         * @param {HTMLElement/String} item The jqx-tree-item/jqx-tree-items-group (or its id or numeric path) to remove.
         */

    }, {
        key: 'removeItem',
        value: function removeItem(item) {
            var that = this;

            item = that.getItem(item);

            if (item === undefined) {
                return;
            }

            if (item instanceof JQX.TreeItemsGroup) {
                var container = item.container;

                if (that._isContainerOpened(container.level, container)) {
                    that._closeSubContainersTreeMode(container.level, container);
                }
            }

            var restoreSorting = that.sorted && that.autoSort;

            if (restoreSorting) {
                that._unsortItems(that.$.mainContainer);
            }

            item.parentElement.removeChild(item);
            that._menuItems = {};
            that._refreshItemPaths(that.$.mainContainer, true, undefined, that.sorted && !that.autoSort);

            if (restoreSorting) {
                that._applyGrouping(that.$.mainContainer);
            }

            var filterQuery = that._state.filter,
                oldSelectedIndexes = that.selectedIndexes.slice(0);

            if (filterQuery) {
                that._applyFilter(filterQuery);
            }

            that._checkOverflow();

            that.selectedIndexes = [];
            that._applySelection(true, oldSelectedIndexes);
        }

        /**
         * Saves the Tree's state.
         */

    }, {
        key: 'saveState',
        value: function saveState() {
            var that = this;

            if (!that.id) {
                that.warn(that.localize('noId'));
            } else {
                window.localStorage.setItem('jqxTree' + that.id, JSON.stringify(that._state));
            }

            return JSON.parse(JSON.stringify(that._state));
        }

        /**
         * Selects an item.
         *
         * @param {HTMLElement/String} item jqx-tree-item/jqx-tree-items-group (or its id or numeric path).
         */

    }, {
        key: 'select',
        value: function select(item) {
            var that = this;

            item = that.getItem(item);

            if (item === undefined || item.selected || item.templateApplied) {
                return;
            }

            that._handleSelection(item, { type: 'programmatic' });
        }

        /**
         * Unselects an item.
         *
         * @param {HTMLElement/String} item jqx-tree-item/jqx-tree-items-group (or its id or numeric path).
         */

    }, {
        key: 'unselect',
        value: function unselect(item) {
            var that = this;

            item = that.getItem(item);

            if (item === undefined || !item.selected || item.templateApplied) {
                return;
            }

            that._handleSelection(item, { type: 'programmatic' });
        }

        /**
         * Updates an item.
         *
         * @param {HTMLElement/String} item jqx-tree-item/jqx-tree-items-group (or its id or numeric path).
         * @param {Object} newItem An object with updated properties.
         */

    }, {
        key: 'updateItem',
        value: function updateItem(item, newItem) {
            var that = this;

            item = that.getItem(item);

            if (item === undefined || newItem === undefined) {
                return;
            }

            var treeItem = item instanceof JQX.TreeItem;

            for (var prop in newItem) {
                if (newItem.hasOwnProperty(prop)) {
                    if (treeItem) {
                        if (['disabled', 'label', 'level', 'selected', 'separator', 'shortcut', 'value'].indexOf(prop) === -1) {
                            continue;
                        }
                    } else if (['disabled', 'expanded', 'label', 'level', 'selected', 'separator', 'value'].indexOf(prop) === -1) {
                        continue;
                    }

                    item[prop] = newItem[prop];
                }
            }
        }

        /**
         * Called when a property is changed.
         */

    }, {
        key: 'propertyChangedHandler',
        value: function propertyChangedHandler(propertyName, oldValue, newValue) {
            var that = this;

            switch (propertyName) {
                case 'allowDrag':
                case 'allowDrop':
                case 'autoLoadState':
                case 'autoSort':
                case 'editable':
                case 'filterInputPlaceholder':
                case 'loadingIndicatorPlaceholder':
                case 'selectionDisplayMode':
                case 'showLines':
                case 'showRootLines':
                case 'toggleElementPosition':
                case 'toggleMode':
                    break;
                case 'autoHideToggleElement':
                    if (newValue) {
                        that.$mainContainer.addClass('hidden-arrows');
                    } else {
                        that.$mainContainer.removeClass('hidden-arrows');
                    }

                    break;
                case 'autoSaveState':
                    if (!newValue) {
                        return;
                    }

                    if (!that.id) {
                        that.warn(that.localize('noId'));
                        that.autoSaveState = false;
                        return;
                    }

                    window.localStorage.setItem('jqxTree' + that.id, JSON.stringify(that._state));
                    break;
                case 'dataSource':
                    {
                        var oldSelectedIndexes = that.selectedIndexes.slice(0);

                        that.selectedIndexes = [];
                        that._menuItems = {};
                        that._processDataSource();
                        that._checkOverflow();
                        that._expandItemsByDefault();
                        that._applySelection(true, oldSelectedIndexes);

                        var filterQuery = that._state.filter;

                        if (filterQuery) {
                            that._applyFilter(filterQuery);
                        }

                        break;
                    }
                case 'disabled':
                    that._setFocusable();
                    that.$.scrollButtonNear.disabled = newValue;
                    that.$.scrollButtonFar.disabled = newValue;

                    if (!newValue) {
                        that._updateScrollButtonVisibility();
                    }

                    break;
                case 'displayLoadingIndicator':
                    if (newValue) {
                        that._discardKeyboardHover(true);
                        that.$loadingIndicatorContainer.removeClass('jqx-hidden');
                    } else {
                        that.$loadingIndicatorContainer.addClass('jqx-hidden');
                    }

                    break;
                case 'filterable':
                    if (newValue === false) {
                        that._applyFilter('');
                        that.$.filterInput.value = '';
                    }

                    that._checkOverflow();
                    break;
                case 'filterMode':
                    if (that.filterable && that._state.filter) {
                        that._applyFilter(that._state.filter);
                    }

                    break;
                case 'hasThreeStates':
                    if (that.selectionMode !== 'checkBox') {
                        return;
                    }

                    if (newValue) {
                        that._applySelection(false);
                    } else {
                        var indeterminateItems = (that.enableShadowDOM ? that.shadowRoot : that).querySelectorAll('[indeterminate]');

                        for (var i = 0; i < indeterminateItems.length; i++) {
                            indeterminateItems[i].removeAttribute('indeterminate');
                        }
                    }

                    break;
                case 'loadingIndicatorPosition':
                    if (newValue === 'center') {
                        that.$loadingIndicatorPlaceHolder.addClass('jqx-hidden');
                    } else {
                        that.$loadingIndicatorPlaceHolder.removeClass('jqx-hidden');
                    }

                    break;
                case 'overflow':
                    if (that.scrollMode === 'scrollbar') {
                        if (newValue === 'scroll') {
                            that.$.scrollViewer.verticalScrollBarVisibility = 'visible';
                        } else {
                            that.$.scrollViewer.verticalScrollBarVisibility = 'auto';
                        }

                        return;
                    }

                    that.$.scrollViewer.scrollTop = 0;

                    if (newValue === 'hidden') {
                        that.$scrollViewer.removeClass('scroll-buttons-shown');
                        that.$scrollButtonNear.addClass('jqx-hidden');
                        that.$scrollButtonFar.addClass('jqx-hidden');
                    } else {
                        that.$.scrollButtonNear.disabled = that.disabled;
                        that.$.scrollButtonFar.disabled = that.disabled;

                        if (newValue === 'auto') {
                            that.$scrollButtonNear.addClass('jqx-hidden');
                            that.$scrollButtonFar.addClass('jqx-hidden');
                            that._checkOverflow();
                        } else {
                            that.$scrollViewer.addClass('scroll-buttons-shown');
                            that.$scrollViewer.removeClass('one-button-shown');
                            that.$scrollButtonNear.removeClass('jqx-hidden');
                            that.$scrollButtonFar.removeClass('jqx-hidden');
                            that._updateScrollButtonVisibility();
                        }
                    }

                    that.$.scrollViewer.refresh();
                    break;
                case 'rightToLeft':
                    {
                        var oldPadding = void 0,
                            newPadding = void 0;

                        if (newValue) {
                            oldPadding = 'paddingLeft';
                            newPadding = 'paddingRight';
                        } else {
                            oldPadding = 'paddingRight';
                            newPadding = 'paddingLeft';
                        }

                        for (var path in that._menuItems) {
                            if (that._menuItems.hasOwnProperty(path)) {
                                var item = that._menuItems[path],
                                    labelContainer = item.firstElementChild;

                                labelContainer.style[oldPadding] = '';
                                that._setIndentation(labelContainer, item.level, newPadding);
                            }
                        }

                        break;
                    }
                case 'scrollMode':
                    if (that.overflow === 'hidden') {
                        return;
                    }

                    that.$.scrollViewer.scrollTop = 0;

                    if (newValue === 'scrollButtons') {
                        if (that.overflow === 'scroll') {
                            that.$scrollViewer.addClass('scroll-buttons-shown');
                            that.$scrollButtonNear.removeClass('jqx-hidden');
                            that.$scrollButtonFar.removeClass('jqx-hidden');
                        }

                        that.$.scrollViewer.verticalScrollBarVisibility = 'auto';
                        that._checkOverflow();
                        return;
                    }

                    that.$scrollViewer.removeClass('scroll-buttons-shown');
                    that.$scrollViewer.removeClass('one-button-shown');
                    that.$scrollButtonNear.addClass('jqx-hidden');
                    that.$scrollButtonFar.addClass('jqx-hidden');

                    if (that.overflow === 'auto') {
                        that.$.scrollViewer.verticalScrollBarVisibility = 'auto';
                    } else {
                        that.$.scrollViewer.verticalScrollBarVisibility = 'visible';
                    }

                    break;
                case 'selectedIndexes':
                    that._applySelection(false, oldValue);
                    break;
                case 'selectionMode':
                    if (that._menuItems['0'] === undefined) {
                        return;
                    }

                    if (oldValue === 'one' && newValue !== 'none' && newValue !== 'checkBox' && newValue !== 'radioButton' || oldValue.indexOf('oneOrMany') !== -1 && newValue.indexOf('oneOrMany') !== -1 || oldValue === 'none' && (newValue.indexOf('zero') !== -1 || newValue === 'checkBox') || newValue === 'zeroOrMany' && oldValue !== 'checkBox' || oldValue === 'radioButton' && newValue.indexOf('Many') !== -1 || !that.hasThreeStates && (newValue === 'checkBox' || oldValue === 'checkBox' && newValue === 'zeroOrMany')) {

                        if (newValue === 'one' || newValue === 'oneOrManyExtended') {
                            that._lastSelectedItem = that._menuItems[that.selectedIndexes[that.selectedIndexes.length - 1]];
                        } else {
                            that._lastSelectedItem = undefined;
                        }

                        return;
                    }

                    if (that.hasThreeStates && oldValue === 'checkBox') {
                        var _indeterminateItems = (that.enableShadowDOM ? that.shadowRoot : that).querySelectorAll('[indeterminate]');

                        for (var _i2 = 0; _i2 < _indeterminateItems.length; _i2++) {
                            _indeterminateItems[_i2].removeAttribute('indeterminate');
                        }
                    }

                    that._applySelection(false);
                    break;
                case 'sort':
                    {
                        if (!that.sorted) {
                            return;
                        }

                        that._refreshSorting();
                        break;
                    }
                case 'sortDirection':
                    if (that.sorted && !that.sort) {
                        that._unsortItems(that.$.mainContainer);
                        that._applyGrouping(that.$.mainContainer);
                    }

                    break;
                case 'sorted':
                    {
                        if (!newValue && !that.autoSort) {
                            that._refreshItemPathsAndSelection();
                            that._updateState('sorted', false);
                            return;
                        }

                        if (newValue) {
                            that._applyGrouping(that.$.mainContainer);
                        } else {
                            that._unsortItems(that.$.mainContainer);
                        }

                        var _filterQuery = that._state.filter;

                        if (_filterQuery) {
                            that._applyFilter(_filterQuery);
                        }

                        that._updateState('sorted', newValue);
                        that._checkOverflow();
                        break;
                    }
                case 'unfocusable':
                    that._setFocusable();
                    break;
            }
        }

        /**
         * Adds drag feedback.
         */

    }, {
        key: '_addDragFeedback',
        value: function _addDragFeedback() {
            var that = this,
                feedback = document.createElement('div');

            feedback.className = 'jqx-tree-item-feedback';
            feedback.setAttribute('parent-tree-id', that.id);

            if (that.theme) {
                feedback.classList.add(that.theme);
            }

            if (that.dragFeedbackFormatFunction) {
                feedback.innerHTML = that.dragFeedbackFormatFunction(that._dragDetails.Items);
            } else if (that._dragDetails.Items.length === 1) {
                feedback.innerHTML = that._dragDetails.Item.label;
            } else {
                feedback.classList.add('multiple');
                feedback.innerHTML = '&#xf0c5;';
            }

            document.body.appendChild(feedback);
            return feedback;
        }

        /**
         * Applies filter.
         */

    }, {
        key: '_applyFilter',
        value: function _applyFilter(filterQuery) {
            var that = this;

            function hide(filteredItem, item) {
                if (filteredItem) {
                    if (item.hidden) {
                        item.$.removeClass('jqx-hidden');
                    }

                    item.hidden = false;
                } else {
                    if (!item.hidden) {
                        item.$.addClass('jqx-hidden');
                    }

                    item.hidden = true;
                }
            }

            function filter(item, childItems) {
                var shownChildren = false,
                    numberOfShownChildren = 0,
                    lastShownChild = void 0;

                childItems = Array.from(childItems);

                // filter children
                for (var i = 0; i < childItems.length; i++) {
                    var currentChild = childItems[i];

                    if (currentChild instanceof JQX.TreeItem) {
                        hide(that._findItem(currentChild, filterQuery), currentChild);
                    } else {
                        filter(currentChild, currentChild.itemContainer.children);
                    }

                    if (!currentChild.hidden) {
                        numberOfShownChildren++;
                        lastShownChild = currentChild;
                    }

                    shownChildren = shownChildren || !currentChild.hidden;
                }

                // filter the item itself
                if (item !== that.$.mainContainer) {
                    var filteredItem = that._findItem(item, filterQuery);

                    hide(shownChildren || filteredItem, item);

                    if (shownChildren && filteredItem === null) {
                        item.$.addClass('filtered-child');
                    } else {
                        item.$.removeClass('filtered-child');
                    }

                    if (!shownChildren && childItems.length > 0) {
                        item.hiddenChildren = true;
                        item.$.addClass('hidden-children');
                        that.collapseItem(item, undefined, false);
                    } else {
                        item.hiddenChildren = false;
                        item.$.removeClass('hidden-children');
                    }
                }

                if (filterQuery !== '' && numberOfShownChildren > 0) {
                    lastShownChild.$.addClass('last-filtered-child');
                }
            }

            if (filterQuery === '' && !that.hasAttribute('filter-applied')) {
                return;
            }

            var lastFilteredChildren = Array.from(that.getElementsByClassName('last-filtered-child'));

            for (var i = 0; i < lastFilteredChildren.length; i++) {
                lastFilteredChildren[i].$.removeClass('last-filtered-child');
            }

            filter(that.$.mainContainer, that.$.mainContainer.children);

            if (filterQuery !== '') {
                that.setAttribute('filter-applied', '');
            } else {
                that.removeAttribute('filter-applied');
            }

            that._updateState('filter', filterQuery);
            that._checkOverflow();
        }

        /**
         * Applies hierarchical checkbox selection.
         */

    }, {
        key: '_applyHierarchicalSelection',
        value: function _applyHierarchicalSelection(item, validatedSelection) {
            var that = this,
                branch = item !== that.$.mainContainer,
                children = branch ? item.itemContainer.children : item.children;
            var selectedChildren = 0,
                indeterminateChildren = 0;

            for (var i = 0; i < children.length; i++) {
                var currentChild = children[i];

                if (item.selected) {
                    currentChild.set('selected', true);
                }

                if (currentChild instanceof JQX.TreeItemsGroup) {
                    that._applyHierarchicalSelection(currentChild, validatedSelection);
                } else if (currentChild.selected) {
                    validatedSelection.push(currentChild.path);
                }

                if (branch) {
                    if (currentChild.selected) {
                        selectedChildren++;
                    } else if (currentChild.hasAttribute('indeterminate')) {
                        indeterminateChildren++;
                    }
                }
            }

            if (!branch) {
                return;
            }

            that._setThreeStateCheckbox(item, selectedChildren, indeterminateChildren);

            if (item.selected) {
                validatedSelection.push(item.path);
            }
        }

        /**
         * Applies radio button selection.
         */

    }, {
        key: '_applyRadioButtonSelection',
        value: function _applyRadioButtonSelection(item, initiallySelected, validatedSelection) {
            var that = this,
                children = item !== that.$.mainContainer ? item.itemContainer.children : item.children,
                selectedChildren = [];
            var selectedSibling = void 0;

            for (var i = 0; i < children.length; i++) {
                var currentChild = children[i];

                if (currentChild instanceof JQX.TreeItemsGroup) {
                    that._applyRadioButtonSelection(currentChild, initiallySelected, validatedSelection);
                }

                currentChild.set('selected', false);

                if (initiallySelected.indexOf(currentChild.path) !== -1) {
                    selectedChildren.push(currentChild);
                }
            }

            if (selectedChildren.length === 0) {
                selectedSibling = children[0];
            } else {
                selectedSibling = selectedChildren[selectedChildren.length - 1];
            }

            selectedSibling.set('selected', true);
            validatedSelection.push(selectedSibling.path);
        }

        /**
         * Applies selection.
         */

    }, {
        key: '_applySelection',
        value: function _applySelection(combine, oldSelectedIndexes) {
            var that = this;
            var selected = that.selectedIndexes.slice(0);

            if (oldSelectedIndexes === undefined) {
                oldSelectedIndexes = selected.slice(0);
            }

            if (that._menuItems['0'] === undefined) {
                // no items in Tree
                that.selectedIndexes = [];
                that._lastSelectedItem = undefined;

                if (that.isCompleted && JSON.stringify(oldSelectedIndexes) !== JSON.stringify([])) {
                    that.$.fireEvent('change', {
                        'selectedIndexes': that.selectedIndexes,
                        'oldSelectedIndexes': oldSelectedIndexes
                    });
                }

                return;
            }

            var selectionMode = that.selectionMode,
                itemsWithSelectedAttr = Array.from((that.enableShadowDOM ? that.shadowRoot : that).querySelectorAll('jqx-tree-item[selected], jqx-tree-items-group[selected]'));

            for (var i = selected.length - 1; i >= 0; i--) {
                var currentMatchingItem = that._menuItems[selected[i]];

                if (currentMatchingItem === undefined) {
                    selected.splice(i, 1);
                }
            }

            if (combine) {
                for (var _i3 = 0; _i3 < itemsWithSelectedAttr.length; _i3++) {
                    if (selected.indexOf(itemsWithSelectedAttr[_i3].path) === -1) {
                        selected.push(itemsWithSelectedAttr[_i3].path);
                    }
                }
            } else {
                for (var _i4 = 0; _i4 < itemsWithSelectedAttr.length; _i4++) {
                    itemsWithSelectedAttr[_i4].set('selected', false);
                }

                itemsWithSelectedAttr.length = 0;
            }

            that._sortPathCollection(selected);

            switch (selectionMode) {
                case 'none':
                    selected.length = 0;

                    for (var _i5 = 0; _i5 < itemsWithSelectedAttr.length; _i5++) {
                        itemsWithSelectedAttr[_i5].set('selected', false);
                    }

                    break;
                case 'one':
                case 'zeroOrOne':
                    if (selectionMode !== 'zeroOrOne' && selected.length === 0) {
                        selected.push('0');
                    }

                    for (var _i6 = 0; _i6 < selected.length; _i6++) {
                        var _currentMatchingItem = that._menuItems[selected[_i6]];

                        if (_i6 === selected.length - 1) {
                            _currentMatchingItem.set('selected', true);
                            selected = [selected[_i6]];
                            break;
                        }

                        if (itemsWithSelectedAttr.indexOf(_currentMatchingItem) !== -1) {
                            _currentMatchingItem.set('selected', false);
                        }
                    }

                    break;
                case 'oneOrMany':
                case 'oneOrManyExtended':
                    if (selected.length === 0) {
                        selected.push('0');
                    }

                    for (var _i7 = 0; _i7 < selected.length; _i7++) {
                        that._menuItems[selected[_i7]].set('selected', true);
                    }

                    break;
                case 'zeroOrMany':
                case 'checkBox':
                    for (var _i8 = 0; _i8 < selected.length; _i8++) {
                        that._menuItems[selected[_i8]].set('selected', true);
                    }

                    if (selectionMode === 'checkBox' && that.hasThreeStates) {
                        var validatedSelection = [];

                        that._applyHierarchicalSelection(that.$.mainContainer, validatedSelection);
                        that._sortPathCollection(validatedSelection);
                        selected = validatedSelection;
                    }

                    break;
                case 'radioButton':
                    {
                        var _validatedSelection = [];

                        that._applyRadioButtonSelection(that.$.mainContainer, selected, _validatedSelection);
                        that._sortPathCollection(_validatedSelection);
                        selected = _validatedSelection;
                        break;
                    }
            }

            that.selectedIndexes = selected;
            that._updateState('selected');

            if (selectionMode === 'one' || selectionMode === 'oneOrManyExtended') {
                that._lastSelectedItem = that._menuItems[selected[selected.length - 1]];
            } else {
                that._lastSelectedItem = undefined;
            }

            if (that.isCompleted && arguments[2] !== false && JSON.stringify(oldSelectedIndexes) !== JSON.stringify(selected)) {
                that.$.fireEvent('change', {
                    'selectedIndexes': that.selectedIndexes,
                    'oldSelectedIndexes': oldSelectedIndexes
                });
            }
        }

        /**
         * Automatically loads stored state.
         */

    }, {
        key: '_autoLoadState',
        value: function _autoLoadState(state) {
            var that = this,
                selectedIndexes = [];

            for (var i = 0; i < that._menuItemsGroupsToExpand.length; i++) {
                that._menuItemsGroupsToExpand[i].set('expanded', false);
            }

            that._menuItemsGroupsToExpand = [];

            for (var _i9 = 0; _i9 < state.expanded.length; _i9++) {
                var originallyExpandedItem = that.getItem(state.expanded[_i9]);

                if (originallyExpandedItem) {
                    that._menuItemsGroupsToExpand.push(originallyExpandedItem);
                }
            }

            if (that.filterable && state.filter) {
                that._applyFilter(state.filter);
                that.$.filterInput.value = state.filter;
            }

            for (var _i10 = 0; _i10 < state.selected.length; _i10++) {
                var originallySelectedItem = that.getItem(state.selected[_i10]);

                if (originallySelectedItem) {
                    selectedIndexes.push(originallySelectedItem.path);
                }
            }

            that.selectedIndexes = selectedIndexes;
        }

        /**
         * blur handler.
         */

    }, {
        key: '_blurHandler',
        value: function _blurHandler() {
            this._discardKeyboardHover(true);
        }

        /**
         * Checks if an item can be hovered.
         */

    }, {
        key: '_canItemBeHovered',
        value: function _canItemBeHovered(item) {
            var level = item.level;

            return item.disabled === false && item.templateApplied !== true && item.hidden !== true && (level === 1 || level > 1 && this._isContainerOpened(level, item.parentElement.container) && item.getBoundingClientRect().height > 0);
        }

        /**
         * Checks if an item can be selected.
         */

    }, {
        key: '_canItemBeSelected',
        value: function _canItemBeSelected(item) {
            return item.disabled === false && item.templateApplied !== true;
        }

        /**
         * Checks if items overflow and shows/hides scroll buttons.
         */

    }, {
        key: '_checkOverflow',
        value: function _checkOverflow() {
            var that = this,
                scrollViewer = that.$.scrollViewer,
                overflow = that.overflow;

            if (that.scrollMode === 'scrollbar' || overflow === 'hidden') {
                scrollViewer.refresh();
                return;
            }

            var oldScrollTop = scrollViewer.scrollTop;

            if (overflow === 'auto') {
                scrollViewer.$.removeClass('scroll-buttons-shown');
                scrollViewer.$.removeClass('one-button-shown');
                that.$scrollButtonNear.addClass('jqx-hidden');
                that.$scrollButtonFar.addClass('jqx-hidden');
            }

            var overflowing = Math.round(scrollViewer.$.scrollViewerContentContainer.offsetHeight) > Math.round(scrollViewer.$.scrollViewerContainer.offsetHeight),
                showNear = Math.round(scrollViewer.scrollTop) > 0,
                showFar = Math.round(scrollViewer.$.scrollViewerContainer.offsetHeight + scrollViewer.scrollTop) < Math.round(scrollViewer.$.scrollViewerContentContainer.offsetHeight);

            if (overflowing) {
                if (overflow === 'auto') {
                    scrollViewer.$.addClass('scroll-buttons-shown');

                    if (showNear) {
                        that.$scrollButtonNear.removeClass('jqx-hidden');
                    }

                    if (showFar) {
                        that.$scrollButtonFar.removeClass('jqx-hidden');
                    }

                    if ((showNear && showFar) === false) {
                        scrollViewer.$.addClass('one-button-shown');
                    }

                    if (!that.disabled) {
                        that.$.scrollButtonNear.disabled = false;
                        that.$.scrollButtonFar.disabled = false;
                    }

                    scrollViewer.scrollTop = oldScrollTop;
                } else {
                    that.$scrollButtonNear.removeClass('jqx-hidden');
                    that.$scrollButtonFar.removeClass('jqx-hidden');

                    if (that.disabled) {
                        that.$.scrollButtonNear.disabled = true;
                        that.$.scrollButtonFar.disabled = true;
                    } else {
                        that.$.scrollButtonNear.disabled = !showNear;
                        that.$.scrollButtonFar.disabled = !showFar;
                    }
                }
            } else if (overflow === 'scroll') {
                that.$.scrollButtonNear.disabled = true;
                that.$.scrollButtonFar.disabled = true;
            }

            scrollViewer.refresh();
        }

        /**
         * Applies initial settings to the Tree element.
         */

    }, {
        key: '_createElement',
        value: function _createElement() {
            var that = this,
                scrollViewerStyle = window.getComputedStyle(that.$.scrollViewer);

            that.$.scrollViewer.onVerticalChange = that._verticalScrollbarHandler;

            Object.defineProperty(that, 'dataSource', {
                get: function get() {
                    if (that.context === that) {
                        return that.properties.dataSource.value;
                    } else {
                        return that._getDataSource();
                    }
                },
                set: function set(value) {
                    that.updateProperty(that, that._properties.dataSource, value);
                }
            });

            if (!that.id && (that.autoLoadState || that.autoSaveState)) {
                that.warn(that.localize('noId'));
                that.autoLoadState = false;
                that.autoSaveState = false;
            }

            that.mode = 'tree';
            that._element = 'tree';
            that._isMobile = JQX.Utilities.Core.isMobile;
            that._edgeMacFF = false;
            that._autoScrollCoefficient = JQX.Utilities.Core.Browser.Firefox ? 4 : JQX.Utilities.Core.Browser.Edge ? 8 : 2;
            that._scrollViewerPadding = parseFloat(scrollViewerStyle.paddingTop) + parseFloat(scrollViewerStyle.paddingBottom) || 0;
            that._state = { expanded: [], filter: '', selected: [] };
            that._dblclickObject = { numberOfClicks: 0 };

            if (that.autoHideToggleElement) {
                that.$mainContainer.addClass('hidden-arrows');
            }

            if (that.disabled) {
                that.$.scrollButtonNear.disabled = true;
                that.$.scrollButtonFar.disabled = true;
            }

            if (that.scrollMode === 'scrollbar' && that.overflow === 'scroll') {
                that.$.scrollViewer.verticalScrollBarVisibility = 'visible';
            }

            if (that.dataSource === null && that.$.mainContainer.firstElementChild instanceof HTMLUListElement) {
                that._processUList();
            }

            var items = that.getElementsByTagName('jqx-tree-item');

            var itemsReady = function itemsReady() {
                var previousState = void 0;

                if (that.autoLoadState) {
                    previousState = window.localStorage.getItem('jqxTree' + that.id);

                    if (previousState) {
                        previousState = JSON.parse(previousState);
                        that.sorted = previousState.sorted;
                    }
                }

                that._setFocusable();

                that._menuItems = {};

                if (that.dataSource === null) {
                    that._processHTML(that.$.mainContainer, 1);
                } else {
                    // Task (3)
                    that._processDataSource();
                }

                if (that.scrollMode === 'scrollButtons' && that.overflow === 'scroll') {
                    that.$scrollViewer.addClass('scroll-buttons-shown');
                    that.$scrollButtonNear.removeClass('jqx-hidden');
                    that.$scrollButtonFar.removeClass('jqx-hidden');
                    that._updateScrollButtonVisibility();
                }

                that._checkOverflow();

                if (previousState) {
                    that._autoLoadState(previousState);
                }

                that._expandItemsByDefault();
                that._applySelection(true);

                that._updateState('sorted', that.sorted);

                if (that.displayLoadingIndicator) {
                    that.$loadingIndicatorContainer.removeClass('jqx-hidden');
                }

                if (that.loadingIndicatorPosition !== 'center') {
                    that.$loadingIndicatorPlaceHolder.removeClass('jqx-hidden');
                }

                if (that.__onCompleted) {
                    that._onCompleted = that.__onCompleted;
                    that.__onCompleted = null;
                    that._onCompleted();
                }
            };

            if (items.length === 0) {
                itemsReady();
            } else {
                if (that._onCompleted) {
                    that.__onCompleted = that._onCompleted;
                    that._onCompleted = null;
                }
                that._ensureItemsReady(items, itemsReady);
            }
        }

        /**
         * dblclick handler.
         */

    }, {
        key: '_dblclickHandler',
        value: function _dblclickHandler(pressedItem, arrow, event) {
            var that = this;

            if (that.toggleMode !== 'dblclick' || pressedItem instanceof JQX.TreeItem || arrow) {
                return;
            }

            that._menuItemsGroupSelectionHandler(pressedItem, event);
        }

        /**
         * Removes "focused" class added by keyboard navigation.
         */

    }, {
        key: '_discardKeyboardHover',
        value: function _discardKeyboardHover(overrideCheck, mouseoutMouseover) {
            var that = this;

            if (mouseoutMouseover || !that._hoveredViaKeyboard) {
                return;
            }

            if (!overrideCheck && that._hoveredViaKeyboard instanceof JQX.MenuItemsGroup && that._isContainerOpened(that._hoveredViaKeyboard.level + 1, that._hoveredViaKeyboard.container)) {
                return;
            }

            that._hoveredViaKeyboard.removeAttribute('focus');
            that._hoveredViaKeyboard = undefined;
        }

        /**
         * Document up handler.
         */

    }, {
        key: '_documentUpHandler',
        value: function _documentUpHandler(event) {
            var that = this,
                downItem = that._downItem,
                upTarget = that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target;

            delete that._downItem;

            if (that._editedItem && !that._editInputDown && (!that._isMobile && upTarget !== that.$.editInput || that._isMobile && document.elementFromPoint(event.clientX, event.clientY) !== that.$.editInput)) {

                that._endEditing();
                return;
            }

            delete that._editInputDown;

            if (downItem) {
                var pressedItem = upTarget.closest('jqx-tree-item') || upTarget.closest('jqx-tree-items-group');

                if (pressedItem && pressedItem.selected && pressedItem === downItem && (!that._dragDetails || !that._dragDetails.FeedbackShown) && !(pressedItem instanceof JQX.TreeItemsGroup && (upTarget.closest('.jqx-tree-items-group-arrow') || upTarget === pressedItem.container || upTarget === pressedItem.container.firstElementChild))) {

                    that._handleSelection(pressedItem, event);
                }
            }

            var dragDetails = that._dragDetails;

            if (!dragDetails) {
                return;
            }

            var targetTree = JQX.Tree.hoveredTree,
                targetItem = JQX.Tree.hoveredItem;

            delete that._dragDetails;
            delete JQX.Tree.treeItemDragged;
            delete JQX.Tree.hoveredTree;
            delete JQX.Tree.hoveredItem;
            that.$.scrollViewer._scrollView.disableSwipeScroll = false;

            if (!dragDetails.FeedbackShown) {
                return;
            }

            var dropTarget = targetTree || document.elementFromPoint(event.clientX, event.clientY);
            var position = void 0;

            document.body.classList.remove('jqx-dragging');
            document.body.removeChild(dragDetails.Feedback);

            if (targetTree) {
                clearInterval(targetTree._dragInterval);
            }

            var draggedItem = dragDetails.Item,
                draggedItems = dragDetails.Items,
                validDraggedItems = dragDetails.ValidItems;

            if (!dropTarget) {
                return;
            }

            if (!targetItem || draggedItem.contains(targetItem)) {
                // drops item somewhere in the DOM
                that.$.fireEvent('dragEnd', {
                    'item': draggedItem,
                    'items': draggedItems,
                    'target': dropTarget,
                    'data': dragDetails,
                    'previousContainer': that,
                    'container': targetTree || dropTarget,
                    'originalEvent': event
                });
                return;
            }

            if (!(targetTree && targetTree.allowDrop && !targetTree.disabled)) {
                return;
            }

            var affectedTrees = [targetTree];
            var dropDetailsPosition = void 0;

            targetItem.classList.remove('drop-target');

            if (targetItem.classList.contains('top')) {
                targetItem.classList.remove('top');
                dropDetailsPosition = 'top';
                position = 0;
            } else if (targetItem.classList.contains('bottom')) {
                targetItem.classList.remove('bottom');
                dropDetailsPosition = 'bottom';
                position = 2;
            } else {
                dropDetailsPosition = 'inside';
                position = 1;
            }

            dragDetails.DropDetails = { item: targetItem, position: dropDetailsPosition };

            if (targetTree !== that) {
                affectedTrees.push(that);
            } else if (dragDetails.ValidateOnDrop) {
                // drop inside the same tree
                for (var i = 0; i < validDraggedItems.length; i++) {
                    if (validDraggedItems[i].contains(targetItem)) {
                        return;
                    }
                }
            }

            var dragEndEvent = that.$.fireEvent('dragEnd', {
                'item': draggedItem,
                'items': draggedItems,
                'target': targetItem,
                'data': dragDetails,
                'previousContainer': that,
                'container': targetTree,
                'originalEvent': event
            });

            if (dragEndEvent.defaultPrevented) {
                return;
            }

            if (targetTree.sorted && targetTree.autoSort) {
                targetTree._unsortItems(targetTree.$.mainContainer);
            }

            for (var _i11 = 0; _i11 < validDraggedItems.length; _i11++) {
                that._moveTreeItem(validDraggedItems[_i11], targetItem, position, affectedTrees);
            }

            if (targetTree.sorted && targetTree.autoSort) {
                targetTree._applyGrouping(targetTree.$.mainContainer);
            }

            if (targetTree !== that && targetTree._state.filter) {
                targetTree._applyFilter(targetTree._state.filter);
            }
        }

        /**
         * editInput blur handler.
         */

    }, {
        key: '_editInputBlurHandler',
        value: function _editInputBlurHandler() {
            this._endEditing();
        }

        /**
         * Ends editing operation.
         */

    }, {
        key: '_endEditing',
        value: function _endEditing(discardChanges) {
            var that = this,
                editedItem = that._editedItem;

            if (!editedItem) {
                return;
            }

            delete that._editedItem;
            that.$editInput.addClass('jqx-hidden');
            that.focus();

            if (discardChanges) {
                return;
            }

            var newValue = that.$.editInput.value,
                restoreSorting = that.sorted && that.autoSort,
                filterQuery = that._state.filter;

            if (newValue === editedItem.label) {
                return;
            }

            editedItem.set('label', newValue);
            editedItem.firstElementChild.firstElementChild.firstElementChild.innerHTML = newValue;

            if (restoreSorting) {
                that._unsortItems(that.$.mainContainer);
                that._applyGrouping(that.$.mainContainer);
            }

            if (filterQuery) {
                that._applyFilter(filterQuery);
            }
        }

        /**
         * Makes sure an item is visible by scrolling to it.
         */

    }, {
        key: '_ensureVisible',
        value: function _ensureVisible(item) {
            var that = this;

            that._ensureVisibleTreeMode(item, item.getBoundingClientRect(), that.$.scrollViewer, that.$.scrollViewer.getBoundingClientRect(), that._scrollViewerPadding);

            //Used in GanttChart to ensure the TaskBar inside the Timeline is also visible
            if (that._ensureVisibleCallback) {
                that._ensureVisibleCallback(item);
            }
        }

        /**
         * filterInput keydown handler.
         */

    }, {
        key: '_filterInputKeydownHandler',
        value: function _filterInputKeydownHandler(event) {
            if (event.key !== 'PageDown') {
                if (event.key === 'PageUp') {
                    event.preventDefault();
                    event.stopPropagation();
                }

                return;
            }

            var that = this;
            var itemToHighlight = void 0;

            event.preventDefault();
            event.stopPropagation();

            if (that.selectedIndexes.length > 0) {
                var oldSelectedIndexes = that.selectedIndexes.slice(0);

                itemToHighlight = that._lastSelectedItem || that._menuItems[that.selectedIndexes[that.selectedIndexes.length - 1]];

                if (that.selectionMode !== 'checkBox' && that.selectionMode !== 'radioButton') {
                    that.selectedIndexes = [itemToHighlight.path];
                    that._applySelection(false, oldSelectedIndexes);
                }

                that.focus();
            } else {
                itemToHighlight = that._getFirstEnabledChild(that.$.mainContainer);
                that.focus();

                if (itemToHighlight) {
                    that._hoverViaKeyboard(itemToHighlight);
                }
            }

            that._ensureVisible(itemToHighlight);
        }

        /**
         * focus handler.
         */

    }, {
        key: '_focusHandler',
        value: function _focusHandler() {
            var that = this;

            if (that.selectedIndexes.length > 0 && !that._hoveredViaKeyboard) {
                if (that._lastSelectedItem) {
                    that._hoverViaKeyboard(that._lastSelectedItem, false, undefined, false);
                } else {
                    that._hoverViaKeyboard(that._menuItems[that.selectedIndexes[that.selectedIndexes.length - 1]], false, undefined, false);
                }
            }
        }

        /**
         * Gets a JSON representation of the current Tree state.
         */

    }, {
        key: '_getDataSource',
        value: function _getDataSource() {
            var that = this,
                dataSource = [];

            function recursion(children, itemsArray) {
                for (var i = 0; i < children.length; i++) {
                    var currentChild = children[i],
                        dataSourceItem = { label: currentChild.label };

                    if (currentChild.disabled) {
                        dataSourceItem.disabled = true;
                    }

                    if (currentChild.selected) {
                        dataSourceItem.selected = true;
                    }

                    if (currentChild.separator) {
                        dataSourceItem.separator = true;
                    }

                    if (currentChild.value !== null) {
                        dataSourceItem.value = currentChild.value;
                    }

                    if (currentChild instanceof JQX.TreeItem) {
                        if (currentChild.shortcut) {
                            dataSourceItem.shortcut = currentChild.shortcut;
                        }
                    } else {
                        if (currentChild.expanded) {
                            dataSourceItem.expanded = true;
                        }

                        dataSourceItem.items = [];
                        recursion(currentChild.itemContainer.children, dataSourceItem.items);
                    }

                    itemsArray.push(dataSourceItem);
                }
            }

            recursion(that.$.mainContainer.children, dataSource);

            return dataSource;
        }

        /**
         * Handles hierarchical checkbox selection.
         */

    }, {
        key: '_handleHierarchicalSelection',
        value: function _handleHierarchicalSelection(item, selectedIndexes) {
            function checkUncheckChildren(item, check) {
                var children = item.itemContainer.children;

                for (var i = 0; i < children.length; i++) {
                    var currentChild = children[i];

                    currentChild.set('selected', check);
                    currentChild.removeAttribute('indeterminate');

                    if (currentChild instanceof JQX.TreeItemsGroup) {
                        checkUncheckChildren(currentChild, check);
                    }
                }
            }

            var that = this;
            var currentItem = item;

            if (item.selected) {
                item.set('selected', false);
            } else {
                item.set('selected', true);
                item.removeAttribute('indeterminate');
            }

            while (currentItem.parentItem) {
                var parent = currentItem.parentItem,
                    children = parent.itemContainer.children;
                var selectedChildren = 0,
                    indeterminateChildren = 0;

                for (var i = 0; i < children.length; i++) {
                    if (children[i].selected) {
                        selectedChildren++;
                    } else if (children[i].hasAttribute('indeterminate')) {
                        indeterminateChildren++;
                    }
                }

                that._setThreeStateCheckbox(parent, selectedChildren, indeterminateChildren);

                currentItem = parent;
            }

            if (item instanceof JQX.TreeItemsGroup) {
                checkUncheckChildren(item, item.selected);
            }

            selectedIndexes.length = 0;

            var selectedItems = Array.from((that.enableShadowDOM ? that.shadowRoot : that).querySelectorAll('[selected]'));

            for (var _i12 = 0; _i12 < selectedItems.length; _i12++) {
                selectedIndexes.push(selectedItems[_i12].path);
            }

            that._sortPathCollection(selectedIndexes);
        }

        /**
         * Handles item selection.
         */

    }, {
        key: '_handleSelection',
        value: function _handleSelection(item, event) {
            var that = this,
                selectionMode = that.selectionMode;

            if (selectionMode === 'none' || event.type !== 'programmatic' && !that._canItemBeSelected(item)) {
                return;
            }

            var selected = item.selected;

            if (selected && event.type === 'down') {
                return;
            }

            var oldSelectedIndexes = that.selectedIndexes.slice(0);
            var selectedIndexes = oldSelectedIndexes.slice(0);

            switch (selectionMode) {
                case 'one':
                    if (selected) {
                        return;
                    }

                    that._menuItems[selectedIndexes[0]].set('selected', false);
                    that.selectedIndexes = [item.path];
                    item.set('selected', true);
                    that._lastSelectedItem = item;
                    break;
                case 'zeroOrOne':
                    if (selected) {
                        that.selectedIndexes = [];
                        item.set('selected', false);
                    } else {
                        if (selectedIndexes[0] !== undefined) {
                            that._menuItems[selectedIndexes[0]].set('selected', false);
                        }

                        that.selectedIndexes = [item.path];
                        item.set('selected', true);
                    }

                    break;
                case 'oneOrMany':
                case 'zeroOrMany':
                    if (selected) {
                        if (selectedIndexes.length === 1 && selectionMode !== 'zeroOrMany') {
                            return;
                        }

                        selectedIndexes.splice(selectedIndexes.indexOf(item.path), 1);
                        item.set('selected', false);
                    } else {
                        selectedIndexes.push(item.path);
                        that._sortPathCollection(selectedIndexes);
                        item.set('selected', true);
                    }

                    that.selectedIndexes = selectedIndexes;
                    break;
                case 'oneOrManyExtended':
                    {
                        var ctrlKey = event.ctrlKey,
                            shiftKey = event.shiftKey;

                        if (!ctrlKey && !shiftKey || shiftKey && item === that._lastSelectedItem) {
                            for (var i = 0; i < selectedIndexes.length; i++) {
                                that._menuItems[selectedIndexes[i]].set('selected', false);
                            }

                            selectedIndexes = [item.path];
                            item.set('selected', true);
                            that._lastSelectedItem = item;
                        } else if (ctrlKey) {
                            if (item.selected && selectedIndexes.length > 1) {
                                selectedIndexes.splice(selectedIndexes.indexOf(item.path), 1);
                                item.set('selected', false);
                            } else if (!item.selected) {
                                selectedIndexes.push(item.path);
                                that._sortPathCollection(selectedIndexes);
                                item.set('selected', true);
                                that._lastSelectedItem = item;
                            }
                        } else if (shiftKey) {
                            for (var _i13 = 0; _i13 < selectedIndexes.length; _i13++) {
                                that._menuItems[selectedIndexes[_i13]].set('selected', false);
                            }

                            selectedIndexes = that._selectItemRange(that._lastSelectedItem, item);
                        }

                        that.selectedIndexes = selectedIndexes;
                        break;
                    }
                case 'checkBox':
                    if (that.hasThreeStates) {
                        that._handleHierarchicalSelection(item, selectedIndexes);
                    } else {
                        if (selected) {
                            selectedIndexes.splice(selectedIndexes.indexOf(item.path), 1);
                            item.set('selected', false);
                        } else {
                            selectedIndexes.push(item.path);
                            that._sortPathCollection(selectedIndexes);
                            item.set('selected', true);
                        }
                    }

                    that.selectedIndexes = selectedIndexes;
                    break;
                case 'radioButton':
                    {
                        if (item.selected) {
                            return;
                        }

                        var selectedSibling = void 0;

                        for (var _i14 = 0; _i14 < item.parentElement.children.length; _i14++) {
                            var currentSibling = item.parentElement.children[_i14];

                            if (currentSibling.selected) {
                                selectedSibling = currentSibling;
                                break;
                            }
                        }

                        var selectedSiblingIndex = selectedIndexes.indexOf(selectedSibling.path);

                        selectedSibling.set('selected', false);
                        item.set('selected', true);
                        selectedIndexes.splice(selectedSiblingIndex, 1);
                        selectedIndexes.push(item.path);
                        that._sortPathCollection(selectedIndexes);
                        that.selectedIndexes = selectedIndexes;
                        break;
                    }
            }

            that._discardKeyboardHover(true);
            that._hoverViaKeyboard(item, false, undefined, !that._treeAnimationInProgress);
            that._updateState('selected');

            if (JSON.stringify(oldSelectedIndexes) !== JSON.stringify(that.selectedIndexes)) {
                //Will prevent 'change' firing on ready() of the ownerElement
                if (that.ownerElement && !that.ownerElement.isCompleted) {
                    return;
                }

                that.$.fireEvent('change', {
                    'item': item,
                    'selectedIndexes': that.selectedIndexes,
                    'oldSelectedIndexes': oldSelectedIndexes
                });
            }
        }

        /**
         * Highlights an item via the keyboard.
         */

    }, {
        key: '_hoverViaKeyboard',
        value: function _hoverViaKeyboard(item, selectOnHover, event, ensureVisible) {
            if (!item) {
                return;
            }

            var that = this;

            item.setAttribute('focus', '');
            that._hoveredViaKeyboard = item;

            if (ensureVisible !== false) {
                that._ensureVisible(item);
            }

            if (selectOnHover) {
                that._handleSelection(item, event);
            }

            //NOTE: Used in GanttChart in order to handle Task Tree item focus state
            if (that._hoverViaKeyboardCallback) {
                that._hoverViaKeyboardCallback(item);
            }
        }

        /**
         * Keydown event handler.
         */

    }, {
        key: '_keydownHandler',
        value: function _keydownHandler(event) {
            var that = this,
                key = event.key;

            if (that._editedItem) {
                if (key === 'Enter') {
                    that._endEditing();
                } else if (key === 'Escape') {
                    that._endEditing(true);
                }

                return;
            }

            if (document.activeElement !== that || ['ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'End', 'Enter', 'F2', 'Home', 'PageDown', 'PageUp', ' '].indexOf(key) === -1 || that.disabled || that.displayLoadingIndicator) {
                return;
            }

            event.preventDefault();

            var treeItems = Array.from(that.$.mainContainer.querySelectorAll('jqx-tree-item, jqx-tree-items-group')),
                selectOnHover = that.selectionMode === 'one' || that.selectionMode === 'oneOrManyExtended' && !event.ctrlKey,
                highlightedItem = that.$.mainContainer.querySelector('[focus]');

            function moveDown(startIndex) {
                for (var i = startIndex; i < treeItems.length; i++) {
                    var currentItem = treeItems[i];

                    if (that._canItemBeHovered(currentItem)) {
                        if (highlightedItem) {
                            if (highlightedItem === currentItem) {
                                break;
                            }

                            highlightedItem.removeAttribute('focus');
                        }

                        that._hoverViaKeyboard(currentItem, selectOnHover, event);
                        break;
                    }
                }
            }

            function moveUp(startIndex) {
                for (var i = startIndex; i >= 0; i--) {
                    var currentItem = treeItems[i];

                    if (that._canItemBeHovered(currentItem)) {
                        if (highlightedItem) {
                            if (highlightedItem === currentItem) {
                                break;
                            }

                            highlightedItem.removeAttribute('focus');
                        }

                        that._hoverViaKeyboard(currentItem, selectOnHover, event);
                        break;
                    }
                }
            }

            function navigateToParentItem() {
                if (highlightedItem.level > 1) {
                    highlightedItem.removeAttribute('focus');
                    that._hoverViaKeyboard(highlightedItem.parentItem, selectOnHover, event);
                }
            }

            var startIndex = void 0;

            switch (key) {
                case 'ArrowDown':
                    if (highlightedItem) {
                        startIndex = treeItems.indexOf(highlightedItem) + 1;
                    } else {
                        startIndex = 0;
                    }

                    moveDown(startIndex);
                    break;
                case 'ArrowLeft':
                    if (!highlightedItem) {
                        return;
                    }

                    if (highlightedItem instanceof JQX.TreeItem) {
                        navigateToParentItem();
                    } else {
                        if (that._isContainerOpened(highlightedItem.level + 1, highlightedItem.container)) {
                            that._closeSubContainersTreeMode(highlightedItem.level + 1, highlightedItem.container, true, true);
                            return;
                        }

                        navigateToParentItem();
                    }
                    break;
                case 'ArrowRight':
                    if (!highlightedItem || highlightedItem instanceof JQX.TreeItem) {
                        return;
                    }

                    if (that._isContainerOpened(highlightedItem.level + 1, highlightedItem.container)) {
                        highlightedItem.removeAttribute('focus');
                        that._hoverViaKeyboard(that._getFirstEnabledChild(highlightedItem.itemContainer), selectOnHover, event);
                    } else {
                        that._menuItemsGroupSelectionHandler(highlightedItem, { target: highlightedItem, type: 'keydown' });
                    }

                    break;
                case 'ArrowUp':
                    if (highlightedItem) {
                        startIndex = treeItems.indexOf(highlightedItem) - 1;
                    } else {
                        startIndex = treeItems.length - 1;
                    }

                    moveUp(startIndex);
                    break;
                case 'End':
                    moveUp(treeItems.length - 1);
                    break;
                case 'Enter':
                    if (highlightedItem && highlightedItem instanceof JQX.TreeItemsGroup) {
                        that._menuItemsGroupSelectionHandler(highlightedItem, { target: highlightedItem, type: 'keydown' });
                    }

                    break;
                case 'F2':
                    if (that.editable) {
                        that._startEditing(highlightedItem);
                    }

                    break;
                case 'Home':
                    moveDown(0);
                    break;
                case 'PageDown':
                    that._pageDownHandler(treeItems, highlightedItem, selectOnHover, event);
                    break;
                case 'PageUp':
                    that._pageUpHandler(treeItems, highlightedItem, selectOnHover, event);
                    break;
                case ' ':
                    if (highlightedItem) {
                        that._handleSelection(highlightedItem, event);
                    }

                    break;
            }
        }

        /**
         * mainContainer swipeleft/swiperight handler.
         */

    }, {
        key: '_mainContainerSwipeHandler',
        value: function _mainContainerSwipeHandler(event) {
            if (JQX.Tree.treeItemDragged) {
                event.stopPropagation();
            }
        }

        /**
         * jqx-menu-items-group selection handler.
         */

    }, {
        key: '_menuItemsGroupSelectionHandler',
        value: function _menuItemsGroupSelectionHandler(closestItemsGroup, event, fireEvent) {
            var that = this,
                toggleMode = that.toggleMode,
                arrow = event.originalEvent ? event.originalEvent.target.classList.contains('jqx-tree-items-group-arrow') : false,
                container = closestItemsGroup.container;

            if (that._waitAnimation && that._treeAnimationInProgress === container) {
                return;
            }

            if (event.type === 'down' && !arrow && (toggleMode !== 'dblclick' || that._dblclickObject.numberOfClicks === 1)) {
                that._handleSelection(closestItemsGroup, event);
            }

            if (event.type === 'down' && !arrow && (toggleMode === 'dblclick' && that._dblclickObject.numberOfClicks !== 2 || toggleMode === 'click' && that._dblclickObject.numberOfClicks > 1 || toggleMode === 'arrow') || closestItemsGroup.hiddenChildren) {
                return;
            }

            var level = container.level;
            var animation = that.hasAnimation;

            if (event.type === 'keydown') {
                that._discardKeyboardHover();
            }

            if (that._treeAnimationInProgress) {
                container.removeEventListener('transitionend', that._transitionendHandlerExpand);
                container.removeEventListener('transitionend', that._transitionendHandlerCollapse);
            }

            if (that._isContainerOpened(level, container)) {
                that._closeSubContainersTreeMode(level, container, true, fireEvent !== false);
            } else {
                var expandingEvent = that.$.fireEvent('expanding', {
                    'item': closestItemsGroup,
                    'label': closestItemsGroup.label,
                    'path': closestItemsGroup.path,
                    'value': closestItemsGroup.value,
                    'children': closestItemsGroup.itemContainer.children
                });

                if (expandingEvent.defaultPrevented) {
                    return;
                }

                if (animation) {
                    if (event.type !== 'expand') {
                        that._ensureVisibleOnTransitionend = closestItemsGroup;
                    }

                    that._expandSection(container);
                }

                container.$.removeClass('jqx-visibility-hidden');

                if (event.type === 'keydown') {
                    closestItemsGroup.setAttribute('focus', '');
                    that._hoveredViaKeyboard = closestItemsGroup;
                }

                closestItemsGroup.$.addClass('jqx-tree-items-group-opened');
                closestItemsGroup.$.addClass('jqx-tree-items-group-expanded');

                that._addOpenedContainer(level, container);

                if (event.type === undefined) {
                    that._hoverViaKeyboard(that._getFirstEnabledChild(closestItemsGroup.itemContainer));
                }

                if (fireEvent !== false) {
                    var eventDetail = {
                        'item': closestItemsGroup,
                        'label': closestItemsGroup.label,
                        'path': closestItemsGroup.path,
                        'value': closestItemsGroup.value,
                        'children': closestItemsGroup.itemContainer.children
                    };

                    if (that.toggleCallback) {
                        eventDetail.type = 'expand';
                        that.toggleCallback(eventDetail);
                    } else {
                        that.$.fireEvent('expand', eventDetail);
                    }
                }
            }

            if (!animation) {
                that._checkOverflow();

                if (event.type !== 'expand') {
                    that._ensureVisible(closestItemsGroup);
                }
            }
        }

        /**
         * mouseenter handler.
         */

    }, {
        key: '_mouseenterHandler',
        value: function _mouseenterHandler() {
            var that = this;

            if (that.autoHideToggleElement) {
                that.$mainContainer.removeClass('hidden-arrows');
            }

            if (JQX.Tree.treeItemDragged && that.allowDrop && !that.disabled) {
                JQX.Tree.hoveredTree = that;
            }
        }

        /**
         * mouseleave handler.
         */

    }, {
        key: '_mouseleaveHandler',
        value: function _mouseleaveHandler() {
            var that = this;

            if (that.autoHideToggleElement) {
                that.$mainContainer.addClass('hidden-arrows');
            }

            if (JQX.Tree.treeItemDragged) {
                if (JQX.Tree.hoveredTree) {
                    clearInterval(JQX.Tree.hoveredTree._dragInterval);
                    delete JQX.Tree.hoveredTree;
                }

                var hoveredItem = JQX.Tree.hoveredItem;

                if (hoveredItem) {
                    hoveredItem.classList.remove('drop-target');
                    hoveredItem.classList.remove('top');
                    hoveredItem.classList.remove('bottom');
                    delete JQX.Tree.hoveredItem;
                }
            }
        }

        /**
         * Move handler.
         */

    }, {
        key: '_moveHandler',
        value: function _moveHandler(event) {
            var that = this,
                dragDetails = that._dragDetails;

            if (!dragDetails) {
                return;
            }

            if (!dragDetails.FeedbackShown) {
                if (Math.abs(dragDetails.StartPosition.left - event.pageX) > 5 || Math.abs(dragDetails.StartPosition.top - event.pageY) > 5) {

                    var dragStartEvent = that.$.fireEvent('dragStart', {
                        'item': dragDetails.Item,
                        'items': dragDetails.Items,
                        'data': dragDetails,
                        'container': that,
                        'previousContainer': that,
                        'originalEvent': dragDetails.OriginalEvent
                    });

                    if (dragStartEvent.defaultPrevented) {
                        delete that._dragDetails;
                        delete JQX.Tree.treeItemDragged;
                        delete JQX.Tree.hoveredTree;
                        delete JQX.Tree.hoveredItem;
                        that.$.scrollViewer._scrollView.disableSwipeScroll = false;
                        return;
                    }

                    document.body.classList.add('jqx-dragging');
                    dragDetails.Feedback = that._addDragFeedback();
                    dragDetails.FeedbackShown = true;
                } else {
                    return;
                }
            }

            var dragOffset = that.dragOffset;
            var hoveredTree = void 0,
                target = void 0,
                hoveredItem = void 0;

            that.$.fireEvent('dragging', {
                'item': dragDetails.Item,
                'items': dragDetails.Items,
                'data': dragDetails,
                'originalEvent': event
            });

            dragDetails.Feedback.style.left = event.pageX + dragOffset[0] + 'px';
            dragDetails.Feedback.style.top = event.pageY + dragOffset[1] + 'px';

            if (that._isMobile) {
                var oldHoveredItem = JQX.Tree.hoveredItem;

                if (oldHoveredItem) {
                    oldHoveredItem.classList.remove('drop-target');
                    oldHoveredItem.classList.remove('top');
                    oldHoveredItem.classList.remove('bottom');
                    delete JQX.Tree.hoveredItem;
                }

                var realTarget = document.elementFromPoint(event.clientX, event.clientY);

                if (JQX.Tree.hoveredTree) {
                    clearInterval(JQX.Tree.hoveredTree._dragInterval);
                    delete JQX.Tree.hoveredTree;
                }

                if (realTarget) {
                    hoveredTree = realTarget.closest('jqx-tree');

                    if (hoveredTree && hoveredTree.allowDrop) {
                        JQX.Tree.hoveredTree = hoveredTree;
                        target = realTarget.closest('jqx-tree-item') || realTarget.closest('jqx-tree-items-group');

                        if (target) {
                            hoveredItem = target;
                        } else {
                            target = realTarget;
                        }
                    }
                }
            }

            hoveredTree = JQX.Tree.hoveredTree;

            if (!hoveredTree) {
                return;
            }

            var filterInputHeight = hoveredTree.filterable ? hoveredTree.$.filterInput.offsetHeight + 10 : 0;

            clearInterval(hoveredTree._dragInterval);
            hoveredTree._dragInterval = setInterval(function () {
                var rect = hoveredTree.getBoundingClientRect();

                if (hoveredTree.$.scrollViewer.scrollHeight > 0 && rect.left <= event.clientX && rect.left + rect.width >= event.clientX) {
                    if (event.clientY >= rect.top + filterInputHeight && event.clientY <= rect.top + 20 + filterInputHeight) {
                        hoveredTree.$.scrollViewer.scrollTop -= that._autoScrollCoefficient;

                        if (hoveredTree.scrollMode === 'scrollButtons') {
                            hoveredTree._updateScrollButtonVisibility();
                        }
                    } else if (event.clientY >= rect.top + rect.height - 20 && event.clientY <= rect.top + rect.height) {
                        hoveredTree.$.scrollViewer.scrollTop += that._autoScrollCoefficient;

                        if (hoveredTree.scrollMode === 'scrollButtons') {
                            hoveredTree._updateScrollButtonVisibility();
                        }
                    } else {
                        clearInterval(hoveredTree._dragInterval);
                    }
                } else {
                    clearInterval(hoveredTree._dragInterval);
                }
            }, 1);

            if (!that._isMobile) {
                target = event.originalEvent.target;

                if (target && target.enableShadowDOM) {
                    target = event.originalEvent.composedPath()[0];
                }

                if (target && target.closest) {
                    hoveredItem = target.closest('jqx-tree-item') || target.closest('jqx-tree-items-group');
                }
            }

            if (hoveredItem) {
                if (JQX.Tree.hoveredItem && hoveredItem !== JQX.Tree.hoveredItem) {
                    JQX.Tree.hoveredItem.classList.remove('drop-target');
                    JQX.Tree.hoveredItem.classList.remove('top');
                    JQX.Tree.hoveredItem.classList.remove('bottom');
                }

                JQX.Tree.hoveredItem = hoveredItem;

                if (dragDetails.Item.contains(hoveredItem)) {
                    return;
                }

                var hoveredItemRect = hoveredItem.getBoundingClientRect();

                if (hoveredItem instanceof JQX.TreeItem) {
                    if (event.clientY - hoveredItemRect.top <= hoveredItemRect.height / 2) {
                        hoveredItem.classList.remove('bottom');
                        hoveredItem.classList.add('top');
                    } else {
                        hoveredItem.classList.remove('top');
                        hoveredItem.classList.add('bottom');
                    }
                } else {
                    if (event.clientY - hoveredItemRect.top <= 10) {
                        hoveredItem.classList.remove('bottom');
                        hoveredItem.classList.add('top');
                    } else if (!hoveredItem.expanded && hoveredItemRect.bottom - event.clientY <= 10) {
                        hoveredItem.classList.remove('top');
                        hoveredItem.classList.add('bottom');
                    } else {
                        hoveredItem.classList.remove('top');
                        hoveredItem.classList.remove('bottom');
                    }
                }

                hoveredItem.classList.add('drop-target');
            } else {
                if (JQX.Tree.hoveredItem) {
                    JQX.Tree.hoveredItem.classList.remove('drop-target');
                    JQX.Tree.hoveredItem.classList.remove('top');
                    JQX.Tree.hoveredItem.classList.remove('bottom');
                }

                if (target === hoveredTree.$.scrollViewer.$.scrollViewerContainer) {
                    if (hoveredTree._menuItems['0']) {
                        var lastVisibleItem = hoveredTree.$.mainContainer.lastElementChild,
                            i = hoveredTree.$.mainContainer.childElementCount - 1;

                        while (lastVisibleItem.hidden) {
                            i--;
                            lastVisibleItem = hoveredTree.$.mainContainer.children[i];

                            if (!lastVisibleItem) {
                                break;
                            }
                        }

                        if (lastVisibleItem) {
                            JQX.Tree.hoveredItem = lastVisibleItem;
                            JQX.Tree.hoveredItem.classList.add('bottom');
                        } else {
                            JQX.Tree.hoveredItem = hoveredTree.$.container;
                        }

                        JQX.Tree.hoveredItem.classList.add('drop-target');
                    } else {
                        JQX.Tree.hoveredItem = hoveredTree.$.container;
                        JQX.Tree.hoveredItem.classList.add('drop-target');
                    }
                } else {
                    delete JQX.Tree.hoveredItem;
                }
            }
        }

        /**
         * Moves the sub-items of a jqx-tree-items-group.
         */

    }, {
        key: '_moveSubItems',
        value: function _moveSubItems(children, targetTree, padding) {
            var that = this;

            for (var i = 0; i < children.length; i++) {
                var currentChild = children[i];

                currentChild.menu = targetTree;
                currentChild.set('level', currentChild.parentItem.level + 1);
                currentChild.firstElementChild.style.paddingLeft = '';
                currentChild.firstElementChild.style.paddingRight = '';
                that._setIndentation(currentChild.firstElementChild, currentChild.level, padding);
                // restore filtered state
                currentChild.hidden = false;
                currentChild.$.removeClass('jqx-hidden');
                currentChild.$.removeClass('filtered-child');
                currentChild.$.removeClass('last-filtered-child');

                if (currentChild instanceof JQX.TreeItemsGroup) {
                    currentChild.$.removeClass('hidden-children');
                    currentChild.container.level = currentChild.level + 1;
                    that._moveSubItems(currentChild.itemContainer.children, targetTree, padding);

                    if (targetTree !== that && currentChild.expanded) {
                        targetTree._menuItemsGroupsToExpand.push(currentChild);
                        that._updateState('expanded', currentChild.id, false);
                    }
                }
            }
        }

        /**
         * Moves a jqx-tree-item.
         */

    }, {
        key: '_moveTreeItem',
        value: function _moveTreeItem(draggedItem, targetItem, position, affectedTrees) {
            var that = this,
                oldLevel = draggedItem.level;

            if (position === 0) {
                if (targetItem.previousElementSibling === draggedItem) {
                    return;
                }

                targetItem.parentElement.insertBefore(draggedItem, targetItem);
                draggedItem.set('level', targetItem.level);
            } else if (position === 2) {
                if (targetItem.nextElementSibling === draggedItem) {
                    return;
                }

                targetItem.parentElement.insertBefore(draggedItem, targetItem.nextElementSibling || null);
                draggedItem.set('level', targetItem.level);
            } else if (targetItem === affectedTrees[0].$.container) {
                affectedTrees[0].$.mainContainer.appendChild(draggedItem);
                draggedItem.set('level', 1);
            } else {
                if (targetItem.itemContainer.lastElementChild === draggedItem) {
                    return;
                }

                targetItem.itemContainer.appendChild(draggedItem);
                draggedItem.set('level', targetItem.level + 1);
            }

            var padding = affectedTrees[0].rightToLeft ? 'paddingRight' : 'paddingLeft';

            draggedItem.menu = affectedTrees[0];
            draggedItem.parentItem = draggedItem.parentElement.menuItemsGroup;
            draggedItem.firstElementChild.style.paddingLeft = '';
            draggedItem.firstElementChild.style.paddingRight = '';
            that._setIndentation(draggedItem.firstElementChild, draggedItem.level, padding);
            // restore filtered state
            draggedItem.hidden = false;
            draggedItem.$.removeClass('jqx-hidden');
            draggedItem.$.removeClass('filtered-child');
            draggedItem.$.removeClass('last-filtered-child');

            if (draggedItem instanceof JQX.TreeItemsGroup) {
                draggedItem.$.removeClass('hidden-children');
                draggedItem.container.level = draggedItem.level + 1;
                that._moveSubItems(draggedItem.itemContainer.children, affectedTrees[0], padding);

                if (draggedItem.expanded) {
                    var index = that._openedContainers[oldLevel + 1].indexOf(draggedItem.container);

                    if (index !== -1) {
                        that._openedContainers[oldLevel + 1].splice(index, 1);
                    }

                    affectedTrees[0]._menuItemsGroupsToExpand.push(draggedItem);

                    if (affectedTrees.length === 2) {
                        that._updateState('expanded', draggedItem.id, false);
                    }
                }
            }

            for (var i = 0; i < affectedTrees.length; i++) {
                var tree = affectedTrees[i],
                    oldContext = tree.context,
                    oldSelectedIndexes = tree.selectedIndexes.slice(0);

                tree.context = tree;
                tree._menuItems = {};
                tree._refreshItemPaths(tree.$.mainContainer, true, undefined, tree.sorted && !tree.autoSort);
                tree.selectedIndexes = [];
                tree._applySelection(true, oldSelectedIndexes, false);
                tree._checkOverflow();
                tree.context = oldContext;
            }

            affectedTrees[0]._expandItemsByDefault();
        }

        /**
         * An empty handler used to override unnecessarily inherited Menu handlers.
         */

    }, {
        key: '_overriddenMenuHandler',
        value: function _overriddenMenuHandler() {}

        /**
         * Handles PgDn navigation.
         */

    }, {
        key: '_pageDownHandler',
        value: function _pageDownHandler(treeItems, highlightedItem, selectOnHover, event) {
            var that = this,
                scrollViewer = that.$.scrollViewer;

            function getLastItemInView() {
                for (var i = treeItems.length - 1; i >= 0; i--) {
                    var currentItem = treeItems[i];

                    if (that._canItemBeHovered(currentItem) && that._getOffsetTop(currentItem) + currentItem.firstElementChild.offsetHeight <= scrollViewer.scrollTop + scrollViewer.$.container.offsetHeight) {
                        return currentItem;
                    }
                }
            }

            if (!highlightedItem) {
                return;
            }

            var lastItemInView = getLastItemInView();

            if (!lastItemInView) {
                return;
            }

            if (highlightedItem !== lastItemInView) {
                highlightedItem.removeAttribute('focus');
                that._hoverViaKeyboard(lastItemInView, selectOnHover, event);
            } else if (scrollViewer.scrollTop + scrollViewer.$.container.offsetHeight !== scrollViewer.$.scrollViewerContentContainer.offsetHeight) {

                that.$.scrollViewer.scrollTop += scrollViewer.$.container.offsetHeight;

                if (that.scrollMode === 'scrollButtons') {
                    that._updateScrollButtonVisibility();
                }

                lastItemInView = getLastItemInView();
                highlightedItem.removeAttribute('focus');
                that._hoverViaKeyboard(lastItemInView, selectOnHover, event);
            }
        }

        /**
         * Handles PgUp navigation.
         */

    }, {
        key: '_pageUpHandler',
        value: function _pageUpHandler(treeItems, highlightedItem, selectOnHover, event) {
            var that = this,
                scrollViewer = that.$.scrollViewer;

            function getFirstItemInView() {
                for (var i = 0; i < treeItems.length; i++) {
                    var currentItem = treeItems[i];

                    if (that._canItemBeHovered(currentItem) && that._getOffsetTop(currentItem) >= scrollViewer.scrollTop) {
                        return currentItem;
                    }
                }
            }

            if (!highlightedItem) {
                return;
            }

            var firstItemInView = getFirstItemInView();

            if (!firstItemInView) {
                return;
            }

            if (highlightedItem !== firstItemInView) {
                highlightedItem.removeAttribute('focus');
                that._hoverViaKeyboard(firstItemInView, selectOnHover, event);
            } else if (scrollViewer.scrollTop !== 0) {
                that.$.scrollViewer.scrollTop -= scrollViewer.$.container.offsetHeight;

                if (that.scrollMode === 'scrollButtons') {
                    that._updateScrollButtonVisibility();
                }

                firstItemInView = getFirstItemInView();
                highlightedItem.removeAttribute('focus');
                that._hoverViaKeyboard(firstItemInView, selectOnHover, event);
            } else if (that.filterable) {
                that.$.filterInput.focus();
            }
        }

        /**
         * Refreshes item paths and selection.
         */

    }, {
        key: '_refreshItemPathsAndSelection',
        value: function _refreshItemPathsAndSelection() {
            var that = this,
                oldSelectedIndexes = that.selectedIndexes.slice(0);

            that._menuItems = {};
            that._refreshItemPaths(that.$.mainContainer, true);
            that.selectedIndexes = [];
            that._applySelection(true, oldSelectedIndexes);
        }

        /**
         * Refreshes sorting.
         */

    }, {
        key: '_refreshSorting',
        value: function _refreshSorting() {
            var that = this;

            that._unsortItems(that.$.mainContainer);
            that._applyGrouping(that.$.mainContainer);

            var filterQuery = that._state.filter;

            if (filterQuery) {
                that._applyFilter(filterQuery);
            }

            that._checkOverflow();
        }

        /**
         * Scrolls using scroll buttons.
         */

    }, {
        key: '_scroll',
        value: function _scroll(scrollCoefficient) {
            var that = this;

            that.$.scrollViewer.scrollTop = that.$.scrollViewer.scrollTop + scrollCoefficient * 10;
            that._updateScrollButtonVisibility();
            that.focus();
        }

        /**
         * Far scroll button click handler.
         */

    }, {
        key: '_scrollButtonFarClickHandler',
        value: function _scrollButtonFarClickHandler() {
            var that = this;

            if (that.$.scrollButtonFar.disabled) {
                return;
            }

            that._scroll(1);
        }

        /**
         * Near scroll button click handler.
         */

    }, {
        key: '_scrollButtonNearClickHandler',
        value: function _scrollButtonNearClickHandler() {
            var that = this;

            if (that.$.scrollButtonNear.disabled) {
                return;
            }

            that._scroll(-1);
        }

        /**
         * scrollViewer down handler.
         */

    }, {
        key: '_scrollViewerDownHandler',
        value: function _scrollViewerDownHandler(event) {
            var that = this;

            if (event.target !== that.$.scrollViewer || that.disabled || that.displayLoadingIndicator || !that._isMobile && event.which !== 1) {
                return;
            }

            function continueSelection() {
                var pressedItem = target.closest('jqx-tree-item') || target.closest('jqx-tree-items-group');

                if (!(pressedItem && that._canItemBeSelected(pressedItem))) {
                    return;
                }

                var arrow = target.closest('.jqx-tree-items-group-arrow');
                var selectionHandler = void 0;

                if (pressedItem instanceof JQX.TreeItem) {
                    selectionHandler = '_handleSelection';
                } else {
                    if (target === pressedItem.container || target === pressedItem.container.firstElementChild) {
                        return;
                    }

                    selectionHandler = '_menuItemsGroupSelectionHandler';
                }

                clearTimeout(that._dblclickTimeout);

                if (pressedItem !== that._dblclickObject.target) {
                    that._dblclickObject.numberOfClicks = 0;
                }

                that._dblclickObject.target = pressedItem;
                that._dblclickObject.numberOfClicks++;

                that._dblclickTimeout = setTimeout(function () {
                    that._dblclickObject.numberOfClicks = 0;
                }, 300);

                if (that._dblclickObject.numberOfClicks === 2) {
                    if (!that.editable) {
                        that._dblclickHandler(pressedItem, arrow, event);
                        that._dblclickObject.numberOfClicks = 0;
                    } else {
                        that._startEditing(pressedItem);
                        return;
                    }
                }

                if (pressedItem.selected) {
                    that._downItem = pressedItem;
                }

                that[selectionHandler](pressedItem, event);
                that._discardKeyboardHover(true);
                that._hoverViaKeyboard(pressedItem, false, undefined, false);

                if (!arrow) {
                    that._startDragging(pressedItem, event);
                }
            }

            var target = event.originalEvent.target;

            if (target === that.$.editInput) {
                that._editInputDown = true;
                return;
            }

            if (that._isMobile) {
                var current = that.$.scrollViewer.scrollTop;

                setTimeout(function () {
                    if (that.$.scrollViewer.scrollTop !== current) {
                        return;
                    } else {
                        var oldContext = that.context;

                        that.context = that;
                        continueSelection();
                        that.context = oldContext;
                    }
                }, 250);
            } else {
                continueSelection();
            }
        }

        /**
         * scrollViewer wheel handler.
         */

    }, {
        key: '_scrollViewerWheelHandler',
        value: function _scrollViewerWheelHandler() {
            var that = this;

            if (that.scrollMode === 'scrollButtons' && that.overflow !== 'hidden') {
                that._updateScrollButtonVisibility();
            }
        }

        /**
         * Selects a range of items.
         */

    }, {
        key: '_selectItemRange',
        value: function _selectItemRange(from, to) {
            var that = this,
                treeItems = Array.from(that.$.mainContainer.querySelectorAll('jqx-tree-item, jqx-tree-items-group')),
                indexOfFrom = treeItems.indexOf(from),
                indexOfTo = treeItems.indexOf(to),
                selectedIndexes = [];

            for (var i = Math.min(indexOfFrom, indexOfTo); i <= Math.max(indexOfFrom, indexOfTo); i++) {
                var currentItem = treeItems[i];

                if (that._canItemBeHovered(currentItem)) {
                    selectedIndexes.push(currentItem.path);
                    currentItem.set('selected', true);
                }
            }

            return selectedIndexes;
        }

        /**
         * Sets whether the element can be focused.
         */

    }, {
        key: '_setFocusable',
        value: function _setFocusable() {
            babelHelpers.get(Tree.prototype.__proto__ || Object.getPrototypeOf(Tree.prototype), '_setFocusable', this).call(this);

            var that = this;

            if (that.disabled || that.unfocusable) {
                that.$.filterInput.tabIndex = -1;
                return;
            }

            that.$.filterInput.removeAttribute('tabindex');
        }

        /**
         * Sets item indentation.
         */

    }, {
        key: '_setIndentation',
        value: function _setIndentation(labelContainer, level, padding) {
            labelContainer.style[padding] = level * 20 - 10 + 'px';
        }

        /**
         * Sets checked, unchecked, or indeterminate state to a checkbox.
         */

    }, {
        key: '_setThreeStateCheckbox',
        value: function _setThreeStateCheckbox(item, selectedChildren, indeterminateChildren) {
            if (selectedChildren === item.itemContainer.childElementCount) {
                item.removeAttribute('indeterminate');
                item.set('selected', true);
            } else if (selectedChildren === 0 && indeterminateChildren === 0) {
                item.removeAttribute('indeterminate');
                item.set('selected', false);
            } else {
                item.setAttribute('indeterminate', '');
                item.set('selected', false);
            }
        }

        /**
         * Sorts items.
         */

    }, {
        key: '_sortItems',
        value: function _sortItems(item) {
            var that = this;

            if (!that.sorted) {
                return;
            }

            var parent = void 0;

            if (item instanceof JQX.TreeItemsGroup) {
                parent = item.container.firstElementChild;
            } else if (item === that.$.mainContainer) {
                parent = item;
            }

            var children = Array.from(parent.children);

            if (that.sort) {
                // custom sorting
                var customSortingResult = that.sort(children, item);

                if (Array.isArray(customSortingResult)) {
                    children = customSortingResult;
                }
            } else if (that.sortDirection === 'asc') {
                children.sort(function (a, b) {
                    return a.label.localeCompare(b.label);
                });
            } else {
                children.sort(function (a, b) {
                    return b.label.localeCompare(a.label);
                });
            }

            // sort items in DOM
            for (var i = children.length - 1; i >= 0; i--) {
                parent.insertBefore(children[i], parent.firstElementChild);
            }
        }

        /**
         * Sorts a collection of item paths.
         */

    }, {
        key: '_sortPathCollection',
        value: function _sortPathCollection(collection) {
            collection.sort(function (a, b) {
                var aSplit = a.split('.'),
                    bSplit = b.split('.'),
                    maxLength = Math.max(aSplit.length, bSplit.length);

                for (var i = 0; i < maxLength; i++) {
                    var aCurrent = parseFloat(aSplit[i]),
                        bCurrent = parseFloat(bSplit[i]);

                    if (isNaN(aCurrent)) {
                        return -1;
                    }

                    if (isNaN(bCurrent)) {
                        return 1;
                    }

                    if (aCurrent < bCurrent) {
                        return -1;
                    }

                    if (aCurrent > bCurrent) {
                        return 1;
                    }
                }
            });
        }

        /**
         * starts dragging operation
         */

    }, {
        key: '_startDragging',
        value: function _startDragging(pressedItem, event) {
            var that = this,
                selectionMode = that.selectionMode;

            if (!that.allowDrag || that._editedItem || selectionMode === 'none') {
                return;
            }

            var items = [],
                validItems = [];
            var validateOnDrop = void 0;

            if (['one', 'zeroOrOne', 'checkBox', 'radioButton'].indexOf(selectionMode) !== -1) {
                validateOnDrop = false;
                items.push(pressedItem);
                validItems.push(pressedItem);
            } else {
                // selectionModes 'oneOrManyExtended', 'zeroOrMany', 'oneOrMany'
                validateOnDrop = true;

                for (var i = 0; i < that.selectedIndexes.length; i++) {
                    items.push(that._menuItems[that.selectedIndexes[i]]);
                    validItems.push(items[i]);
                }

                for (var _i15 = 0; _i15 < items.length; _i15++) {
                    var item = items[_i15];

                    if (validItems.indexOf(item) === -1) {
                        continue;
                    }

                    for (var j = validItems.length - 1; j >= 0; j--) {
                        var nextItem = validItems[j];

                        if (nextItem === item) {
                            break;
                        }

                        if (item.contains(nextItem)) {
                            validItems.splice(j, 1);
                        }
                    }
                }
            }

            that._dragDetails = {
                StartPosition: {
                    left: event.pageX, top: event.pageY
                },
                Items: items,
                ValidItems: validItems,
                Item: pressedItem,
                FeedbackShown: false,
                ValidateOnDrop: validateOnDrop,
                OriginalEvent: event,
                StartTime: new Date(),
                Dragging: true
            };

            JQX.Tree.treeItemDragged = true;
            that.$.scrollViewer._scrollView.disableSwipeScroll = true;

            if (that.allowDrop) {
                JQX.Tree.hoveredTree = that;
                JQX.Tree.hoveredItem = pressedItem;
            }
        }

        /**
         * Starts editing operation.
         */

    }, {
        key: '_startEditing',
        value: function _startEditing(item) {
            var that = this,
                editInput = that.$.editInput;
            var getOffset = void 0,
                padding = void 0;

            if (!that._canItemBeSelected(item)) {
                return;
            }

            var labelContainer = item.firstElementChild,
                labelElement = labelContainer.firstElementChild;

            if (!that.rightToLeft) {
                getOffset = function getOffset() {
                    return labelElement.offsetLeft + parseFloat(window.getComputedStyle(labelContainer).borderLeftWidth);
                };
                padding = 'paddingLeft';
            } else {
                getOffset = function getOffset() {
                    return labelContainer.offsetWidth - labelElement.offsetLeft - labelElement.offsetWidth;
                };
                padding = 'paddingRight';
            }

            if (item instanceof JQX.TreeItemsGroup) {
                editInput.style[padding] = getOffset() + (that.showLines ? parseFloat(window.getComputedStyle(labelElement.firstElementChild).paddingLeft) : 0) - 1 + 'px';
                editInput.style.height = labelContainer.offsetHeight + 'px';
            } else {
                editInput.style[padding] = item.offsetWidth + parseInt(labelContainer.style[padding], 10) - labelContainer.offsetWidth + parseFloat(window.getComputedStyle(labelElement.firstElementChild).paddingLeft) - 2 + 'px';
                editInput.style.height = item.offsetHeight + 'px';
            }

            editInput.style.top = that._getOffsetTop(item) + 'px';
            that.$editInput.removeClass('jqx-hidden');
            editInput.value = item.label;
            that._editedItem = item;

            setTimeout(function () {
                editInput.focus();
            }, 0);
        }

        /**
         * styleChanged event handler.
         */

    }, {
        key: '_styleChangedHandler',
        value: function _styleChangedHandler(event) {
            if (event.detail.styleProperties && event.detail.styleProperties['font-size']) {
                this._checkOverflow();
            }
        }

        /**
         * Updates scroll button visibility.
         */

    }, {
        key: '_updateScrollButtonVisibility',
        value: function _updateScrollButtonVisibility() {
            var that = this,
                overflow = that.overflow;

            if (that.scrollMode === 'scrollbar' || overflow === 'hidden') {
                return;
            }

            var showNear = true,
                showFar = true;

            if (Math.round(that.$.scrollViewer.scrollTop) === 0) {
                showNear = false;
            }

            if (Math.round(that.$.scrollViewer.$.scrollViewerContainer.offsetHeight + that.$.scrollViewer.scrollTop) >= Math.round(that.$.scrollViewer.$.scrollViewerContentContainer.offsetHeight)) {
                showFar = false;
            }

            if (overflow === 'auto') {
                if (showNear && showFar) {
                    that.$scrollButtonNear.removeClass('jqx-hidden');
                    that.$scrollButtonFar.removeClass('jqx-hidden');
                    that.$scrollViewer.removeClass('one-button-shown');
                    that.$.scrollViewer.refresh();
                    return;
                }

                if (showNear) {
                    that.$scrollButtonNear.removeClass('jqx-hidden');
                } else {
                    that.$scrollButtonNear.addClass('jqx-hidden');
                }

                if (showFar) {
                    that.$scrollButtonFar.removeClass('jqx-hidden');
                } else {
                    that.$scrollButtonFar.addClass('jqx-hidden');
                }

                that.$scrollViewer.addClass('one-button-shown');
                that.$.scrollViewer.refresh();
            } else if (overflow === 'scroll' && !that.disabled) {
                that.$.scrollButtonNear.disabled = !showNear;
                that.$.scrollButtonFar.disabled = !showFar;
            }
        }

        /**
         * Updates stored state.
         */

    }, {
        key: '_updateState',
        value: function _updateState(field, value, add) {
            var that = this;

            switch (field) {
                case 'expanded':
                    {
                        var index = that._state.expanded.indexOf(value);

                        if (add && index === -1) {
                            that._state.expanded.push(value);
                        } else if (!add && index !== -1) {
                            that._state.expanded.splice(index, 1);
                        } else {
                            return;
                        }

                        break;
                    }
                case 'filter':
                    that._state.filter = value !== undefined ? value : that.$.filterInput.value;
                    break;
                case 'selected':
                    that._state.selected = [];

                    for (var i = 0; i < that.selectedIndexes.length; i++) {
                        var currentSelectedItem = that._menuItems[that.selectedIndexes[i]];

                        that._state.selected.push(currentSelectedItem.id);
                    }
                    break;
                case 'sorted':
                    that._state.sorted = value;
                    break;
            }

            if (that.autoSaveState) {
                window.localStorage.setItem('jqxTree' + that.id, JSON.stringify(that._state));
            }
        }

        /**
         * Vertical Scroll Bar handler
         */

    }, {
        key: '_verticalScrollbarHandler',
        value: function _verticalScrollbarHandler() {
            var scrollViewer = this,
                verticalScrollBar = scrollViewer.$.verticalScrollBar,
                value = verticalScrollBar.value;

            if (scrollViewer.disabled) {
                return;
            }

            if (verticalScrollBar.max === value) {
                if (!scrollViewer._bottomReached) {
                    scrollViewer.$.fireEvent('scrollBottomReached');
                    delete scrollViewer._topReached;
                    scrollViewer._bottomReached = true;
                }

                return;
            }

            if (verticalScrollBar.min === value) {
                if (!scrollViewer._topReached) {
                    scrollViewer.$.fireEvent('scrollTopReached');
                    delete scrollViewer._bottomReached;
                    scrollViewer._topReached = true;
                }
                return;
            }

            delete scrollViewer._topReached;
            delete scrollViewer._bottomReached;
        }
    }], [{
        key: 'properties',

        // Tree's properties.
        get: function get() {
            return {
                'allowDrag': {
                    value: false,
                    type: 'boolean'
                },
                'allowDrop': {
                    value: false,
                    type: 'boolean'
                },
                'autoHideToggleElement': {
                    value: false,
                    type: 'boolean'
                },
                'autoLoadState': {
                    value: false,
                    type: 'boolean'
                },
                'autoSaveState': {
                    value: false,
                    type: 'boolean'
                },
                'autoSort': {
                    value: true,
                    type: 'boolean'
                },
                'displayLoadingIndicator': {
                    value: false,
                    type: 'boolean'
                },
                'dragFeedbackFormatFunction': {
                    value: null,
                    type: 'function?'
                },
                'dragOffset': {
                    value: [10, 10],
                    type: 'array'
                },
                'editable': {
                    value: false,
                    type: 'boolean'
                },
                'filterable': {
                    value: false,
                    type: 'boolean'
                },
                'filterInputPlaceholder': {
                    value: '',
                    type: 'string'
                },
                'filterMode': {
                    value: 'containsIgnoreCase',
                    allowedValues: ['contains', 'containsIgnoreCase', 'doesNotContain', 'doesNotContainIgnoreCase', 'equals', 'equalsIgnoreCase', 'startsWith', 'startsWithIgnoreCase', 'endsWith', 'endsWithIgnoreCase'],
                    type: 'string'
                },
                'hasThreeStates': {
                    value: false,
                    type: 'boolean'
                },
                'loadingIndicatorPlaceholder': {
                    value: 'Loading...',
                    type: 'string'
                },
                'loadingIndicatorPosition': {
                    value: 'center',
                    allowedValues: ['bottom', 'center', 'top'],
                    type: 'string'
                },
                'messages': {
                    value: {
                        'en': {
                            'noId': 'jqx-tree: Saving and loading the element\'s state are not available if the element has no id.'
                        }
                    },
                    type: 'object',
                    extend: true
                },
                'scrollMode': {
                    value: 'scrollbar',
                    allowedValues: ['scrollbar', 'scrollButtons'],
                    type: 'string'
                },
                'selectedIndexes': {
                    value: [],
                    type: 'array'
                },
                'selectionDisplayMode': {
                    value: 'row',
                    allowedValues: ['row', 'label'],
                    type: 'string'
                },
                'selectionMode': {
                    value: 'one',
                    allowedValues: ['none', 'oneOrManyExtended', 'zeroOrMany', 'oneOrMany', 'zeroOrOne', 'one', 'checkBox', 'radioButton'],
                    type: 'string'
                },
                'showLines': {
                    value: false,
                    type: 'boolean'
                },
                'showRootLines': {
                    value: false,
                    type: 'boolean'
                },
                'sort': {
                    value: null,
                    type: 'function?'
                },
                'sortDirection': {
                    value: 'asc',
                    allowedValues: ['asc', 'desc'],
                    type: 'string'
                },
                'sorted': {
                    value: false,
                    type: 'boolean'
                },
                'toggleElementPosition': {
                    value: 'near',
                    allowedValues: ['near', 'far'],
                    type: 'string'
                },
                'toggleMode': {
                    value: 'dblclick',
                    allowedValues: ['click', 'dblclick', 'arrow'],
                    type: 'string'
                }
            };
        }

        /**
         * Tree's event listeners.
         */

    }, {
        key: 'listeners',
        get: function get() {
            return {
                'blur': '_blurHandler',
                'focus': '_focusHandler',
                'keydown': '_keydownHandler',
                'mouseenter': '_mouseenterHandler',
                'mouseleave': '_mouseleaveHandler',
                'resize': '_checkOverflow',
                'styleChanged': '_styleChangedHandler',
                'transitionend': '_overriddenMenuHandler',
                'container.click': '_overriddenMenuHandler',
                'container.mouseout': '_overriddenMenuHandler',
                'container.mouseover': '_overriddenMenuHandler',
                'editInput.blur': '_editInputBlurHandler',
                'filterInput.keydown': '_filterInputKeydownHandler',
                'filterInput.keyup': '_filterInputKeyupHandler',
                'mainContainer.click': '_overriddenMenuHandler',
                'mainContainer.mouseleave': '_overriddenMenuHandler',
                'mainContainer.mouseout': '_overriddenMenuHandler',
                'mainContainer.mouseover': '_overriddenMenuHandler',
                'mainContainer.swipeleft': '_mainContainerSwipeHandler',
                'mainContainer.swiperight': '_mainContainerSwipeHandler',
                'scrollButtonFar.click': '_scrollButtonFarClickHandler',
                'scrollButtonNear.click': '_scrollButtonNearClickHandler',
                'scrollViewer.down': '_scrollViewerDownHandler',
                'scrollViewer.kineticScroll': '_scrollViewerWheelHandler',
                'mainContainer.wheel': '_scrollViewerWheelHandler',
                'document.move': '_moveHandler',
                'document.up': '_documentUpHandler'
            };
        }

        /**
         * Tree's required files.
         */

    }, {
        key: 'requires',
        get: function get() {
            return {
                'JQX.ScrollBar': 'jqxscrollbar.js'
            };
        }

        /**
        * CSS files needed for the element (ShadowDOM)
        */

    }, {
        key: 'styleUrls',
        get: function get() {
            return ['jqx.scrollbar.css', 'jqx.scrollviewer.css', 'jqx.tree.css'];
        }
    }]);
    return Tree;
}(JQX.Menu));