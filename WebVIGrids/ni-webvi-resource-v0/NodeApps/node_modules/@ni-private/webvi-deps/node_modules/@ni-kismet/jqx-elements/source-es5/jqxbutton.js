'use strict';

/**
* Button custom element.
*/
JQX('jqx-button', function (_JQX$ContentElement) {
    babelHelpers.inherits(Button, _JQX$ContentElement);

    function Button() {
        babelHelpers.classCallCheck(this, Button);
        return babelHelpers.possibleConstructorReturn(this, (Button.__proto__ || Object.getPrototypeOf(Button)).apply(this, arguments));
    }

    babelHelpers.createClass(Button, [{
        key: 'template',


        /** Button's template. */
        value: function template() {
            return '<button class=\'jqx-button\' inner-h-t-m-l=\'[[innerHTML]]\' id=\'button\' type=\'[[type]]\' name=\'[[name]]\' value=\'[[value]]\' disabled=\'[[disabled]]\' role=\'button\'></button>';
        }
    }, {
        key: 'focus',
        value: function focus() {
            var that = this;

            if (!that.$.button) {
                HTMLElement.prototype.focus.call(that);
                return;
            }

            that.$.button.focus();
        }
    }, {
        key: 'blur',
        value: function blur() {
            var that = this;

            if (!that.$.button) {
                HTMLElement.prototype.blur.call(that);
                return;
            }

            that.$.button.blur();
        }
    }, {
        key: '_upHandler',
        value: function _upHandler(event) {
            var that = this;

            event.stopPropagation();
            that.$.setAttributeValue('active', false);
        }
    }, {
        key: '_focusHandler',
        value: function _focusHandler() {
            var that = this;

            that.$.setAttributeValue('focus', true);
        }
    }, {
        key: '_blurHandler',
        value: function _blurHandler() {
            var that = this;

            that.$.setAttributeValue('focus', false);
        }
    }, {
        key: '_clickHandler',
        value: function _clickHandler(event) {
            var that = this;

            if (that.clickMode !== 'release' && that.clickMode !== 'pressAndRelease' || that.readonly) {
                event.preventDefault();
                event.stopPropagation();
            }
        }
    }, {
        key: '_downHandler',
        value: function _downHandler(event) {
            var that = this;

            if (that.disabled) {
                return;
            }

            //if (!that.enableShadowDOM) {
            //    event.originalEvent.stopPropagation();
            //}

            if (that.hasRippleAnimation) {
                JQX.Utilities.Animation.Ripple.animate(that, event.pageX, event.pageY);
            }

            that.$.setAttributeValue('active', true);

            if ((that.clickMode === 'press' || that.clickMode === 'pressAndRelease') && !that.readonly) {
                var buttons = 'buttons' in event ? event.buttons : event.which;

                that.$.fireEvent('click', { buttons: buttons, clientX: event.clientX, clientY: event.clientY, pageX: event.pageX, pageY: event.pageY, screenX: event.screenX, screenY: event.screenY });
            }
        }
    }, {
        key: '_mouseEnterHandler',
        value: function _mouseEnterHandler(event) {
            var that = this;

            if (that.readonly) {
                return;
            }

            that.$button.setAttributeValue('hover', true);
            that.$.setAttributeValue('hover', true);

            if (that.clickMode === 'hover') {
                var buttons = 'buttons' in event ? event.buttons : event.which;

                that.$.fireEvent('click', { buttons: buttons, clientX: event.clientX, clientY: event.clientY, pageX: event.pageX, pageY: event.pageY, screenX: event.screenX, screenY: event.screenY });
            }
        }
    }, {
        key: '_touchEndHandler',
        value: function _touchEndHandler() {
            var that = this;

            setTimeout(function () {
                that.$button.setAttributeValue('hover', false);
                that.$.setAttributeValue('hover', false);
            }, 300);
        }
    }, {
        key: '_mouseLeaveHandler',
        value: function _mouseLeaveHandler() {
            var that = this;

            that.$button.setAttributeValue('hover', false);
            that.$.setAttributeValue('hover', false);
        }

        /**
        * Called when a property is changed.
        */

    }, {
        key: 'propertyChangedHandler',
        value: function propertyChangedHandler(propertyName, oldValue, newValue) {
            babelHelpers.get(Button.prototype.__proto__ || Object.getPrototypeOf(Button.prototype), 'propertyChangedHandler', this).call(this, propertyName, oldValue, newValue);

            var that = this;

            if (propertyName === 'disabled') {
                that._setFocusable();

                if (that.$button) {
                    that.$button.setAttributeValue('hover', false);
                }

                that.$.setAttributeValue('hover', false);

                if (that instanceof JQX.RepeatButton) {
                    that._stopRepeat();
                }
            } else if (propertyName === 'unfocusable') {
                that._setFocusable();
            }
        }

        /**
         * Sets tab index 
         */

    }, {
        key: '_setFocusable',
        value: function _setFocusable() {
            var that = this;

            var target = that.$.button ? that.$.button : that;

            if (that.disabled || that.unfocusable) {
                target.removeAttribute('tabindex');
                target.tabIndex = -1;
                return;
            }

            target.tabIndex = that.tabIndex > 0 ? that.tabIndex : 0;
        }
    }, {
        key: 'ready',
        value: function ready() {
            var that = this;

            babelHelpers.get(Button.prototype.__proto__ || Object.getPrototypeOf(Button.prototype), 'ready', this).call(this);

            that._setFocusable();
        }
    }], [{
        key: 'properties',

        // Button's properties.
        get: function get() {
            return {
                'value': {
                    type: 'string'
                },
                'name': {
                    type: 'string'
                },
                'type': {
                    value: 'button',
                    type: 'string'
                },
                'clickMode': {
                    allowedValues: ['hover', 'press', 'release', 'pressAndRelease'],
                    type: 'string',
                    value: 'release'
                }
            };
        }

        /**
        * CSS files needed for the element (ShadowDOM)
        */

    }, {
        key: 'styleUrls',
        get: function get() {
            return ['jqx.button.css'];
        }
    }, {
        key: 'listeners',
        get: function get() {
            return {
                'button.down': '_downHandler',
                'button.mouseenter': '_mouseEnterHandler',
                'button.mouseleave': '_mouseLeaveHandler',
                'button.touchend': '_touchEndHandler',
                'button.click': '_clickHandler',
                'button.up': '_upHandler',
                'up': '_upHandler',
                'button.focus': '_focusHandler',
                'button.blur': '_blurHandler'
            };
        }
    }]);
    return Button;
}(JQX.ContentElement));

/**
* Repeat Button.
*/
JQX('jqx-repeat-button', function (_JQX$Button) {
    babelHelpers.inherits(RepeatButton, _JQX$Button);

    function RepeatButton() {
        babelHelpers.classCallCheck(this, RepeatButton);
        return babelHelpers.possibleConstructorReturn(this, (RepeatButton.__proto__ || Object.getPrototypeOf(RepeatButton)).apply(this, arguments));
    }

    babelHelpers.createClass(RepeatButton, [{
        key: '_clickHandler',
        value: function _clickHandler(event) {
            var that = this;

            if (that.clickMode !== 'release' || that.preventDefaultClick || that.readonly || that.disabled) {
                event.preventDefault();
                event.stopPropagation();
                that.preventDefaultClick = false;
            }
        }
    }, {
        key: '_updateInBoundsFlag',
        value: function _updateInBoundsFlag(event) {
            var that = this;

            that._isPointerInBounds = true;

            if (event.type === 'mouseleave') {
                that._isPointerInBounds = false;

                that.$button.setAttributeValue('hover', false);
                that.$.setAttributeValue('hover', false);
            } else {
                that.$button.setAttributeValue('hover', true);
                that.$.setAttributeValue('hover', true);
            }

            var buttons = 'buttons' in event ? event.buttons : event.which;
            if (buttons !== 1) {
                that._stopRepeat(event);
            }
        }
    }, {
        key: '_startRepeat',
        value: function _startRepeat(event) {
            var that = this;
            if (!that._initialTimer && !that.readonly) {
                that._initialTimer = setTimeout(function () {
                    that._repeatTimer = setInterval(function () {
                        if (that._isPointerInBounds) {
                            var buttons = 'buttons' in event ? event.buttons : event.which;

                            that.$.fireEvent('click', { buttons: buttons, clientX: event.clientX, clientY: event.clientY, pageX: event.pageX, pageY: event.pageY, screenX: event.screenX, screenY: event.screenY });
                            that.preventDefaultClick = true;
                        }
                    }, that.delay);
                }, that.initialDelay);
            }
        }
    }, {
        key: '_stopRepeat',
        value: function _stopRepeat() {
            var that = this;

            if (that.readonly) {
                return;
            }

            that.$.setAttributeValue('active', false);

            if (that._repeatTimer) {
                clearInterval(that._repeatTimer);
                that._repeatTimer = null;
            }

            if (that._initialTimer) {
                clearTimeout(that._initialTimer);
                that._initialTimer = null;
            }
        }
    }], [{
        key: 'properties',

        // button's properties.
        get: function get() {
            return {
                'delay': {
                    value: 50,
                    type: 'number'
                },
                'initialDelay': {
                    value: 150,
                    type: 'number'
                }
            };
        }
    }, {
        key: 'listeners',
        get: function get() {
            return {
                'button.mousedown': '_startRepeat',
                'button.mouseenter': '_updateInBoundsFlag',
                'button.mouseleave': '_updateInBoundsFlag',
                'document.mouseup': '_stopRepeat'
            };
        }
    }]);
    return RepeatButton;
}(JQX.Button));

/**
* Toggle Button.
*/
JQX('jqx-toggle-button', function (_JQX$Button2) {
    babelHelpers.inherits(ToggleButton, _JQX$Button2);

    function ToggleButton() {
        babelHelpers.classCallCheck(this, ToggleButton);
        return babelHelpers.possibleConstructorReturn(this, (ToggleButton.__proto__ || Object.getPrototypeOf(ToggleButton)).apply(this, arguments));
    }

    babelHelpers.createClass(ToggleButton, [{
        key: 'ready',


        /** Called when the element is ready. Used for one-time configuration of the ToggleButton. */
        value: function ready() {
            babelHelpers.get(ToggleButton.prototype.__proto__ || Object.getPrototypeOf(ToggleButton.prototype), 'ready', this).call(this);
        }

        /**
         * Overrides the inherited "click" handler of the inner button element.
         */

    }, {
        key: '_buttonClickHandler',
        value: function _buttonClickHandler() {}
    }, {
        key: '_buttonMouseLeaveHandler',
        value: function _buttonMouseLeaveHandler() {
            var that = this;

            that.removeAttribute('hover');
        }

        /**
         * Changes the check state on hover.
         */

    }, {
        key: '_buttonMouseEnterHandler',
        value: function _buttonMouseEnterHandler() {
            var that = this;

            that.setAttribute('hover', '');

            if (that.disabled || that.readonly || that.clickMode !== 'hover') {
                return;
            }

            that._changeCheckState('pointer');
            that.focus();
            that._updateHidenInputNameAndValue();
        }

        /** Changes the check state wneh widget container is clicked. */

    }, {
        key: '_documentUpHandler',
        value: function _documentUpHandler() {
            var that = this;

            if (!that._pressed) {
                return;
            }

            that._pressed = false;

            if (that.disabled || that.readonly || that.clickMode === 'press') {
                return;
            }

            that._changeCheckState('pointer');
            that.focus();
            that._updateHidenInputNameAndValue();
        }
    }, {
        key: '_downHandler',
        value: function _downHandler(event) {
            var that = this;

            if (that.disabled || that.readonly) {
                return;
            }

            if (that.hasRippleAnimation) {
                JQX.Utilities.Animation.Ripple.animate(that, event.pageX, event.pageY);
            }

            that._pressed = true;

            if (that.clickMode === 'press' || that.clickMode === 'pressAndRelease') {
                that._changeCheckState('pointer');
                that.$.fireEvent('click');
                that._updateHidenInputNameAndValue();
            }

            if (that.clickMode === 'press') {
                event.preventDefault();
                event.stopPropagation();
            }
        }
    }, {
        key: '_dragStartHandler',
        value: function _dragStartHandler(event) {
            event.preventDefault();
        }

        /** Changes the check state when spacebar is pressed. */

    }, {
        key: '_keyHandler',
        value: function _keyHandler(event) {
            var that = this;

            if (that.disabled !== true && !that.readonly && event.keyCode === 32) {
                if (event.type === 'keydown') {
                    event.preventDefault();
                    return;
                }

                if (that.switchMode === 'none') {
                    return;
                }

                that._changeCheckState('keyboard');
                that._updateHidenInputNameAndValue();
            }
        }

        /** Changes the check state. */

    }, {
        key: '_changeCheckState',
        value: function _changeCheckState(changeType) {
            var that = this;

            var oldValue = null;

            if (that.checked === null) {
                that.checked = true;
            } else {
                oldValue = that.checked;
                that.checked = !that.checked;
            }

            that._handleTextSelection();

            that.$.fireEvent('change', { 'value': that.checked, 'oldValue': oldValue, changeType: changeType });
        }
    }, {
        key: '_handleTextSelection',
        value: function _handleTextSelection() {
            var that = this;

            that.$.addClass('jqx-unselectable');

            if (that.timer) {
                clearTimeout(that.timer);
            }

            that.timer = setTimeout(function () {
                return that.$.removeClass('jqx-unselectable');
            }, 500);
        }

        /**
        * Called when a property is changed.
        */

    }, {
        key: 'propertyChangedHandler',
        value: function propertyChangedHandler(propertyName, oldValue, newValue) {
            babelHelpers.get(ToggleButton.prototype.__proto__ || Object.getPrototypeOf(ToggleButton.prototype), 'propertyChangedHandler', this).call(this, propertyName, oldValue, newValue);
            var that = this;

            if (propertyName === 'checked') {
                that.$.fireEvent('change', { 'value': newValue, 'oldValue': oldValue, changeType: 'api' });
            }

            switch (propertyName) {
                case 'trueTemplate':
                    that._handleTemplate(true);
                    break;
                case 'falseTemplate':
                    that._handleTemplate(false);
                    break;
                case 'indeterminateTemplate':
                    that._handleTemplate();
                    break;
            }
        }
    }, {
        key: '_htmlBindOnInitialization',
        value: function _htmlBindOnInitialization() {
            var that = this;

            that._bindContentProperty('trueContent', 'jqx-true-content');
            that._bindContentProperty('falseContent', 'jqx-false-content');
            that._bindContentProperty('indeterminateContent', 'jqx-indeterminate-content');
        }
    }, {
        key: '_bindContentProperty',
        value: function _bindContentProperty(propertyName, className) {
            var that = this;

            if (!that.$[propertyName + 'Container']) {
                return;
            }

            var testElement = document.createElement('div');

            testElement.innerHTML = that.innerHTML;

            var elements = testElement.getElementsByClassName(className),
                element = void 0;

            if (elements.length > 0) {
                for (var i = 0; i < elements.length; i++) {
                    element = elements[i];
                }
            }

            if (that[propertyName] === '') {
                that[propertyName] = element === undefined ? '' : element.outerHTML;
            }

            that.$[propertyName + 'Container'].innerHTML = that[propertyName];
        }
    }, {
        key: '_updateContentProperties',
        value: function _updateContentProperties() {
            var that = this;

            update('trueContent');
            update('falseContent');
            update('indeterminateContent');

            function update(property) {
                if (that.$[property + 'Container']) {
                    that[property] = that.$[property + 'Container'].innerHTML;
                }
            }
        }
    }, {
        key: '_updateHidenInputValue',
        value: function _updateHidenInputValue() {
            var that = this;

            if (!that.$.hiddenInput) {
                return;
            }

            var inputValue = void 0;

            if (that.checked === null) {
                inputValue = 'null';
            } else if (that.checked === false) {
                inputValue = 'off';
            } else {
                inputValue = that.value || 'on';
            }

            that.$.hiddenInput.setAttribute('value', inputValue);
        }
    }, {
        key: '_updateHidenInputName',
        value: function _updateHidenInputName() {
            var that = this;

            if (!that.$.hiddenInput) {
                return;
            }

            var inputName = that.checked === false ? '' : that.name || '';

            that.$.hiddenInput.setAttribute('name', inputName);
        }
    }, {
        key: '_updateHidenInputNameAndValue',
        value: function _updateHidenInputNameAndValue() {
            var that = this;

            that._updateHidenInputName();
            that._updateHidenInputValue();
        }

        /**
         * Apply a template to true/false/indeterminate states of the elements.
         */

    }, {
        key: '_handleTemplate',
        value: function _handleTemplate(state, oldValue) {
            var that = this;
            var template = void 0,
                templateTarget = void 0,
                value = void 0;

            if (state === true) {
                template = that.trueTemplate;
                templateTarget = that.$.trueContentContainer;
                value = that.trueContent;
            } else if (state === false) {
                template = that.falseTemplate;
                templateTarget = that.$.falseContentContainer;
                value = that.falseContent;
            } else {
                template = that.indeterminateTemplate;
                templateTarget = that.$.indeterminateContentContainer;
                value = that.indeterminateContent;
            }

            if (oldValue) {
                templateTarget.innerHTML = value ? value : '';
            }

            if (template === null || !template) {
                return;
            }

            if (typeof template === 'function') {
                template(templateTarget, { value: value });
                return;
            }

            if (!('content' in document.createElement('template'))) {
                that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() }));
                return;
            }

            template = document.getElementById(template);
            if (template === null || !('content' in template)) {
                that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: 'template' }));
                return;
            }

            var content = template.content,
                childrenCount = content.childNodes.length,
                regex = /{{\w+}}/g;
            var bindingString = void 0,
                bindingDetails = [];

            for (var i = 0; i < childrenCount; i++) {
                bindingString = regex.exec(content.childNodes[i].innerHTML);
                while (bindingString) {
                    bindingDetails.push({ childNodeIndex: i, bindingString: bindingString[0] });
                    bindingString = regex.exec(content.childNodes[i].innerHTML);
                }
            }

            var bindingsCount = bindingDetails.length;
            var clone = document.importNode(template.content, true),
                bindingHolderElement = void 0,
                bindingStringsCount = void 0;

            for (var b = 0; b < bindingsCount; b++) {
                bindingHolderElement = clone.childNodes[bindingDetails[b].childNodeIndex];
                bindingStringsCount = bindingDetails.length;
                for (var _i = 0; _i < bindingStringsCount; _i++) {
                    bindingHolderElement.innerHTML = bindingHolderElement.innerHTML.replace(bindingDetails[b].bindingString, value);
                }
            }

            templateTarget.innerHTML = '';
            for (var _i2 = 0; _i2 < clone.childNodes.length; _i2++) {
                if (clone.childNodes[_i2].outerHTML) {
                    templateTarget.innerHTML += clone.childNodes[_i2].outerHTML;
                }
            }
        }
    }], [{
        key: 'properties',

        // Toggle Button's properties.
        get: function get() {
            return {
                'checked': {
                    value: false,
                    type: 'boolean?'
                },
                'falseContent': {
                    value: '',
                    reflectToAttribute: false,
                    type: 'string'
                },
                'indeterminateContent': {
                    value: '',
                    reflectToAttribute: false,
                    type: 'string'
                },
                'indeterminate': {
                    value: false,
                    type: 'boolean'
                },
                'trueContent': {
                    value: '',
                    reflectToAttribute: false,
                    type: 'string'
                },
                'indeterminateTemplate': {
                    value: null,
                    type: 'any'
                },
                'trueTemplate': {
                    value: null,
                    type: 'any'
                },
                'falseTemplate': {
                    value: null,
                    type: 'any'
                },
                'type': {
                    value: 'toggle',
                    type: 'string',
                    defaultReflectToAttribute: true,
                    readonly: true
                }
            };
        }

        /**
        * Toggle Button's event listeners.
        */

    }, {
        key: 'listeners',
        get: function get() {
            return {
                'keydown': '_keyHandler',
                'keyup': '_keyHandler',
                'dragstart': '_dragStartHandler',
                'button.click': '_buttonClickHandler',
                'button.mouseenter': '_buttonMouseEnterHandler',
                'button.mouseleave': '_buttonMouseLeaveHandler',
                'document.up': '_documentUpHandler'
            };
        }
    }]);
    return ToggleButton;
}(JQX.Button));