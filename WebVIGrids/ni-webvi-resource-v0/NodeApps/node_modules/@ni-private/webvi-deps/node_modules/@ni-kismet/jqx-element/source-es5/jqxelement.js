'use strict';

(function () {
    'use strict';

    var Version = '3.4.0';
    var templates = [];

    var namespace = 'JQX';

    if (window[namespace] && window[namespace].Version) {
        if (window[namespace].Version === Version) {
            return;
        } else if (window[namespace].Version !== Version) {
            namespace += Version;
        } else {
            var suffix = 2;
            while (window[namespace]) {
                namespace += suffix.toString();
                suffix++;
            }
        }
    }

    function Import(urls, async) {
        var loadedScriptsLength = 0;

        var loadScript = function loadScript(url, baseUrl) {
            return new Promise(function (resolve) {
                var script = document.createElement('script');

                script.src = url;
                script.onload = resolve;

                for (var j = 0; j < document.head.children.length; j++) {
                    var child = document.head.children[j];

                    if (child.src && child.src.toString().indexOf(baseUrl) >= 0) {
                        resolve();
                        return;
                    }
                }

                document.head.appendChild(script);
            });
        };

        return new Promise(function (resolve) {
            var urlBase = Utilities.Core.getScriptLocation();

            var syncLoadScripts = function syncLoadScripts(index) {
                if (!urls[index]) {
                    return;
                }

                var url = urlBase + '/' + urls[index];

                loadScript(url, urls[index]).then(function () {
                    loadedScriptsLength++;

                    if (loadedScriptsLength === urls.length) {
                        resolve();
                    }

                    syncLoadScripts(index + 1);
                });
            };

            if (async) {
                for (var i = 0; i < urls.length; i++) {
                    var url = urlBase + '/' + urls[i];

                    loadScript(url, urls[i]).then(function () {
                        loadedScriptsLength++;

                        if (loadedScriptsLength === urls.length) {
                            resolve();
                        }
                    });
                }
            } else {
                syncLoadScripts(0);
            }
        });
    }

    /**
     * This is a base class for localization. Users can implement it in order to handle translations via i18n.
     */

    var LocalizationModule = function () {
        function LocalizationModule() {
            babelHelpers.classCallCheck(this, LocalizationModule);
        }

        babelHelpers.createClass(LocalizationModule, [{
            key: 'addMessages',


            /** 
             * Adds messages. 
             * @param {String} - the string value's key.
             * @param {Object} - the messages object.
             */
            value: function addMessages(messageKey, messages) {
                var that = this;

                Object.assign(that.messages[messageKey], messages);
            }

            /**
              * Translates a text.
              * @param {String} the string value's key.
              * @param {Object} the values to be replaced in the string.
              * @return {String} the translated text.
             */

        }, {
            key: 'localize',
            value: function localize(messageKey, messageArguments) {
                var that = this;

                if (!that.messages || !that.messages[that.locale]) {
                    return undefined;
                }

                var message = that.messages[that.locale][messageKey];

                if (message === '') {
                    return '';
                }

                if (!message) {
                    return undefined;
                }

                var defaultMessage = message;
                for (var messageName in messageArguments) {
                    var messageValue = messageArguments[messageName];
                    message = message.replace(new RegExp('{{' + messageName + '}}', 'g'), messageValue);
                }

                if (that.localizeFormatFunction) {
                    that.localizeFormatFunction(defaultMessage, message, messageArguments);
                }

                return message;
            }
        }], [{
            key: 'moduleName',
            get: function get() {
                return 'LocalizationModule';
            }
        }, {
            key: 'properties',
            get: function get() {
                var properties = {
                    'messages': {
                        value: {
                            en: {}
                        },
                        type: 'object',
                        inherit: true,
                        reflectToAttribute: false
                    },
                    'locale': {
                        value: 'en',
                        type: 'string',
                        reflectToAttribute: false
                    },
                    'localizeFormatFunction': {
                        value: undefined,
                        type: 'function',
                        reflectToAttribute: false
                    }
                };

                return properties;
            }
        }]);
        return LocalizationModule;
    }();

    /**
     * This is a base class for error logging.
     */


    var ErrorModule = function () {
        function ErrorModule() {
            babelHelpers.classCallCheck(this, ErrorModule);
        }

        babelHelpers.createClass(ErrorModule, [{
            key: 'log',


            /** Displays a log in the console.*/
            value: function log(message) {
                var that = this;

                that._logger('log', message);
            }

            /** Displays a warning in the console.*/

        }, {
            key: 'warn',
            value: function warn(message) {
                var that = this;

                that._logger('warn', message);
            }

            /** Displays an error in the console.*/

        }, {
            key: 'error',
            value: function error(message) {
                var that = this;

                that._logger('error', message);
            }

            /**
              Logs an Error.
              @param {String} the error's level - 'warn', 'error' or 'log'.
              @param {Error} the error to be logged.
             */

        }, {
            key: '_logger',
            value: function _logger(level, error) {
                var that = this;

                if (that.debugMode) {
                    var errorMessage = error instanceof Error ? error.message : error.toString();

                    console[level](errorMessage);
                }

                if (that.rethrowError && level === 'error') {
                    throw error;
                }
            }
        }], [{
            key: 'moduleName',
            get: function get() {
                return 'ErrorModule';
            }
        }, {
            key: 'properties',
            get: function get() {
                var properties = {
                    'rethrowError': {
                        value: true,
                        type: 'boolean',
                        reflectToAttribute: false
                    },
                    'debugMode': {
                        value: true,
                        type: 'boolean',
                        reflectToAttribute: false
                    }
                };

                return properties;
            }
        }]);
        return ErrorModule;
    }();

    /**
     * This is a base class for data binding.
     */


    var BindingModule = function () {
        function BindingModule() {
            babelHelpers.classCallCheck(this, BindingModule);
        }

        babelHelpers.createClass(BindingModule, [{
            key: 'getBindings',


            /**
             * @typedef {Object} bindings
             * @property {Array<Node>} children The child nodes.
             * @property {Node} node The node.
             * @property {BindingData} data The node's binding data.
             */

            /**
             * @typedef {Object} BindingData
             * @property {Boolean} twoWay - Deterimes whether it's one way or two way data binding.
             * @property {Boolean} updating - Determines whether the node is in update state.
             * @property {Object}  value - The bound property's value.
             * @property {String}  name - The bound property's name.
             */
            value: function getBindings(node, ownerMap) {
                var that = this;

                var index = 0;
                var map = {};
                var boundData = function (node) {
                    if (node instanceof HTMLElement) {
                        return that.parseAttributes(node);
                    } else {
                        var boundProperty = that.parseProperty(node.data ? node.data.trim() : null, 'textContent', node);

                        if (boundProperty) {
                            if (that.ownerElement && node.parentNode === that.ownerElement.$.content) {
                                boundProperty.value = that.ownerElement.$.html !== '' ? that.ownerElement.$.html : undefined;
                                that.ownerElement.innerHTML = '';
                            }

                            return {
                                'textContent': boundProperty
                            };
                        }
                    }

                    return undefined;
                }(node);

                if (boundData) {
                    map.data = boundData;
                }

                if (!ownerMap) {
                    map.mapping = [];
                    ownerMap = map;
                }

                if (node.getAttribute) {
                    map.nodeId = node.getAttribute('jqx-id');

                    if (ownerMap && boundData) {
                        ownerMap.mapping[map.nodeId] = boundData;
                    }
                }

                map.node = node;

                if (node.firstChild) {
                    map.children = {};
                }

                for (var child = node.firstChild; child; child = child.nextSibling) {
                    map.children[index++] = that.getBindings(child, ownerMap);
                }

                return map;
            }
        }, {
            key: '_addRemovePropertyBinding',
            value: function _addRemovePropertyBinding(hostPropertyName, targetPropertyName, targetElement, removeBinding) {
                if (!hostPropertyName || !targetPropertyName || !targetElement) {
                    return;
                }

                var that = this;
                var bindings = that.ownerElement.bindings;
                var id = targetElement.getAttribute('jqx-id');
                var twoWayBinding = hostPropertyName.indexOf('{{') >= 0;

                hostPropertyName = hostPropertyName.replace('{{', '').replace('}}', '').replace('[[', '').replace(']]', '');

                var not = false;

                if (hostPropertyName.indexOf('!') >= 0) {
                    hostPropertyName = hostPropertyName.replace('!', '');
                    not = true;
                }

                var hostProperty = that.ownerElement._properties[hostPropertyName];
                var boundProperty = {
                    name: hostPropertyName, reflectToAttribute: hostProperty.reflectToAttribute, twoWay: twoWayBinding, type: hostProperty.type, not: not
                };

                var setBinding = function setBinding(boundChildren) {
                    for (var childIndex in boundChildren) {
                        var child = boundChildren[childIndex];

                        if (child.nodeId === id) {
                            if (!child.data) {
                                child.data = {};
                            }

                            if (removeBinding) {
                                child.data[targetPropertyName] = null;
                                delete child.data[targetPropertyName];
                            } else {
                                child.data[targetPropertyName] = boundProperty;
                            }

                            break;
                        }

                        if (child.children) {
                            setBinding(child.children);
                        } else if (child.node && child.node.children && child.node === targetElement.parentElement) {
                            var node = child.node;

                            if (node.firstChild) {
                                child.children = {};
                            } else {
                                continue;
                            }

                            var index = 0;

                            for (var currentChild = node.firstChild; currentChild; currentChild = currentChild.nextSibling) {
                                child.children[index++] = that.getBindings(currentChild);
                            }

                            setBinding(child.children);
                        }
                    }
                };
                setBinding(bindings.children);

                if (!removeBinding) {
                    that.ownerElement.boundProperties[hostPropertyName] = true;
                } else {
                    delete that.ownerElement.boundProperties[hostPropertyName];
                }

                that.updateBoundNodes(hostPropertyName);
            }
        }, {
            key: 'addPropertyBinding',
            value: function addPropertyBinding(hostPropertyName, targetPropertyName, targetElement) {
                var that = this;

                that._addRemovePropertyBinding(hostPropertyName, targetPropertyName, targetElement);
            }
        }, {
            key: 'removePropertyBinding',
            value: function removePropertyBinding(hostPropertyName, targetPropertyName, targetElement) {
                var that = this;

                that._addRemovePropertyBinding(hostPropertyName, targetPropertyName, targetElement, true);
            }

            /**
             * Parses the element's attributes.
             * @param {HTMLElement} - html element.
             * @return {Array<BindingData>}
             */

        }, {
            key: 'parseAttributes',
            value: function parseAttributes(htmlElement) {
                var that = this;

                var boundProperties = undefined;

                for (var i = 0; i < htmlElement.attributes.length; i++) {
                    var attribute = htmlElement.attributes[i];
                    var attributeName = attribute.name;
                    var attributeValue = attribute.value;
                    if (!BindingModule.cache['toCamelCase' + attributeName]) {
                        BindingModule.cache['toCamelCase' + attributeName] = Utilities.Core.toCamelCase(attributeName);
                    }

                    var propertyName = BindingModule.cache['toCamelCase' + attributeName];

                    if (attributeName.indexOf('(') >= 0) {
                        var eventName = attributeName.substring(1, attributeName.length - 1);
                        if (that.ownerElement && !that.ownerElement.dataContext) {
                            that.ownerElement.templateListeners[htmlElement.getAttribute('jqx-id') + '.' + eventName] = attributeValue;
                            htmlElement.removeAttribute(attributeName);
                            continue;
                        } else {
                            if (!boundProperties) {
                                boundProperties = {};
                            }

                            var handlerName = attributeValue.substring(0, attributeValue.indexOf('('));

                            boundProperties[propertyName] = {
                                isEvent: true, name: eventName, value: handlerName
                            };
                            continue;
                        }
                    }

                    var boundProperty = that.parseProperty(attributeValue, attributeName, htmlElement);
                    if (!boundProperty) {
                        continue;
                    }

                    if (!boundProperties) {
                        boundProperties = {};
                    }

                    boundProperties[propertyName] = boundProperty;
                }

                return boundProperties;
            }

            /**
             * Parses a property.
             * @param {String} - The string to parse.
             * @param {name} - property's name.
             * @param {Node} - the node.
             * @return {BindingData}
             */

        }, {
            key: 'parseProperty',
            value: function parseProperty(text, elementAttributeName /*, name, node*/) {
                if (!text || !text.length) return;

                var that = this;

                var boundProperty = void 0;
                var length = text.length;
                var startIndex = 0,
                    lastIndex = 0,
                    endIndex = 0;
                var twoWay = true;

                while (lastIndex < length) {
                    startIndex = text.indexOf('{{', lastIndex);
                    var twoWayStart = text.indexOf('[[', lastIndex);
                    var terminator = '}}';

                    if (twoWayStart >= 0 && (startIndex < 0 || twoWayStart < startIndex)) {
                        startIndex = twoWayStart;
                        twoWay = false;
                        terminator = ']]';
                    }

                    endIndex = startIndex < 0 ? -1 : text.indexOf(terminator, startIndex + 2);

                    if (endIndex < 0) {
                        return;
                    }

                    boundProperty = boundProperty || {};
                    var pathString = text.slice(startIndex + 2, endIndex).trim();
                    var attributeName = pathString;

                    /*   if (twoWay) {
                           const updateToken = function (value) {
                               boundProperty.value = value;
                                    if (node.$ && node.$.isNativeElement) {
                                        if (!BindingModule.cache['toDash' + name]) {
                                       BindingModule.cache['toDash' + name] = Utilities.Core.toDash(name);
                                   }
                                        const attributeName = BindingModule.cache['toDash' + name];
                                   const oldValue = node.$.getAttributeValue(attributeName, boundProperty.type);
                                        if (oldValue !== boundProperty.value) {
                                       node.$.setAttributeValue(attributeName, boundProperty.value, boundProperty.type);
                                   }
                               }
                           }
                                if (pathString.indexOf('::') >= 0) {
                               const eventIndex = pathString.indexOf('::');
                               const eventName = pathString.substring(eventIndex + 2);
                                    that.ownerElement['$' + node.getAttribute('jqx-id')].listen(eventName, function () {
                                   updateToken(node[name]);
                                        const boundPropertyName = boundProperty.name.substring(0, boundProperty.name.indexOf('::'));
                                   that.updateBoundProperty(boundPropertyName, boundProperty);
                               });
                           }
                                if (node.$ && node.$.isCustomElement) {
                               if (!BindingModule.cache['toDash' + name]) {
                                   BindingModule.cache['toDash' + name] = Utilities.Core.toDash(name);
                               }
                                    const attributeName = BindingModule.cache['toDash' + name];
                               const propertyName = Utilities.Core.toCamelCase(attributeName);
                               
                               if (node._properties && node._properties[propertyName]) {
                                   node._properties[propertyName].notify = true;
                               }
                                    that.ownerElement['$' + node.getAttribute('jqx-id')].listen(attributeName + '-changed', function (event) {
                                   const detail = event.detail;
                                        updateToken(detail.value);
                                        const context = that.ownerElement.context;
                                   
                                   if (event.context !== document) {
                                       that.ownerElement.context = that.ownerElement;
                                   }
                                        that.updateBoundProperty(name, boundProperty);
                                        that.ownerElement.context = context;
                               });
                           }
                       }*/

                    boundProperty.name = attributeName;
                    lastIndex = endIndex + 2;
                }

                var propertyName = boundProperty.name;
                var elementProperty = that.ownerElement ? that.ownerElement._properties[propertyName] : null;

                boundProperty.twoWay = twoWay;
                boundProperty.ready = false;

                if (that.ownerElement) {
                    if (propertyName.indexOf('::') >= 0) {
                        that.ownerElement.boundProperties[propertyName.substring(0, propertyName.indexOf('::'))] = true;
                    } else {
                        that.ownerElement.boundProperties[propertyName] = true;
                    }
                }

                if (elementProperty) {
                    boundProperty.type = elementProperty.type;
                    boundProperty.reflectToAttribute = elementProperty.reflectToAttribute;
                } else {
                    var booleans = ['checked', 'selected', 'async', 'autofocus', 'autoplay', 'controls', 'defer', 'disabled', 'hidden', 'ismap', 'loop', 'multiple', 'open', 'readonly', 'required', 'scoped'];
                    if (booleans.indexOf(elementAttributeName) >= 0) {
                        boundProperty.type = 'boolean';
                    } else {
                        boundProperty.type = 'string';
                    }

                    boundProperty.reflectToAttribute = true;
                }

                return boundProperty;
            }

            /**
             * Updates element's data bound nodes.
             */

        }, {
            key: 'updateTextNodes',
            value: function updateTextNodes() {
                var that = this;

                that.updateTextNode(that.ownerElement.shadowRoot || that.ownerElement, that.ownerElement.bindings, that.ownerElement);
            }

            /**
             * Updates a data bound node.
             * @param {Node} - The bound node.
             * @param {Array<BindingData>} - The node's binding data.
             * @param {Element} - The element to be updated.
             */

        }, {
            key: 'updateTextNode',
            value: function updateTextNode(node, bindings, element) {
                var that = this;

                if (!bindings) {
                    return;
                }

                var index = 0;
                for (var child = node.firstChild; child; child = child.nextSibling) {
                    if (!bindings.children) {
                        break;
                    }

                    that.updateTextNode(child, bindings.children[index++], element);
                }

                if (!bindings || !bindings.data) {
                    return;
                }

                for (var name in bindings.data) {
                    var boundProperty = bindings.data[name];
                    var boundPropertyName = boundProperty.name;

                    if (name !== 'textContent' || !boundProperty.twoWay || boundProperty.updating || boundProperty.value === undefined) {
                        continue;
                    }

                    element[boundPropertyName] = boundProperty.value;
                }
            }

            /**
             * Updates a data bound property.
             * @param {String} - The propery's name.
             * @param {Object} - The property's value.
             */

        }, {
            key: 'updateBoundProperty',
            value: function updateBoundProperty(propertyName, propertyConfig) {
                if (propertyConfig.updating) {
                    return;
                }

                var that = this;
                var element = that.ownerElement;

                propertyConfig.updating = true;
                element[propertyName] = propertyConfig.value;
                propertyConfig.updating = false;
            }

            /**
             * Updates element's data bound nodes.
             */

        }, {
            key: 'updateBoundNodes',
            value: function updateBoundNodes(propertyName) {
                var that = this;

                that.updateBoundNode(that.ownerElement.shadowRoot || that.ownerElement, that.ownerElement.bindings, that.ownerElement, propertyName);
                if (that.ownerElement.detachedChildren.length > 0) {
                    var _loop = function _loop(i) {
                        var node = that.ownerElement.detachedChildren[i];
                        var jqxId = node.getAttribute('jqx-id');

                        var getBindings = function getBindings(bindings) {
                            if (bindings.nodeId === jqxId) {
                                return bindings;
                            }

                            for (var index in bindings.children) {
                                var _node = bindings.children[index];
                                var attribute = _node.getAttribute ? _node.getAttribute('jqx-id') : '';

                                if (attribute === jqxId) {
                                    return bindings;
                                }

                                if (_node.children) {
                                    var result = getBindings(_node);
                                    if (result) {
                                        return result;
                                    }
                                }
                            }

                            return null;
                        };

                        var bindings = getBindings(that.ownerElement.bindings);

                        if (bindings) {
                            that.updateBoundNode(node, bindings, that.ownerElement, propertyName, true);
                        } else {
                            if (node.getAttribute && that.ownerElement.bindings.mapping) {
                                var element = that.ownerElement;
                                var _bindings = that.ownerElement.bindings;

                                if (_bindings) {
                                    for (var mapping in _bindings.mapping) {
                                        var childNode = element.querySelector('[jqx-id="' + mapping + '"]');

                                        if (childNode) {
                                            var dataBoundProperties = _bindings.mapping[mapping];

                                            that.updateBoundData(childNode, dataBoundProperties, element, propertyName);
                                        }
                                    }
                                }
                            }
                        }
                    };

                    for (var i = 0; i < that.ownerElement.detachedChildren.length; i++) {
                        _loop(i);
                    }
                }
            }
        }, {
            key: 'updateBoundMappedNodes',
            value: function updateBoundMappedNodes() {
                var that = this;
                //const node = that.ownerElement.shadowRoot || that.ownerElement;
                var bindings = that.ownerElement.bindings;
                var element = that.ownerElement;

                if (!bindings.mapping) {
                    return;
                }

                for (var mapping in bindings.mapping) {
                    var childNode = element.querySelector('[jqx-id="' + mapping + '"]');

                    if (childNode) {
                        var dataBoundProperties = bindings.mapping[mapping];

                        that.updateBoundData(childNode, dataBoundProperties, element);
                    } else if (element.getAttribute('aria-controls')) {
                        var detachedChildNode = document.getElementById(element.getAttribute('aria-controls'));

                        childNode = detachedChildNode.querySelector('[jqx-id="' + mapping + '"]');

                        if (childNode) {
                            var _dataBoundProperties = bindings.mapping[mapping];

                            that.updateBoundData(childNode, _dataBoundProperties, element);
                        }
                    }
                }
            }

            /**
             * Updates a data bound node.
             * @param {Node} - The bound node.
             * @param {Array<BindingData>} - The node's binding data.
             * @param {Element} - The element to be updated.
             */

        }, {
            key: 'updateBoundNode',
            value: function updateBoundNode(node, bindings, element, propertyName, detached) {
                var that = this;

                if (!bindings) {
                    return;
                }

                /*
                if (node.getAttribute && bindings.mapping) {
                    for (let mapping in bindings.mapping) {
                        const childNode = element.querySelector('[jqx-id="' + mapping + '"]');
                          if (childNode) {
                            const dataBoundProperties = bindings.mapping[mapping];
                              that.updateBoundData(childNode, dataBoundProperties, element, null);
                        }
                    }
                    return;
                }
                */

                var index = 0;
                if (!detached) {
                    for (var child = node.firstChild; child; child = child.nextSibling) {
                        if (!bindings.children) {
                            break;
                        }
                        //       that.updateBoundNode(child, bindings.children[index++], element, propertyName);

                        if (child.getAttribute) {
                            (function () {
                                var childId = child.getAttribute('jqx-id');
                                var childBindings = function () {
                                    for (var binding in bindings.children) {
                                        if (bindings.children[binding].nodeId === childId) {
                                            return bindings.children[binding];
                                        }
                                    }
                                }();

                                that.updateBoundNode(child, childBindings, element, propertyName);
                                index++;
                            })();
                        } else {
                            that.updateBoundNode(child, bindings.children[index++], element, propertyName);
                        }
                    }
                } else if (detached && !bindings.data) {
                    for (var _child = node.firstChild; _child; _child = _child.nextSibling) {
                        if (!bindings.children) {
                            break;
                        }

                        //   that.updateBoundNode(child, bindings.children[index++], element, propertyName, detached);

                        if (_child.getAttribute) {
                            (function () {
                                var childId = _child.getAttribute('jqx-id');
                                var childBindings = function () {
                                    for (var binding in bindings.children) {
                                        if (bindings.children[binding].nodeId === childId) {
                                            return bindings.children[binding];
                                        }
                                    }
                                }();

                                that.updateBoundNode(_child, childBindings, element, propertyName);
                                index++;
                            })();
                        } else {
                            that.updateBoundNode(_child, bindings.children[index++], element, propertyName, detached);
                        }
                    }
                }

                if (!bindings || !bindings.data) {
                    return;
                }

                var dataBoundProperties = bindings.data;

                that.updateBoundData(node, dataBoundProperties, element, propertyName);
            }
        }, {
            key: 'updateBoundData',
            value: function updateBoundData(node, dataBoundProperties, element, propertyName) {
                var that = this;

                var _loop2 = function _loop2(name) {
                    var boundProperty = dataBoundProperties[name];
                    var boundPropertyName = boundProperty.name;

                    if (boundProperty.updating) {
                        return 'continue';
                    }

                    if (boundPropertyName.indexOf('::') >= 0) {
                        boundPropertyName = boundPropertyName.substring(0, boundPropertyName.indexOf('::'));
                    }

                    if (propertyName !== undefined && propertyName !== boundPropertyName) {
                        return 'continue';
                    }

                    if (boundPropertyName.indexOf('(') >= 0) {
                        var args = boundPropertyName.substring(boundPropertyName.indexOf('('));

                        var methodName = boundPropertyName.substring(0, boundPropertyName.indexOf('('));

                        args = args.substring(1, args.length - 1);
                        args = args.replace(/ /ig, '');
                        args = args.split(',');
                        if (args.length > 0 && args[0] !== '') {
                            var values = [];
                            for (var i = 0; i < args.length; i++) {
                                values.push(element[args[i]]);
                            }

                            boundProperty.value = element[methodName].apply(element, values);
                        } else {
                            boundProperty.value = element[methodName]();
                        }

                        boundProperty.type = babelHelpers.typeof(boundProperty.value);
                    } else {
                        boundProperty.value = element[boundPropertyName];
                    }

                    if (boundPropertyName === 'innerHTML') {
                        if (node[name].toString().trim() !== element[boundPropertyName].toString().trim()) {
                            if (boundProperty.ready) {
                                node[name] = boundProperty.value.toString().trim();
                            } else if (element._properties[boundPropertyName].defaultValue !== boundProperty.value) {
                                node[name] = boundProperty.value.toString().trim();
                            }
                        }
                    } else {
                        if (boundProperty.not) {
                            node[name] = !boundProperty.value;
                        } else {
                            node[name] = boundProperty.value;
                        }
                    }

                    if (node.$ && node.$.isNativeElement) {
                        if (!BindingModule.cache['toDash' + name]) {
                            BindingModule.cache['toDash' + name] = Utilities.Core.toDash(name);
                        }

                        var attributeName = BindingModule.cache['toDash' + name];
                        var oldValue = node.$.getAttributeValue(attributeName, boundProperty.type);
                        if (boundProperty.reflectToAttribute && (oldValue !== boundProperty.value || !boundProperty.ready)) {
                            node.$.setAttributeValue(attributeName, boundProperty.value, boundProperty.type);
                        }
                        if (!boundProperty.reflectToAttribute) {
                            node.$.setAttributeValue(attributeName, null, boundProperty.type);
                        }
                    }

                    if (!boundProperty.ready) {
                        if (node.$ && node.$.isCustomElement) {
                            if (!BindingModule.cache['toDash' + name]) {
                                BindingModule.cache['toDash' + name] = Utilities.Core.toDash(name);
                            }

                            var _attributeName = BindingModule.cache['toDash' + name];

                            if (!node._properties) {
                                node._beforeCreatedProperties = node._properties = node.propertyByAttributeName = [];
                            }

                            if (!node._properties[name]) {
                                node._properties[name] = {
                                    attributeName: _attributeName
                                };
                                node._beforeCreatedProperties[name] = node._properties[name];
                                node.propertyByAttributeName[_attributeName] = node._properties[name];
                            }

                            var propertyConfig = node._properties[name];

                            propertyConfig.isUpdating = true;

                            if (boundProperty.reflectToAttribute) {
                                if (boundProperty.not) {
                                    node.$.setAttributeValue(propertyConfig.attributeName, !boundProperty.value, boundProperty.type);
                                } else {
                                    node.$.setAttributeValue(propertyConfig.attributeName, boundProperty.value, boundProperty.type);
                                }
                            }

                            if (!boundProperty.reflectToAttribute) {
                                node.$.setAttributeValue(propertyConfig.attributeName, null, boundProperty.type);
                            }

                            propertyConfig.isUpdating = false;
                        }

                        if (boundProperty.twoWay) {
                            var updateToken = function updateToken(value) {
                                boundProperty.value = value;

                                if (node.$ && node.$.isNativeElement) {
                                    if (!BindingModule.cache['toDash' + name]) {
                                        BindingModule.cache['toDash' + name] = Utilities.Core.toDash(name);
                                    }

                                    var _attributeName2 = BindingModule.cache['toDash' + name];
                                    var _oldValue = node.$.getAttributeValue(_attributeName2, boundProperty.type);

                                    if (boundProperty.reflectToAttribute && _oldValue !== boundProperty.value) {
                                        node.$.setAttributeValue(_attributeName2, boundProperty.value, boundProperty.type);
                                    }
                                    if (!boundProperty.reflectToAttribute) {
                                        node.$.setAttributeValue(_attributeName2, null, boundProperty.type);
                                    }
                                }
                            };

                            if (boundProperty.name.indexOf('::') >= 0) {
                                var eventIndex = boundProperty.name.indexOf('::');
                                var eventName = boundProperty.name.substring(eventIndex + 2);

                                that.ownerElement['$' + node.getAttribute('jqx-id')].listen(eventName, function () {
                                    updateToken(node[name]);

                                    var boundPropertyName = boundProperty.name.substring(0, boundProperty.name.indexOf('::'));

                                    that.updateBoundProperty(boundPropertyName, boundProperty);
                                });
                            }

                            if (node.$ && node.$.isCustomElement) {
                                if (node._properties[name]) {
                                    node._properties[name].notify = true;
                                }

                                if (!BindingModule.cache['toDash' + name]) {
                                    BindingModule.cache['toDash' + name] = Utilities.Core.toDash(name);
                                }

                                var _attributeName3 = BindingModule.cache['toDash' + name];

                                that.ownerElement['$' + node.getAttribute('jqx-id')].listen(_attributeName3 + '-changed', function (event) {
                                    var detail = event.detail;
                                    updateToken(detail.value);

                                    var context = that.ownerElement.context;

                                    if (event.context !== document) {
                                        that.ownerElement.context = that.ownerElement;
                                    }

                                    that.updateBoundProperty(boundProperty.name, boundProperty);

                                    //    that.updateBoundProperty(name, boundProperty);

                                    that.ownerElement.context = context;
                                });
                            }
                        }
                    }

                    boundProperty.ready = true;
                };

                for (var name in dataBoundProperties) {
                    var _ret4 = _loop2(name);

                    if (_ret4 === 'continue') continue;
                }
            }
        }], [{
            key: 'clearCache',
            value: function clearCache() {
                var that = this;

                that.cache = {};
            }
        }, {
            key: 'moduleName',
            get: function get() {
                return 'BindingModule';
            }
        }]);
        return BindingModule;
    }();

    /** This is a class with utility methods for determing the type of a value. */


    var Types = function () {
        function Types() {
            babelHelpers.classCallCheck(this, Types);
        }

        babelHelpers.createClass(Types, null, [{
            key: 'isBoolean',

            /**
             * Determines whether a value is Boolean. 
             * @param {Object}.
             * @return {Boolean}.
             */
            value: function isBoolean(value) {
                return typeof value === 'boolean';
            }

            /**
             * Determines whether a value is Function. 
             * @param {Object}.
             * @return {Boolean}.
             */

        }, {
            key: 'isFunction',
            value: function isFunction(value) {
                return !!(value && value.constructor && value.call && value.apply);
            }

            /**
             * Determines whether a value is Array. 
             * @param {Object}.
             * @return {Boolean}.
             */

        }, {
            key: 'isArray',
            value: function isArray(value) {
                return Array.isArray(value);
            }

            /**
             * Determines whether a value is Object. 
             * @param {Object}.
             * @return {Boolean}.
             */

        }, {
            key: 'isObject',
            value: function isObject(value) {
                var that = this;

                return value && ((typeof value === 'undefined' ? 'undefined' : babelHelpers.typeof(value)) === 'object' || that.isFunction(value)) || false;
            }

            /**
             * Determines whether a value is Date. 
             * @param {Object}.
             * @return {Boolean}.
             */

        }, {
            key: 'isDate',
            value: function isDate(value) {
                return value instanceof Date;
            }

            /**
             * Determines whether a value is String. 
             * @param {Object}.
             * @return {Boolean}.
             */

        }, {
            key: 'isString',
            value: function isString(value) {
                return typeof value === 'string';
            }

            /**
             * Determines whether a value is Number. 
             * @param {Object}.
             * @return {Boolean}.
             */

        }, {
            key: 'isNumber',
            value: function isNumber(value) {
                return typeof value === 'number';
            }

            /**
             * Determines the type of an object.
             * @param {Object}.
             * @return {String} The value's type or undefined, if the type is unknown.
             */

        }, {
            key: 'getType',
            value: function getType(value) {
                var that = this;

                var types = ['Boolean', 'Number', 'String', 'Function', 'Array', 'Date', 'Object'];
                var type = types.find(function (type) {
                    if (that['is' + type](value)) {
                        return type;
                    }
                });

                return type ? type.toLowerCase() : undefined;
            }
        }]);
        return Types;
    }();

    var Ripple = function () {
        function Ripple() {
            babelHelpers.classCallCheck(this, Ripple);
        }

        babelHelpers.createClass(Ripple, null, [{
            key: 'animate',
            value: function animate(element, left, top, callback) {
                var target = element;

                if (!target || target instanceof HTMLElement === false) {
                    return;
                }

                if (target.getElementsByClassName('jqx-ripple').length === 0) {
                    var span = document.createElement('span');

                    span.classList.add('jqx-ripple');

                    var canAppendRipple = true;
                    var firstElementChild = null;

                    if (window[namespace].EnableShadowDOM && target.enableShadowDOM) {

                        for (var i = 0; i < target.shadowRoot.host.shadowRoot.children.length; i++) {
                            if (target.shadowRoot.host.shadowRoot.children[i].tagName.toLowerCase() === 'link') {
                                continue;
                            }

                            firstElementChild = target.shadowRoot.host.shadowRoot.children[i];
                        }

                        if (target.shadowRoot.host.shadowRoot.querySelector('.jqx-ripple')) {
                            canAppendRipple = false;
                        }
                    } else {
                        firstElementChild = target.firstElementChild;
                    }

                    if (canAppendRipple) {
                        if (firstElementChild && !firstElementChild.noRipple && firstElementChild.offsetHeight > 0) {
                            firstElementChild.appendChild(span);
                        } else {
                            target.appendChild(span);
                        }
                    }
                }

                var ripple = null;

                if (window[namespace].EnableShadowDOM && target.enableShadowDOM) {
                    ripple = target.shadowRoot.host.shadowRoot.querySelector('.jqx-ripple');
                } else {
                    ripple = target.getElementsByClassName('jqx-ripple')[0];
                }

                if (!ripple) {
                    return;
                }

                ripple.innerHTML = '';
                ripple.classList.remove('jqx-animate');
                ripple.style.height = ripple.style.width = Math.max(target.offsetHeight, target.offsetWidth) + 'px';

                var parentStyle = window.getComputedStyle(ripple.parentElement),
                    borderLeftWidth = parseInt(parentStyle.borderLeftWidth) || 0,
                    borderTopWidth = parseInt(parentStyle.borderTopWidth) || 0,
                    rect = target.getBoundingClientRect(),
                    x = left - (rect.left + window.pageXOffset) - ripple.offsetWidth / 2 - borderLeftWidth,
                    y = top - (rect.top + window.pageYOffset) - ripple.offsetHeight / 2 - borderTopWidth;

                ripple.style.left = x + 'px';
                ripple.style.top = y + 'px';
                ripple.classList.add('jqx-animate');

                //Remove the ripple element when animation is over
                ripple.addEventListener('animationend', function handler() {
                    if (ripple.parentElement) {
                        ripple.parentElement.removeChild(ripple);
                    }

                    if (callback) {
                        callback();
                    }

                    ripple.removeEventListener('animationend', handler);
                    ripple.removeEventListener('animationcancel', handler);
                });

                //Remove the ripple element if the animation is canceled. Just in case
                ripple.addEventListener('animationcancel', function handler() {
                    if (ripple.parentElement) {
                        ripple.parentElement.removeChild(ripple);
                    }

                    if (callback) {
                        callback();
                    }

                    ripple.removeEventListener('animationcancel', handler);
                    ripple.removeEventListener('animationend', handler);
                });
            }
        }]);
        return Ripple;
    }();

    var Easings = function () {
        function Easings() {
            babelHelpers.classCallCheck(this, Easings);
        }

        babelHelpers.createClass(Easings, null, [{
            key: 'easeInQuad',
            value: function easeInQuad(t, b, c, d) {
                return c * (t /= d) * t + b;
            }
        }, {
            key: 'easeOutQuad',
            value: function easeOutQuad(t, b, c, d) {
                return -c * (t /= d) * (t - 2) + b;
            }
        }, {
            key: 'easeInOutQuad',
            value: function easeInOutQuad(t, b, c, d) {
                if ((t /= d / 2) < 1) {
                    return c / 2 * t * t + b;
                }
                return -c / 2 * (--t * (t - 2) - 1) + b;
            }
        }, {
            key: 'easeInCubic',
            value: function easeInCubic(t, b, c, d) {
                return c * (t /= d) * t * t + b;
            }
        }, {
            key: 'easeOutCubic',
            value: function easeOutCubic(t, b, c, d) {
                return c * ((t = t / d - 1) * t * t + 1) + b;
            }
        }, {
            key: 'easeInOutCubic',
            value: function easeInOutCubic(t, b, c, d) {
                if ((t /= d / 2) < 1) {
                    return c / 2 * t * t * t + b;
                }

                return c / 2 * ((t -= 2) * t * t + 2) + b;
            }
        }, {
            key: 'easeInQuart',
            value: function easeInQuart(t, b, c, d) {
                return c * (t /= d) * t * t * t + b;
            }
        }, {
            key: 'easeOutQuart',
            value: function easeOutQuart(t, b, c, d) {
                return -c * ((t = t / d - 1) * t * t * t - 1) + b;
            }
        }, {
            key: 'easeInOutQuart',
            value: function easeInOutQuart(t, b, c, d) {
                if ((t /= d / 2) < 1) {
                    return c / 2 * t * t * t * t + b;
                }
                return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
            }
        }, {
            key: 'easeInQuint',
            value: function easeInQuint(t, b, c, d) {
                return c * (t /= d) * t * t * t * t + b;
            }
        }, {
            key: 'easeOutQuint',
            value: function easeOutQuint(t, b, c, d) {
                return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
            }
        }, {
            key: 'easeInOutQuint',
            value: function easeInOutQuint(t, b, c, d) {
                if ((t /= d / 2) < 1) {
                    return c / 2 * t * t * t * t * t + b;
                }
                return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
            }
        }, {
            key: 'easeInSine',
            value: function easeInSine(t, b, c, d) {
                return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
            }
        }, {
            key: 'easeOutSine',
            value: function easeOutSine(t, b, c, d) {
                return c * Math.sin(t / d * (Math.PI / 2)) + b;
            }
        }, {
            key: 'easeInOutSine',
            value: function easeInOutSine(t, b, c, d) {
                return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
            }
        }, {
            key: 'easeInExpo',
            value: function easeInExpo(t, b, c, d) {
                return t === 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
            }
        }, {
            key: 'easeOutExpo',
            value: function easeOutExpo(t, b, c, d) {
                return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
            }
        }, {
            key: 'easeInOutExpo',
            value: function easeInOutExpo(t, b, c, d) {
                if (t === 0) {
                    return b;
                }
                if (t === d) {
                    return b + c;
                }
                if ((t /= d / 2) < 1) {
                    return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
                }
                return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
            }
        }, {
            key: 'easeInCirc',
            value: function easeInCirc(t, b, c, d) {
                return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
            }
        }, {
            key: 'easeOutCirc',
            value: function easeOutCirc(t, b, c, d) {
                return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
            }
        }, {
            key: 'easeInOutCirc',
            value: function easeInOutCirc(t, b, c, d) {
                if ((t /= d / 2) < 1) {
                    return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
                }
                return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
            }
        }, {
            key: 'easeInElastic',
            value: function easeInElastic(t, b, c, d) {
                var s = 1.70158;
                var p = 0;
                var a = c;

                if (t === 0) {
                    return b;
                }

                if ((t /= d) === 1) {
                    return b + c;
                }

                if (!p) {
                    p = d * .3;
                }

                if (a < Math.abs(c)) {
                    a = c;
                    s = p / 4;
                } else {
                    s = p / (2 * Math.PI) * Math.asin(c / a);
                }

                return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
            }
        }, {
            key: 'easeOutElastic',
            value: function easeOutElastic(t, b, c, d) {
                var s = 1.70158;
                var p = 0;
                var a = c;

                if (t === 0) {
                    return b;
                }
                if ((t /= d) === 1) {
                    return b + c;
                }
                if (!p) {
                    p = d * .3;
                }
                if (a < Math.abs(c)) {
                    a = c;
                    s = p / 4;
                } else {
                    s = p / (2 * Math.PI) * Math.asin(c / a);
                }

                return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
            }
        }, {
            key: 'easeInOutElastic',
            value: function easeInOutElastic(t, b, c, d) {
                var s = 1.70158;
                var p = 0;
                var a = c;

                if (t === 0) {
                    return b;
                }
                if ((t /= d / 2) === 2) {
                    return b + c;
                }
                if (!p) {
                    p = d * (.3 * 1.5);
                }
                if (a < Math.abs(c)) {
                    a = c;
                    s = p / 4;
                } else {
                    s = p / (2 * Math.PI) * Math.asin(c / a);
                }
                if (t < 1) {
                    return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
                }

                return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;
            }
        }, {
            key: 'easeInBack',
            value: function easeInBack(t, b, c, d, s) {
                if (s === undefined) {
                    s = 1.70158;
                }

                return c * (t /= d) * t * ((s + 1) * t - s) + b;
            }
        }, {
            key: 'easeOutBack',
            value: function easeOutBack(t, b, c, d, s) {
                if (s === undefined) {
                    s = 1.70158;
                }
                return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
            }
        }, {
            key: 'easeInOutBack',
            value: function easeInOutBack(t, b, c, d, s) {
                if (s === undefined) {
                    s = 1.70158;
                }
                if ((t /= d / 2) < 1) {
                    return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
                }
                return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
            }
        }, {
            key: 'easeInBounce',
            value: function easeInBounce(t, b, c, d) {
                return c - this.easeOutBounce(d - t, 0, c, d) + b;
            }
        }, {
            key: 'easeOutBounce',
            value: function easeOutBounce(t, b, c, d) {
                if ((t /= d) < 1 / 2.75) {
                    return c * (7.5625 * t * t) + b;
                } else if (t < 2 / 2.75) {
                    return c * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + b;
                } else if (t < 2.5 / 2.75) {
                    return c * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + b;
                } else {
                    return c * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + b;
                }
            }
        }, {
            key: 'easeInOutBounce',
            value: function easeInOutBounce(t, b, c, d) {
                if (t < d / 2) {
                    return this.easeInBounce(t * 2, 0, c, d) * .5 + b;
                }
                return this.easeOutBounce(t * 2 - d, 0, c, d) * .5 + c * .5 + b;
            }
        }]);
        return Easings;
    }();

    /** This is a class with utility methods. */


    var Core = function () {
        function Core() {
            babelHelpers.classCallCheck(this, Core);
        }

        babelHelpers.createClass(Core, null, [{
            key: 'toCamelCase',
            value: function toCamelCase(value) {
                return value.replace(/-([a-z])/g, function (g) {
                    return g[1].toUpperCase();
                });
            }
        }, {
            key: 'toDash',
            value: function toDash(value) {
                return value.split(/(?=[A-Z])/).join('-').toLowerCase();
            }
        }, {
            key: 'unescapeHTML',
            value: function unescapeHTML(value) {
                var doc = new DOMParser().parseFromString(value, 'text/html');
                return doc.documentElement.textContent;
            }
        }, {
            key: 'escapeHTML',
            value: function escapeHTML(value) {
                var entityMap = {
                    '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', '\'': '&#39;', '/': '&#x2F;', '`': '&#x60;', '=': '&#x3D;'
                };

                return String(value).replace(/[&<>"'`=\/]/g, function (s) {
                    return entityMap[s];
                });
            }
        }, {
            key: 'createGUID',
            value: function createGUID() {
                function part() {
                    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
                }

                return part() + part() + '-' + part() + '-' + part() + '-' + part() + '-' + part() + part() + part();
            }
        }, {
            key: 'getScriptLocation',
            value: function getScriptLocation() {
                if (window[namespace].BaseUrl !== './') {
                    return window[namespace].BaseUrl;
                }

                var location = function () {
                    if (document.currentScript) {
                        var _link = document.currentScript.src;
                        var lastIndex = _link.lastIndexOf('/');

                        _link = _link.substring(0, lastIndex);

                        return _link;
                    }

                    var error = new Error();
                    var startCharacter = '(',
                        endCharacter = ')';

                    if (JQX.Utilities.Core.Browser.Safari) {
                        startCharacter = '@';
                        endCharacter = '\n';
                    }

                    if (error.fileName) {
                        return error.fileName.replace('/jqxelement.js', '');
                    }

                    var link = error.stack.split(startCharacter);

                    link = link[1];
                    link = link.split(endCharacter)[0];
                    link = link.split(':');
                    link.splice(-2, 2);
                    link = link.join(':');

                    return link.replace('/jqxelement.js', '');
                }();

                return location;
            }
        }, {
            key: 'CSSVariablesSupport',
            value: function CSSVariablesSupport() {
                return window.CSS && window.CSS.supports && window.CSS.supports('(--fake-var: 0)');
            }
        }, {
            key: 'assign',
            value: function assign(target, source) {
                var _this = this;

                var isObject = function isObject(item) {
                    return item && (typeof item === 'undefined' ? 'undefined' : babelHelpers.typeof(item)) === 'object' && !Array.isArray(item) && item !== null;
                };

                var output = Object.assign({}, target);
                if (isObject(target) && isObject(source)) {
                    Object.keys(source).forEach(function (key) {
                        if (isObject(source[key])) {
                            if (!(key in target)) {
                                Object.assign(output, babelHelpers.defineProperty({}, key, source[key]));
                            } else {
                                output[key] = _this.assign(target[key], source[key]);
                            }
                        } else {
                            Object.assign(output, babelHelpers.defineProperty({}, key, source[key]));
                        }
                    });
                }

                return output;
            }
        }, {
            key: 'html',
            value: function html(node, htmlString) {
                var that = this;

                var output = '';
                var nodes = node.childNodes;

                if (htmlString) {
                    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;

                    node.innerHTML = htmlString.replace(rxhtmlTag, '<$1></$2>');
                    return;
                }

                for (var i = 0, l = nodes.length, child; i < l && (child = nodes[i]); i++) {
                    var miscElements = ['strong'];

                    if (child instanceof HTMLElement || child.tagName && miscElements.indexOf(child.tagName.toLowerCase()) >= 0) {
                        var tagName = child.tagName.toLowerCase();
                        var attrs = child.attributes;

                        var nodeOutput = '<' + tagName;

                        for (var j = 0, attr; attr = attrs[j]; j++) {
                            nodeOutput += ' ' + attr.name + '="' + attr.value.replace(/[&\u00A0"]/g, Utilities.Core.escapeHTML) + '"';
                        }

                        nodeOutput += '>';

                        var voidElements = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];

                        if (voidElements[tagName]) {
                            output += nodeOutput;
                        }

                        output = output + nodeOutput + that.html(child) + '</' + tagName + '>';
                    } else {
                        output += child.textContent.replace(/[&\u00A0<>]/g, Utilities.Core.escapeHTML);
                    }
                }
                return output;
            }
        }, {
            key: 'isMobile',
            get: function get() {
                var isMobile = /(iphone|ipod|ipad|android|iemobile|blackberry|bada)/.test(window.navigator.userAgent.toLowerCase());

                return isMobile;
            }
        }, {
            key: 'Browser',
            get: function get() {
                var versionSearchString = void 0;

                var browser = function browser() {
                    var data = [{
                        string: navigator.userAgent, subString: 'Edge', identity: 'Edge'
                    }, {
                        string: navigator.userAgent, subString: 'MSIE', identity: 'IE'
                    }, {
                        string: navigator.userAgent, subString: 'Trident', identity: 'IE'
                    }, {
                        string: navigator.userAgent, subString: 'Firefox', identity: 'Firefox'
                    }, {
                        string: navigator.userAgent, subString: 'Opera', identity: 'Opera'
                    }, {
                        string: navigator.userAgent, subString: 'OPR', identity: 'Opera'
                    }, {
                        string: navigator.userAgent, subString: 'Chrome', identity: 'Chrome'
                    }, { string: navigator.userAgent, subString: 'Safari', identity: 'Safari' }];

                    for (var i = 0; i < data.length; i++) {
                        var dataString = data[i].string;
                        versionSearchString = data[i].subString;

                        if (dataString.indexOf(data[i].subString) !== -1) {
                            return data[i].identity;
                        }
                    }

                    return 'Other';
                };

                var version = function version(dataString) {
                    var index = dataString.indexOf(versionSearchString);
                    if (index === -1) {
                        return;
                    }

                    var rv = dataString.indexOf('rv:');

                    if (versionSearchString === 'Trident' && rv !== -1) {
                        return parseFloat(dataString.substring(rv + 3));
                    } else {
                        return parseFloat(dataString.substring(index + versionSearchString.length + 1));
                    }
                };

                var result = {};

                result[browser()] = true;
                result.version = version(navigator.userAgent) || version(navigator.appVersion) || 'Unknown';

                return result;
            }
        }]);
        return Core;
    }();

    var styleObservedElements = [];

    var StyleObserver = function () {
        function StyleObserver() {
            babelHelpers.classCallCheck(this, StyleObserver);
        }

        babelHelpers.createClass(StyleObserver, null, [{
            key: 'watch',
            value: function watch(element) {
                styleObservedElements.push(element);

                if (StyleObserver.interval) {
                    clearInterval(StyleObserver.interval);
                }

                StyleObserver.interval = setInterval(function () {
                    StyleObserver.observe();
                }, 100);
            }
        }, {
            key: 'observeElement',
            value: function observeElement(element) {
                var that = element;

                var computedStyle = element._computedStyle || that.hasStyleObserver !== 'resize' ? document.defaultView.getComputedStyle(that, null) : {};

                var canRaiseResize = true;
                var styleProperties = that.hasStyleObserver !== 'resize' ? ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth', 'borderBottomWidth', 'display', 'visibility', 'font-size', 'font-family', 'font-style', 'font-weight', 'max-height', 'min-height', 'max-width', 'min-width', 'overflow', 'overflow-x', 'overflow-y'] : [];

                if (element.styleProperties) {
                    styleProperties = styleProperties.concat(element.styleProperties);
                }

                if (element.observableStyleProperties) {
                    styleProperties = element.observableStyleProperties;
                }

                if (!that._styleInfo) {
                    that._styleInfo = [];

                    for (var i = 0; i < styleProperties.length; i++) {
                        var styleProperty = styleProperties[i];

                        that._styleInfo[styleProperty] = computedStyle[styleProperty];
                    }

                    return;
                }

                if (!element.isHidden) {
                    if (computedStyle['display'] !== 'none') {
                        if (element.offsetWidth === 0 || element.offsetHeight === 0) {
                            element.isHidden = true;
                        }
                    }
                }

                if (element.isHidden) {
                    element.visibilityChangedHandler();

                    if (!element.isHidden) {
                        canRaiseResize = false;
                    } else {
                        return;
                    }
                }

                var changedStyleProperties = [];

                for (var _i = 0; _i < styleProperties.length; _i++) {
                    var _styleProperty = styleProperties[_i];

                    if (that._styleInfo[_styleProperty] !== computedStyle[_styleProperty]) {
                        changedStyleProperties[_styleProperty] = {
                            oldValue: that._styleInfo[_styleProperty], value: computedStyle[_styleProperty]
                        };
                        changedStyleProperties.length++;
                    }

                    that._styleInfo[_styleProperty] = computedStyle[_styleProperty];
                }

                if (changedStyleProperties.length > 0) {
                    that.$.fireEvent('styleChanged', {
                        styleProperties: changedStyleProperties
                    }, {
                        bubbles: false,
                        cancelable: true
                    });

                    if (changedStyleProperties['display'] && canRaiseResize) {
                        that.$.fireEvent('resize', that, {
                            bubbles: false,
                            cancelable: true
                        });
                    }
                }
            }
        }, {
            key: 'observe',
            value: function observe() {
                for (var i = 0; i < styleObservedElements.length; i++) {
                    var that = styleObservedElements[i];

                    this.observeElement(that);
                }
            }
        }, {
            key: 'unwatch',
            value: function unwatch(element) {
                if (StyleObserver.interval) {
                    clearInterval(StyleObserver.interval);
                }

                var elementIndex = styleObservedElements.indexOf(element);

                if (elementIndex !== -1) {
                    styleObservedElements.splice(elementIndex, 1);
                }

                if (styleObservedElements.length > 0) {
                    StyleObserver.interval = setInterval(function () {
                        StyleObserver.observe();
                    }, 100);
                }
            }
        }]);
        return StyleObserver;
    }();

    var dataContextInfo = [];

    var data = [];
    var inputEventTypes = ['resize', 'down', 'up', 'move', 'tap', 'taphold', 'swipeleft', 'swiperight', 'swipetop', 'swipebottom'];

    /** This is a class which extends an element and adds custom input events to it. */

    var InputEvents = function () {
        function InputEvents(target) {
            babelHelpers.classCallCheck(this, InputEvents);

            var that = this;

            that.target = target;
            that.$target = new _Extend(target);
            that.$document = new _Extend(document);
            that.id = (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase();
            // that.target === document ? '' : that.target.id || that.target.getAttribute('jqx-id');

            var result = {
                handlers: {}, boundEventTypes: [], listen: that.listen.bind(that), unlisten: that.unlisten.bind(that)
            };

            //The taphold delay. If this delay is passed then taphold event will be fired.
            that.tapHoldDelay = 750;
            //Defines the minimum swipe distance required by the plugin.
            that.swipeMin = 10;
            //Defines the maximum swipe distance. After it is passed the propagation of the event will be restored, therefore the scrolling will be available.
            that.swipeMax = 5000;
            //The swipe delay. After it is passed swipe event won't be fired.
            that.swipeDelay = 1000;
            //The taphold delay. If this delay is passed then taphold event will be fired.
            that.tapHoldDelay = 750;

            that.inputEventProperties = ['clientX', 'clientY', 'pageX', 'pageY', 'screenX', 'screenY'];

            inputEventTypes.forEach(function (eventType) {
                result[eventType] = function (handler) {
                    result.handlers[eventType] = handler;
                };

                that[eventType] = function (event) {
                    if (!result.handlers[event.type]) {
                        if ((event.type === 'mousemove' || event.type === 'pointermove' || event.type === 'touchmove') && result.handlers['move']) {
                            var moveEvent = that.createEvent(event, 'move');
                            result.handlers['move'](moveEvent);
                        }

                        return true;
                    }

                    return result.handlers[event.type](event);
                };
            });

            that.listen();

            that.handlers = result.handlers;

            return result;
        }

        babelHelpers.createClass(InputEvents, [{
            key: 'listen',
            value: function listen(eventType) {
                var that = this;

                if (eventType === 'resize') {
                    if (!that.target.resizeTrigger && that.target !== document && that.target !== window && that.target.hasResizeObserver !== false) {

                        var container = document.createElement('div');
                        container.className = 'jqx-resize-trigger-container';
                        container.innerHTML = '<div class="jqx-resize-trigger-container">' + '<div class="jqx-resize-trigger"></div>' + '</div>' + '<div class="jqx-resize-trigger-container">' + '<div class="jqx-resize-trigger-shrink"></div>' + '</div>';

                        if (window[namespace].EnableShadowDOM && that.target.enableShadowDOM) {
                            that.target.shadowRoot.appendChild(container);
                        } else {
                            that.target.appendChild(container);
                        }

                        that.target.resizeTrigger = container;

                        var expand = container.childNodes[0];
                        var expandChild = expand.childNodes[0];
                        var shrink = container.childNodes[1];
                        var reset = function reset() {
                            expandChild.style.width = '100000px';
                            expandChild.style.height = '100000px';

                            expand.scrollLeft = 100000;
                            expand.scrollTop = 100000;

                            shrink.scrollLeft = 100000;
                            shrink.scrollTop = 100000;
                        };

                        var dirty = void 0,
                            requestAnimationFrameId = void 0,
                            newWidth = void 0,
                            newHeight = void 0;

                        var lastWidth = that.target.offsetWidth;
                        var lastHeight = that.target.offsetHeight;

                        if (lastWidth === 0 || lastHeight === 0) {
                            var resizeFunc = function resizeFunc() {
                                reset();
                                that.target.removeEventListener('resize', resizeFunc);
                            };

                            that.target.addEventListener('resize', resizeFunc);
                            reset();
                        } else {
                            reset();
                        }

                        that.target.resizeHandler = function () {
                            if (!requestAnimationFrameId) {
                                requestAnimationFrameId = requestAnimationFrame(function () {
                                    requestAnimationFrameId = 0;
                                    newWidth = that.target.offsetWidth;
                                    newHeight = that.target.offsetHeight;
                                    dirty = newWidth !== lastWidth || newHeight !== lastHeight;
                                    if (that.target.requiresLayout) {
                                        dirty = true;
                                    }

                                    if (!dirty) {
                                        return;
                                    }

                                    lastWidth = newWidth;
                                    lastHeight = newHeight;

                                    var resizeEvent = new CustomEvent('resize', {
                                        bubbles: false,
                                        cancelable: true
                                    });

                                    that.resize(resizeEvent);

                                    that.target.requiresLayout = false;
                                });
                            }

                            reset();
                        };

                        expand.addEventListener('scroll', that.target.resizeHandler);
                        shrink.addEventListener('scroll', that.target.resizeHandler);
                    }
                }

                if (that.isListening) {
                    return;
                }

                that.isListening = true;
                that.isPressed = false;
                that.isReleased = false;
                that.isInBounds = false;

                if (window.PointerEvent) {
                    that.$target.listen('pointerdown.inputEvents' + that.id, that.pointerDown.bind(that));
                    that.$target.listen('pointerup.inputEvents' + that.id, that.pointerUp.bind(that));
                    that.$target.listen('pointermove.inputEvents' + that.id, that.pointerMove.bind(that));
                    that.$target.listen('pointercancel.inputEvents' + that.id, that.pointerCancel.bind(that));
                } else {
                    var hasTouch = 'ontouchstart' in window;

                    if (hasTouch) {
                        that.$target.listen('touchmove.inputEvents' + that.id, that.touchMove.bind(that));
                        that.$target.listen('touchstart.inputEvents' + that.id, that.touchStart.bind(that));
                        that.$target.listen('touchend.inputEvents' + that.id, that.touchEnd.bind(that));
                        that.$target.listen('touchcancel.inputEvents' + that.id, that.touchCancel.bind(that));
                    }

                    that.$target.listen('mousedown.inputEvents' + that.id, that.mouseDown.bind(that));
                    that.$target.listen('mouseup.inputEvents' + that.id, that.mouseUp.bind(that));
                    that.$target.listen('mousemove.inputEvents' + that.id, that.mouseMove.bind(that));
                    that.$target.listen('mouseleave.inputEvents' + that.id, that.mouseLeave.bind(that));
                }

                that.$document.listen('mouseup.inputEvents' + that.id, that.handleDocumentUp.bind(that));
            }
        }, {
            key: 'unlisten',
            value: function unlisten(eventType) {
                var that = this;

                that.isListening = false;

                if (window.PointerEvent) {
                    that.$target.unlisten('pointerdown.inputEvents' + that.id);
                    that.$target.unlisten('pointerup.inputEvents' + that.id);
                    that.$target.unlisten('pointermove.inputEvents' + that.id);
                    that.$target.unlisten('pointercancel.inputEvents' + that.id);
                } else {
                    var hasTouch = 'ontouchstart' in window;
                    if (hasTouch) {
                        that.$target.unlisten('touchstart.inputEvents' + that.id);
                        that.$target.unlisten('touchmove.inputEvents' + that.id);
                        that.$target.unlisten('touchend.inputEvents' + that.id);
                        that.$target.unlisten('touchcancel.inputEvents' + that.id);
                    }

                    that.$target.unlisten('mousedown.inputEvents' + that.id);
                    that.$target.unlisten('mouseup.inputEvents' + that.id);
                    that.$target.unlisten('mousemove.inputEvents' + that.id);
                    that.$target.unlisten('mouseleave.inputEvents' + that.id);
                }

                that.$document.unlisten('mouseup.inputEvents' + that.id, that.handleDocumentUp);

                if (eventType === 'resize' && that.target.resizeTrigger) {
                    var container = that.target.resizeTrigger;
                    var expand = container.childNodes[0];
                    var shrink = container.childNodes[1];

                    expand.removeEventListener('scroll', that.target.resizeHandler);
                    shrink.removeEventListener('scroll', that.target.resizeHandler);

                    that.target.resizeHandler = null;
                    (window[namespace].EnableShadowDOM && that.target.enableShadowDOM ? that.target.shadowRoot : that.target).removeChild(container);
                    delete that.target.resizeTrigger;
                }
            }
        }, {
            key: 'handleDocumentUp',
            value: function handleDocumentUp(event) {
                var that = this;

                that.isPressed = false;
                that.isReleased = false;
                that.resetSwipe(event);
            }
        }, {
            key: 'createEvent',
            value: function createEvent(event, eventType) {
                var that = this;
                var touches = event.touches;
                var changedTouches = event.changedTouches;
                var touch = touches && touches.length ? touches[0] : changedTouches && changedTouches.length ? changedTouches[0] : undefined;
                var customEvent = new CustomEvent(eventType, {
                    bubbles: true,
                    cancelable: true
                });
                customEvent.originalEvent = event;
                if (touch) {
                    for (var j = 0; j < that.inputEventProperties.length; j++) {
                        var key = that.inputEventProperties[j];

                        customEvent[key] = touch[key];
                    }

                    return customEvent;
                }

                for (var _key in event) {
                    if (!(_key in customEvent)) {
                        customEvent[_key] = event[_key];
                    }
                }

                return customEvent;
            }
        }, {
            key: 'fireTap',
            value: function fireTap(event) {
                var that = this;

                clearTimeout(this.tapHoldTimeout);
                if (!this.tapHoldFired && this.isInBounds) {
                    var tap = that.createEvent(event, 'tap');
                    that.tap(tap);
                }
            }
        }, {
            key: 'initTap',
            value: function initTap(event) {
                var that = this;

                that.isInBounds = true;
                that.tapHoldFired = false;
                that.tapHoldTimeout = setTimeout(function () {
                    if (that.isInBounds) {
                        that.tapHoldFired = true;
                        var taphold = that.createEvent(event, 'taphold');
                        that.taphold(taphold);
                    }
                }, that.tapHoldDelay);
            }
        }, {
            key: 'pointerDown',
            value: function pointerDown(event) {
                var that = this;

                return that.handleDown(event);
            }
        }, {
            key: 'mouseDown',
            value: function mouseDown(event) {
                var that = this;

                if (that.isPressed || that.touchStartTime && new Date() - that.touchStartTime < 500) {
                    return;
                }

                return that.handleDown(event);
            }
        }, {
            key: 'touchStart',
            value: function touchStart(event) {
                var that = this;

                that.touchStartTime = new Date();
                that.isTouchMoved = true;

                return that.handleDown(event);
            }
        }, {
            key: 'mouseUp',
            value: function mouseUp(event) {
                var that = this;

                if (that.isReleased || that.touchEndTime && new Date() - that.touchEndTime < 500) {
                    return;
                }

                return that.handleUp(event);
            }
        }, {
            key: 'handleDown',
            value: function handleDown(event) {
                var that = this;

                that.isReleased = false;
                that.isPressed = true;

                var down = that.createEvent(event, 'down');

                if (that.handlers['tap'] || that.handlers['taphold']) {
                    that.initTap(down);
                }

                if (that.handlers['swipeleft'] || that.handlers['swiperight'] || that.handlers['swipetop'] || that.handlers['swipebottom']) {
                    that.initSwipe(down);
                }

                return that.down(down);
            }
        }, {
            key: 'handleUp',
            value: function handleUp(event) {
                var that = this;

                that.isReleased = true;
                that.isPressed = false;

                var up = that.createEvent(event, 'up');
                var result = that.up(up);

                if (that.handlers['tap'] || that.handlers['taphold']) {
                    that.fireTap(up);
                }

                that.resetSwipe(up);

                return result;
            }
        }, {
            key: 'handleMove',
            value: function handleMove(event) {
                var that = this;

                var eventResult = that.move(event);

                if (that.isPressed) {
                    that._maxSwipeVerticalDistance = Math.max(that._maxSwipeVerticalDistance, Math.abs(that._startY - event.pageY));
                    that._maxSwipeHorizontalDistance = Math.max(that._maxSwipeHorizontalDistance, Math.abs(that._startX - event.pageX));
                    eventResult = that.handleSwipeEvents(event);
                }

                return eventResult;
            }
        }, {
            key: 'touchEnd',
            value: function touchEnd(event) {
                var that = this;

                that.touchEndTime = new Date();
                return that.handleUp(event);
            }
        }, {
            key: 'pointerUp',
            value: function pointerUp(event) {
                var that = this;

                return that.handleUp(event);
            }
        }, {
            key: 'pointerCancel',
            value: function pointerCancel(event) {
                var that = this;

                that.pointerUp(event);
            }
        }, {
            key: 'touchCancel',
            value: function touchCancel(event) {
                var that = this;

                that.touchEnd(event);
            }
        }, {
            key: 'mouseLeave',
            value: function mouseLeave() {
                var that = this;

                that.isInBounds = false;
            }
        }, {
            key: 'mouseMove',
            value: function mouseMove(event) {
                var that = this;

                if (that.isTouchMoved) {
                    return;
                }

                return that.handleMove(event);
            }
        }, {
            key: 'pointerMove',
            value: function pointerMove(event) {
                var that = this;

                return that.handleMove(event);
            }
        }, {
            key: 'touchMove',
            value: function touchMove(event) {
                var that = this;
                var touches = event.touches;
                var changedTouches = event.changedTouches;
                var touch = touches && touches.length ? touches[0] : changedTouches && changedTouches.length ? changedTouches[0] : undefined;

                for (var j = 0; j < that.inputEventProperties.length; j++) {
                    var key = that.inputEventProperties[j];

                    if (event[key] === undefined) {
                        event[key] = touch[key];
                    }
                }

                that.isTouchMoved = true;

                return that.handleMove(event);
            }
        }, {
            key: 'handleSwipeEvents',
            value: function handleSwipeEvents(event) {
                var that = this;

                var eventResult = true;

                if (that.handlers['swipetop'] || that.handlers['swipebottom']) {
                    eventResult = this.handleVerticalSwipeEvents(event);
                }

                if (eventResult === false) {
                    return eventResult;
                }

                if (that.handlers['swipeleft'] || that.handlers['swiperight']) {
                    eventResult = this.handleHorizontalSwipeEvents(event);
                }

                return eventResult;
            }
        }, {
            key: 'handleVerticalSwipeEvents',
            value: function handleVerticalSwipeEvents(event) {
                var current = void 0,
                    diff = void 0;
                current = event.pageY;
                diff = current - this._startY;

                return this.swiped(event, diff, 'vertical');
            }
        }, {
            key: 'handleHorizontalSwipeEvents',
            value: function handleHorizontalSwipeEvents(event) {
                var current = void 0,
                    diff = void 0;
                current = event.pageX;
                diff = current - this._startX;

                return this.swiped(event, diff, 'horizontal');
            }
        }, {
            key: 'swiped',
            value: function swiped(event, diff, direction) {
                var that = this;

                direction = direction || 0;
                if (Math.abs(diff) >= that.swipeMin && !that._swipeEvent && !that._swipeLocked) {
                    var eventType = diff < 0 ? 'swipeleft' : 'swiperight';
                    if (direction === 'horizontal') {
                        that._swipeEvent = that.createEvent(event, eventType);
                    } else {
                        eventType = diff < 0 ? 'swipetop' : 'swipebottom';
                        that._swipeEvent = that.createEvent(event, diff < 0 ? 'swipetop' : 'swipebottom');
                    }

                    if (that[eventType]) {
                        that[eventType](this._swipeEvent);
                        if (Math.abs(diff) <= this.swipeMax) {
                            event.stopImmediatePropagation();
                            return false;
                        }
                    }
                }

                return true;
            }
        }, {
            key: 'resetSwipe',
            value: function resetSwipe() {
                var that = this;

                that._swipeEvent = null;
                clearTimeout(this._swipeTimeout);
            }
        }, {
            key: 'initSwipe',
            value: function initSwipe(event) {
                var that = this;

                that._maxSwipeVerticalDistance = 0;
                that._maxSwipeHorizontalDistance = 0;
                that._startX = event.pageX;
                that._startY = event.pageY;
                that._swipeLocked = false;
                that._swipeEvent = null;
                that._swipeTimeout = setTimeout(function () {
                    that._swipeLocked = true;
                }, that.swipeDelay);
            }
        }]);
        return InputEvents;
    }();

    var Scroll = function () {
        babelHelpers.createClass(Scroll, [{
            key: 'scrollWidth',
            get: function get() {
                var that = this;

                if (that.horizontalScrollBar) {
                    return that.horizontalScrollBar.max;
                }

                return -1;
            },
            set: function set(value) {
                var that = this;

                if (value < 0) {
                    value = 0;
                }

                if (that.horizontalScrollBar) {
                    that.horizontalScrollBar.max = value;
                }
            }
        }, {
            key: 'scrollHeight',
            get: function get() {
                var that = this;

                if (that.verticalScrollBar) {
                    return that.verticalScrollBar.max;
                }

                return -1;
            },
            set: function set(value) {
                var that = this;

                if (value < 0) {
                    value = 0;
                }

                if (that.verticalScrollBar) {
                    that.verticalScrollBar.max = value;
                }
            }
        }, {
            key: 'scrollLeft',
            get: function get() {
                var that = this;

                if (that.horizontalScrollBar) {
                    return that.horizontalScrollBar.value;
                }

                return -1;
            },
            set: function set(value) {
                var that = this;

                if (value < 0) {
                    value = 0;
                }

                if (that.horizontalScrollBar) {
                    that.horizontalScrollBar.value = value;
                }
            }
        }, {
            key: 'scrollTop',
            get: function get() {
                var that = this;

                if (that.verticalScrollBar) {
                    return that.verticalScrollBar.value;
                }

                return -1;
            },
            set: function set(value) {
                var that = this;

                if (value < 0) {
                    value = 0;
                }

                if (that.verticalScrollBar) {
                    that.verticalScrollBar.value = value;
                }
            }
        }, {
            key: 'vScrollBar',
            get: function get() {
                var that = this;

                return that.verticalScrollBar;
            }
        }, {
            key: 'hScrollBar',
            get: function get() {
                var that = this;

                return that.horizontalScrollBar;
            }
        }]);

        function Scroll(container, horizontalScrollBar, verticalScrollBar) {
            babelHelpers.classCallCheck(this, Scroll);

            var that = this;

            that.container = container;
            that.horizontalScrollBar = horizontalScrollBar;
            that.verticalScrollBar = verticalScrollBar;
            that.disableSwipeScroll = false;
            that.listen();
        }

        babelHelpers.createClass(Scroll, [{
            key: 'listen',
            value: function listen() {
                var that = this;
                var isMobile = Core.isMobile;
                var horizontalScrollBar = that.horizontalScrollBar;
                var verticalScrollBar = that.verticalScrollBar;

                that.inputEvents = new InputEvents(that.container);

                var dragStarted = void 0,
                    rafId = void 0,
                    pointerCaptured = void 0,
                    timestamp = void 0,
                    ticker = void 0,
                    now = void 0,
                    elapsed = void 0,
                    timeConstant = 500,
                    currentScrollInfo = void 0;

                var createScrollInfo = function createScrollInfo(scrollBar) {
                    return {
                        amplitude: 0,
                        delta: 0,
                        initialValue: 0,
                        min: 0,
                        max: scrollBar.max,
                        previousValue: 0,
                        pointerPosition: 0,
                        targetValue: 0,
                        scrollBar: scrollBar,
                        value: 0,
                        velocity: 0
                    };
                };

                var hScrollInfo = createScrollInfo(horizontalScrollBar);
                var vScrollInfo = createScrollInfo(verticalScrollBar);

                var track = function track() {
                    now = Date.now();
                    elapsed = now - timestamp;
                    timestamp = now;

                    var updateScrollInfo = function updateScrollInfo(scrollInfo) {
                        scrollInfo.delta = scrollInfo.value - scrollInfo.previousValue;
                        scrollInfo.previousValue = scrollInfo.value;
                        var velocity = 1000 * scrollInfo.delta / (1 + elapsed);
                        scrollInfo.velocity = 0.8 * velocity + 0.2 * scrollInfo.velocity;
                    };

                    updateScrollInfo(vScrollInfo);
                    updateScrollInfo(hScrollInfo);
                };

                var scroll = function scroll(value) {
                    currentScrollInfo.value = value > currentScrollInfo.max ? currentScrollInfo.max : value < currentScrollInfo.min ? currentScrollInfo.min : value;
                    currentScrollInfo.scrollBar.value = currentScrollInfo.value;

                    return value > currentScrollInfo.max ? 'max' : value < currentScrollInfo.min ? 'min' : 'value';
                };

                function autoScroll() {
                    var elapsed = void 0,
                        delta = void 0;
                    if (currentScrollInfo.amplitude) {
                        that.container.$.fireEvent('kineticScroll');
                        elapsed = Date.now() - timestamp;
                        delta = -currentScrollInfo.amplitude * Math.exp(-elapsed / timeConstant);
                        if (delta > 5 || delta < -5) {
                            scroll(currentScrollInfo.targetValue + delta);
                            cancelAnimationFrame(rafId);
                            rafId = 0;
                            rafId = requestAnimationFrame(autoScroll);
                        } else {
                            scroll(currentScrollInfo.targetValue);
                        }
                    }
                }

                that.inputEvents['down'](function (event) {
                    if (!isMobile) {
                        return;
                    }

                    var originalTarget = event.originalEvent.target,
                        target = originalTarget && originalTarget.closest ? originalTarget.closest('jqx-scroll-bar') : undefined;

                    if (target === that.horizontalScrollBar || target === that.verticalScrollBar) {
                        return;
                    }

                    pointerCaptured = true;
                    dragStarted = false;

                    var updateScrollInfo = function updateScrollInfo(scrollInfo, pointerPosition) {
                        scrollInfo.amplitude = 0;
                        scrollInfo.pointerPosition = pointerPosition;
                        scrollInfo.previousValue = scrollInfo.value;
                        scrollInfo.value = scrollInfo.scrollBar.value;
                        scrollInfo.initialValue = scrollInfo.value;
                        scrollInfo.max = scrollInfo.scrollBar.max;
                    };

                    updateScrollInfo(vScrollInfo, event.clientY);
                    updateScrollInfo(hScrollInfo, event.clientX);

                    timestamp = Date.now();
                    clearInterval(ticker);
                    ticker = setInterval(track, timeConstant);
                });

                that.inputEvents['up'](function () {
                    if (!pointerCaptured) {
                        return true;
                    }

                    clearInterval(ticker);

                    if (that.disableSwipeScroll) {
                        pointerCaptured = false;
                        return;
                    }

                    var startScroll = function startScroll(scrollInfo) {
                        currentScrollInfo = scrollInfo;
                        scrollInfo.amplitude = 0.8 * scrollInfo.velocity;
                        scrollInfo.targetValue = Math.round(scrollInfo.value + scrollInfo.amplitude);
                        timestamp = Date.now();
                        cancelAnimationFrame(rafId);
                        rafId = requestAnimationFrame(autoScroll);
                        scrollInfo.velocity = 0;
                    };

                    if (vScrollInfo.velocity > 10 || vScrollInfo.velocity < -10) {
                        startScroll(vScrollInfo);
                    } else if (hScrollInfo.velocity > 10 || hScrollInfo.velocity < -10) {
                        startScroll(hScrollInfo);
                    }

                    pointerCaptured = false;
                });

                that.inputEvents['move'](function (event) {
                    if (!pointerCaptured) {
                        return true;
                    }

                    if (that.disableSwipeScroll) {
                        return;
                    }

                    if (dragStarted) {
                        event.originalEvent.preventDefault();
                        event.originalEvent.stopPropagation();
                    }

                    hScrollInfo.visible = horizontalScrollBar.offsetHeight > 0;
                    vScrollInfo.visible = verticalScrollBar.offsetWidth > 0;

                    if (!pointerCaptured || !hScrollInfo.visible && !vScrollInfo.visible) {
                        return;
                    }

                    vScrollInfo.ratio = -vScrollInfo.max / vScrollInfo.scrollBar.offsetHeight;
                    vScrollInfo.delta = (event.clientY - vScrollInfo.pointerPosition) * vScrollInfo.ratio;

                    hScrollInfo.ratio = -hScrollInfo.max / hScrollInfo.scrollBar.offsetWidth;
                    hScrollInfo.delta = (event.clientX - hScrollInfo.pointerPosition) * hScrollInfo.ratio;

                    var dragged = 'value';

                    var doDrag = function doDrag(scrollInfo, pointerPosition, event) {
                        if (scrollInfo.delta > 5 || scrollInfo.delta < -5) {
                            currentScrollInfo = scrollInfo;

                            dragged = scrollInfo.initialValue + scrollInfo.delta > currentScrollInfo.max ? 'max' : scrollInfo.initialValue + scrollInfo.delta < currentScrollInfo.min ? 'min' : 'value';

                            if (dragged === 'min' && scrollInfo.initialValue === 0) {
                                return true;
                            }

                            if (dragged === 'max' && scrollInfo.initialValue === scrollInfo.max) {
                                return true;
                            }

                            if (!scrollInfo.visible) {
                                return true;
                            }

                            that.container.$.fireEvent('kineticScroll');
                            scroll(scrollInfo.initialValue + scrollInfo.delta);
                            track();

                            event.originalEvent.preventDefault();
                            event.originalEvent.stopPropagation();
                            dragStarted = true;

                            return false;
                        }

                        return null;
                    };

                    var verticalDragResult = doDrag(vScrollInfo, event.clientY, event);
                    if (verticalDragResult === null) {
                        var horizontalDragResult = doDrag(hScrollInfo, event.clientX, event);
                        if (horizontalDragResult !== null) {
                            return horizontalDragResult;
                        }
                    } else {
                        return verticalDragResult;
                    }
                });

                var elapsedScrollTo = void 0;
                that.scrollTo = function (value, vertically) {
                    var scrollInfo = vertically === false ? hScrollInfo : vScrollInfo;
                    var isScrolling = false;

                    if (!timestamp) {
                        timestamp = Date.now();
                    }

                    if (!elapsedScrollTo) {
                        elapsedScrollTo = Date.now();
                    }

                    if (Math.abs(Date.now() - elapsedScrollTo) > 375) {
                        timestamp = Date.now();
                    } else {
                        isScrolling = true;
                    }

                    elapsedScrollTo = Date.now();

                    scrollInfo.value = scrollInfo.scrollBar.value;
                    scrollInfo.delta = value - scrollInfo.value;
                    scrollInfo.max = scrollInfo.scrollBar.max;

                    if (value <= scrollInfo.min) {
                        value = scrollInfo.min;
                    }

                    if (value >= scrollInfo.max) {
                        value = scrollInfo.max;
                    }

                    scrollInfo.targetValue = value;

                    var to = value;
                    var from = scrollInfo.value;

                    scrollInfo.velocity = 100 * scrollInfo.delta / (1 + scrollInfo.max);
                    scrollInfo.from = from;

                    var scroll = function scroll(value) {
                        scrollInfo.value = value > scrollInfo.max ? scrollInfo.max : value < scrollInfo.min ? scrollInfo.min : value;
                        scrollInfo.scrollBar.value = scrollInfo.value;

                        return value > scrollInfo.max ? 'max' : value < scrollInfo.min ? 'min' : 'value';
                    };

                    var autoScroll = function autoScroll() {
                        var delta = void 0;
                        var duration = 175;
                        var time = Date.now() - elapsedScrollTo;
                        var elapsed = Math.min(1000, Date.now() - timestamp);
                        var amplitude = scrollInfo.velocity * Math.exp(elapsed / duration);

                        if (isScrolling) {
                            if (amplitude < 0 && scrollInfo.value <= value) {
                                amplitude = 0;
                            } else if (amplitude > 0 && scrollInfo.value >= value) {
                                amplitude = 0;
                            }
                            if (scrollInfo.value + amplitude <= scrollInfo.min || scrollInfo.value + amplitude >= scrollInfo.max) {
                                amplitude = 0;
                            }

                            if (amplitude > 0.5 || amplitude < -0.5) {
                                scroll(scrollInfo.value + amplitude);
                                cancelAnimationFrame(rafId);
                                rafId = 0;
                                rafId = requestAnimationFrame(autoScroll);
                            } else {
                                scroll(scrollInfo.targetValue);
                            }
                        } else {
                            if (time >= duration) {
                                cancelAnimationFrame(rafId);
                                that.container.$.fireEvent('kineticScroll');
                                rafId = 0;
                                return;
                            }

                            delta = Utilities.Animation.Easings.easeInSine(time, from, to - from, duration);
                            scroll(delta);
                            cancelAnimationFrame(rafId);
                            rafId = 0;
                            rafId = requestAnimationFrame(autoScroll);
                        }
                    };

                    cancelAnimationFrame(rafId);
                    rafId = requestAnimationFrame(autoScroll);
                };

                that.inputEvents.listen();
            }
        }, {
            key: 'unlisten',
            value: function unlisten() {
                var that = this;

                if (that.inputEvents) {
                    that.inputEvents.unlisten();
                }

                delete that.inputEvents;
            }
        }]);
        return Scroll;
    }();

    /** This is a class which extends an element with utility methods. */


    var _Extend = function () {
        function Extend(element) {
            babelHelpers.classCallCheck(this, Extend);

            this.events = {};
            this.handlers = {};
            this.element = element;
        }

        /**
         * Gets whether an element has a CSS Class. 
         * @param {String}.
         */


        babelHelpers.createClass(Extend, [{
            key: 'hasClass',
            value: function hasClass(className) {
                var that = this;
                var classNames = className.split(' ');

                for (var i = 0; i < classNames.length; i++) {
                    var result = that.element.classList.contains(classNames[i]);

                    if (!result) {
                        return false;
                    }
                }

                return true;
            }

            /**
             * Adds a CSS Class to an element. 
             * @param {String}.
             */

        }, {
            key: 'addClass',
            value: function addClass(className) {
                var that = this;

                if (that.hasClass(className)) {
                    return;
                }

                var classNames = className.split(' ');

                for (var i = 0; i < classNames.length; i++) {
                    that.element.classList.add(classNames[i]);
                }

                if (!that.isNativeElement) {
                    StyleObserver.observeElement(that.element);
                }
            }

            /**
             * Removes a CSS Class from an element. 
             * @param {String}.
             */

        }, {
            key: 'removeClass',
            value: function removeClass(className) {
                var that = this;

                if (arguments.length === 0) {
                    that.element.removeAttribute('class');
                    return;
                }

                var classNames = className.split(' ');

                for (var i = 0; i < classNames.length; i++) {
                    that.element.classList.remove(classNames[i]);
                }

                if (that.element.className === '') {
                    that.element.removeAttribute('class');
                }
                if (!that.isNativeElement) {
                    StyleObserver.observeElement(that.element);
                }
            }
        }, {
            key: 'dispatch',


            /** 
             * Applies the event handlers.
             * @param {Event} - event object.
             */
            value: function dispatch(event) {
                var that = this;
                var handleObjects = that.events[event.type];
                var shouldSort = false;

                if (handleObjects.length > 1) {
                    for (var i = 0; i < handleObjects.length; i++) {
                        var handleObject = handleObjects[i];

                        if (handleObject.namespace && handleObject.namespace.indexOf('_') >= 0) {
                            shouldSort = true;
                            break;
                        }
                    }
                }

                if (shouldSort) {
                    handleObjects.sort(function (element1, element2) {
                        var namespace1 = element1.namespace;
                        var namespace2 = element2.namespace;

                        if (namespace1.indexOf('_') === -1) {
                            namespace1 = 0;
                        } else {
                            namespace1 = parseInt(namespace1.substring(namespace1.indexOf('_') + 1));
                        }

                        if (namespace2.indexOf('_') === -1) {
                            namespace2 = 0;
                        } else {
                            namespace2 = parseInt(namespace2.substring(namespace2.indexOf('_') + 1));
                        }

                        if (namespace1 < namespace2) {
                            return -1;
                        }

                        if (namespace1 > namespace2) {
                            return 1;
                        }

                        return 0;
                    });
                }

                for (var _i2 = 0; _i2 < handleObjects.length; _i2++) {
                    var _handleObject = handleObjects[_i2];
                    event.namespace = _handleObject.namespace;
                    event.context = _handleObject.context;

                    if (event.defaultPrevented) {
                        break;
                    }

                    var result = _handleObject.handler.apply(that.element, [event]);

                    if (result !== undefined) {
                        event.result = result;

                        if (result === false) {
                            event.preventDefault();
                            event.stopPropagation();
                            break;
                        }
                    }
                }

                return event.result;
            }

            /** 
             * Fires a new event.
             * @param {String} - event type.
             * @param {Object} - event details.
             * @param {Object} - event options.
             */

        }, {
            key: 'fireEvent',
            value: function fireEvent(eventType, detail, options) {
                var that = this;

                if (!options) {
                    options = {
                        bubbles: true,
                        cancelable: true
                    };
                }
                options.detail = detail || {};

                var customEvent = new CustomEvent(eventType, options);
                customEvent.originalStopPropagation = customEvent.stopPropagation;
                customEvent.stopPropagation = function () {
                    customEvent.isPropagationStopped = true;
                    return customEvent.originalStopPropagation();
                };

                that.dispatchEvent(customEvent);

                return customEvent;
            }
        }, {
            key: 'dispatchEvent',

            /** 
                * Dispatches an event.
                * @param {CustomEvent} - event.
                */
            value: function dispatchEvent(customEvent) {
                var that = this;
                var eventType = customEvent.type;
                var context = that.element.context;

                that.element.context = document;

                if (that.element['on' + eventType]) {
                    that.element['on' + eventType](customEvent);
                } else {
                    that.element.dispatchEvent(customEvent);
                }

                that.element.context = context;
            }

            /** 
             * Adds an event listener.
             * @param {String} - event types.
             * @param {Function} - the event handler.
             */

        }, {
            key: 'listen',
            value: function listen(types, handler) {
                var that = this;
                var typesArray = types.split('.');
                var namespace = typesArray.slice(1).join('.');
                var eventType = typesArray[0];

                if (!that.events[eventType]) {
                    that.events[eventType] = [];
                }

                var handleObject = {
                    type: eventType,
                    handler: handler,
                    context: that.element,
                    namespace: namespace
                };

                if (inputEventTypes.indexOf(eventType) >= 0) {
                    if (!that.inputEvents) {
                        that.inputEvents = new InputEvents(that.element);
                    }

                    that.inputEvents[eventType](function (event) {
                        that.dispatchEvent(event);
                    });

                    that.inputEvents.boundEventTypes.push(eventType);
                    that.inputEvents.listen(eventType);
                }

                if (that.events[eventType].length === 0) {
                    that.handlers[eventType] = that.dispatch.bind(that);

                    if (eventType === 'wheel') {
                        that.element.addEventListener('wheel', that.handlers[eventType], that.isPassiveSupported ? { passive: false } : false);
                    } else {
                        that.element.addEventListener(eventType, that.handlers[eventType], false);
                    }
                }

                that.events[eventType].push(handleObject);
            }

            /** 
             * Removes an event listener.
             * @param {String} - event types.
             */

        }, {
            key: 'unlisten',
            value: function unlisten(types) {
                var that = this;
                var typesArray = types.split('.');
                var namespace = typesArray.slice(1).join('.');
                var eventType = typesArray[0];

                var handleObjects = that.events[eventType];

                if (that.inputEvents && that.inputEvents.boundEventTypes.indexOf(eventType) >= 0) {
                    that.inputEvents.boundEventTypes.splice(that.inputEvents.boundEventTypes.indexOf(eventType), 1);
                    if (that.inputEvents.boundEventTypes.length === 0) {
                        that.inputEvents.unlisten(eventType);
                    }
                }

                if (!handleObjects) {
                    return;
                }

                for (var i = 0; i < handleObjects.length; i++) {
                    if (namespace !== '') {
                        var index = handleObjects.findIndex(function (o) {
                            return o.namespace === namespace;
                        });
                        handleObjects.splice(index, 1);
                        break;
                    } else {
                        handleObjects = [];
                    }
                }
                if (handleObjects.length === 0) {
                    that.element.removeEventListener(eventType, that.handlers[eventType]);
                    that.events[eventType] = [];
                    delete that.handlers[eventType];
                }
            }

            /** 
            * Gets the element's attribute value by using the property's value.
            * @param {String} - attribute's name.
            * @param {String} - property's type.
            * @return {Object} The converted from String attribute value. 
            */

        }, {
            key: 'getAttributeValue',
            value: function getAttributeValue(attributeName, type) {
                var that = this;
                var attributeString = that.element.getAttribute(attributeName);

                if (that.isNativeElement) {
                    return that.deserialize(attributeString, type);
                }

                var propertyConfig = that.element.propertyByAttributeName[attributeName];
                var typedValue = propertyConfig.deserialize === undefined ? that.deserialize(attributeString, type, propertyConfig.nullable) : that.element[propertyConfig.deserialize](attributeString);

                return typedValue;
            }

            /** 
             * Sets the element's attribute using the property's value.
             * @param {String} - attribute's name.
             * @param {Object} - property's value.
             * @param {String} - property's type.
             */

        }, {
            key: 'setAttributeValue',
            value: function setAttributeValue(attributeName, value, type) {
                var that = this;
                var newAttributeValue = void 0;
                var nullable = false;

                if (!that.isNativeElement) {
                    var propertyConfig = that.element.propertyByAttributeName[attributeName];

                    nullable = propertyConfig ? propertyConfig.nullable : true;

                    if (propertyConfig && propertyConfig.serialize) {
                        newAttributeValue = that.element[propertyConfig.serialize](value);
                    } else {
                        newAttributeValue = that.serialize(value, type, nullable);
                    }
                } else {
                    newAttributeValue = that.serialize(value, type);
                    if (type === 'boolean') {
                        var booleans = ['checked', 'selected', 'async', 'autofocus', 'autoplay', 'controls', 'defer', 'disabled', 'hidden', 'ismap', 'loop', 'multiple', 'open', 'readonly', 'required', 'scoped'];
                        if (booleans.indexOf(attributeName) >= 0) {
                            if (!value) {
                                that.element.removeAttribute(attributeName);
                            } else {
                                that.element.setAttribute(attributeName, '');
                            }
                            return;
                        }
                    }
                }

                if (type === 'array' || type === 'object') {
                    if (newAttributeValue === '[]' || newAttributeValue === '{}') {
                        that.element.removeAttribute(attributeName);
                        return;
                    }
                }

                if (newAttributeValue === undefined) {
                    that.element.removeAttribute(attributeName);
                } else {
                    that.element.setAttribute(attributeName, newAttributeValue);
                }
            }

            /** 
             * Converts a javascript value to string.
             * @param {Object} the value to be converted.
             * @return {String} The converted to String value. If the type is unknown, returns undefined.
             */

        }, {
            key: 'serialize',
            value: function serialize(value, type, nullable) {
                if (type === undefined) {
                    type = Utilities.Types.getType(value);
                }

                if (value === undefined || !nullable && value === null) {
                    return undefined;
                }

                if (nullable && value === null) {
                    return 'null';
                }

                if (type === 'string') {
                    return value;
                }

                if (type === 'boolean' || type === 'bool') {
                    if (value === true || value === 'true' || value === 1 || value === '1') {
                        return '';
                    } else if (value === false || value === 'false' || value === 0 || value === '0') {
                        return undefined;
                    }
                }

                if (type === 'array') {
                    return JSON.stringify(value);
                }

                var types = ['string', 'number', 'int', 'integer', 'float', 'date', 'any', 'function'];
                if (types.indexOf(type) >= 0) {
                    return value.toString();
                }

                if (type === 'object') {
                    return JSON.stringify(value);
                }

                return undefined;
            }

            /** 
             * Converts a string to a Javascript value.
             * @param {String}
             * @param {String}
             * @return {Object} The converted String value.
             */

        }, {
            key: 'deserialize',
            value: function deserialize(stringValue, type, nullable) {
                var nullValue = stringValue === 'null';

                if (stringValue === undefined || nullValue && !nullable) {
                    return undefined;
                }

                if (nullValue && nullable) {
                    return null;
                }

                if (type === 'boolean' || type === 'bool') {
                    if (stringValue === null) {
                        return false;
                    }

                    // Boolean properties are set based on the presence of the attribute: if the attribute exists at all, the value is true.
                    return true;
                } else if (type === 'number' || type === 'float') {
                    if (stringValue === 'NaN') {
                        return NaN;
                    }

                    if (stringValue === 'Infinity') {
                        return Infinity;
                    }

                    if (stringValue === '-Infinity') {
                        return -Infinity;
                    }

                    return parseFloat(stringValue);
                } else if (type === 'int' || type === 'integer') {
                    if (stringValue === 'NaN') {
                        return NaN;
                    }

                    if (stringValue === 'Infinity') {
                        return Infinity;
                    }

                    if (stringValue === '-Infinity') {
                        return -Infinity;
                    }

                    return parseInt(stringValue);
                } else if (type === 'string') {
                    return stringValue;
                } else if (type === 'any') {
                    return stringValue;
                } else if (type === 'date') {
                    return new Date(stringValue);
                } else if (type === 'function') {
                    if (typeof window[stringValue] === 'function') {
                        return window[stringValue];
                    }
                } else if (type === 'array' || type === 'object') {
                    try {
                        var jsonObject = JSON.parse(stringValue);

                        if (jsonObject) {
                            return jsonObject;
                        }
                    } catch (er) {
                        if (window[stringValue] && babelHelpers.typeof(window[stringValue]) === 'object') {
                            return window[stringValue];
                        } else if (type === 'array' && stringValue.indexOf('[') >= 0) {
                            if (stringValue.indexOf('{') >= 0) {
                                var _array = stringValue.replace(/{/ig, '').replace('[', '').replace(']', '').replace(/'/ig, '').replace(/"/ig, '').trim();

                                _array = _array.split('},');

                                for (var i = 0; i < _array.length; i++) {
                                    var parsedObject = {};

                                    var parts = _array[i].trim().split(',');

                                    for (var j = 0; j < parts.length; j++) {
                                        var key = parts[j].split(':')[0].trim();
                                        var value = parts[j].split(':')[1].trim();

                                        parsedObject[key] = value;
                                    }

                                    _array[i] = parsedObject;
                                }

                                return _array;
                            }

                            var array = stringValue.replace('[', '').replace(']', '').replace(/'/ig, '').replace(/"/ig, '').trim().split(',');

                            return array;
                        }
                    }
                }

                return undefined;
            }
        }, {
            key: 'isCustomElement',
            get: function get() {
                var that = this;

                if (that.element instanceof window[namespace].BaseElement === true) {
                    return true;
                }

                if (that.element.tagName === 'DIV' || that.element.tagName === 'SPAN' || that.element.tagName === 'BUTTON' || that.element.tagName === 'INPUT' || that.element.tagName === 'UL' || that.element.tagName === 'LI') {
                    return false;
                }

                if (document.createElement(that.element.nodeName) instanceof window[namespace].BaseElement === true) {
                    return true;
                }

                return false;
            }

            /** Determines whether this element is native HTMLElement. */

        }, {
            key: 'isNativeElement',
            get: function get() {
                var that = this;

                if (!that.isCustomElement) {
                    return true;
                }

                return false;
            }
        }, {
            key: 'isPassiveSupported',
            get: function get() {
                // Test via a getter in the options object to see if the passive property is accessed
                var that = this;

                if (that.supportsPassive !== undefined) {
                    return that.supportsPassive;
                }

                that.supportsPassive = false;
                try {
                    var opts = Object.defineProperty({}, 'passive', {
                        get: function get() {
                            that.supportsPassive = true;
                        }
                    });
                    window.addEventListener('testPassive', null, opts);
                    window.removeEventListener('testPassive', null, opts);
                } catch (e) {
                    //
                }

                return that.supportsPassive;
            }
        }]);
        return Extend;
    }();

    /** Animation class. */


    var Animation = function () {
        function Animation() {
            babelHelpers.classCallCheck(this, Animation);
        }

        babelHelpers.createClass(Animation, null, [{
            key: 'Ripple',


            /** Get access to Ripple class. */
            get: function get() {
                return Ripple;
            }

            /** Get access to Easings class. */

        }, {
            key: 'Easings',
            get: function get() {
                return Easings;
            }
        }]);
        return Animation;
    }();

    /** Utilities class. */


    var Utilities = function () {
        function Utilities() {
            babelHelpers.classCallCheck(this, Utilities);
        }

        babelHelpers.createClass(Utilities, null, [{
            key: 'Extend',


            /**
             * Extends Element with useful methods.
             * @param {HTMLElement}
             */
            value: function Extend(element) {
                return new _Extend(element);
            }
        }, {
            key: 'Assign',
            value: function Assign(moduleName, module) {
                if (moduleName.indexOf('.') >= 0) {
                    var modules = moduleName.split('.');

                    if (!Utilities[modules[0]]) {
                        Utilities[modules[0]] = {};
                    }

                    Utilities[modules[0]][modules[1]] = module;
                    return;
                }

                Utilities[moduleName] = module;
            }
        }, {
            key: 'Types',


            /** Get access to Types class. */
            get: function get() {
                return Types;
            }
        }, {
            key: 'Core',
            get: function get() {
                return Core;
            }
        }, {
            key: 'Animation',
            get: function get() {
                return Animation;
            }
        }, {
            key: 'Scroll',
            get: function get() {
                return Scroll;
            }
        }, {
            key: 'InputEvents',
            get: function get() {
                return InputEvents;
            }
        }]);
        return Utilities;
    }();

    var $document = Utilities.Extend(document);

    BindingModule.cache = {};
    /**
     * This is a base class for JQX Elements. It extends HTMLElement.
     */

    var BaseElement = function (_HTMLElement) {
        babelHelpers.inherits(BaseElement, _HTMLElement);

        function BaseElement() {
            babelHelpers.classCallCheck(this, BaseElement);
            return babelHelpers.possibleConstructorReturn(this, (BaseElement.__proto__ || Object.getPrototypeOf(BaseElement)).apply(this, arguments));
        }

        babelHelpers.createClass(BaseElement, [{
            key: 'template',


            /**
             * Gets the element's HTML Template.
             *
             * @returns {String} - element's template.
             */
            value: function template() {
                return '<div></div>';
            }

            /** Called when the element is registered. */

        }, {
            key: 'registered',
            value: function registered() {
                var that = this;

                if (that.onRegistered) {
                    that.onRegistered();
                }
            }

            /** Called when the element has been created. */

        }, {
            key: 'created',
            value: function created() {
                var that = this;

                that.isReady = false;
                that._initElement(that);
                that._setModuleState('created');

                if (that.onCreated) {
                    that.onCreated();
                }
            }

            /** Called when the element is rendered and configured. Use for one-time post configuration of your element. */

        }, {
            key: 'completed',
            value: function completed() {
                var that = this;

                that.isCompleted = true;

                if (that._onCompleted) {
                    that._onCompleted();
                }

                if (that.onCompleted) {
                    that.onCompleted();
                }
            }
        }, {
            key: 'whenReady',
            value: function whenReady(callback) {
                var that = this;

                if (that.isCompleted) {
                    callback();
                    return;
                }

                if (!that.whenReadyCallbacks) {
                    that.whenReadyCallbacks = [];
                }

                that.whenReadyCallbacks.push(callback);
            }
        }, {
            key: 'addThemeClass',
            value: function addThemeClass() {
                var that = this;

                if (that.theme !== '') {
                    that.classList.add('jqx-' + that.theme);
                }
            }
        }, {
            key: 'addDefaultClass',
            value: function addDefaultClass() {
                var that = this;

                that.classList.add(that.nodeName.toLowerCase() + '-element');
            }

            /** Called when the element is ready. Use for one-time configuration of your element. */

        }, {
            key: 'ready',
            value: function ready() {
                var _this3 = this;

                var that = this;

                that.addThemeClass();
                that.addDefaultClass();

                if (that.visibility === 'collapsed') {
                    that.classList.add('jqx-hidden');
                } else if (that.visibility === 'hidden') {
                    that.classList.add('jqx-visibility-hidden');
                }

                var requires = function requires() {
                    var missingModules = [];

                    var requires = that.getStaticMember('requires');

                    for (var require in requires) {
                        var modules = require.split('.');

                        if (modules.length > 2) {
                            if (!window[namespace].Utilities[modules[2]]) {
                                missingModules.push(requires[require]);
                            }
                        } else if (!window[namespace][modules[1]]) {
                            missingModules.push(requires[require]);
                        }
                    }

                    if (missingModules.length > 0) {
                        var _that = _this3;

                        _that.error(_that.localize('missingReference', { elementType: _that.nodeName.toLowerCase(), files: missingModules.join(', ') }));
                    }
                };

                requires();

                if (that.dataContext) {
                    that.applyDataContext();
                }

                if (that.onReady) {
                    that.onReady();
                }

                if (that.shadowRoot && JQX(that._selector)) {
                    if (JQX(that._selector).styleUrls) {
                        var styleUrls = JQX(that._selector).styleUrls;

                        for (var i = 0; i < styleUrls.length; i++) {
                            that.importStyle(styleUrls[i]);
                        }
                    }

                    if (JQX(that._selector).styles) {
                        var scopedStyle = document.createElement('style');
                        scopedStyle.innerHTML = JQX(that._selector).styles;
                        that.shadowRoot.insertBefore(scopedStyle, that.shadowRoot.firstChild);
                    }
                }

                if (JQX(that._selector) && JQX(that._selector).ready) {
                    JQX(that._selector).ready();
                }
            }
        }, {
            key: 'applyDataContext',
            value: function applyDataContext(dataContextObject) {
                var that = this;
                var dataContext = typeof that.dataContext === 'string' ? window[that.dataContext] || document[that.dataContext] : that.dataContext;

                if (dataContextObject) {
                    dataContext = dataContextObject;
                    that.dataContext = dataContextObject;
                }

                if (!dataContext) {
                    that.dataContextProperties = null;

                    var lazyApplyDataContext = function lazyApplyDataContext() {
                        var dataContext = typeof that.dataContext === 'string' ? window[that.dataContext] || document[that.dataContext] : that.dataContext;

                        if (dataContext) {
                            that.applyDataContext();
                            window.removeEventListener('load', lazyApplyDataContext);
                        }
                    };
                    window.addEventListener('load', lazyApplyDataContext);

                    return;
                }

                if (!dataContext._uid) {
                    dataContext._uid = (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase();

                    dataContext._properties = [];

                    var _loop3 = function _loop3(propertyName) {
                        var dataContextItem = dataContext[propertyName];

                        if (typeof dataContextItem === 'function' || propertyName === '_properties' || propertyName === '_uid') {
                            return 'continue';
                        }

                        dataContext._properties[propertyName] = dataContextItem;
                        Object.defineProperty(dataContext, propertyName, {
                            configurable: false,
                            enumerable: true,
                            get: function get() {
                                return dataContext._properties[propertyName];
                            },
                            set: function set(value) {
                                var oldValue = dataContext._properties[propertyName];
                                dataContext._properties[propertyName] = value;
                                var changedProperties = [];

                                changedProperties[propertyName] = {
                                    oldValue: oldValue, value: value
                                };
                                changedProperties.length++;
                                that.updatingDataContext = true;
                                $document.fireEvent('dataContextPropertyChanged', {
                                    dataContext: dataContext,
                                    properties: changedProperties
                                }, {
                                    bubbles: false,
                                    cancelable: true
                                });
                                that.updatingDataContext = false;
                            }
                        });
                    };

                    for (var propertyName in dataContext) {
                        var _ret5 = _loop3(propertyName);

                        if (_ret5 === 'continue') continue;
                    }
                }

                that.dataContextProperties = that.parseAttributes(that);
                that.dataContextPropertiesMap = {};

                that.dataContextListeners = {};

                if (!that.dataContextProperties) {
                    that.dataContextProperties = null;
                    return;
                }

                that.updatingDataContext = true;

                for (var _boundProperty in that.dataContextProperties) {
                    var binding = that.dataContextProperties[_boundProperty];
                    var name = binding.name;

                    binding.propertyName = _boundProperty;

                    that.dataContextPropertiesMap[name] = _boundProperty;

                    if (!BindingModule.cache['toDash' + _boundProperty]) {
                        BindingModule.cache['toDash' + _boundProperty] = Utilities.Core.toDash(name);
                    }

                    if (binding.isEvent) {
                        (function () {
                            var handlerName = binding.value;
                            if (that.dataContextListeners[name]) {
                                that.removeEventListener(name, that.dataContextListeners[name]);
                            }

                            that.dataContextListeners[name] = function (event) {
                                dataContext[handlerName](event);
                            };
                            that.addEventListener(name, that.dataContextListeners[name]);
                        })();
                    }

                    if (name.indexOf('.') >= 0) {
                        var path = name.split('.');
                        var dataBoundObject = dataContext[path[0]];

                        for (var i = 1; i < path.length; i++) {
                            dataBoundObject = dataBoundObject[path[i]];
                        }

                        if (dataBoundObject !== undefined) {
                            that[_boundProperty] = dataBoundObject;
                        }
                    } else {
                        that[_boundProperty] = dataContext[name];
                    }
                }

                that.dataContextPropertyChangedHandler = function (event) {
                    var properties = event.detail.properties;
                    var dataContext = event.detail.dataContext;
                    var elementDataContext = typeof that.dataContext === 'string' ? window[that.dataContext] || document[that.dataContext] : that.dataContext;

                    if (dataContext === elementDataContext) {
                        for (var property in properties) {
                            var elementPropertyName = that.dataContextPropertiesMap[property];
                            var context = that.context;

                            if (!elementPropertyName) {
                                continue;
                            }

                            that.context = document;
                            that[elementPropertyName] = properties[property].value;
                            that.context = context;
                        }
                    }
                };

                $document.listen('dataContextPropertyChanged', that.dataContextPropertyChangedHandler);

                that.updatingDataContext = false;
            }
        }, {
            key: 'updateDataContextProperty',
            value: function updateDataContextProperty(propertyName) {
                var that = this;
                var dataContext = typeof that.dataContext === 'string' ? window[that.dataContext] || document[that.dataContext] : that.dataContext;
                var boundProperty = that.dataContextProperties[propertyName];

                if (that.updatingDataContext) {
                    return;
                }

                if (boundProperty.twoWay) {
                    var name = boundProperty.name;

                    if (name.indexOf('.') >= 0) {
                        var path = name.split('.');
                        var dataBoundObject = dataContext[path[0]];

                        for (var i = 1; i < path.length; i++) {
                            dataBoundObject = dataBoundObject[path[i]];
                        }

                        if (dataBoundObject !== undefined) {
                            dataBoundObject = that[propertyName];

                            if (dataContextInfo[dataContext._uid]) {
                                dataContextInfo[dataContext._uid][propertyName] = dataBoundObject;
                            }
                        }
                    } else {
                        dataContext[name] = that[propertyName];

                        if (dataContextInfo[dataContext._uid]) {
                            dataContextInfo[dataContext._uid][propertyName] = dataContext[name];
                        }
                    }
                }
            }
        }, {
            key: 'initProperties',
            value: function initProperties() {
                var that = this;

                if (JQX(that._selector) && JQX(that._selector).properties) {
                    that._initProperties = JQX(that._selector).properties;
                }

                if (that._initProperties) {
                    var propertyNames = Object.keys(that._initProperties);

                    for (var i = 0; i < propertyNames.length; i++) {
                        var propertyName = propertyNames[i];
                        var propertyValue = that._initProperties[propertyName];

                        if (propertyValue.constructor === JQX.ObservableArray) {
                            that[propertyName] = propertyValue.toArray();
                            continue;
                        }

                        if (propertyValue.constructor === JQX.DataAdapter || propertyValue.constructor === JQX.Observable || (typeof propertyValue === 'undefined' ? 'undefined' : babelHelpers.typeof(propertyValue)) !== 'object' || Utilities.Types.isArray(propertyValue)) {
                            that[propertyName] = propertyValue;
                            continue;
                        }

                        if ((typeof propertyValue === 'undefined' ? 'undefined' : babelHelpers.typeof(propertyValue)) === 'object') {
                            (function () {
                                var setHierarchicalProperty = function setHierarchicalProperty(propertyValue, path) {
                                    var subPropertyNames = Object.keys(propertyValue);

                                    for (var _i3 = 0; _i3 < subPropertyNames.length; _i3++) {
                                        var _propertyName = subPropertyNames[_i3];
                                        var subPropertyValue = propertyValue[_propertyName];

                                        if ((typeof subPropertyValue === 'undefined' ? 'undefined' : babelHelpers.typeof(subPropertyValue)) === 'object' && !Utilities.Types.isArray(subPropertyValue) && subPropertyValue.constructor !== Date) {
                                            setHierarchicalProperty(subPropertyValue, path + '_' + _propertyName);
                                        } else {
                                            that[path + '_' + _propertyName] = subPropertyValue;
                                        }
                                    }
                                };

                                setHierarchicalProperty(propertyValue, propertyName);
                            })();
                        }
                    }
                }
            }
        }, {
            key: 'setup',
            value: function setup() {
                var that = this;

                that.context = this;

                if (that.isReady && !that.isCompleted) {
                    return;
                }

                if (that.isReady) {
                    that._setModuleState('attached');
                    that.isAttached = true;
                    that.attached();
                    that._handleListeners('listen');

                    that.context = document;
                    return;
                }

                if (that.ownerElement && that.ownerElement.detachedChildren.indexOf(that) >= 0) {
                    that.ownerElement.detachedChildren.splice(that.ownerElement.detachedChildren.indexOf(that), 1);
                }

                that.isReady = true;

                that.methods = that.getStaticMember('methods');

                that.initProperties();
                var isMobile = Core.isMobile;

                if (isMobile) {
                    that.classList.add('jqx-mobile');
                }
                /* Updates the properties by using the attribute values. */

                for (var i = 0; i < that.attributes.length; i += 1) {
                    var property = that.propertyByAttributeName[that.attributes[i].name];

                    if (!property) {
                        continue;
                    }

                    var attributeValue = that.$.getAttributeValue(property.attributeName, property.type);
                    var attributeValueString = attributeValue ? attributeValue.toString() : '';

                    if (attributeValueString.indexOf('{{') >= 0 || attributeValueString.indexOf('[[') >= 0) {
                        continue;
                    }

                    if (property.type !== 'object' && property.type !== 'array') {
                        if (that.attributes[i].value.indexOf('{{') >= 0 || that.attributes[i].value.indexOf('[[') >= 0) {
                            continue;
                        }
                    }

                    if (attributeValue !== undefined && property.value !== attributeValue) {
                        var attributeValueType = Utilities.Types.getType(attributeValue);
                        var attributeUntypedValue = that.attributes[i].value;

                        if (property.type === 'any' || property.type === 'object') {
                            if ('' + that[property.name] === attributeValue) {
                                continue;
                            }
                        }

                        if (property.type === 'array') {
                            if (that[property.name] && JSON.stringify(that[property.name]) === attributeValue) {
                                continue;
                            }
                        }

                        if (attributeValueType === 'number' && isNaN(attributeValue) && attributeUntypedValue !== 'NaN' && attributeUntypedValue !== 'Infinity' && attributeUntypedValue !== '-Infinity') {
                            var localizedError = that.localize('propertyInvalidValueType', { name: property.name, actualType: 'string', type: property.type });
                            that.log(localizedError);
                        }

                        property.isUpdatingFromAttribute = true;
                        that[property.name] = attributeValue;
                        property.isUpdatingFromAttribute = false;
                    }
                }

                /* Set the default boolean and innerhtml attributes by using the property values. */
                for (var propertyName in that._properties) {
                    var _property = that._properties[propertyName];

                    if (propertyName === 'innerHTML' && _property.value === _property.defaultValue) {
                        _property.value = _property.defaultValue = Utilities.Core.html(that);
                    }

                    if (_property.type === 'boolean' || _property.type === 'bool') {
                        if (that.getAttribute(_property.attributeName) === 'false') {
                            _property.isUpdating = true;
                            that.setAttribute(_property.attributeName, '');
                            _property.isUpdating = false;
                        }
                    }

                    if (!_property.defaultReflectToAttribute || !_property.reflectToAttribute) {
                        continue;
                    }

                    if (_property.defaultReflectToAttribute && _property.defaultReflectToAttributeConditions) {
                        var reflectToAttribute = true;

                        for (var _i4 = 0; _i4 < _property.defaultReflectToAttributeConditions.length; _i4++) {
                            var condition = _property.defaultReflectToAttributeConditions[_i4];
                            var conditionName = void 0;
                            var conditionValue = void 0;

                            for (var name in condition) {
                                conditionName = name;
                                conditionValue = condition[name];
                            }

                            if (that._properties[conditionName] && that._properties[conditionName].value !== conditionValue) {
                                reflectToAttribute = false;
                            }
                        }

                        if (!reflectToAttribute) {
                            continue;
                        }
                    }

                    _property.isUpdating = true;
                    that.$.setAttributeValue(_property.attributeName, _property.value, _property.type);
                    _property.isUpdating = false;
                }

                var children = [];

                if (that.children.length > 0) {
                    for (var _i5 = 0; _i5 < that.children.length; _i5++) {
                        var _node2 = that.children[_i5];

                        if (Utilities.Extend(_node2).isCustomElement) {
                            children.push(_node2);
                        }
                    }
                }

                that.applyTemplate();

                that.complete = function () {
                    if (!that.templateBindingsReady) {
                        var updateTemplateBindings = function updateTemplateBindings(node) {
                            if (node.templateBindingsReady) {
                                return;
                            }

                            node.templateBindingsReady = true;
                            node.updateTextNodes();
                            node.updateBoundNodes();
                        };

                        if (!that.ownerElement) {
                            updateTemplateBindings(that);
                        } else {
                            var owner = that.ownerElement;
                            var owners = [];
                            while (owner) {
                                owners.push(owner);
                                owner = owner.ownerElement;
                            }

                            for (var _i6 = owners.length - 1; _i6 >= 0; _i6--) {
                                updateTemplateBindings(owners[_i6]);
                            }

                            updateTemplateBindings(that);
                        }
                    }

                    var init = function init() {
                        that._setModuleState('ready');

                        that.ready();

                        that.isAttached = true;
                        that._setModuleState('attached');
                        that.attached();
                        that._handleListeners('listen');

                        if (!that.isHidden) {
                            if (that.offsetWidth === 0 || that.offsetHeight === 0) {
                                that.isHidden = true;
                            }
                        }

                        that.completed();

                        that.context = document;

                        if (that.whenReadyCallbacks) {
                            for (var _i7 = 0; _i7 < that.whenReadyCallbacks.length; _i7++) {
                                that.whenReadyCallbacks[_i7]();
                            }

                            that.whenReadyCallbacks = [];
                        }
                    };

                    if (window[namespace].EnableShadowDOM) {
                        init();
                    } else {
                        if (!that.wait) {
                            if (!that.classList.contains('jqx-async')) {
                                if (!that.ownerElement || that.parents[that.parents.length - 1].nodeName === 'HTML') {
                                    init();
                                } else {
                                    that.checkIsInDomInterval = setInterval(function () {
                                        if (that.parents[that.parents.length - 1].nodeName === 'HTML') {
                                            clearInterval(that.checkIsInDomInterval);

                                            var _owner = that.ownerElement;
                                            var _owners = [];
                                            while (_owner) {
                                                _owners.push(_owner);
                                                _owner = _owner.ownerElement;
                                            }

                                            for (var _i8 = _owners.length - 1; _i8 >= 0; _i8--) {
                                                _owners[_i8].updateBoundMappedNodes();
                                            }

                                            init();
                                        }
                                    }, 100);
                                }
                            } else {
                                requestAnimationFrame(function () {
                                    init();
                                });
                            }
                        } else {
                            that.classList.add('jqx-visibility-hidden');
                        }
                    }
                };

                // All of the registered elements inside the element's local DOM are ready, and have had their ready methods called.
                var templateNodes = [].slice.call(that.querySelectorAll('[jqx-id]')).concat(children);

                if (window[namespace].EnableShadowDOM && that.enableShadowDOM) {
                    templateNodes = [].slice.call(that.shadowRoot.querySelectorAll('[jqx-id]')).concat(children);
                }

                if (templateNodes.length === 0) {
                    that.complete();
                } else {
                    that._completeListeners = 0;

                    var _loop4 = function _loop4(_i9) {
                        var node = templateNodes[_i9];

                        if (Utilities.Extend(node).isCustomElement) {
                            var completeEventHandler = function () {
                                that._completeListeners--;
                                if (that._completeListeners === 0) {
                                    that.complete();

                                    delete that._completeListeners;
                                }
                            }.bind(that);

                            if (!node.isCompleted && !node.isUtilityElement && node.wait === false) {
                                that._completeListeners++;

                                if (!node._onCompleted) {
                                    node.completeHandlers = [];

                                    node._onCompleted = function () {
                                        for (var _i10 = 0; _i10 < node.completeHandlers.length; _i10++) {
                                            node.completeHandlers[_i10]();
                                        }
                                    };
                                }
                                node.completeHandlers.push(completeEventHandler);
                            }
                        }
                    };

                    for (var _i9 = 0; _i9 < templateNodes.length; _i9++) {
                        _loop4(_i9);
                    }

                    if (that._completeListeners === 0) {
                        that.complete();
                    }
                }
            }
        }, {
            key: 'visibilityChangedHandler',
            value: function visibilityChangedHandler() {
                var that = this;

                if (!that.isReady) {
                    return;
                }

                requestAnimationFrame(function () {
                    if (!that.isHidden && that.offsetWidth === 0 || that.offsetHeight === 0) {
                        that.isHidden = true;
                    } else {
                        if (that.isHidden) {
                            that.isHidden = false;
                            that.$.fireEvent('resize', that, {
                                bubbles: false,
                                cancelable: true
                            });
                        }
                    }
                });
            }

            /** Called when an attribute is changed. */

        }, {
            key: 'attributeChangedCallback',
            value: function attributeChangedCallback(name, oldValue, newValue) {
                var that = this;
                var property = that.propertyByAttributeName[name];

                if (name === 'class' || name === 'style') {
                    that.visibilityChangedHandler();
                }

                if (!property) {
                    that.attributeChanged(name, oldValue, newValue);
                }

                if (!property || property && property.isUpdating) {
                    return;
                }

                var newPropertyValue = that.$.getAttributeValue(property.attributeName, property.type);
                if (newValue !== undefined && that[property.name] !== newPropertyValue) {
                    property.isUpdatingFromAttribute = true;
                    if (newPropertyValue !== undefined) {
                        that[property.name] = newPropertyValue;
                    } else {
                        that[property.name] = that._properties[property.name].defaultValue;
                    }
                    property.isUpdatingFromAttribute = false;
                }
            }

            /** Called when one of the element's attributes is changed. Use to handle attribute changes that don't correspond to declared properties. */

        }, {
            key: 'attributeChanged',
            value: function attributeChanged(name, oldValue, newValue) {
                if (oldValue !== newValue) {
                    /* attribute change handling logic here. */
                }
            }
        }, {
            key: 'attached',


            /** Called after the element is attached to the document. Can be called multiple times during the lifetime of an element. */
            value: function attached() {
                var that = this;

                if (that.hasStyleObserver) {
                    StyleObserver.watch(that);
                }

                if (that.onAttached) {
                    that.onAttached();
                }

                if (JQX(that._selector) && JQX(that._selector).attached) {
                    JQX(that._selector).attached();
                }
            }

            /** Called after the element is detached from the document. Can be called multiple times during the lifetime of an element. */

        }, {
            key: 'detached',
            value: function detached() {
                var that = this;

                if (that.hasStyleObserver) {
                    StyleObserver.unwatch(that);
                }

                that._setModuleState('detached');
                that.isAttached = false;

                if (that.ownerElement && that.ownerElement.detachedChildren.indexOf(that) === -1) {
                    that.ownerElement.detachedChildren.push(that);
                }
                that._handleListeners('unlisten');

                if (that.onDetached) {
                    that.onDetached();
                }

                if (JQX(that._selector) && JQX(that._selector).detached) {
                    JQX(that._selector).detached();
                }
            }

            /** Called when a property value is changed. */

        }, {
            key: 'propertyChangedHandler',
            value: function propertyChangedHandler(propertyName, oldValue, newValue) {
                var that = this;

                if (oldValue === newValue) {
                    return;
                }

                if (propertyName === 'theme') {
                    if (oldValue !== '') {
                        that.classList.remove('jqx-' + oldValue);
                    }

                    if (newValue !== '') {
                        that.classList.add('jqx-' + newValue);
                    }
                }

                if (propertyName === 'visibility') {
                    if (oldValue === 'collapsed') {
                        that.classList.remove('jqx-hidden');
                    } else if (oldValue === 'hidden') {
                        that.classList.remove('jqx-visibility-hidden');
                    }

                    if (newValue === 'collapsed') {
                        that.classList.add('jqx-hidden');
                    } else if (newValue === 'hidden') {
                        that.classList.add('jqx-visibility-hidden');
                    }
                }

                if (that.propertyChanged) {
                    that.propertyChanged(propertyName, oldValue, newValue);
                }
                /* Property changed logic goes here. */
            }
        }, {
            key: '_handleListeners',
            value: function _handleListeners(action) {
                var that = this;
                var tagName = that.tagName.toLowerCase();
                var listeners = that.getStaticMember('listeners');

                var processListeners = function processListeners(listeners) {
                    var _loop5 = function _loop5(listener) {
                        var path = listener.split('.');
                        var eventType = path[0];
                        var element = that.$;

                        if (path[1]) {
                            eventType = path[1];
                            element = that['$' + path[0]];

                            if (path[0] === 'document') {
                                var id = that.jqxId;
                                if (id === '') {
                                    id = Utilities.Core.toCamelCase(tagName);
                                }
                                eventType = eventType + '.' + id;
                            } else if (that.jqxId) {
                                eventType = eventType + '.' + that.jqxId + '_' + that.parents.length;
                            }
                        } else if (that.jqxId) {
                            eventType = eventType + '.' + that.jqxId;
                        }

                        var handlerName = listeners[listener];
                        var handler = function handler(event) {
                            var context = that.context;
                            that.context = that;
                            if (that[handlerName]) {
                                that[handlerName].apply(that, [event]);
                            }
                            that.context = context;
                        };

                        if (!element) {
                            return 'continue';
                        }

                        element[action](eventType, handler);
                    };

                    for (var listener in listeners) {
                        var _ret9 = _loop5(listener);

                        if (_ret9 === 'continue') continue;
                    }
                };

                processListeners(listeners);
                processListeners(that.templateListeners);
                if (JQX(that._selector) && JQX(that._selector).properties) {
                    processListeners(JQX(that._selector).listeners);
                }
            }

            /** Parses the element's template. */

        }, {
            key: 'parseTemplate',
            value: function parseTemplate() {
                var that = this;
                var template = that.template();
                var fragment = document.createDocumentFragment();

                if (templates[that.nodeName]) {
                    return templates[that.nodeName].cloneNode(true);
                }

                if (template === '') {
                    return null;
                }

                /* Create a wrapper DIV tag. */
                var tmpElement = document.createElement('div');
                fragment.appendChild(tmpElement);

                /* Fill the nodes array with the wrapper's childNodes. */
                tmpElement.innerHTML = template;
                var nodes = tmpElement.childNodes;

                /* Remove the wrapper DIV tag. */
                tmpElement.parentNode.removeChild(tmpElement);

                /* Add the nodes to the fragment. */
                for (var i = 0; i < nodes.length; i++) {
                    fragment.appendChild(nodes[i]);
                }

                templates[that.nodeName] = fragment;

                return fragment.cloneNode(true);
            }
        }, {
            key: 'applyTemplate',
            value: function applyTemplate() {
                var that = this;

                var template = that.parseTemplate();

                if (!template) {
                    return;
                }

                //const template = document.importNode(templateElement, true);

                if (!template.hasChildNodes) {
                    return;
                }

                var rootElement = template.childNodes[0];
                var map = function map(name, element) {
                    that['$' + name] = element.$ = Utilities.Extend(element);
                    that.$[name] = element;
                    element.ownerElement = that;
                };

                /* Create a content element. */
                var contentElement = rootElement;

                if (rootElement.getElementsByTagName('content').length > 0) {
                    var contentInsertionPoint = rootElement.getElementsByTagName('content')[0];
                    contentElement = contentInsertionPoint.parentNode;
                    contentElement.removeChild(contentInsertionPoint);
                } else {
                    var preudoContentElement = template.querySelectorAll('[inner-h-t-m-l]');
                    if (preudoContentElement && preudoContentElement.length > 0) {
                        contentElement = preudoContentElement[0];
                    }
                }

                that.$.template = rootElement.nodeName.toLowerCase() === 'template' ? rootElement : rootElement.querySelector('template');

                /* Build nodes map. */
                var templateNodes = template.querySelectorAll('[id]');
                if (templateNodes.length === 0) {
                    templateNodes = template.querySelectorAll('*');
                }

                map('root', rootElement);
                map('content', contentElement);

                that.$.html = that.innerHTML.toString().trim();

                for (var i = 0; i < templateNodes.length; i += 1) {
                    var templateNode = templateNodes[i];
                    if (templateNode.id === '') {
                        templateNode.id = 'child' + i;
                    }

                    map(templateNode.id, templateNode);
                    templateNode.setAttribute('jqx-id', templateNode.id);

                    if (!that.shadowRoot) {
                        templateNode.removeAttribute('id');
                    }
                }

                if (that.hasTemplateBindings !== false) {
                    that.bindings = that.getBindings(template);
                } else {
                    that.bindings = [];
                }
                that.$root.addClass('jqx-container');

                /* Move element's initial nodes to the content element. */

                while (that.childNodes.length) {
                    contentElement.appendChild(that.firstChild);
                }

                /* Append the template. */
                that.appendTemplate(template);

                if (that.$.template) {
                    var templateContainer = document.createElement('div');

                    templateContainer.classList.add('jqx-template-container');
                    that.$.templateContainer = templateContainer;
                    that.$.template.parentNode.insertBefore(templateContainer, that.$.template);
                    that.refreshTemplate();
                }
            }
        }, {
            key: 'refreshTemplate',
            value: function refreshTemplate() {
                var that = this;

                if (!that.$.templateContainer) {
                    return;
                }

                that.templateDetached(that.$.templateContainer);

                var templateContent = that.$.template.content.cloneNode(true);
                that.templateBindings = that.getBindings(templateContent);
                that.templateProperties = [];

                var fragment = document.createDocumentFragment();

                var applyBindings = function applyBindings(boundChildren, ownerElement, item) {
                    for (var childIndex in boundChildren) {
                        var child = boundChildren[childIndex];
                        var _node3 = child.node.cloneNode();

                        ownerElement.appendChild(_node3);

                        var array = [];
                        var hasArray = false;

                        if (child.data) {
                            for (var templatePropertyName in child.data) {
                                var _data = child.data[templatePropertyName];
                                var hostPropertyName = _data.name;

                                that.templateProperties[hostPropertyName] = true;
                                _node3.removeAttribute(Utilities.Core.toDash(templatePropertyName));

                                if (templatePropertyName === '*items') {
                                    array = that[hostPropertyName];
                                    hasArray = true;
                                } else if (hostPropertyName.indexOf('item.') >= 0 && item) {
                                    _data.value = item[hostPropertyName.substring('item.'.length)];
                                    _node3[templatePropertyName] = _data.value;
                                } else if (hostPropertyName.indexOf('item') >= 0 && item) {
                                    _data.value = item;
                                    _node3[templatePropertyName] = _data.value;
                                } else if (templatePropertyName === '*if') {
                                    if (hostPropertyName.indexOf('(') >= 0) {

                                        var args = hostPropertyName.substring(hostPropertyName.indexOf('('));
                                        var result = void 0;

                                        var methodName = hostPropertyName.substring(0, hostPropertyName.indexOf('('));

                                        args = args.substring(1, args.length - 1);
                                        args = args.replace(/ /ig, '');
                                        args = args.split(',');
                                        if (args.length > 0 && args[0] !== '') {
                                            var values = [];
                                            for (var i = 0; i < args.length; i++) {
                                                values.push(that[args[i]]);
                                            }

                                            result = that[methodName].apply(that, values);
                                        } else {
                                            result = that[methodName]();
                                        }

                                        if (false === result) {
                                            ownerElement.removeChild(_node3);
                                        }
                                    } else if (!that[hostPropertyName]) {
                                        ownerElement.removeChild(_node3);
                                    }
                                } else {
                                    that.updateBoundNode(_node3, child, that, hostPropertyName);
                                }
                            }
                        }

                        if (array.length > 0 || hasArray) {
                            for (var _i11 = 0; _i11 < array.length; _i11++) {
                                if (child.children) {
                                    applyBindings(child.children, _node3, array[_i11]);
                                }
                            }
                        } else {
                            if (child.children) {
                                applyBindings(child.children, _node3, item);
                            }
                        }
                    }
                };

                applyBindings(that.templateBindings.children, fragment);

                that.$.templateContainer.innerHTML = '';
                that.$.templateContainer.appendChild(fragment);

                that.templateAttached(that.$.templateContainer);
            }
        }, {
            key: 'templateAttached',
            value: function templateAttached() {}
        }, {
            key: 'templateDetached',
            value: function templateDetached() {}
        }, {
            key: 'appendTemplate',
            value: function appendTemplate(template) {
                var that = this;

                that.appendChild(template);
            }

            /** Defines the custom element's default modules. The function is called once when the element's script file is referred. */

        }, {
            key: 'defineElementModules',
            value: function defineElementModules() {
                var that = this;

                var proto = that.constructor.prototype;

                if (proto.elementName === 'BaseElement') {
                    proto.modules = that.constructor.modules;

                    var modules = proto.modules;

                    for (var i = 0; i < modules.length; i += 1) {
                        that.addModule(modules[i]);
                    }
                } else {
                    var _modules = proto.modules;

                    for (var _i12 = 0; _i12 < _modules.length; _i12 += 1) {
                        var module = _modules[_i12];
                        var _proto = module.prototype;

                        that.defineElementMethods(_proto.methodNames, _proto);
                        that.defineElementProperties(module.properties);
                    }
                }
            }
        }, {
            key: 'watch',
            value: function watch(properties, propertyChangedCallback) {
                var that = this;

                if (properties === null || propertyChangedCallback === null) {
                    that._watch = null;
                    return;
                }

                that._watch = {
                    properties: properties,
                    propertyChangedCallback: propertyChangedCallback
                };
            }
        }, {
            key: 'unwatch',
            value: function unwatch() {
                var that = this;

                that._watch = null;
            }
        }, {
            key: 'set',
            value: function set(propertyName, value, notify) {
                var that = this;

                var context = that.context;

                if (notify === true) {
                    that.context = document;
                } else {
                    that.context = that;
                }

                that[propertyName] = value;

                that.context = context;
            }
        }, {
            key: 'get',
            value: function get(propertyName) {
                var that = this;

                return that[propertyName];
            }
        }, {
            key: '_setModuleState',
            value: function _setModuleState(stateName, args) {
                var that = this;
                var statusName = 'is' + stateName.substring(0, 1).toUpperCase() + stateName.substring(1);
                var callbackName = 'on' + stateName.substring(0, 1).toUpperCase() + stateName.substring(1);

                for (var i = 0; i < that.modulesList.length; i++) {
                    var module = that.modulesList[i];

                    module[statusName] = true;

                    if (module[stateName]) {
                        module[stateName](args);
                    }

                    if (module[callbackName]) {
                        module[callbackName](args);
                    }
                }
            }

            /**
             * Adds a module to the the element. Module's methods and properties are mixed into the element's prototype.
             * @param {Object}.
             */

        }, {
            key: 'addModule',
            value: function addModule(module, subclasses) {
                var that = this;

                if (!module) {
                    return;
                }

                var modules = that.modules.slice(0);
                var proto = module.prototype;
                var baseProto = Object.getPrototypeOf(module);

                if (baseProto.name && baseProto.name !== module.name) {
                    that.addModule(baseProto);
                }

                if (!module.moduleName && module.name) {
                    module.moduleName = module.name;
                }

                if (modules.findIndex(function (currentModule) {
                    return module.moduleName === currentModule.moduleName;
                }) === -1) {
                    modules.push(module);
                }

                that.defineModule(module);
                that.defineElementMethods(proto.methodNames, proto);
                that.defineElementProperties(module.properties);

                var elementProto = that.constructor.prototype;
                elementProto.modules = modules;

                if (subclasses) {
                    for (var tagName in JQX.Elements.tagNames) {
                        var _element = JQX.Elements.tagNames[tagName];

                        var _baseProto = Object.getPrototypeOf(_element);
                        var protoChain = [];

                        while (_baseProto !== HTMLElement) {
                            protoChain.push(_baseProto.prototype);
                            _baseProto = Object.getPrototypeOf(_baseProto);
                        }

                        if (protoChain.indexOf(that) >= 0 && _element !== that) {
                            _element.prototype.addModule(module);
                        }
                    }
                }
            }

            /** Defines a module and creates its properties. */

        }, {
            key: 'defineModule',
            value: function defineModule(module) {
                if (module.isDefined) {
                    return;
                }

                module.prototype._initModule = function (element) {
                    var that = this;

                    that.ownerElement = element;
                };

                var properties = module.properties || {};
                var propertyNames = Object.keys(properties);
                var methodNames = Object.getOwnPropertyNames(module.prototype);

                module.prototype.methodNames = methodNames;

                var _loop6 = function _loop6(j) {
                    var propertyName = propertyNames[j];
                    var property = properties[propertyName];

                    Object.defineProperty(module.prototype, propertyName, {
                        configurable: false,
                        enumerable: true,
                        get: function get() {
                            var that = this;

                            if (!that.ownerElement) {
                                return property.value;
                            }

                            return that.ownerElement[propertyName];
                        },
                        set: function set(value) {
                            var that = this;

                            that.ownerElement[propertyName] = value;
                        }
                    });
                };

                for (var j = 0; j < propertyNames.length; j += 1) {
                    _loop6(j);
                }

                module.isDefined = true;
            }
        }, {
            key: 'getStaticMember',
            value: function getStaticMember(memberName, memberType) {
                var that = this;
                var element = window[namespace][that.elementName];

                var staticMember = element[memberName];

                if (!memberType) {
                    memberType = '';
                }

                var inheritedStaticMember = memberType === 'array' ? [] : memberType === 'string' ? '' : {};
                var baseProto = Object.getPrototypeOf(element);
                var protoChain = [];

                while (baseProto[memberName]) {
                    protoChain.push(baseProto[memberName]);
                    baseProto = Object.getPrototypeOf(baseProto);
                }

                for (var i = protoChain.length - 1; i >= 0; i--) {
                    if (memberType === 'array') {
                        for (var j = 0; j < protoChain[i].length; j++) {
                            if (inheritedStaticMember.indexOf(protoChain[i][j]) === -1) {
                                inheritedStaticMember.push(protoChain[i][j]);
                            }
                        }
                    } else if (memberType === 'string') {
                        if (inheritedStaticMember.indexOf(protoChain[i]) === -1) {
                            inheritedStaticMember += protoChain[i];
                        }
                    } else {
                        inheritedStaticMember = Utilities.Core.assign(inheritedStaticMember, protoChain[i]);
                    }
                }

                if (memberType === 'array') {
                    for (var _j = 0; _j < staticMember.length; _j++) {
                        if (inheritedStaticMember.indexOf(staticMember[_j]) === -1) {
                            inheritedStaticMember.push(staticMember[_j]);
                        }
                    }

                    return inheritedStaticMember;
                }

                if (memberType === 'string') {
                    if (inheritedStaticMember.indexOf(staticMember) === -1) {
                        inheritedStaticMember += staticMember;
                    }

                    return inheritedStaticMember;
                }

                return Utilities.Core.assign(inheritedStaticMember, staticMember);
            }
        }, {
            key: 'defineElementHierarchicalProperties',
            value: function defineElementHierarchicalProperties(properties, context) {
                var that = this;
                var propertyObjectsTree = [];

                var buildPropertyObjects = function buildPropertyObjects(properties) {
                    var propertyNames = Object.keys(properties);

                    for (var i = 0; i < propertyNames.length; i++) {
                        var parentPropertyName = propertyNames[i];

                        if (parentPropertyName === 'messages') {
                            continue;
                        }

                        var parentProperty = properties[parentPropertyName];
                        var propertyKeys = Object.keys(parentProperty);
                        var isPropertyObject = propertyKeys.indexOf('value') >= 0 && propertyKeys.indexOf('type') >= 0 && babelHelpers.typeof(parentProperty.value) === 'object';

                        if (parentProperty.type === 'propertyObject' || isPropertyObject) {
                            (function () {
                                var buildPropertyObject = function buildPropertyObject(parentProperty, parentPropertyName) {
                                    if (!parentProperty.value) {
                                        return;
                                    }

                                    var propertyNames = Object.keys(parentProperty.value);

                                    var _loop7 = function _loop7(j) {
                                        var propertyName = propertyNames[j];
                                        var property = parentProperty.value[propertyName];
                                        var subPropertyName = parentPropertyName + '_' + propertyName;

                                        if ((typeof property === 'undefined' ? 'undefined' : babelHelpers.typeof(property)) !== 'object' || property === null) {
                                            return 'break';
                                        }

                                        var propertyKeys = Object.keys(property);
                                        var isPropertyObject = propertyKeys.indexOf('value') >= 0 && propertyKeys.indexOf('type') >= 0;

                                        if (!isPropertyObject) {
                                            return 'break';
                                        }

                                        property.parentPropertyName = parentPropertyName;

                                        if (context) {
                                            var elementProperty = context._properties[subPropertyName];

                                            if (parentProperty.value.hasOwnProperty(propertyName)) {
                                                if (!elementProperty.isDefined) {
                                                    delete parentProperty.value[propertyName];
                                                } else {
                                                    return 'continue';
                                                }
                                            }

                                            elementProperty.isDefined = true;

                                            Object.defineProperty(parentProperty.value, propertyName, {
                                                configurable: false,
                                                enumerable: true,
                                                get: function get() {
                                                    return context._properties[subPropertyName].value;
                                                },
                                                set: function set(value) {
                                                    context.updateProperty(context, context._properties[subPropertyName], value);
                                                }
                                            });
                                        }

                                        if (!propertyObjectsTree[subPropertyName]) {
                                            propertyObjectsTree[subPropertyName] = property;
                                            propertyObjectsTree.length++;
                                        }

                                        if (property.type === 'propertyObject' || babelHelpers.typeof(property.value) === 'object' && property.type !== 'array') {
                                            if (context) {
                                                buildPropertyObject(context._properties[subPropertyName], subPropertyName);
                                            } else {
                                                buildPropertyObject(property, subPropertyName);
                                            }
                                        }
                                    };

                                    _loop8: for (var j = 0; j < propertyNames.length; j++) {
                                        var _ret12 = _loop7(j);

                                        switch (_ret12) {
                                            case 'break':
                                                break _loop8;

                                            case 'continue':
                                                continue;}
                                    }
                                };
                                buildPropertyObject(parentProperty, parentPropertyName);
                            })();
                        }
                    }
                };

                buildPropertyObjects(properties);

                if (propertyObjectsTree.length > 0 && !context) {
                    that.defineElementProperties(propertyObjectsTree);
                }
            }

            /** Defines the element properties, methods and modules. */

        }, {
            key: 'defineElement',
            value: function defineElement() {
                var that = this;
                var proto = that.constructor.prototype;
                var properties = that.getStaticMember('properties');
                var methods = Object.getOwnPropertyNames(proto);

                proto.extendedProperties = {};
                proto.boundProperties = {};
                proto.templateListeners = {};

                that.defineElementModules();
                that.defineElementMethods(methods, proto);
                that.defineElementProperties(properties);
                that.defineElementHierarchicalProperties(that.extendedProperties);

                /* Initialization of element's instance properties. */
                proto._initElement = function () {
                    var that = this;

                    var properties = proto.extendedProperties;
                    var propertyNames = Object.keys(properties);
                    var modules = that.modules;

                    that.$ = Utilities.Extend(that);
                    that.$document = $document;
                    that.jqxId = (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase();

                    if (!that.isCreated) {
                        that.modulesList = [];
                        that._properties = [];
                        if (that._beforeCreatedProperties) {
                            that._properties = that._beforeCreatedProperties;
                            delete that._beforeCreatedProperties;
                        }

                        that.detachedChildren = [];
                        that.propertyByAttributeName = [];
                    }

                    for (var i = 0; i < modules.length; i += 1) {
                        var module = modules[i];
                        var moduleInstance = new module();
                        moduleInstance._initModule(that);
                        that.modulesList.push(moduleInstance);
                    }

                    var _loop9 = function _loop9(_i13) {
                        var propertyName = propertyNames[_i13];
                        var property = properties[propertyName];
                        var defaultValue = property.value;

                        if (that._properties[propertyName]) {
                            if (that._properties[propertyName].notify !== undefined) {
                                return 'continue';
                            } else {
                                delete that._properties[propertyName];
                            }
                        }

                        if (isOldChrome && propertyName === 'innerHTML') {
                            delete that[propertyName];
                        }

                        if (window.navigator.userAgent.indexOf('PhantomJS') === -1 && that.hasOwnProperty(propertyName)) {
                            defaultValue = that[propertyName];

                            delete that[propertyName];
                        }

                        if (property.type === 'array' && defaultValue !== undefined && defaultValue !== null) {
                            defaultValue = defaultValue.slice(0);
                        }

                        if (property.type === 'object' && defaultValue !== undefined && defaultValue !== null) {
                            if (Array.isArray(defaultValue)) {
                                defaultValue = defaultValue.slice(0);
                            } else {
                                defaultValue = Object.assign({}, defaultValue);
                            }
                        }

                        that._properties[propertyName] = {
                            name: propertyName,
                            notify: property.notify,
                            allowedValues: property.allowedValues,
                            type: property.type,
                            nullable: property.nullable,
                            reflectToAttribute: property.reflectToAttribute,
                            defaultReflectToAttribute: property.defaultReflectToAttribute,
                            defaultReflectToAttributeConditions: property.defaultReflectToAttributeConditions,
                            value: defaultValue,
                            readOnly: property.readOnly,
                            defaultValue: defaultValue,
                            attributeName: property.attributeName,
                            observer: property.observer,
                            inherit: property.inherit,
                            extend: property.extend,
                            validator: property.validator
                        };

                        that.propertyByAttributeName[property.attributeName] = that._properties[propertyName];

                        if (!property.hasOwnProperty('type')) {
                            var localizedError = that.localize('propertyUnknownType', { name: propertyName });
                            that.log(localizedError);
                        }

                        if (property.type === 'any' || property.type === 'propertyObject') {
                            return 'continue';
                        }

                        var defaultValueType = Utilities.Types.getType(defaultValue);
                        if (defaultValue !== undefined && defaultValue !== null && property.type !== defaultValueType && !property.validator) {
                            if (property.type === 'object' && defaultValueType === 'array') {
                                return 'continue';
                            }

                            if (defaultValueType === 'number') {
                                var types = ['integer', 'int', 'float'];
                                var propertyIndex = types.findIndex(function (type) {
                                    return type === property.type;
                                });

                                if (propertyIndex >= 0) {
                                    return 'continue';
                                }
                            }
                            var _localizedError = that.localize('propertyInvalidValueType', { name: propertyName, actualType: defaultValueType, type: property.type });
                            that.log(_localizedError);
                        }
                    };

                    for (var _i13 = 0; _i13 < propertyNames.length; _i13 += 1) {
                        var _ret13 = _loop9(_i13);

                        if (_ret13 === 'continue') continue;
                    }

                    that.defineElementHierarchicalProperties(that._properties, that);

                    that.isCreated = true;
                };

                /* Calls the registered method. It is useful for one-time configuration. */
                proto.registered();
            }

            /**
             * Defines Element's methods. 
             * {Array} - methods.
             * {Object} - method owner's prototype.
             */

        }, {
            key: 'defineElementMethods',
            value: function defineElementMethods(methods, proto) {
                var that = this;
                var elementProto = that.constructor.prototype;

                var invokeMethod = function invokeMethod(method, methodName) {
                    var args = Array.prototype.slice.call(arguments, 2);

                    var elementMethod = function elementMethod() {
                        /* Raise an exception when the method is invoked while the element is not in Ready state. */
                        if (!this.isReady && methodName !== 'localize' && methodName !== 'importStyle' && methodName !== 'log' && methodName !== 'parseAttributes') {
                            var localizedError = this.localize('elementNotInDOM');
                            this.log(localizedError);
                        }

                        var methodContext = this;
                        for (var i = 0; i < this.modulesList.length; i++) {
                            var module = this.modulesList[i];
                            if (methodName in module) {
                                methodContext = module;
                                break;
                            }
                        }

                        var context = this.context;
                        var methodArguments = args.concat(Array.prototype.slice.call(arguments));
                        var methodReturnType = null;

                        var areTypesEqual = function areTypesEqual(typeA, typeB) {
                            if (typeA === typeB) {
                                return true;
                            }

                            if (typeA === 'number' && (typeB === 'int' || typeB === 'integer' || typeB === 'float')) {
                                return true;
                            }

                            if (typeA === 'bool' && typeB === 'boolean' || typeA === 'boolean' && typeB === 'bool') {
                                return true;
                            }

                            if (typeA === 'object' && typeB === 'any') {
                                return true;
                            }
                        };

                        if (this['methods']) {
                            var methodMetaInformation = this['methods'][methodName];

                            if (methodMetaInformation) {
                                var methodSplitParts = methodMetaInformation.split(':');

                                methodReturnType = methodSplitParts[methodSplitParts.length - 1].trim();

                                var metaArguments = methodMetaInformation.substring(1 + methodMetaInformation.indexOf('('), methodMetaInformation.lastIndexOf(')'));
                                var metaArgumentsList = [];
                                var metaArgumentsSplit = metaArguments.split(',');

                                var argument = '';
                                for (var _i14 = 0; _i14 < metaArgumentsSplit.length; _i14++) {
                                    var metaArgument = metaArgumentsSplit[_i14];

                                    argument += metaArgument;

                                    if (metaArgument.indexOf(':') >= 0) {
                                        metaArgumentsList.push(argument);
                                        argument = '';
                                    } else {
                                        argument += ',';
                                    }
                                }

                                var metaArgumentsListRequiredCount = metaArgumentsList.length;

                                for (var m = 0; m < metaArgumentsList.length; m++) {
                                    var metaArgumentString = metaArgumentsList[m].trim();
                                    var metaArgumentSplitParts = metaArgumentString.split(':');
                                    var metaArgumentName = metaArgumentSplitParts[0].split('=')[0].trim();
                                    var metaArgumentOptional = metaArgumentName.indexOf('?') >= 0;

                                    var metaArgumentNullableType = metaArgumentSplitParts[1].indexOf('?') >= 0;
                                    var metaArgumentType = metaArgumentSplitParts[1].replace(/\?/ig, '').trim();
                                    var metaArgumentTypes = metaArgumentType.split('|');

                                    var metaArgumentDefaultValue = metaArgumentSplitParts[0].split('=')[1];

                                    var callerArgumentType = Utilities.Types.getType(methodArguments[m]);

                                    if (undefined === methodArguments[m] && metaArgumentDefaultValue) {
                                        metaArgumentDefaultValue = metaArgumentDefaultValue.trim();

                                        switch (metaArgumentType[0]) {
                                            case 'date':
                                                {
                                                    var dateObjectArguments = metaArgumentDefaultValue.substring(metaArgumentDefaultValue.indexOf('(') + 1, metaArgumentDefaultValue.lastIndexOf(')'));
                                                    dateObjectArguments = dateObjectArguments.length > 0 ? dateObjectArguments.split(',').map(function (arg) {
                                                        return parseInt(arg);
                                                    }) : [];

                                                    metaArgumentDefaultValue = dateObjectArguments.length === 0 ? new Date() : new Date(dateObjectArguments[0], dateObjectArguments[1], dateObjectArguments[2]);
                                                    break;
                                                }
                                            case 'bool':
                                            case 'boolean':
                                                metaArgumentDefaultValue = metaArgumentDefaultValue === 'true' || metaArgumentDefaultValue === '1' ? true : false;
                                                break;
                                            case 'int':
                                            case 'integer':
                                                metaArgumentDefaultValue = parseInt(metaArgumentDefaultValue);
                                                break;
                                            case 'float':
                                            case 'number':
                                                metaArgumentDefaultValue = parseFloat(metaArgumentDefaultValue);
                                                break;
                                            case 'any':
                                            case 'object':
                                                metaArgumentDefaultValue = metaArgumentDefaultValue.indexOf('{') >= 0 ? JSON.parse(metaArgumentDefaultValue) : metaArgumentDefaultValue;
                                                break;
                                        }

                                        methodArguments.push(metaArgumentDefaultValue);
                                    } else if (metaArgumentOptional) {
                                        metaArgumentsListRequiredCount--;
                                    }

                                    if (metaArgumentType !== callerArgumentType && callerArgumentType) {
                                        var isInvalidValueType = true;

                                        for (var _i15 = 0; _i15 < metaArgumentTypes.length; _i15++) {
                                            if (areTypesEqual(callerArgumentType, metaArgumentTypes[_i15])) {
                                                isInvalidValueType = false;
                                                break;
                                            }
                                        }

                                        if (isInvalidValueType && !(methodArguments[m] === null && metaArgumentNullableType)) {
                                            var _localizedError2 = this.localize('methodInvalidValueType', { name: methodName, actualType: callerArgumentType, type: metaArgumentType, argumentIndex: m });
                                            this.log(_localizedError2);
                                        }
                                    }

                                    if (methodArguments.length < metaArgumentsListRequiredCount) {
                                        var _localizedError3 = this.localize('methodInvalidArgumentsCount', { name: methodName, actualArgumentsCount: methodArguments.length, argumentsCount: metaArgumentsListRequiredCount });
                                        this.log(_localizedError3);
                                    }
                                }
                            }
                        }

                        this.context = this;
                        var result = method.apply(methodContext, methodArguments);

                        if (methodReturnType) {
                            var actualReturnType = Utilities.Types.getType(result) === undefined ? 'void' : Utilities.Types.getType(result);

                            if (!areTypesEqual(actualReturnType, methodReturnType)) {
                                var _localizedError4 = this.localize('methodInvalidReturnType', { name: methodName, actualType: actualReturnType, type: methodReturnType });
                                this.log(_localizedError4);
                            }
                        }
                        this.context = context;

                        return result;
                    };

                    return elementMethod;
                };

                /* Exclude these methods. */
                var excludeMethods = ['constructor', 'ready', 'created', 'attached', 'detached', 'appendChild', 'insertBefore', 'removeChild', 'connect', 'disconnectedCallback', 'connectedCallback', 'attributeChangedCallback', 'propertyChangedHandler'];

                /* Wrap Custom Element's methods. */

                var _loop10 = function _loop10(index) {
                    var methodName = methods[index];

                    if (methodName.startsWith('_') || excludeMethods.find(function (excludeMethodName) {
                        return excludeMethodName === methodName;
                    }) !== undefined) {
                        return 'continue';
                    }

                    if (elementProto.extendedProperties[methodName]) return 'continue';

                    if (!Utilities.Types.isFunction(proto[methodName])) return 'continue';

                    elementProto[methodName] = invokeMethod(proto[methodName], methodName);
                };

                for (var index in methods) {
                    var _ret14 = _loop10(index);

                    if (_ret14 === 'continue') continue;
                }
            }

            /** Defines the custom element's properties. The function is called once when an element's script file is referred. */

        }, {
            key: 'defineElementProperties',
            value: function defineElementProperties(properties) {
                if (!properties) {
                    return;
                }

                var that = this;
                var proto = that.constructor.prototype;
                var propertyNames = Object.keys(properties);
                var defaultProperties = that.getStaticMember('properties');

                Object.assign(proto.extendedProperties, properties);

                /* Called when a property is set. Updates the property and synchronizes with the attribute. */
                that.updateProperty = function (context, property, value) {
                    var that = context;

                    if (!property || property.readOnly) {
                        return;
                    }

                    /* Raises an exception when the new value is not in the allowedValues list. */
                    if (property.allowedValues) {
                        var isValidValue = false;

                        for (var i = 0; i < property.allowedValues.length; i++) {
                            if (property.allowedValues[i] === value) {
                                isValidValue = true;
                                break;
                            }
                        }

                        if (!isValidValue) {
                            var allowedValuesString = JSON.stringify(property.allowedValues).replace(/\[|\]/gi, '').replace(',', ', ').replace(/"/gi, '\'');
                            var actualValueString = '\'' + value + '\'';
                            var localizedError = that.localize('propertyInvalidValue', { name: property.name, actualValue: actualValueString, value: allowedValuesString });

                            that.log(localizedError);
                            return;
                        }
                    }

                    var propertyName = property.name;
                    var oldValue = that._properties[propertyName].value;

                    /* Calls the property's validator, if defined. */
                    if (property.validator) {
                        if (that[property.validator]) {
                            var _context = that.context;

                            that.context = that;

                            var validatedResult = that[property.validator](oldValue, value);

                            if (validatedResult !== undefined) {
                                value = validatedResult;
                            }

                            that.context = _context;
                        }
                    }

                    if (oldValue === value) {
                        return;
                    }

                    if (that.propertyChanging) {
                        var canChangeProperty = that.propertyChanging(propertyName, oldValue, value);

                        if (canChangeProperty === false || canChangeProperty === null) {
                            return;
                        }
                    }

                    if (!property.hasOwnProperty('type')) {
                        var _localizedError5 = that.localize('propertyUnknownType', { name: propertyName });
                        that.log(_localizedError5);
                    }

                    if (property.type === 'array' && JSON.stringify(oldValue) === JSON.stringify(value)) {
                        return;
                    }

                    if (value !== undefined && value !== null && property.type !== 'any' && property.type !== 'propertyObject' && property.type !== Utilities.Types.getType(value) && !property.validator || value === null && !property.nullable) {
                        var throwError = true;

                        if (property.type === 'object' && Utilities.Types.getType(value) === 'array') {
                            throwError = false;
                        }

                        if (Utilities.Types.getType(value) === 'number') {
                            var types = ['integer', 'int', 'float'];
                            var propertyIndex = types.findIndex(function (type) {
                                return type === property.type;
                            });

                            if (propertyIndex >= 0) {
                                throwError = false;
                            }
                        }

                        if (throwError) {
                            var _localizedError6 = that.localize('propertyInvalidValueType', { name: propertyName, actualType: Utilities.Types.getType(value), type: property.type });
                            that.error(_localizedError6);
                            return;
                        }
                    }

                    property.isUpdating = true;
                    that._properties[propertyName].value = value;

                    /* Updates the element's attribute value. */
                    if (!property.isUpdatingFromAttribute && property.reflectToAttribute) {
                        that.$.setAttributeValue(property.attributeName, value, property.type);
                    }

                    /* Calls the element's propertyChangedHandler function when the element is in Ready state and the property is observed. */
                    var isReady = that.isReady && (!that.ownerElement || that.ownerElement && that.ownerElement.isReady);

                    if (isReady) {
                        if (propertyName === 'wait') {
                            if (!value && oldValue && !that.isCompleted) {
                                that.classList.remove('jqx-visibility-hidden');
                                if (that.ownerElement) {
                                    that.ownerElement.updateBoundMappedNodes();
                                }
                                that.updateBoundMappedNodes();
                                that.complete();
                            }
                        }

                        if (that.context !== that && !that.wait) {
                            /* Setting context to that prevents calling propertyChangedHandler, if the custom element's developer
                             * sets another element property within the propertyChangedHandler. 
                            */
                            var _context2 = that.context;

                            that.context = that;
                            that.propertyChangedHandler(propertyName, oldValue, value);
                            that.context = _context2;

                            /* Calls the property's observer, if defined. */
                            if (property.observer) {
                                if (that[property.observer]) {
                                    that.context = that;
                                    that[property.observer](oldValue, value);
                                    that.context = document;
                                }
                            }

                            if (that._watch && that._watch.properties.indexOf(propertyName) >= 0) {
                                that._watch.propertyChangedCallback(propertyName, oldValue, value);
                            }
                        }

                        /* Dispatch an event when property's notify member is set. */
                        var notify = property.notify || that.boundProperties[propertyName];
                        if (notify) {
                            that.$.fireEvent(property.attributeName + '-changed', { context: that.context, oldValue: oldValue, value: that[propertyName] });
                            if (that.boundProperties[propertyName]) {
                                that.updateBoundNodes(propertyName);
                            }
                        }

                        if (notify && that.templateProperties && that.templateProperties[propertyName]) {
                            that.refreshTemplate();
                        }

                        if (that.dataContextProperties) {
                            if (propertyName === 'dataContext') {
                                that.applyDataContext();
                            } else if (that.dataContextProperties[propertyName]) {
                                that.updateDataContextProperty(propertyName);
                            }
                        }
                    }
                    property.isUpdating = false;
                };

                /* Defines element's properties. */

                var _loop11 = function _loop11(i) {
                    var propertyName = propertyNames[i];
                    var property = properties[propertyName];
                    var attributeName = Utilities.Core.toDash(propertyName);
                    var type = property.type || 'any';
                    var nullable = type.indexOf('?') >= 0 || type === 'any';

                    if (nullable && type !== 'any') {
                        property.type = type.substring(0, type.length - 1);
                    }

                    property.nullable = nullable;
                    property.attributeName = attributeName.toLowerCase();
                    property.name = propertyName;
                    property.reflectToAttribute = property.reflectToAttribute !== undefined ? property.reflectToAttribute : true;

                    if (property.inherit && defaultProperties[propertyName]) {
                        property.value = defaultProperties[propertyName].value;
                    }

                    if (property.extend && defaultProperties[propertyName]) {
                        Utilities.Core.assign(property.value, defaultProperties[propertyName].value);
                    }

                    if (proto.hasOwnProperty(propertyName)) {
                        return 'continue';
                    }

                    Object.defineProperty(proto, propertyName, {
                        configurable: false,
                        enumerable: true,
                        get: function get() {
                            var that = this;

                            if (!that._properties[propertyName]) {
                                return undefined;
                            }

                            return that._properties[propertyName].value;
                        },
                        set: function set(value) {
                            var that = this;

                            that.updateProperty(that, that._properties[propertyName], value);
                        }
                    });
                };

                for (var i = 0; i < propertyNames.length; i += 1) {
                    var _ret15 = _loop11(i);

                    if (_ret15 === 'continue') continue;
                }
            }
        }, {
            key: 'classNamesMap',
            get: function get() {
                return {
                    animation: 'jqx-animate',
                    rippleAnimation: 'jqx-ripple'
                };
            }
        }, {
            key: 'hasAnimation',
            get: function get() {
                var that = this;

                if (that.animation === 'none') {
                    return false;
                }

                return true;
            }
        }, {
            key: 'hasRippleAnimation',
            get: function get() {
                var that = this;

                if (that.animation === 'none') {
                    return false;
                }

                if (that.animation === 'advanced') {
                    return true;
                }

                return false;
            }

            /**
             * Element's modules.
             *
             * @return {Array<Module>} - element's modules.
             */

        }, {
            key: 'properties',
            get: function get() {
                var that = this;

                if (!that._properties) {
                    that._properties = [];
                }

                return that._properties;
            }

            /**
             * Gets the element's parents.
             *
             * @return {Array<HTMLElement>} - element's parents.
             */

        }, {
            key: 'parents',
            get: function get() {
                var that = this;

                var matched = [],
                    current = that.parentNode;

                while (current && current.nodeType !== 9) {
                    if (current instanceof HTMLElement === true) {
                        matched.push(current);
                    }
                    current = current.parentNode;
                }
                return matched;
            }

            /**
             * Gets if the element is currently focused.
             *
             * @return {Boolean}.
             */

        }, {
            key: 'focused',
            get: function get() {
                return this.contains(document.activeElement);
            }
        }, {
            key: '_selector',
            get: function get() {
                var that = this;

                if (that.id) {
                    return '#' + that.id;
                }

                if (that.classList.length > 0) {
                    return '.' + that.classList[0];
                }
            }
        }, {
            key: 'hasStyleObserver',
            set: function set(value) {
                var that = this;

                if (that._hasStyleObserver === undefined) {
                    that._hasStyleObserver = value;
                }

                if (value) {
                    StyleObserver.watch(that);
                } else {
                    StyleObserver.unwatch(that);
                }
            },
            get: function get() {
                var that = this;

                if (that._hasStyleObserver !== undefined) {
                    return that._hasStyleObserver;
                }

                return true;
            }
        }], [{
            key: 'properties',

            /**
             * Element's properties.
             *
             * @return {Object} - element's properties.
             */
            get: function get() {
                return {
                    'animation': {
                        value: 'advanced',
                        type: 'string',
                        allowedValues: ['none', 'simple', 'advanced']
                    },
                    'unfocusable': {
                        value: false,
                        type: 'boolean'
                    },
                    'disabled': {
                        value: false,
                        type: 'boolean'
                    },
                    'dataContext': {
                        value: null,
                        reflectToAttribute: false,
                        type: 'any'
                    },
                    'messages': {
                        value: {
                            'en': {
                                'propertyUnknownType': '\'{{name}}\' property is with undefined \'type\' member!',
                                'propertyInvalidValue': 'Invalid \'{{name}}\' property value! Actual value: \'{{actualValue}}\', Expected value: \'{{value}}\'!',
                                'propertyInvalidValueType': 'Invalid \'{{name}}\' property value type! Actual type: \'{{actualType}}\', Expected type: \'{{type}}\'!',
                                'methodInvalidValueType': 'Invalid \'{{name}}\' method argument value type! Actual type: \'{{actualType}}\', Expected type: \'{{type}}\' for argument with index: \'{{argumentIndex}}\'!',
                                'methodInvalidArgumentsCount': 'Invalid \'{{name}}\' method arguments count! Actual arguments count: \'{{actualArgumentsCount}}\', Expected at least: \'{{argumentsCount}}\' argument(s)!',
                                'methodInvalidReturnType': 'Invalid \'{{name}}\' method return type! Actual type: \'{{actualType}}\', Expected type: \'{{type}}\'!',
                                'elementNotInDOM': 'Element does not exist in DOM! Please, add the element to the DOM, before invoking a method.',
                                'moduleUndefined': 'Module is undefined.',
                                'missingReference': '{{elementType}}: Missing reference to \'{{files}}\'.',
                                'htmlTemplateNotSuported': '{{elementType}}: Web Browser doesn\'t support HTMLTemplate elements.',
                                'invalidTemplate': '{{elementType}}: \'{{property}}\' property accepts a string that must match the id of an HTMLTemplate element from the DOM.'
                            }
                        },
                        reflectToAttribute: false,
                        type: 'object'
                    },
                    'readonly': {
                        value: false,
                        type: 'boolean'
                    },
                    'rightToLeft': {
                        value: false,
                        type: 'boolean'
                    },
                    'theme': {
                        value: window[namespace].Theme,
                        type: 'string'
                    },
                    'visibility': {
                        value: 'visible',
                        allowedValues: ['visible', 'collapsed', 'hidden'],
                        type: 'string'
                    },
                    'wait': {
                        value: false,
                        type: 'boolean'
                    }
                };
            }

            /**
             * Element's requires.
             *
             * @return {Object} - element's required modules.
             */

        }, {
            key: 'requires',
            get: function get() {
                return {};
            }

            /**
             * Element's listeners.
             *
             * @return {Object} - element's listeners.
             */

        }, {
            key: 'listeners',
            get: function get() {
                return {
                    'theme-changed': function themeChanged(event) {
                        this.theme = event.detail.newValue;
                    }
                };
            }
        }, {
            key: 'methods',
            get: function get() {
                return {};
            }
        }, {
            key: 'modules',
            get: function get() {
                return window[namespace].Modules;
            }
        }, {
            key: 'version',
            get: function get() {
                return window[namespace].Version;
            }
        }]);
        return BaseElement;
    }(HTMLElement);

    var customElements = [];
    var registeredCallbacks = [];
    var registeredLoadedCallbacks = [];
    var isOldChrome = false;

    var chromeAgent = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
    if (chromeAgent) {
        var chromeVersion = parseInt(chromeAgent[2], 10);
        if (chromeVersion <= 50) {
            isOldChrome = true;
        }
    }

    var connectElements = function connectElements() {
        if (document.readyState !== 'complete') {
            return;
        }

        registeredLoadedCallbacks.sort(function (element1, element2) {
            var indexA = element1.element.parents.length;
            var indexB = element2.element.parents.length;

            if (indexA < indexB) {
                return -1;
            }

            if (indexA > indexB) {
                return 1;
            }

            return 0;
        });

        for (var i = 0; i < registeredLoadedCallbacks.length; i++) {
            registeredLoadedCallbacks[i].element.isLoading = false;
            registeredLoadedCallbacks[i].callback();
        }

        registeredLoadedCallbacks = [];
        document.removeEventListener('readystatechange', connectElements);
    };

    document.addEventListener('readystatechange', connectElements);

    var BaseCustomElement = function (_BaseElement) {
        babelHelpers.inherits(BaseCustomElement, _BaseElement);
        babelHelpers.createClass(BaseCustomElement, [{
            key: 'importStyle',
            value: function importStyle(path, loadHandler) {
                var that = this;

                if (!that.shadowRoot || !path) {
                    return;
                }

                //Check if style link already exists
                var rootChildren = that.shadowRoot.children;

                for (var i = 0; i < rootChildren.length; i++) {
                    var rootChild = rootChildren[i];

                    if (rootChild instanceof HTMLLinkElement && rootChild.href === path) {
                        return;
                    }
                }

                var link = document.createElement('link');

                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = path;
                link.onload = loadHandler;

                that.shadowRoot.insertBefore(link, that.shadowRoot.firstChild);
            }
        }, {
            key: 'attributeChanged',
            value: function attributeChanged(name, oldValue, newValue) {
                if (name === 'style-url') {
                    this.styleUrl = newValue;
                }
            }
        }, {
            key: 'attributeChangedCallback',
            value: function attributeChangedCallback(name, oldValue, newValue) {
                var that = this;

                if (!that.isReady) {
                    return;
                }

                babelHelpers.get(BaseCustomElement.prototype.__proto__ || Object.getPrototypeOf(BaseCustomElement.prototype), 'attributeChangedCallback', this).call(this, name, oldValue, newValue);
            }
            /** Called when an instance of the custom element is created. */

        }, {
            key: 'styleUrl',
            get: function get() {
                return this._styleUrl;
            },
            set: function set(path) {
                this._styleUrl = path;
            }
        }, {
            key: 'enableShadowDOM',
            get: function get() {
                return window[namespace].EnableShadowDOM;
            }
        }], [{
            key: 'observedAttributes',
            get: function get() {
                var that = this;
                var observedAttributes = ['external-style'];

                for (var _propertyName2 in that.prototype.extendedProperties) {
                    var propertyConfig = that.prototype.extendedProperties[_propertyName2];

                    observedAttributes.push(propertyConfig.attributeName);
                }

                return observedAttributes;
            }
        }, {
            key: 'styleUrls',
            get: function get() {
                return ['jqx.variables.css', 'jqx.misc.css', 'jqx.common.css'];
            }
        }, {
            key: 'styles',
            get: function get() {
                return '';
            }
        }]);

        function BaseCustomElement(selector, properties) {
            babelHelpers.classCallCheck(this, BaseCustomElement);

            /*  initialization code goes here. */
            var _this4 = babelHelpers.possibleConstructorReturn(this, (BaseCustomElement.__proto__ || Object.getPrototypeOf(BaseCustomElement)).call(this));

            var that = _this4;

            if (selector) {
                var _ret18;

                if (properties) {
                    that._initProperties = properties;
                }

                var createElement = function createElement(selector) {
                    if (typeof selector === 'string' ? document.querySelector(selector) : selector) {
                        var _element2 = typeof selector === 'string' ? document.querySelector(selector) : selector;

                        if (_element2 instanceof HTMLDivElement) {
                            var customElement = document.createElement(that.tagName);

                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = undefined;

                            try {
                                for (var _iterator = _element2.attributes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                    var attribute = _step.value;

                                    customElement.setAttribute(attribute.name, _element2.getAttribute(attribute.name));
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return) {
                                        _iterator.return();
                                    }
                                } finally {
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }

                            while (_element2.childNodes.length) {
                                customElement.appendChild(_element2.firstChild);
                            }

                            if (typeof selector === 'string') {
                                customElement.id = selector.substring(1);
                            }

                            customElement._initProperties = properties;

                            if (_element2.parentNode) {
                                _element2.parentNode.replaceChild(customElement, _element2);
                            }

                            return customElement;
                        } else {
                            if (properties) {
                                var context = _element2.context;

                                _element2._initProperties = properties;

                                if (_element2.isReady) {
                                    _element2.context = _element2;

                                    var oldValues = {};
                                    var values = {};

                                    for (var _propertyName3 in properties) {
                                        oldValues[_propertyName3] = _element2[_propertyName3];
                                        values[_propertyName3] = properties[_propertyName3];
                                    }

                                    if (Object.getOwnPropertyNames(properties).length > 0) {
                                        _element2.initProperties();
                                        _element2.propertyChangedHandler(properties, oldValues, values);
                                    }

                                    _element2.context = context;
                                }
                            }
                        }

                        return _element2;
                    }
                };

                if (typeof selector === 'string') {
                    var elements = document.querySelectorAll(selector);
                    var _customElements = [];

                    if (elements.length > 1) {
                        var _ret16;

                        for (var i = 0; i < elements.length; i++) {
                            var _element3 = createElement(elements[i]);

                            _customElements.push(_element3);
                        }

                        return _ret16 = _customElements, babelHelpers.possibleConstructorReturn(_this4, _ret16);
                    }
                } else if (selector && selector.length > 0) {
                    var _elements = selector;

                    if (_elements.length > 1) {
                        var _ret17;

                        for (var _i16 = 0; _i16 < _elements.length; _i16++) {
                            var _element4 = createElement(_elements[_i16]);

                            customElements.push(_element4);
                        }

                        return _ret17 = customElements, babelHelpers.possibleConstructorReturn(_this4, _ret17);
                    }
                }

                return _ret18 = createElement(selector), babelHelpers.possibleConstructorReturn(_this4, _ret18);
            }

            that._styleUrl = '';
            // Uncomment when scopedStyle is implemented in all elements.
            if (window[namespace].EnableShadowDOM && that.enableShadowDOM) {
                that.attachShadow({ mode: 'open' });
            }

            if (that.isUtilityElement) {
                return babelHelpers.possibleConstructorReturn(_this4);
            }

            that.created();
            return _this4;
        }

        babelHelpers.createClass(BaseCustomElement, [{
            key: 'connect',
            value: function connect() {
                var that = this;

                var isReady = that.isReady;
                var templateStyle = void 0;

                if (!isReady) {
                    if (that.children.length > 0 && that.children[0] instanceof HTMLStyleElement) {
                        templateStyle = that.children[0];
                        that.removeChild(templateStyle);
                    }
                }

                if (!that.shadowRoot || isReady && that.shadowRoot) {
                    that.setup();
                }

                if (!isReady && that.shadowRoot) {
                    (function () {
                        that.wait = false;
                        that.removeAttribute('wait');

                        if (templateStyle) {
                            that.shadowRoot.insertBefore(templateStyle, that.shadowRoot.firstChild);
                        }

                        that.importStyle(that._styleUrl);

                        var styleUrls = that.getStaticMember('styleUrls', 'array');
                        var styles = that.getStaticMember('styles', 'string');

                        var loadedStyles = 0;
                        that.classList.add('jqx-element-init');

                        for (var i = 0; i < styleUrls.length; i++) {
                            that.importStyle(Utilities.Core.getScriptLocation() + window[namespace].StyleBaseUrl + styleUrls[i], function () {
                                loadedStyles++;

                                if (loadedStyles === styleUrls.length) {
                                    that.whenReady(function () {
                                        that.classList.remove('jqx-element-init');
                                    });
                                    that.setup();
                                }
                            });
                        }

                        if (styles) {
                            var scopedStyle = document.createElement('style');
                            scopedStyle.innerHTML = styles;
                            that.shadowRoot.insertBefore(scopedStyle, that.shadowRoot.firstChild);
                        }
                    })();
                }
            }
            /** Called when an instance of custom element is attached to the DOM. */

        }, {
            key: 'connectedCallback',
            value: function connectedCallback() {
                var that = this;

                if (that.isLoading || that.isUtilityElement) {
                    return;
                }

                that.classList.add('jqx-element-init');

                var updateVisibility = function updateVisibility() {
                    that.classList.remove('jqx-element-init');
                };

                if (document.readyState === 'complete' /*&& !ElementRegistry.isRegistering */) {
                        updateVisibility();
                        that.connect();
                    } else {
                    that.isLoading = true;
                    registeredLoadedCallbacks.push({
                        element: this, callback: function () {
                            if (this.isReady) {
                                return;
                            }

                            updateVisibility();
                            this.connect();
                        }.bind(that)
                    });
                }
            }

            /** Called when an instance of custom element is detached from the DOM. V0 spec. */

        }, {
            key: 'disconnectedCallback',
            value: function disconnectedCallback() {
                var that = this;

                if (!that.isAttached) {
                    return;
                }

                that.detached();
            }

            /** Called when an instance of custom element is attached to the DOM. */

        }, {
            key: 'adoptedCallback',
            value: function adoptedCallback() {
                var that = this;

                that.setup();
            }
        }, {
            key: 'appendTemplate',
            value: function appendTemplate(template) {
                var that = this;

                if (that.shadowRoot) {
                    that.shadowRoot.appendChild(template);
                } else {
                    that.appendChild(template);
                }
            }
        }]);
        return BaseCustomElement;
    }(BaseElement);

    var elementDependencies = {
        'jqx-accordion': ['jqx-accordion-item'],
        'jqx-breadcrumb': [],
        'jqx-button': [],
        'jqx-toggle-button': ['jqx-button'],
        'jqx-repeat-button': ['jqx-button'],
        'jqx-calendar': ['jqx-repeat-button', 'jqx-drop-down-list', 'jqx-tooltip'],
        'jqx-card': [],
        'jqx-carousel': ['jqx-button'],
        'jqx-chart': [],
        'jqx-check-box': ['jqx-toggle-button'],
        'jqx-chip': [],
        'jqx-color-panel': ['jqx-button'],
        'jqx-color-picker': ['jqx-drop-down-button'],
        'jqx-combo-box': ['jqx-drop-down-list'],
        'jqx-date-time-picker': ['jqx-calendar', 'jqx-time-picker'],
        'jqx-docking-layout': ['jqx-splitter', 'jqx-window', 'jqx-tabs'],
        'jqx-drop-down-button': ['jqx-button'],
        'jqx-drop-down-list': ['jqx-list-box'],
        'jqx-file-upload': ['jqx-button'],
        'jqx-filter-panel': ['jqx-list-box', 'jqx-numeric-text-box', 'jqx-menu', 'jqx-tree', 'jqx-drop-down-list', 'jqx-date-time-picker', 'jqx-calendar', 'jqx-tooltip'],
        'jqx-gauge': ['jqx-button', 'jqx-tank'],
        'jqx-grid': ['jqx-grid-cell', 'jqx-grid-column', 'jqx-grid-row', 'jqx-input', 'jqx-menu', 'jqx-filter-panel', 'jqx-pager', 'jqx-date-time-picker'],
        'jqx-grid-cell': ['jqx-grid'],
        'jqx-grid-column': ['jqx-grid'],
        'jqx-grid-row': ['jqx-grid'],
        'jqx-input': ['jqx-scroll-bar'],
        'jqx-led': ['jqx-button'],
        'jqx-list-box': ['jqx-scroll-viewer', 'jqx-list-item', 'jqx-list-items-group'],
        'jqx-list-item': ['jqx-list-box'],
        'jqx-list-items-group': ['jqx-list-box'],
        'jqx-list-menu': ['jqx-menu', 'jqx-list-menu-item', 'jqx-list-menu-items-group'],
        'jqx-list-menu-item': ['jqx-list-menu'],
        'jqx-list-menu-items-group': ['jqx-list-menu'],
        'jqx-masked-text-box': ['jqx-text-box'],
        'jqx-menu': ['jqx-scroll-viewer', 'jqx-menu-item'],
        'jqx-multiline-text-box': ['jqx-text-box'],
        'jqx-multiline-split-button': ['jqx-drop-down-button'],
        'jqx-numeric-text-box': ['jqx-button'],
        'jqx-pager': ['jqx-drop-down-list'],
        'jqx-password-text-box': ['jqx-text-box'],
        'jqx-power-button': ['jqx-button'],
        'jqx-progress-bar': ['jqx-button'],
        'jqx-radio-button': ['jqx-button', 'jqx-toggle-button'],
        'jqx-scroll-bar': [],
        'jqx-slider': ['jqx-button', 'jqx-repeat-button', 'jqx-tank'],
        'jqx-sortable': ['jqx-button'],
        'jqx-splitter': [],
        'jqx-sort-panel': ['jqx-input', 'jqx-sortable'],
        'jqx-switch-button': ['jqx-toggle-button'],
        'jqx-scroll-viewer': ['jqx-button', 'jqx-scroll-bar'],
        'jqx-table': [],
        'jqx-tabs': ['jqx-repeat-button', 'jqx-tab-item', 'jqx-tab-items-group'],
        'jqx-tab-item': ['jqx-tabs'],
        'jqx-tab-items-group': ['jqx-tabs'],
        'jqx-tank': ['jqx-button'],
        'jqx-text-box': ['jqx-drop-down-list'],
        'jqx-time-picker': [],
        'jqx-toast': [],
        'jqx-tooltip': [],
        'jqx-tree': ['jqx-menu', 'jqx-tree-item', 'jqx-tree-items-group'],
        'jqx-tree-item': ['jqx-tree'],
        'jqx-tree-items-group': ['jqx-tree'],
        'jqx-window': ['jqx-button']
        /**
         * This is a base class for registration of custom elements.
         */
    };
    var ElementRegistry = function () {
        function ElementRegistry() {
            babelHelpers.classCallCheck(this, ElementRegistry);
        }

        babelHelpers.createClass(ElementRegistry, null, [{
            key: 'register',

            /**
             * Called by each custom element to register it. 
               @param {String} - tag name.
               @param {Object} - element's object like Button, NumericTextBox, etc.
             */
            value: function register(tagName, element) {
                var proto = element.prototype;
                var elementName = Core.toCamelCase(tagName).replace(/[a-z]+/, '');

                var elementVersion = element.version || window[namespace].Version;

                if (window.customElements.get(tagName) && window.customElements.get(tagName).version === elementVersion) {
                    return;
                }

                if (window[namespace].Define && window[namespace].Define.indexOf(tagName) === -1 && tagName !== 'jqx-base-element' && tagName !== 'jqx-content-element' && tagName !== 'jqx-scroll-viewer') {

                    if (window[namespace].Defined) {
                        return;
                    }

                    //let shouldDefine = false;

                    var getAllDependencies = function getAllDependencies(tagName, dependencies) {
                        var tagNames = elementDependencies[tagName];

                        if (!dependencies) {
                            dependencies = [];
                        }

                        if (tagNames) {
                            for (var i = 0; i < tagNames.length; i++) {
                                var currentTagName = tagNames[i];

                                if (dependencies.indexOf(currentTagName) === -1) {
                                    dependencies.push(currentTagName);

                                    dependencies = getAllDependencies(currentTagName, dependencies);
                                }
                            }
                        }

                        return dependencies;
                    };

                    var tags = window[namespace].Define;
                    var newTags = tags.slice(0);

                    for (var i = 0; i < tags.length; i++) {
                        var dependencies = getAllDependencies(tags[i]);

                        for (var j = 0; j < dependencies.length; j++) {
                            if (newTags.indexOf(dependencies[j]) === -1) {
                                newTags.push(dependencies[j]);
                            }
                        }
                    }

                    window[namespace].Define = newTags;
                    window[namespace].Defined = true;

                    if (window[namespace].Define.indexOf(tagName) === -1) {
                        return;
                    }
                }

                var tmpTagName = tagName;
                elementVersion = elementVersion.split('.');

                while (window.customElements.get(tagName)) {
                    tagName = tmpTagName + '-' + elementVersion.join('.');
                    elementVersion[2] = parseInt(elementVersion[2]) + 1;
                }

                if (customElements[tagName]) {
                    return;
                }

                customElements[tagName] = window[namespace][elementName] = window[namespace.toLowerCase() + elementName] = element;
                proto.elementName = elementName;
                proto.defineElement();
                if (registeredCallbacks[tagName]) {
                    registeredCallbacks[tagName](proto);
                }

                /** Use customElements v1 spec, if it is supported. */
                window.customElements.define(tagName, element);
            }
        }, {
            key: 'registerElements',
            value: function registerElements() {
                var that = this;

                if (!that.toRegister) {
                    return;
                }

                that.isRegistering = true;

                for (var i = 0; i < that.toRegister.length; i++) {
                    var toRegisterItem = that.toRegister[i];

                    that.register(toRegisterItem.tagName, toRegisterItem.element);
                }

                that.isRegistering = false;
            }

            /**
             * Returns the element's object.
             * @param {String} - tag name.
             * @return {Object} - custom element's object.
             */

        }, {
            key: 'get',
            value: function get(tagName) {
                if (customElements[tagName]) {
                    return customElements[tagName];
                }
                return undefined;
            }

            /**
             * Determines whether the element is registered.
             * @param {String} - tag name.
             * @param {Function} - the callback function which is called when the element is registered.
             */

        }, {
            key: 'whenRegistered',
            value: function whenRegistered(tagName, callback) {
                if (!tagName) {
                    throw new Error('Syntax Error: Invalid tag name');
                }

                var that = this;
                var existingCallback = registeredCallbacks[tagName];
                var element = that.get(tagName);
                var modulesLength = element ? element.modules.length : 3;

                try {
                    if (!existingCallback && !element) {
                        registeredCallbacks[tagName] = function (proto) {
                            try {
                                callback(proto);
                            } catch (error) {
                                var errorMessage = error instanceof Error ? error.message : error.toString();

                                console.log(errorMessage);
                            }
                        };
                    } else if (!existingCallback && element) {
                        callback(element.prototype);
                        registeredCallbacks[tagName] = undefined;
                    } else if (existingCallback && !element) {
                        registeredCallbacks[tagName] = function (proto) {
                            existingCallback(proto);
                            callback(proto);
                        };
                    } else if (existingCallback && element) {
                        if (element.proto) {
                            existingCallback(element.proto);
                            callback(element.proto);
                        }

                        registeredCallbacks[tagName] = undefined;
                    }
                } catch (error) {
                    var errorMessage = error instanceof Error ? error.message : error.toString();

                    console.log(errorMessage);
                }

                if (element && modulesLength !== element.prototype.modules.length) {
                    var elements = document.querySelectorAll(tagName);

                    for (var j = 0; j < elements.length; j++) {
                        var _element5 = elements[j];

                        if (_element5.isCreated) {
                            _element5._initElement();
                        }
                    }
                }
            }
        }]);
        return ElementRegistry;
    }();

    ElementRegistry.lazyRegister = false;
    ElementRegistry.tagNames = [];

    var Observable = function () {
        function Observable(object, observables) {
            babelHelpers.classCallCheck(this, Observable);

            var that = this;

            this.name = 'observable';

            if (object) {
                Object.assign(that, object);
            }

            var proxyMethodsOf = function proxyMethodsOf(obj) {
                Object.getOwnPropertyNames(Object.getPrototypeOf(obj)).forEach(function (methodName) {
                    if (methodName === 'constructor') {
                        return true;
                    }
                    if (methodName.startsWith('_')) {
                        return true;
                    }

                    that[methodName] = obj[methodName];
                });
            };

            proxyMethodsOf(object);

            var proxy = new Proxy(that, {
                deleteProperty: function deleteProperty(target, property) {
                    delete target[property];
                    return true;
                },
                get: function get(target, property /*, receiver*/) {
                    return target[property];
                },
                set: function set(target, property, value /*, receiver*/) {
                    var oldValue = target[property];

                    if (oldValue === value) {
                        return true;
                    }

                    target[property] = value;

                    if (property === 'notifyFn' || property.startsWith('_') || property === 'canNotify') {
                        return true;
                    }

                    if (observables && observables.indexOf(property) === -1) {
                        return true;
                    }

                    if (!that.canNotify) {
                        return true;
                    }

                    that._notify({
                        target: target,
                        propertyName: property,
                        oldValue: oldValue,
                        newValue: value
                    });

                    return true;
                }
            });

            return proxy;
        }

        babelHelpers.createClass(Observable, [{
            key: '_notify',
            value: function _notify(changeArgs) {
                var that = this;

                if (!that.canNotify) {
                    return;
                }

                if (that.notifyFn) {
                    for (var i = 0; i < that.notifyFn.length; i++) {
                        that.notifyFn[i](changeArgs);
                    }
                }
            }
        }, {
            key: 'notify',
            value: function notify(notifyFn) {
                var that = this;

                if (notifyFn) {
                    if (!that.notifyFn) {
                        that.notifyFn = [];
                    }

                    that.notifyFn.push(notifyFn);
                }
            }
        }, {
            key: 'canNotify',
            get: function get() {
                var that = this;

                if (that._canNotify === undefined) {
                    that._canNotify = true;
                }

                return that._canNotify;
            },
            set: function set(value) {
                var that = this;

                that._canNotify = value;
            }
        }]);
        return Observable;
    }();

    var ObservableArray = function () {
        function ObservableArray() {
            babelHelpers.classCallCheck(this, ObservableArray);


            var that = this;

            that.name = 'observableArray';
            that.observables = arguments.length < 3 ? null : arguments[2];

            var arrayProxy = new Proxy(that, {
                deleteProperty: function deleteProperty(target, property) {
                    delete target[property];
                    return true;
                },
                apply: function apply(method, context, args) {
                    return method.apply(context, args);
                },
                get: function get(target, property /*, receiver*/) {
                    if (!target[property] && !isNaN(parseInt(property))) {
                        return that.getItem(parseInt(property));
                    }

                    return target[property];
                },
                set: function set(target, property, value /*, receiver*/) {
                    if (!target[property] && !isNaN(parseInt(property))) {
                        that.setItem(parseInt(property), value);
                        return true;
                    }

                    target[property] = value;

                    return true;
                }
            });

            that._addArgs = {
                eventName: 'change', object: arrayProxy,
                action: 'add',
                index: null,
                removed: new Array(),
                addedCount: 1
            };

            that._removeArgs = {
                eventName: 'change', object: arrayProxy,
                action: 'remove',
                index: null,
                removed: null,
                addedCount: 0
            };

            if (arguments.length >= 1 && Array.isArray(arguments[0])) {
                that._array = [];
                var source = arguments[0];

                for (var i = 0, l = source.length; i < l; i++) {
                    var item = that._getItem(that._array.length, source[i]);

                    that._array.push(item);
                }
            } else {
                that._array = Array.apply(null, arguments);
            }

            if (arguments.length === 2) {
                that.notifyFn = arguments[1];
            }

            return arrayProxy;
        }

        babelHelpers.createClass(ObservableArray, [{
            key: '_notify',
            value: function _notify(changeArgs) {
                var that = this;

                if (!that.canNotify) {
                    return;
                }

                if (that.notifyFn) {
                    that.notifyFn(changeArgs);
                }
            }
        }, {
            key: 'notify',
            value: function notify(notifyFn) {
                var that = this;

                if (notifyFn) {
                    that.notifyFn = notifyFn;
                }
            }
        }, {
            key: 'toArray',
            value: function toArray() {
                var that = this;

                return that._array;
            }
        }, {
            key: '_getItem',
            value: function _getItem(index, item) {
                var that = this;

                if (typeof item === 'string') {
                    return item;
                }

                if (typeof item === 'number') {
                    return item;
                }

                if (item === undefined) {
                    return item;
                }

                var itemProxy = new Proxy(item, {
                    deleteProperty: function deleteProperty(target, property) {
                        delete target[property];
                    },
                    set: function set(target, property, value /*, receiver*/) {
                        var oldValue = target[property];

                        target[property] = value;

                        if (!that._canNotify || target.canNotify === false) {
                            return true;
                        }

                        if (that.observables && !that.observables[property]) {
                            return true;
                        }

                        that._notify({
                            eventName: 'change',
                            object: that,
                            target: target,
                            action: 'update',
                            index: index,
                            path: index + '.' + property,
                            oldValue: oldValue,
                            newValue: value,
                            propertyName: property
                        });

                        return true;
                    }
                });

                return itemProxy;
            }
        }, {
            key: 'getItem',
            value: function getItem(index) {
                return this._array[index];
            }
        }, {
            key: 'setItem',
            value: function setItem(index, value) {
                var that = this;
                var oldValue = that._array[index];

                that._array[index] = that._getItem(index, value);

                that._notify({
                    eventName: 'change', object: this,
                    action: 'update',
                    index: index,
                    removed: [oldValue],
                    addedCount: 1
                });
            }
        }, {
            key: 'toString',
            value: function toString() {
                var that = this;

                return that._array.toString();
            }
        }, {
            key: 'toLocaleString',
            value: function toLocaleString() {
                var that = this;

                return that._array.toLocaleString();
            }
        }, {
            key: 'concat',
            value: function concat() {
                var that = this;

                that._addArgs.index = that._array.length;

                var result = that._array.concat.apply(that._array, arguments);

                return new JQX.ObservableArray(result);
            }
        }, {
            key: 'join',
            value: function join(separator) {
                var that = this;

                return that._array.join(separator);
            }
        }, {
            key: 'pop',
            value: function pop() {
                var that = this;

                that._removeArgs.index = that._array.length - 1;

                delete that[that._array.length - 1];

                var result = that._array.pop();

                that._removeArgs.removed = [result];

                that._notify(that._removeArgs);
                that._notifyLengthChange();

                return result;
            }
        }, {
            key: 'push',
            value: function push() {
                var that = this;

                that._addArgs.index = that._array.length;

                if (arguments.length === 1 && Array.isArray(arguments[0])) {
                    var source = arguments[0];

                    for (var i = 0, l = source.length; i < l; i++) {
                        var item = that._getItem(that._array.length, source[i]);

                        that._array.push(item);
                    }
                } else {
                    var _item = that._getItem(that._addArgs.index, arguments[0]);

                    that._array.push.apply(that._array, [_item]);
                }

                that._addArgs.addedCount = that._array.length - that._addArgs.index;

                that._notify(that._addArgs);
                that._notifyLengthChange();

                return that._array.length;
            }
        }, {
            key: '_notifyLengthChange',
            value: function _notifyLengthChange() {
                var that = this;

                if (!that.canNotify) {
                    return;
                }

                var lengthChangedData = that._createPropertyChangeData('length', that._array.length);

                that._notify(lengthChangedData);
            }
        }, {
            key: '_createPropertyChangeData',
            value: function _createPropertyChangeData(propertyName, value, oldValue) {
                return {
                    eventName: 'change', object: this, propertyName: propertyName, value: value, oldValue: oldValue
                };
            }
        }, {
            key: 'reverse',
            value: function reverse() {
                var that = this;

                return that._array.reverse();
            }
        }, {
            key: 'shift',
            value: function shift() {
                var that = this;
                var result = that._array.shift();

                that._removeArgs.index = 0;
                that._removeArgs.removed = [result];

                that._notify(that._removeArgs);
                that._notifyLengthChange();

                return result;
            }
        }, {
            key: 'slice',
            value: function slice(start, end) {
                var that = this;

                return that._array.slice(start, end);
            }
        }, {
            key: 'sort',
            value: function sort(compareFn) {
                var that = this;

                return that._array.sort(compareFn);
            }
        }, {
            key: 'splice',
            value: function splice(start, deleteCount, addCount) {
                var that = this;

                var length = that._array.length;
                var result = that._array.splice.apply(that._array, arguments);

                if (!addCount) {
                    that._notify({
                        eventName: 'change', object: this,
                        action: 'remove',
                        index: start,
                        removed: result,
                        addedCount: that._array.length > length ? that._array.length - length : 0
                    });
                } else {
                    that._notify({
                        eventName: 'change', object: this,
                        action: 'add',
                        index: start,
                        added: result,
                        addedCount: that._array.length > length ? that._array.length - length : 0
                    });
                }

                if (that._array.length !== length) {
                    that._notifyLengthChange();
                }

                return result;
            }
        }, {
            key: 'unshift',
            value: function unshift() {
                var that = this;

                var length = that._array.length;
                var result = that._array.unshift.apply(that._array, arguments);

                that._addArgs.index = 0;
                that._addArgs.addedCount = result - length;

                that._notify(this._addArgs);
                that._notifyLengthChange();

                return result;
            }
        }, {
            key: 'indexOf',
            value: function indexOf(searchElement, fromIndex) {
                var that = this;
                var index = fromIndex ? fromIndex : 0;

                for (var i = index, l = that._array.length; i < l; i++) {
                    if (that._array[i] === searchElement) {
                        return i;
                    }
                }
                return -1;
            }
        }, {
            key: 'lastIndexOf',
            value: function lastIndexOf(searchElement, fromIndex) {
                var that = this;

                var index = fromIndex ? fromIndex : that._array.length - 1;

                for (var i = index; i >= 0; i--) {
                    if (that._array[i] === searchElement) {
                        return i;
                    }
                }
                return -1;
            }
        }, {
            key: 'find',
            value: function find(callbackfn, thisArg) {
                var that = this;

                return that._array.find(callbackfn, thisArg);
            }
        }, {
            key: 'findIndex',
            value: function findIndex(callbackfn, thisArg) {
                var that = this;

                return that._array.findIndex(callbackfn, thisArg);
            }
        }, {
            key: 'every',
            value: function every(callbackfn, thisArg) {
                var that = this;

                return that._array.every(callbackfn, thisArg);
            }
        }, {
            key: 'some',
            value: function some(callbackfn, thisArg) {
                var that = this;

                return that._array.some(callbackfn, thisArg);
            }
        }, {
            key: 'forEach',
            value: function forEach(callbackfn, thisArg) {
                var that = this;

                that._array.forEach(callbackfn, thisArg);
            }
        }, {
            key: 'map',
            value: function map(callbackfn, thisArg) {
                var that = this;

                return that._array.map(callbackfn, thisArg);
            }
        }, {
            key: 'filter',
            value: function filter(callbackfn, thisArg) {
                var that = this;

                var filteredArray = that._array.filter(callbackfn, thisArg);

                return filteredArray;
            }
        }, {
            key: 'reduce',
            value: function reduce(callbackfn, initialValue) {
                var that = this;

                return initialValue !== undefined ? that._array.reduce(callbackfn, initialValue) : that._array.reduce(callbackfn);
            }
        }, {
            key: 'reduceRight',
            value: function reduceRight(callbackfn, initialValue) {
                var that = this;

                return initialValue !== undefined ? that._array.reduceRight(callbackfn, initialValue) : that._array.reduceRight(callbackfn);
            }
        }, {
            key: 'canNotify',
            get: function get() {
                var that = this;

                if (that._canNotify === undefined) {
                    that._canNotify = true;
                }

                return that._canNotify;
            },
            set: function set(value) {
                var that = this;

                that._canNotify = value;
            }
        }, {
            key: 'length',
            get: function get() {
                return this._array.length;
            },
            set: function set(value) {
                var that = this;

                if (Types.isNumber(value) && that._array && that._array.length !== value) {
                    that.splice(value, that._array.length - value);
                }
            }
        }]);
        return ObservableArray;
    }();

    function Init(selector, element) {
        var properties = element.properties;

        element._properties = [];

        var defineProperties = function defineProperties(properties, propertyPath) {
            var propertyNames = Object.keys(properties);

            var _loop12 = function _loop12(i) {
                var propertyName = propertyNames[i];
                var propertyValue = properties[propertyName];

                element._properties[propertyPath + propertyName] = propertyValue;

                if (Array.isArray(propertyValue)) {
                    element._properties[propertyPath + propertyName] = new ObservableArray(propertyValue, function (detail) {
                        var path = propertyName + '.' + detail.path;
                        var newValue = detail.newValue;
                        var instance = document.querySelector(selector);

                        if (instance) {
                            var pathSteps = path.split('.');
                            var _propertyValue = instance;

                            for (var _i17 = 0; _i17 < pathSteps.length; _i17++) {
                                var step = pathSteps[_i17];

                                _propertyValue = _propertyValue[step];
                            }

                            _propertyValue = newValue;
                        }
                    });

                    return 'continue';
                }

                Object.defineProperty(properties, propertyName, {
                    configurable: false,
                    enumerable: true,
                    get: function get() {
                        return element._properties[propertyPath + propertyName];
                    },
                    set: function set(value) {
                        element._properties[propertyPath + propertyName] = value;
                    }
                });

                if (propertyValue.constructor.name === 'DataAdapter') {
                    return 'continue';
                }

                if ((typeof propertyValue === 'undefined' ? 'undefined' : babelHelpers.typeof(propertyValue)) === 'object' && propertyValue && Object.keys(propertyValue).length > 0) {
                    defineProperties(propertyValue, propertyPath + propertyName + '.');
                }
            };

            for (var i = 0; i < propertyNames.length; i++) {
                var _ret20 = _loop12(i);

                if (_ret20 === 'continue') continue;
            }
        };
        defineProperties(properties, '');

        Object.defineProperty(element, 'properties', {
            configurable: false,
            enumerable: true,
            get: function get() {
                return properties;
            }
        });

        var instance = document.querySelector(selector);

        if (instance && instance.isReady) {
            for (var _property2 in properties) {
                instance[_property2] = properties[_property2];
            }
        }
    }

    var userDefinedSettings = {};

    if (window[namespace]) {
        userDefinedSettings = window[namespace];
    }

    /*
     * Defines the 'JQX' namespace.
     * @param {String} - the tag's name.
     * @param {Object} - the custom element.
     */
    window[namespace] = function (tagName, element) {
        var name = tagName;

        if (!tagName) {
            return;
        }

        if (tagName.indexOf('#') >= 0 || tagName.indexOf('.') >= 0) {
            if (data[tagName]) {
                return data[tagName];
            } else if (element) {
                data[tagName] = new element();
                Init(tagName, data[tagName]);

                return data[tagName];
            }

            return;
        }

        if (!element) {
            return;
        }

        ElementRegistry.tagNames[tagName] = element;

        if (ElementRegistry.lazyRegister) {
            if (!ElementRegistry.toRegister) {
                ElementRegistry.toRegister = [];
            }

            var elementName = Core.toCamelCase(name).replace(/[a-z]+/, '');
            window[namespace][elementName] = element;

            ElementRegistry.toRegister.push({ tagName: name, element: element });
            return;
        }

        ElementRegistry.register(name, element);
    };

    window.addEventListener('load', function () {
        var tagNames = window[namespace].Elements.tagNames;
        var customElements = [];

        for (var tagName in tagNames) {
            var customElement = tagNames[tagName];

            var elements = document.querySelectorAll('[' + tagName + ']');

            for (var j = 0; j < elements.length; j++) {
                var _element6 = elements[j];

                if (_element6 instanceof HTMLDivElement) {
                    _element6.__proto__ = customElement.prototype;
                    _element6.created();
                    _element6.connectedCallback();
                }
                _element6.classList.add('jqx-element-ready');
            }

            var name = customElement.name;

            if (name === 'Item') {
                name = 'ListItem';
            }

            elements = document.querySelectorAll('[is="' + namespace.toLocaleLowerCase() + name + '"]');

            for (var i = 0; i < elements.length; i++) {
                customElements.push(elements[i]);
            }
        }

        if (customElements.length > 0) {
            var parents = function parents(element) {
                var matched = [],
                    current = element.parentNode;

                while (current && current.nodeType !== 9) {
                    if (current instanceof HTMLElement === true) {
                        matched.push(current);
                    }
                    current = current.parentNode;
                }
                return matched;
            };

            customElements.sort(function (element1, element2) {
                var indexA = parents(element1).length;
                var indexB = parents(element2).length;

                if (indexA < indexB) {
                    return 1;
                }

                if (indexA > indexB) {
                    return -1;
                }

                return 0;
            });

            for (var _j2 = 0; _j2 < customElements.length; _j2++) {
                var _element7 = customElements[_j2];
                var _tagName = _element7.getAttribute('is');
                var _customElement = void 0;

                if (_tagName === 'jqxItem') {
                    _customElement = new window['jqxListItem'](_element7);
                } else {
                    _customElement = new window[_tagName](_element7);
                }

                _customElement.removeAttribute('is');
            }
        }
    });

    var Component = function () {
        function Component(selector, properties) {
            babelHelpers.classCallCheck(this, Component);

            var that = this;
            var name = this.constructor.name;

            var element = null;

            if (selector) {
                element = new window[name](selector, properties);
            } else {
                element = new window[name]();
                element._initProperties = properties;
            }

            that._element = element;

            return element;
        }

        babelHelpers.createClass(Component, [{
            key: 'element',
            get: function get() {
                return this._element;
            }
        }]);
        return Component;
    }();

    var App = function () {
        function App(object) {
            babelHelpers.classCallCheck(this, App);

            var that = this;

            that._id = object.id;

            if (object.id) {
                that._appRoot = document.getElementById(that._id);
            } else {
                that._id = window[namespace].Utilities.Core.createGUID();
            }

            if (object.selector) {
                that._id = window[namespace].Utilities.Core.createGUID();
                that._appRoot = document.querySelector(object.selector);
            }

            if (!that._appRoot) {
                that._appRoot = document.body;
            }

            that._appRoot.classList.add('jqx-visibility-hidden');

            var componentsSettings = {};

            if (object.render) {
                var template = object.render();
                var components = object.components;

                var prepareDOM = function prepareDOM() {
                    var fragment = document.createDocumentFragment();

                    var templateDoc = document.implementation.createDocument('http://www.w3.org/1999/xhtml', 'html', null);
                    var templateBody = document.createElementNS('http://www.w3.org/1999/xhtml', 'body');
                    var root = document.createElement('div');

                    templateDoc.documentElement.appendChild(templateBody);

                    templateBody.appendChild(root);
                    root.innerHTML = template;

                    for (var i = 0; i < components.length; i++) {
                        var component = components[i];
                        var name = component.name;
                        var tagName = Utilities.Core.toDash(name);
                        var elements = templateDoc.querySelectorAll(name);

                        component.tagName = tagName;

                        for (var j = 0; j < elements.length; j++) {
                            var _element8 = elements[j];

                            var id = _element8.getAttribute('id') || window[namespace].Utilities.Core.createGUID();
                            var hostElement = document.createElement('div');

                            hostElement.id = id;

                            root.insertBefore(hostElement, _element8);
                            componentsSettings['#' + id] = { name: name, properties: [], rendered: false };
                            _element8.parentNode.removeChild(_element8);
                        }
                    }

                    fragment.appendChild(root);

                    var appRoot = document.querySelector(object.selector);

                    if (appRoot) {
                        appRoot.appendChild(fragment);
                    }
                };

                prepareDOM();
            }

            that._template = object.template || {};
            that._data = object.data || {};

            that._components = componentsSettings;

            var init = function init() {
                that._addAttributeBindings();
                that._renderForBindings();
                that._addModelBindings();
                that._observeData();
                that.render();

                that._appRoot.classList.remove('jqx-visibility-hidden');
            };

            document.readyState === 'complete' ? init() : window.addEventListener('load', init);
        }

        babelHelpers.createClass(App, [{
            key: '_addAttributeBindings',
            value: function _addAttributeBindings(ownerElement, ownerPropertyName) {
                var that = this;
                var bindingModule = new BindingModule();
                var bindings = ownerElement ? bindingModule.getBindings(ownerElement) : bindingModule.getBindings(that._appRoot);

                if (!ownerPropertyName) {
                    ownerPropertyName = '';
                }

                var createId = function createId() {
                    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
                };

                var traverseBindings = function traverseBindings(bindings) {
                    var addChildBinding = function addChildBinding(child) {
                        if (child.data) {
                            var id = child.node.id;

                            if (!id) {
                                child.node.id = id = 'id' + createId();
                            }

                            for (var dataItem in child.data) {
                                var dataItemValue = child.data[dataItem];

                                if (dataItem === 'textContent') {
                                    if (child.node.parentNode.id) {
                                        id = child.node.parentNode.id;
                                    } else {
                                        child.node.id = '';
                                        child.node.parentNode.id = id;
                                    }
                                }

                                if (dataItemValue.isEvent) {
                                    var listener = {};

                                    listener[dataItemValue.name] = dataItemValue.value;

                                    that._addListenerBinding(id, listener);
                                } else {
                                    var binding = {};

                                    binding[dataItem] = ownerPropertyName + dataItemValue.name;

                                    that._addTemplateBinding(id, binding);
                                }
                            }
                        }
                    };

                    addChildBinding(bindings);
                    for (var index in bindings.children) {
                        var child = bindings.children[index];

                        if (child.node && child.node.getAttribute && child.node.getAttribute('jqx-for') && child.node.getAttribute('jqx-for-rendered') === null) {
                            continue;
                        }

                        addChildBinding(child);

                        if (child.children) {
                            traverseBindings(child);
                        }
                    }
                };

                traverseBindings(bindings);
            }
        }, {
            key: '_addTemplateBinding',
            value: function _addTemplateBinding(id, bind) {
                var that = this;

                if (that.template['#' + id]) {
                    if (!that.template['#' + id].bind) {
                        that.template['#' + id].bind = bind;
                    } else {
                        Object.assign(that.template['#' + id].bind, bind);
                    }
                } else {
                    that.template['#' + id] = {
                        bind: bind
                    };
                }
            }
        }, {
            key: '_addListenerBinding',
            value: function _addListenerBinding(id, listener) {
                var that = this;

                if (that.template['#' + id]) {
                    if (!that.template['#' + id].listeners) {
                        that.template['#' + id].listeners = listener;
                    } else {
                        Object.assign(that.template['#' + id].listeners, listener);
                    }
                } else {
                    that.template['#' + id] = {
                        listeners: listener
                    };
                }
            }
        }, {
            key: '_updateDataFromBooleanElement',
            value: function _updateDataFromBooleanElement(element, bind) {
                var that = this;

                var boundPropertyName = bind['checked'];
                var bindItem = that.data[boundPropertyName];

                if (element.value && element.value !== 'on') {
                    if (Array.isArray(bindItem) || bindItem.name === 'observableArray') {
                        if (element.checked) {
                            bindItem.push(element.value);
                        } else {
                            var removeIndex = bindItem.indexOf(element.value);

                            if (removeIndex >= 0) {
                                bindItem.splice(removeIndex, 1);
                            }
                        }
                    } else {
                        if (element.type !== 'radio') {
                            if (element.checked) {
                                that.data[boundPropertyName] = element.value;
                            } else {
                                that.data[boundPropertyName] = '';
                            }
                        } else if (element.checked) {
                            that.data[boundPropertyName] = element.value;
                        }
                    }
                } else {
                    that.data[boundPropertyName] = element.checked;
                }
            }
        }, {
            key: '_updateDataFromNativeElement',
            value: function _updateDataFromNativeElement(element, bind) {
                var that = this;

                if (element.tagName === 'SELECT') {
                    element.addEventListener('change', function () {
                        var boundPropertyName = bind['value'];
                        var dataItem = that.data[boundPropertyName];

                        element.__updating = true;

                        if (Array.isArray(dataItem) || dataItem.name === 'observableArray') {
                            dataItem = new ObservableArray();

                            if (element.selectedOptions) {
                                for (var i = 0; i < element.selectedOptions.length; i++) {
                                    var option = element.selectedOptions[i];

                                    dataItem.push(option.value);
                                }
                            }

                            that.data[boundPropertyName] = dataItem;
                        } else {
                            that.data[boundPropertyName] = element.value;
                        }

                        element.__updating = false;
                    });
                }

                if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                    element.addEventListener('change', function () {
                        element.__updating = true;

                        if (_isBoolean) {
                            that._updateDataFromBooleanElement(element, bind);
                        } else {
                            that.data['value'] = element.value;
                        }

                        element.__updating = false;
                    });

                    var _isBoolean = element.type === 'checkbox' || element.type === 'radio';

                    if (!_isBoolean) {
                        element.addEventListener('keyup', function () {
                            var boundPropertyName = bind['value'];

                            that.data[boundPropertyName] = element.value;
                        });
                    }
                }
            }
        }, {
            key: '_addModelBindings',
            value: function _addModelBindings(ownerElement) {
                var that = this;

                var elements = ownerElement ? ownerElement.querySelectorAll('[jqx-model]') : that._appRoot.querySelectorAll('[jqx-model]');

                for (var i = 0; i < elements.length; i++) {
                    var _element9 = elements[i];
                    var bind = {
                        value: _element9.getAttribute('jqx-model')
                    };

                    if (_element9.type === 'list') {
                        bind = {
                            selectedValues: _element9.getAttribute('jqx-model')
                        };
                    }

                    if (_element9.type === 'checkbox' || _element9.type === 'radio') {
                        bind = {
                            checked: _element9.getAttribute('jqx-model')
                        };
                    }

                    if (!_element9.id) {
                        _element9.id = 'id' + JQX.Utilities.Core.createGUID().replace(/-/ig, '');
                    }

                    that._updateDataFromNativeElement(_element9, bind);
                    that._addTemplateBinding(_element9.id, bind);
                }
            }
        }, {
            key: '_renderForBindings',
            value: function _renderForBindings(invokeRender) {
                var that = this;

                var elements = that._appRoot.querySelectorAll('[jqx-for]');

                for (var i = 0; i < elements.length; i++) {
                    var _element10 = elements[i];
                    var dataName = _element10.getAttribute('jqx-for');
                    var array = that.data[dataName];

                    if (!_element10.id) {
                        _element10.id = 'id' + JQX.Utilities.Core.createGUID().replace(/-/ig, '');
                    }

                    _element10.setAttribute('jqx-for-rendered', '');

                    var selfRepeat = _element10.getAttribute('jqx-for-self') !== null;
                    var toRemove = !selfRepeat ? _element10.querySelectorAll('.jqx-for-item-' + _element10.id) : _element10.parentNode.querySelectorAll('.jqx-for-item-' + _element10.id);

                    for (var r = 0; r < toRemove.length; r++) {
                        if (that.template[toRemove[r].id]) {
                            delete that.template[toRemove[r].id];
                        }

                        toRemove[r].remove();
                    }

                    var _node4 = selfRepeat ? _element10 : _element10.firstElementChild;
                    var fragment = document.createDocumentFragment();

                    for (var j = 0; j < array.length; j++) {
                        var clonedNode = _node4.cloneNode(true);

                        clonedNode.style.display = '';

                        clonedNode.id = _element10.id + '_' + j;
                        clonedNode.classList.add('jqx-for-item');
                        clonedNode.classList.add('jqx-for-item-' + _element10.id);

                        clonedNode.removeAttribute('jqx-for');
                        fragment.appendChild(clonedNode);
                    }

                    _node4.style.display = 'none';

                    if (!selfRepeat) {
                        _element10.appendChild(fragment);
                    } else {
                        _element10.parentNode.insertBefore(fragment, _element10.nextSibling);
                    }

                    var children = that._appRoot.querySelectorAll('.jqx-for-item-' + _element10.id);

                    for (var _j3 = 0; _j3 < children.length; _j3++) {
                        var childNode = children[_j3];

                        that._addAttributeBindings(childNode, dataName + '.' + _j3 + '.');
                    }
                }

                if (invokeRender && elements.length > 0) {
                    that.render();
                }
            }
        }, {
            key: 'notify',
            value: function notify(notifyFn) {
                var that = this;

                that.notifyFn = notifyFn;
            }
        }, {
            key: '_notify',
            value: function _notify(changes) {
                var that = this;

                if (changes.propertyName === 'length') {
                    return;
                }

                if (that.notifyFn) {
                    that.notifyFn(changes);
                }

                var dataPropertyName = changes.propertyName;
                if (changes.object) {
                    dataPropertyName = changes.object.propertyName;
                }

                for (var selector in that.template) {
                    var item = that.template[selector];

                    var elementProperty = null;

                    for (var _property3 in item.bind) {
                        if (typeof item.bind[_property3] === 'function') {
                            continue;
                        }

                        if (item.bind[_property3].indexOf(dataPropertyName) >= 0) {
                            elementProperty = _property3;
                            break;
                        }
                    }

                    if (!elementProperty) {
                        continue;
                    }

                    that._setPropertyFromData(item, elementProperty);
                }

                that._renderForBindings(true);
            }
        }, {
            key: '_observeData',
            value: function _observeData() {
                var that = this;

                that._data = new window[namespace].Observable(that._data);
                that._data.canNotify = false;
                that._data.notify(that._notify.bind(that));

                for (var dataItem in that.data) {
                    if (typeof that.data[dataItem] === 'function') {
                        continue;
                    }

                    if (dataItem.startsWith('_') || dataItem === 'notifyFn' || dataItem === 'canNotify' || dataItem === 'name') {
                        continue;
                    }

                    var dataItemValue = that.data[dataItem];

                    if (Array.isArray(dataItemValue)) {
                        that.data[dataItem] = new JQX.ObservableArray(that.data[dataItem]);
                        that.data[dataItem].canNotify = false;
                        that.data[dataItem].notify(that._notify.bind(that));
                        that.data[dataItem].canNotify = true;
                        that.data[dataItem].propertyName = dataItem;
                    } else if ((typeof dataItemValue === 'undefined' ? 'undefined' : babelHelpers.typeof(dataItemValue)) === 'object' && dataItemValue.constructor === JQX.DataAdapter) {
                        that.data[dataItem].propertyName = dataItem;
                    } else if ((typeof dataItemValue === 'undefined' ? 'undefined' : babelHelpers.typeof(dataItemValue)) === 'object') {
                        that.data[dataItem] = new JQX.Observable(that.data[dataItem]);
                        that.data[dataItem].canNotify = false;
                        that.data[dataItem].notify(that._notify.bind(that));
                        that.data[dataItem].canNotify = true;
                        that.data[dataItem].propertyName = dataItem;
                    }
                }

                that._data.canNotify = true;
            }
        }, {
            key: '_setPropertyFromData',
            value: function _setPropertyFromData(item, propertyName) {
                var that = this;

                if (item.element.__updating || !item.bind) {
                    return;
                }

                var boundPropertyName = item.bind[propertyName];

                if (typeof boundPropertyName === 'function') {
                    return;
                }

                var boundArray = boundPropertyName ? boundPropertyName.split('.') : [];

                var dataItem = that.data;

                for (var i = 0; i < boundArray.length; i++) {
                    var name = boundArray[i];

                    if (typeof dataItem === 'string') {
                        break;
                    }

                    if (undefined === dataItem[name]) {
                        break;
                    }

                    dataItem = dataItem[name];
                }

                if (item.bind.computed) {
                    var computedObject = { item: item, name: boundPropertyName, value: dataItem };

                    item.bind.computed(computedObject);

                    if (computedObject.value !== dataItem) {
                        dataItem = computedObject.value;
                    }
                }

                item.element.__updatingProperties = true;
                if (boundPropertyName && dataItem !== undefined) {
                    if (dataItem.name === 'observableArray') {
                        if (item.element.type === 'checkbox') {
                            item.element[propertyName] = dataItem.indexOf(item.element.value) >= 0;
                        } else {
                            item.element[propertyName] = dataItem.toArray().slice(0);
                        }
                    } else if (item.element.type === 'radio') {
                        if (item.element.value === dataItem) {
                            item.element[propertyName] = true;
                        } else {
                            item.element[propertyName] = false;
                        }
                    } else {
                        item.element[propertyName] = dataItem;
                    }

                    if (that._components[item.selector] && !that._components[item.selector].rendered) {
                        that._components[item.selector].properties[propertyName] = dataItem;
                    }
                } else if (item.properties) {
                    item.element[propertyName] = item.properties[propertyName];

                    if (that._components[item.selector] && !that._components[item.selector].rendered) {
                        that._components[item.selector].properties[propertyName] = item.properties[propertyName];
                    }
                }

                item.element.__updatingProperties = false;
            }
        }, {
            key: 'render',
            value: function render() {
                var that = this;

                var _loop13 = function _loop13(selector) {
                    var item = that.template[selector];
                    var element = item.element ? item.element : document.querySelector(selector);
                    var properties = item.properties;
                    var listeners = item.listeners;
                    var bind = item.bind;

                    if (!element) {
                        return 'continue';
                    }

                    item.selector = selector;
                    item.element = element;

                    if (!element._properties) {
                        element._properties = [];
                    }

                    for (var _propertyName4 in properties) {
                        var _property4 = element._properties ? element._properties[_propertyName4] : null;

                        if (_property4) {
                            _property4.notify = true;
                        }

                        that._setPropertyFromData(item, _propertyName4);
                    }

                    for (var _propertyName5 in bind) {
                        var _property5 = element._properties ? element._properties[_propertyName5] : null;

                        if (_property5) {
                            _property5.notify = true;
                        }

                        that._setPropertyFromData(item, _propertyName5);
                    }

                    if (that._components && that._components[selector] && that._components[selector].rendered === false) {
                        var component = that._components[selector];

                        item.element = component.instance = new window[component.name](selector, component.properties);

                        component.rendered = true;
                    }

                    var handleListeners = function handleListeners(type) {
                        var element = item.element;

                        var _loop14 = function _loop14(listenerName) {
                            if (!element.$) {
                                element.$ = JQX.Utilities.Extend(element);
                            }

                            element.$[type](listenerName, function (event) {
                                var dataHandlerName = listeners[listenerName];

                                if (that.data[dataHandlerName]) {
                                    that.data[dataHandlerName](event);
                                }
                            });
                        };

                        for (var listenerName in listeners) {
                            _loop14(listenerName);
                        }

                        var _loop15 = function _loop15(_propertyName6) {
                            var property = element._properties ? element._properties[_propertyName6] : null;

                            if (property) {
                                var eventHandler = function eventHandler(event) {
                                    if (element.__updatingProperties) {
                                        return;
                                    }

                                    element.__updating = true;

                                    var toggleRadioButtonUpdates = function toggleRadioButtonUpdates(update) {
                                        if (element.type === 'radio') {
                                            var radioButtons = element.parentNode.querySelectorAll('[type="radio"]');

                                            for (var i = 0; i < radioButtons.length; i++) {
                                                radioButtons[i].__updating = update;
                                            }
                                        }
                                    };

                                    toggleRadioButtonUpdates(true);

                                    var boundPropertyName = bind[_propertyName6];

                                    if (element.type === 'radio' || element.type === 'toggle' || element.type === 'checkbox') {
                                        that._updateDataFromBooleanElement(element, bind);
                                    } else {
                                        var setValue = function setValue(obj, path, value) {
                                            var i;
                                            for (i = 0; i < path.length - 1; i++) {
                                                obj = obj[path[i]];
                                            }
                                            obj[path[i]] = value;
                                        };

                                        setValue(that.data, boundPropertyName.split('.'), event.detail.value);
                                    }

                                    element.__updating = false;
                                    toggleRadioButtonUpdates(false);
                                };

                                if (element.type === 'textarea') {
                                    element.$[type]('input.keyup', function (event) {
                                        var customEvent = new CustomEvent('keyup', { detail: { originalEvent: event, value: element.$.input.value } });

                                        eventHandler(customEvent);
                                    });
                                }

                                element.$[type](property.attributeName + '-changed', function (event) {
                                    eventHandler(event);
                                });
                            } else {
                                //
                            }
                        };

                        for (var _propertyName6 in bind) {
                            _loop15(_propertyName6);
                        }
                    };

                    handleListeners('unlisten');
                    handleListeners('listen');

                    element.onAttached = function () {
                        handleListeners('listen');
                    };

                    element.onDetached = function () {
                        handleListeners('unlisten');
                    };
                };

                for (var selector in that.template) {
                    var _ret21 = _loop13(selector);

                    if (_ret21 === 'continue') continue;
                }
            }
        }, {
            key: 'template',
            get: function get() {
                return this._template;
            },
            set: function set(value) {
                this._template = value;
                this.render();
            }
        }, {
            key: 'id',
            get: function get() {
                return this._id;
            },
            set: function set(value) {
                this._id = value;
            }
        }, {
            key: 'data',
            get: function get() {
                return this._data;
            },
            set: function set(value) {
                var that = this;

                that._data = value;
                that._observeData();
                that.render();
            }
        }]);
        return App;
    }();

    Object.assign(window[namespace], {
        Elements: ElementRegistry,
        Modules: [ErrorModule, LocalizationModule, BindingModule],
        BaseElement: BaseCustomElement,
        Utilities: Utilities,
        Import: Import,
        ObservableArray: ObservableArray,
        Observable: Observable,
        App: App,
        Component: Component,
        Define: userDefinedSettings.Define || null,
        Theme: userDefinedSettings.Theme || '',
        EnableShadowDOM: false,
        //    EnableShadowDOM: /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor),
        BaseUrl: './',
        StyleBaseUrl: '/styles/default/scoped/',
        Version: Version

    });

    var theme = window[namespace].Theme;

    Object.defineProperty(window[namespace], 'Theme', {
        configurable: false,
        enumerable: true,
        get: function get() {
            return theme;
        },
        set: function set(value) {
            var oldValue = theme;

            theme = value;

            $document.fireEvent('theme-changed', {
                oldValue: oldValue,
                newValue: value
            }, {
                bubbles: true,
                cancelable: true
            });
        }
    });

    window[namespace]('jqx-base-element', window[namespace].BaseElement);
    /**
    * Content element.
    */
    window[namespace]('jqx-content-element', function (_window$namespace$Bas) {
        babelHelpers.inherits(ContentElement, _window$namespace$Bas);

        function ContentElement() {
            babelHelpers.classCallCheck(this, ContentElement);
            return babelHelpers.possibleConstructorReturn(this, (ContentElement.__proto__ || Object.getPrototypeOf(ContentElement)).apply(this, arguments));
        }

        babelHelpers.createClass(ContentElement, [{
            key: 'template',


            /** Content Element's template. */
            value: function template() {
                return '<div inner-h-t-m-l=\'[[innerHTML]]\'></div>';
            }
        }, {
            key: 'ready',
            value: function ready() {
                babelHelpers.get(ContentElement.prototype.__proto__ || Object.getPrototypeOf(ContentElement.prototype), 'ready', this).call(this);

                var that = this;
                that.applyContent();
            }
        }, {
            key: 'clearContent',
            value: function clearContent() {
                var that = this;

                while (that.$.content.firstChild) {
                    that.$.content.removeChild(that.$.content.firstChild);
                }
            }
        }, {
            key: 'applyContent',
            value: function applyContent() {
                var that = this;

                if (that.content === undefined) {
                    that.content = that.$.content;
                    return;
                }

                if (that.content === '' || that.content === null) {
                    that.clearContent();
                    return;
                }

                if (that.content instanceof HTMLElement) {
                    that.clearContent();
                    that.$.content.appendChild(that.content);
                    return;
                }

                var fragment = document.createDocumentFragment();

                /* Create a wrapper DIV tag. */
                var tmpElement = document.createElement('div');
                fragment.appendChild(tmpElement);

                /* Fill the nodes array with the wrapper's childNodes. */
                if (that.content instanceof HTMLElement) {
                    tmpElement.appendChild(that.content);
                } else {
                    tmpElement.innerHTML = that.content;
                }

                var nodes = Array.from(tmpElement.childNodes);

                /* Remove the wrapper DIV tag. */
                tmpElement.parentNode.removeChild(tmpElement);

                for (var i = 0; i < nodes.length; i++) {
                    fragment.appendChild(nodes[i]);
                }

                that.clearContent();
                that.$.content.appendChild(fragment);
            }
        }, {
            key: 'propertyChangedHandler',
            value: function propertyChangedHandler(propertyName, oldValue, newValue) {
                babelHelpers.get(ContentElement.prototype.__proto__ || Object.getPrototypeOf(ContentElement.prototype), 'propertyChangedHandler', this).call(this, propertyName, oldValue, newValue);

                var that = this;

                if (oldValue === newValue) {
                    return;
                }

                if (propertyName === 'innerHTML') {
                    that.content = newValue;
                    that.applyContent();
                    that.innerHTML = that.content = Utilities.Core.html(that.$.content);
                }

                if (propertyName === 'content') {
                    that.applyContent();
                }
            }
        }], [{
            key: 'properties',
            get: function get() {
                return {
                    'content': {
                        type: 'any',
                        reflectToAttribute: false
                    },
                    'innerHTML': {
                        type: 'string',
                        reflectToAttribute: false
                    }
                };
            }
        }]);
        return ContentElement;
    }(window[namespace].BaseElement));

    window[namespace]('jqx-scroll-viewer', function (_window$namespace$Con) {
        babelHelpers.inherits(ScrollViewer, _window$namespace$Con);

        function ScrollViewer() {
            babelHelpers.classCallCheck(this, ScrollViewer);
            return babelHelpers.possibleConstructorReturn(this, (ScrollViewer.__proto__ || Object.getPrototypeOf(ScrollViewer)).apply(this, arguments));
        }

        babelHelpers.createClass(ScrollViewer, [{
            key: 'template',


            /** ScrollViewer Element's template. */
            value: function template() {
                return '<div id="container" class="jqx-container">\n                    <div id="scrollViewerContainer" class ="jqx-scroll-viewer-container">\n                      <div id="scrollViewerContentContainer" inner-h-t-m-l=\'[[innerHTML]]\' class ="jqx-scroll-viewer-content-container">\n                          <content></content>\n                      </div>\n                    </div>\n                    <jqx-scroll-bar id="verticalScrollBar" animation="[[animation]]" disabled="[[disabled]]" orientation="vertical"></jqx-scroll-bar>\n                    <jqx-scroll-bar id="horizontalScrollBar" animation="[[animation]]" disabled="[[disabled]]"></jqx-scroll-bar>\n                </div>';
            }
        }, {
            key: 'appendChild',
            value: function appendChild(node) {
                var that = this;

                if (!node) {
                    return;
                }

                if (!that.isCompleted || node.classList && node.classList.contains('jqx-resize-trigger-container')) {
                    var args = Array.prototype.slice.call(arguments, 2);
                    return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
                }

                that.$.scrollViewerContentContainer.appendChild(node);
            }
        }, {
            key: 'removeChild',
            value: function removeChild(node) {
                var that = this;

                if (!node) {
                    return;
                }

                if (!that.isCompleted || node.classList && node.classList.contains('jqx-resize-trigger-container')) {
                    var args = Array.prototype.slice.call(arguments, 2);
                    return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
                }

                that.$.scrollViewerContentContainer.removeChild(node);
            }
        }, {
            key: 'removeAll',
            value: function removeAll() {
                var that = this;

                if (that.isCompleted) {
                    that.$.scrollViewerContentContainer.innerHTML = '';
                }
            }
        }, {
            key: '_horizontalScrollbarHandler',
            value: function _horizontalScrollbarHandler(event) {
                var that = this;

                that.$.scrollViewerContentContainer.style.left = -that.scrollLeft + 'px';

                event.stopPropagation();

                if (that.onHorizontalChange) {
                    that.onHorizontalChange(event);
                }
            }
        }, {
            key: '_verticalScrollbarHandler',
            value: function _verticalScrollbarHandler(event) {
                var that = this;

                that.$.scrollViewerContentContainer.style.top = -that.scrollTop + 'px';

                event.stopPropagation();

                if (that.onVerticalChange) {
                    that.onVerticalChange(event);
                }
            }
        }, {
            key: '_mouseWheelHandler',
            value: function _mouseWheelHandler(event) {
                var that = this;

                if (that.disabled || !that.computedHorizontalScrollBarVisibility && !that.computedVerticalScrollBarVisibility) {
                    return;
                }

                if (that.computedVerticalScrollBarVisibility) {
                    event.stopPropagation();
                    event.preventDefault();

                    if (that.scrollHeight > 0) {
                        that.scrollTo(that.scrollTop + that._getScrollCoefficient(event, that.offsetHeight));
                    }
                } else if (that.computedHorizontalScrollBarVisibility) {
                    event.stopPropagation();
                    event.preventDefault();

                    if (that.scrollWidth > 0) {
                        that.scrollTo(undefined, that.scrollLeft + that._getScrollCoefficient(event, that.offsetWidth));
                    }
                }
            }
        }, {
            key: '_getScrollCoefficient',
            value: function _getScrollCoefficient(event, defaultCoefficient) {
                var deltaMode = event.deltaMode,
                    absoluteDeltaY = Math.abs(event.deltaY);
                var coefficient = void 0;

                if (deltaMode === 0) {
                    // DOM_DELTA_PIXEL
                    if (absoluteDeltaY < 100 / 3) {
                        // trackpad
                        coefficient = absoluteDeltaY;
                    } else {
                        coefficient = defaultCoefficient;
                    }
                } else if (deltaMode === 1) {
                    // DOM_DELTA_LINE (Firefox only)
                    if (absoluteDeltaY < 1) {
                        // trackpad
                        coefficient = absoluteDeltaY * (100 / 3);
                    } else {
                        coefficient = defaultCoefficient;
                    }
                } else if (deltaMode === 2) {
                    // DOM_DELTA_PAGE (when "Mouse Properties" -> "Wheel" -> "Vertical Scrolling" -> "One screen at a time" is selected in Windows settings)
                    coefficient = defaultCoefficient;
                }

                return event.deltaY < 0 ? -coefficient : coefficient;
            }
        }, {
            key: 'applyContent',
            value: function applyContent() {
                var that = this;

                babelHelpers.get(ScrollViewer.prototype.__proto__ || Object.getPrototypeOf(ScrollViewer.prototype), 'applyContent', this).call(this);

                that.refresh();
            }
        }, {
            key: 'scrollTo',
            value: function scrollTo(top, left) {
                var that = this;

                if (!that._scrollView) {
                    return;
                }

                if (top !== undefined) {
                    that._scrollView.scrollTo(top);
                }

                if (left !== undefined) {
                    that._scrollView.scrollTo(left, false);
                }
            }
        }, {
            key: 'refreshScrollBarsVisibility',
            value: function refreshScrollBarsVisibility() {
                var that = this;

                if (!that._scrollView) {
                    return;
                }

                that._scrollView.hScrollBar.disabled = that.disabled;
                that._scrollView.vScrollBar.disabled = that.disabled;

                if (that.horizontalScrollBarVisibility === 'disabled') {
                    that._scrollView.hScrollBar.disabled = true;
                }

                if (that.verticalScrollBarVisibility === 'disabled') {
                    that._scrollView.vScrollBar.disabled = true;
                }

                if (that.scrollWidth > 0) {
                    that._scrollView.hScrollBar.$.removeClass('jqx-hidden');
                } else if (that.horizontalScrollBarVisibility !== 'visible') {
                    that._scrollView.hScrollBar.$.addClass('jqx-hidden');
                }

                if (that.scrollHeight > 0) {
                    that._scrollView.vScrollBar.$.removeClass('jqx-hidden');
                } else if (that.verticalScrollBarVisibility !== 'visible') {
                    that._scrollView.vScrollBar.$.addClass('jqx-hidden');
                }

                if (that.horizontalScrollBarVisibility === 'hidden') {
                    that._scrollView.hScrollBar.$.addClass('jqx-hidden');
                }

                if (that.verticalScrollBarVisibility === 'hidden') {
                    that._scrollView.vScrollBar.$.addClass('jqx-hidden');
                }

                if (that.horizontalScrollBarVisibility === 'visible') {
                    that._scrollView.hScrollBar.$.removeClass('jqx-hidden');
                }

                if (that.verticalScrollBarVisibility === 'visible') {
                    that._scrollView.vScrollBar.$.removeClass('jqx-hidden');

                    if (!that.disabled) {
                        that._scrollView.vScrollBar.disabled = that.scrollHeight <= 0;
                    }
                }

                if (that.computedHorizontalScrollBarVisibility && that.computedVerticalScrollBarVisibility) {
                    that._scrollView.hScrollBar.$.addClass('bottom-corner');
                    that._scrollView.vScrollBar.$.addClass('bottom-corner');
                } else {
                    that._scrollView.hScrollBar.$.removeClass('bottom-corner');
                    that._scrollView.vScrollBar.$.removeClass('bottom-corner');
                }
            }
        }, {
            key: 'ready',
            value: function ready() {
                babelHelpers.get(ScrollViewer.prototype.__proto__ || Object.getPrototypeOf(ScrollViewer.prototype), 'ready', this).call(this);

                var that = this;

                that._scrollView = new JQX.Utilities.Scroll(that, that.$.horizontalScrollBar, that.$.verticalScrollBar);

                that.refresh();
            }
        }, {
            key: 'refresh',
            value: function refresh() {
                var that = this;

                function getScrollWidth() {
                    var scrollWidth = that.$.scrollViewerContentContainer.offsetWidth - that.$.scrollViewerContainer.offsetWidth;

                    if (scrollWidth > 0 && that.horizontalScrollBarVisibility !== 'hidden' || that.horizontalScrollBarVisibility === 'visible') {
                        that.$.scrollViewerContainer.classList.add('hscroll');
                    } else {
                        that.$.scrollViewerContainer.classList.remove('hscroll');
                    }

                    return scrollWidth;
                }

                function getScrollHeight() {
                    var scrollHeight = void 0;

                    //NOTE: Safari has an issue where it rounds the parent's height to the lowest integer number ignoring the decimal part
                    if (JQX.Utilities.Core.Browser.Safari) {
                        var contentContainerHeight = that.$.scrollViewerContentContainer.getBoundingClientRect().height,
                            containerHeight = that.$.scrollViewerContainer.getBoundingClientRect().height;

                        if (contentContainerHeight && containerHeight) {
                            scrollHeight = parseInt(contentContainerHeight) - parseInt(containerHeight);
                        }
                    } else {
                        scrollHeight = that.$.scrollViewerContentContainer.offsetHeight - that.$.scrollViewerContainer.offsetHeight;
                    }

                    if (scrollHeight > 0 && that.verticalScrollBarVisibility !== 'hidden' || that.verticalScrollBarVisibility === 'visible') {
                        that.$.scrollViewerContainer.classList.add('vscroll');
                    } else {
                        that.$.scrollViewerContainer.classList.remove('vscroll');
                    }

                    return scrollHeight;
                }

                if (!that.$.scrollViewerContentContainer) {
                    return;
                }

                //Caching the size's before they are re-calculated. Used to check if width/height of the container have changed.
                var initialWidth = that.scrollWidth,
                    initialHeight = that.scrollHeight;

                that.scrollWidth = getScrollWidth();
                that.scrollHeight = getScrollHeight();

                //double check in case vScroll has become hidden and hScroll visibility should be checked 
                if (!that.scrollHeight || initialHeight !== that.scrollHeight) {
                    that.scrollWidth = getScrollWidth();
                }

                //doble check in case hScroll has become hidden and vScroll visibility should be checked
                if (!that.scrollWidth || initialWidth !== that.scrollWidth) {
                    that.scrollHeight = getScrollHeight();
                }

                if (that.computedVerticalScrollBarVisibility) {
                    that.scrollHeight += that._scrollView.hScrollBar.offsetHeight;
                }

                if (that.computedHorizontalScrollBarVisibility) {
                    that.scrollWidth += that._scrollView.vScrollBar.offsetWidth;
                }
            }
        }, {
            key: 'attached',
            value: function attached() {
                var that = this;

                babelHelpers.get(ScrollViewer.prototype.__proto__ || Object.getPrototypeOf(ScrollViewer.prototype), 'attached', this).call(this);

                if (!that._scrollView) {
                    that._scrollView = new JQX.Utilities.Scroll(that, that.$.horizontalScrollBar, that.$.verticalScrollBar);
                }
            }
        }, {
            key: 'detached',
            value: function detached() {
                var that = this;

                babelHelpers.get(ScrollViewer.prototype.__proto__ || Object.getPrototypeOf(ScrollViewer.prototype), 'detached', this).call(this);

                if (that._scrollView) {
                    that._scrollView.unlisten();
                    delete that._scrollView;
                }
            }
        }, {
            key: 'propertyChangedHandler',
            value: function propertyChangedHandler(propertyName, oldValue, newValue) {
                var that = this;

                babelHelpers.get(ScrollViewer.prototype.__proto__ || Object.getPrototypeOf(ScrollViewer.prototype), 'propertyChangedHandler', this).call(this, propertyName, oldValue, newValue);
                that.refresh();
            }
        }, {
            key: 'enableShadowDOM',
            get: function get() {
                return false;
            }
        }, {
            key: 'computedHorizontalScrollBarVisibility',
            get: function get() {
                var that = this;

                if (that._scrollView && that._scrollView.hScrollBar) {
                    return !that._scrollView.hScrollBar.$.hasClass('jqx-hidden');
                }

                return null;
            }
        }, {
            key: 'computedVerticalScrollBarVisibility',
            get: function get() {
                var that = this;

                if (that._scrollView && that._scrollView.vScrollBar) {
                    return !that._scrollView.vScrollBar.$.hasClass('jqx-hidden');
                }

                return null;
            }
        }, {
            key: 'scrollWidth',
            get: function get() {
                var that = this;

                if (that._scrollView && that._scrollView.hScrollBar) {
                    if (that._scrollView.hScrollBar.max === 1 && that.horizontalScrollBarVisibility === 'visible') {
                        return 0;
                    }

                    return that._scrollView.hScrollBar.max;
                }

                return -1;
            },
            set: function set(value) {
                var that = this;

                if (value < 0) {
                    value = 0;
                }

                if (that._scrollView && that._scrollView.hScrollBar) {
                    if (value === 0 && that.horizontalScrollBarVisibility === 'visible') {
                        that._scrollView.hScrollBar.max = 0;
                    } else {
                        that._scrollView.hScrollBar.max = value;
                    }

                    that.refreshScrollBarsVisibility();
                }
            }
        }, {
            key: 'scrollHeight',
            get: function get() {
                var that = this;

                if (that._scrollView && that._scrollView.vScrollBar) {
                    if (that._scrollView.vScrollBar.max === 1 && that.verticalScrollBarVisibility === 'visible') {
                        return 0;
                    }

                    return that._scrollView.vScrollBar.max;
                }

                return 0;
            },
            set: function set(value) {
                var that = this;

                if (value < 0) {
                    value = 0;
                }

                if (that._scrollView && that._scrollView.vScrollBar) {
                    if (value === 0 && that.verticalScrollBarVisibility === 'visible') {
                        that._scrollView.vScrollBar.max = 1;
                    } else {
                        that._scrollView.vScrollBar.max = value;
                    }

                    that.refreshScrollBarsVisibility();
                }
            }
        }, {
            key: 'scrollLeft',
            get: function get() {
                var that = this;

                if (that._scrollView && that._scrollView.hScrollBar) {
                    return that._scrollView.hScrollBar.value;
                }

                return 0;
            },
            set: function set(value) {
                var that = this;

                if (value < 0) {
                    value = 0;
                }

                if (that._scrollView && that._scrollView.hScrollBar) {
                    that._scrollView.hScrollBar.value = value;
                }
            }
        }, {
            key: 'scrollTop',
            get: function get() {
                var that = this;

                if (that._scrollView && that._scrollView.vScrollBar) {
                    return that._scrollView.vScrollBar.value;
                }

                return 0;
            },
            set: function set(value) {
                var that = this;

                if (value < 0) {
                    value = 0;
                }

                if (that._scrollView && that._scrollView.vScrollBar) {
                    that._scrollView.vScrollBar.value = value;
                }
            }
        }], [{
            key: 'properties',
            get: function get() {
                return {
                    'horizontalScrollBarVisibility': {
                        type: 'string',
                        value: 'auto',
                        allowedValues: ['auto', 'disabled', 'hidden', 'visible']
                    },
                    'verticalScrollBarVisibility': {
                        type: 'string',
                        value: 'auto',
                        allowedValues: ['auto', 'disabled', 'hidden', 'visible']
                    }
                };
            }
        }, {
            key: 'listeners',
            get: function get() {
                return {
                    'horizontalScrollBar.change': '_horizontalScrollbarHandler',
                    'verticalScrollBar.change': '_verticalScrollbarHandler',
                    'wheel': '_mouseWheelHandler'
                };
            }
        }]);
        return ScrollViewer;
    }(window[namespace].ContentElement));

    window[namespace].Utilities.Assign('PositionDetection', function () {
        function PositionDetection(context, dropDown, defaultParent, closeMethod) {
            babelHelpers.classCallCheck(this, PositionDetection);

            var that = this;

            if (dropDown) {
                var id = 'dropDown' + Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);

                dropDown.id = id;
                context.setAttribute('aria-controls', id);
            }
            that.context = context;
            that.dropDown = dropDown;
            that.defaultParent = defaultParent;
            that.closeMethod = closeMethod;
        }

        /**
         * Checks Element's position inside the document
         */


        babelHelpers.createClass(PositionDetection, [{
            key: 'handleAutoPositioning',
            value: function handleAutoPositioning() {
                var positionDetection = this,
                    that = positionDetection.context;

                if (that.dropDownPosition !== 'auto' || that.disabled) {
                    return;
                }

                // eslint-disable-next-line
                var requestAnimFrame = function () {
                    return window.requestAnimationFrame;
                }();
                var start = Date.now(),
                    animationFrame = void 0;

                function loop() {
                    animationFrame = requestAnimFrame(loop);

                    //Cancel condition.
                    if (that.dropDownPosition !== 'auto' || that.disabled || that.parentElement === null) {
                        cancelAnimationFrame(animationFrame);
                    }

                    var current = Date.now();

                    if (current - start >= 200) {
                        positionDetection.scrollHandler();
                        start = Date.now();
                    }
                }

                return animationFrame = requestAnimFrame(loop);
            }

            /**
             * Checks window bounds and repositions the listbox popup
             */

        }, {
            key: 'checkBrowserBounds',
            value: function checkBrowserBounds(direction) {
                var that = this.context;

                if (that.dropDownPosition !== 'auto' || that.disabled) {
                    return;
                }

                switch (direction) {
                    case 'vertically':
                        this.checkBrowserBoundsVertically();
                        break;
                    case 'horizontally':
                        this.checkBrowserBoundsHorizontally();
                        break;
                    default:
                        this.checkBrowserBoundsVertically();
                        this.checkBrowserBoundsHorizontally();
                        break;
                }
            }

            /**
             * Check browser bounds Horizontally
             */

        }, {
            key: 'checkBrowserBoundsHorizontally',
            value: function checkBrowserBoundsHorizontally() {
                var that = this.context,
                    dropDown = this.dropDown;
                var isParentChanged = void 0,
                    vScrollBar = 0;

                //if vertical scrollbar is visible
                if (!Core.isMobile && window.innerWidth !== document.documentElement.clientWidth) {
                    vScrollBar = window.innerWidth - document.documentElement.clientWidth;
                }

                if (that._dropDownParent !== null) {
                    isParentChanged = true;
                } else {
                    dropDown.style.left = '';
                }

                var windowWidth = window.innerWidth - vScrollBar;
                var currentOffsetLeft = that.getBoundingClientRect().left;

                //Left side check - Not Tested
                if (currentOffsetLeft < 0) {
                    dropDown.style.left = (isParentChanged ? 0 : Math.abs(currentOffsetLeft)) + 'px';
                    currentOffsetLeft = parseFloat(dropDown.style.left);
                }

                //Right side check
                if (currentOffsetLeft + dropDown.offsetWidth > windowWidth) {
                    var newOffset = currentOffsetLeft - Math.abs(windowWidth - currentOffsetLeft - dropDown.offsetWidth),
                        viewPortHorizontalOffset = Math.max(0, document.documentElement.scrollWidth - (window.innerWidth + document.documentElement.scrollLeft - vScrollBar));

                    dropDown.style.left = (isParentChanged ? newOffset : Math.max(0, newOffset - currentOffsetLeft) - viewPortHorizontalOffset) + 'px';

                    //if vertical scrollbar has become hidden
                    if (window.innerWidth === document.documentElement.clientWidth) {
                        dropDown.style.left = parseFloat(dropDown.style.left) + vScrollBar + 'px';
                    }

                    //if the dropDownList is in another container different from the listBox's
                    if (isParentChanged && window.innerHeight === document.documentElement.clientHeight) {
                        this.positionDropDown(true);
                    }
                }

                //TODO: What if there's no space to the left nor the right ?
            }

            /**
             * Check browser bounds Vertically
             */

        }, {
            key: 'checkBrowserBoundsVertically',
            value: function checkBrowserBoundsVertically(elementCoordinates) {
                var that = this.context,
                    dropDown = this.dropDown,
                    oldDropDownListPosition = that._dropDownListPosition;

                if (!elementCoordinates) {
                    elementCoordinates = that.getBoundingClientRect();
                }

                if (elementCoordinates.height === 0) {
                    return;
                }

                if (document.documentElement.clientHeight - Math.abs(elementCoordinates.top + elementCoordinates.height + dropDown.offsetHeight) >= 0) {
                    that._dropDownListPosition = 'bottom';
                } else if (elementCoordinates.top - dropDown.offsetHeight >= 0) {
                    that._dropDownListPosition = 'top';
                } else {
                    //What if there's no space above or under, place over ?
                    that._dropDownListPosition = 'overlay-center';
                    // Solution: Maybe reduce the height ?
                }

                this.updatePositionAttribute(oldDropDownListPosition, that._dropDownListPosition);
            }

            /**
             * Handles the scrolling
             */

        }, {
            key: 'scrollHandler',
            value: function scrollHandler() {
                var that = this.context;

                if (!that.parentElement) {
                    return;
                }

                var rect = that.getBoundingClientRect();

                if (rect.top === that._positionTop) {
                    return;
                }

                var oldDropDownListPosition = that._dropDownListPosition;

                this.checkBrowserBoundsVertically(rect);

                if (that._dropDownListPosition !== oldDropDownListPosition) {
                    this.positionDropDown();
                }

                that._positionTop = rect.top;
            }
        }, {
            key: 'getDropDownParent',
            value: function getDropDownParent(init) {
                var that = this.context,
                    dropDown = this.dropDown;
                var dropDownAppendTo = that.dropDownAppendTo;

                that._positionedParent = null;

                if (dropDownAppendTo === null) {
                    that._dropDownParent = null;
                } else if (dropDownAppendTo === 'body' || dropDownAppendTo === document.body) {
                    that._dropDownParent = document.body;
                } else if (dropDownAppendTo instanceof HTMLElement) {
                    that._dropDownParent = dropDownAppendTo;
                } else if (typeof dropDownAppendTo === 'string') {
                    dropDownAppendTo = document.getElementById(dropDownAppendTo);

                    if (dropDownAppendTo instanceof HTMLElement) {
                        that._dropDownParent = dropDownAppendTo;
                    } else {
                        that.dropDownAppendTo = null;
                        that._dropDownParent = null;
                    }
                } else {
                    that.dropDownAppendTo = null;
                    that._dropDownParent = null;
                }

                var container = that._dropDownParent;

                if (container === null) {
                    return;
                }

                while (window.getComputedStyle(container).position === 'static' && container !== document.body) {
                    container = container.parentElement;
                }

                if (container === document.body) {
                    that._positionedParent = null;
                } else {
                    that._positionedParent = container;
                }

                if (!dropDown) {
                    return;
                }

                dropDown.setAttribute('animation', that.animation);

                if (that.theme !== '') {
                    dropDown.$.addClass(that.theme);
                }

                if (init) {
                    that._dropDownParent.appendChild(dropDown);
                    dropDown.$.addClass('jqx-drop-down-repositioned');
                }

                if (that.detachedChildren.indexOf(dropDown) === -1) {
                    that.detachedChildren.push(dropDown);
                }
            }
        }, {
            key: 'dropDownAppendToChangedHandler',
            value: function dropDownAppendToChangedHandler() {
                var that = this.context,
                    dropDown = this.dropDown,
                    oldDropDownParent = that._dropDownParent;

                this.getDropDownParent();

                if (that._dropDownParent === oldDropDownParent) {
                    return;
                }

                that[this.closeMethod]();

                ['left', 'top', 'font-size', 'font-family', 'font-style', 'font-weight'].forEach(function (styleName) {
                    return dropDown.style[styleName] = null;
                });

                if (that._dropDownParent === null) {
                    this.defaultParent.appendChild(dropDown);
                    dropDown.$.removeClass('jqx-drop-down-repositioned');
                } else {
                    that._dropDownParent.appendChild(dropDown);
                    dropDown.$.addClass('jqx-drop-down-repositioned');
                }
            }
        }, {
            key: 'dropDownPositionChangedHandler',
            value: function dropDownPositionChangedHandler() {
                var that = this;

                that.dropDown.style.transition = 'none';
                that.context[that.closeMethod]();
                that.setDropDownPosition();
                that.handleAutoPositioning();
            }
        }, {
            key: 'dropDownAttached',
            value: function dropDownAttached(callback) {
                var that = this.context;

                if (that._dropDownParent === null) {
                    return;
                }

                that._dropDownParent.appendChild(this.dropDown);
                this.handleAutoPositioning();

                if (callback) {
                    that[callback]();
                }
            }
        }, {
            key: 'dropDownDetached',
            value: function dropDownDetached() {
                var that = this.context;

                if (that._dropDownParent !== null && document.body.contains(this.dropDown) && document.body.contains(that._dropDownParent)) {
                    that._dropDownParent.removeChild(this.dropDown);
                }
            }

            /**
             * Set the drop down position property.
             * @param {any} value
             */

        }, {
            key: 'setDropDownPosition',
            value: function setDropDownPosition() {
                var that = this.context,
                    value = that.dropDownPosition,
                    oldDropDownListPosition = that._dropDownListPosition;

                if (value === 'auto') {
                    this.checkBrowserBounds();
                } else {
                    that._dropDownListPosition = value;
                }

                this.updatePositionAttribute(oldDropDownListPosition, that._dropDownListPosition);
            }
        }, {
            key: 'updatePositionAttribute',
            value: function updatePositionAttribute(oldPosition, newPosition) {
                var that = this.context,
                    dropDown = this.dropDown;

                if (that.$.dropDownButton && !that.$.dropDownButton.hasAttribute(newPosition)) {
                    that.$.dropDownButton.removeAttribute(oldPosition);
                    that.$.dropDownButton.setAttribute(newPosition, '');
                }

                if (!dropDown.hasAttribute(newPosition)) {
                    dropDown.style.transition = 'none';
                    dropDown.removeAttribute(oldPosition);
                    dropDown.setAttribute(newPosition, '');
                    requestAnimationFrame(function () {
                        dropDown.style.transition = null;
                    });
                }
            }

            /**
             * Calculates the new position of the popup afer it's parent has been changed.
             */

        }, {
            key: 'positionDropDown',
            value: function positionDropDown(vertically) {
                var that = this.context,
                    dropDown = this.dropDown;

                if (!that.opened || that._dropDownParent === null) {
                    return;
                }

                var coordinates = that.getBoundingClientRect();
                var left = void 0,
                    top = void 0;

                if (this.customPositionDropDown) {
                    var customCoordinates = this.customPositionDropDown(coordinates);

                    left = customCoordinates.left;
                    top = customCoordinates.top;
                } else {
                    left = coordinates.left;
                    top = coordinates.top;

                    switch (that._dropDownListPosition) {
                        case 'bottom':
                            top += that.$.container.offsetHeight - 1; // 1 is the min border-width. Doesn't matter if it's bigger.
                            break;
                        case 'center-bottom':
                            top += that.$.container.offsetHeight - 1;
                            left += that.offsetWidth - dropDown.offsetWidth / 2;
                            break;
                        case 'center-top':
                            top -= dropDown.offsetHeight - 1;
                            left += that.offsetWidth - dropDown.offsetWidth / 2;
                            break;
                        case 'top':
                            top -= dropDown.offsetHeight - 1;
                            break;
                        case 'overlay-bottom':
                            break;
                        case 'overlay-center':
                            top -= dropDown.offsetHeight / 2 - that.offsetHeight / 2;
                            break;
                        case 'overlay-top':
                            top -= dropDown.offsetHeight - that.offsetHeight;
                            break;
                    }
                }

                var dropDownOffset = this.getDropDownOffset();

                dropDown.style.top = top + dropDownOffset.y + 'px';

                if (vertically) {
                    return;
                }

                dropDown.style.left = left + dropDownOffset.x + 'px';
            }
        }, {
            key: 'getDropDownOffset',
            value: function getDropDownOffset() {
                var positionedParent = this.context._positionedParent;
                var xOffset = void 0,
                    yOffset = void 0;

                if (positionedParent) {
                    var parentRect = positionedParent.getBoundingClientRect();

                    xOffset = -parentRect.left;
                    yOffset = -parentRect.top;
                } else {
                    xOffset = window.pageXOffset;
                    yOffset = window.pageYOffset;
                }

                return {
                    x: xOffset, y: yOffset
                };
            }

            /**
             * Places dropdown overlay.
             */

        }, {
            key: 'placeOverlay',
            value: function placeOverlay() {
                var that = this.context;

                if (!that.dropDownOverlay || that._overlay) {
                    return;
                }

                var overlay = document.createElement('div');

                overlay.classList.add('jqx-drop-down-overlay');
                overlay.style.width = document.documentElement.scrollWidth + 'px';
                overlay.style.height = document.documentElement.scrollHeight + 'px';

                document.body.appendChild(overlay);
                that._overlay = overlay;
            }

            /**
             * Removes dropdown overlay.
             */

        }, {
            key: 'removeOverlay',
            value: function removeOverlay(onClose) {
                var positionDetection = this,
                    that = positionDetection.context;

                function check() {
                    if (positionDetection.dropDown.getBoundingClientRect().height > 0) {
                        requestAnimationFrame(check);
                    } else {
                        document.body.removeChild(that._overlay);
                        delete that._overlay;
                    }
                }

                if (that._overlay) {
                    if (that.hasAnimation && onClose) {
                        requestAnimationFrame(check);
                    } else {
                        document.body.removeChild(that._overlay);
                        delete that._overlay;
                    }
                }
            }
        }]);
        return PositionDetection;
    }());
})();