'use strict';

// Draw class
JQX.Utilities.Assign('Draw', function () {
    function Draw(host, renderEngine) {
        babelHelpers.classCallCheck(this, Draw);

        var that = this;

        that.host = host;
        that.renderEngine = renderEngine || '';

        that.refresh();

        var functions = ['clear', 'removeElement', 'attr', 'getAttr', 'line', 'circle', 'rect', 'path', 'pieslice', 'pieSlicePath', 'text', 'measureText'];

        for (var i in functions) {
            that._addFn(JQX.Utilities.Draw.prototype, functions[i]);
        }
    }

    babelHelpers.createClass(Draw, [{
        key: '_addFn',
        value: function _addFn(target, name) {
            if (target[name]) return;

            target[name] = function () {
                return this.renderer[name].apply(this.renderer, arguments);
            };
        }
    }, {
        key: '_initRenderer',
        value: function _initRenderer(host) {
            return this.createRenderer(this, host);
        }
    }, {
        key: '_internalRefresh',
        value: function _internalRefresh() {
            var self = this;

            if (!self.renderer) {
                self.host.innerHTML = '';
                self._initRenderer(self.host);
            }

            // validate visiblity
            if (window.getComputedStyle(self.host).display === 'none') {
                return;
            }

            var renderer = self.renderer;
            if (!renderer) return;

            var rect = renderer.getRect();

            self._render({ x: 1, y: 1, width: rect.width, height: rect.height });
        }
    }, {
        key: '_render',
        value: function _render(rect) {
            this._plotRect = rect;
        }

        // Public API

    }, {
        key: 'refresh',
        value: function refresh() {
            this._internalRefresh();
        }
    }, {
        key: 'getSize',
        value: function getSize() {
            var rect = this._plotRect;
            return { width: rect.width, height: rect.height };
        }
    }, {
        key: 'toGreyScale',
        value: function toGreyScale(color) {
            if (color.indexOf('#') === -1) return color;

            var rgb = this.cssToRgb(color);
            rgb[0] = rgb[1] = rgb[2] = Math.round(0.3 * rgb[0] + 0.59 * rgb[1] + 0.11 * rgb[2]);
            var hex = this.rgbToHex(rgb[0], rgb[1], rgb[2]);
            return '#' + hex[0] + hex[1] + hex[2];
        }
    }, {
        key: 'decToHex',
        value: function decToHex(dec) {
            return dec.toString(16);
        }
    }, {
        key: 'hexToDec',
        value: function hexToDec(hex) {
            return parseInt(hex, 16);
        }
    }, {
        key: 'rgbToHex',
        value: function rgbToHex(r, g, b) {
            return [this.decToHex(r), this.decToHex(g), this.decToHex(b)];
        }
    }, {
        key: 'hexToRgb',
        value: function hexToRgb(h, e, x) {
            return [this.hexToDec(h), this.hexToDec(e), this.hexToDec(x)];
        }
    }, {
        key: 'cssToRgb',
        value: function cssToRgb(color) {
            if (color.indexOf('rgb') <= -1) {
                return this.hexToRgb(color.substring(1, 3), color.substring(3, 5), color.substring(5, 7));
            }
            return color.substring(4, color.length - 1).split(',');
        }
    }, {
        key: 'hslToRgb',
        value: function hslToRgb(hsl) {
            var r = void 0,
                g = void 0,
                b = void 0;
            var h = parseFloat(hsl[0]);
            var s = parseFloat(hsl[1]);
            var l = parseFloat(hsl[2]);

            if (s === 0) {
                r = g = b = l;
            } else {
                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = this.hueToRgb(p, q, h + 1 / 3);
                g = this.hueToRgb(p, q, h);
                b = this.hueToRgb(p, q, h - 1 / 3);
            }
            return [r * 255, g * 255, b * 255];
        }
    }, {
        key: 'hueToRgb',
        value: function hueToRgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;

            if (t < 1 / 6) return p + (q - p) * 6 * t;else if (t < 1 / 2) return q;else if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;

            return p;
        }
    }, {
        key: 'rgbToHsl',
        value: function rgbToHsl(rgb) {
            var r = parseFloat(rgb[0]) / 255;
            var g = parseFloat(rgb[1]) / 255;
            var b = parseFloat(rgb[2]) / 255;

            var max = Math.max(r, g, b),
                min = Math.min(r, g, b);
            var h = void 0,
                s = void 0,
                l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                var diff = max - min;
                s = l > 0.5 ? diff / (2 - max - min) : diff / (max + min);
                switch (max) {
                    case r:
                        h = (g - b) / diff + (g < b ? 6 : 0);break;
                    case g:
                        h = (b - r) / diff + 2;break;
                    case b:
                        h = (r - g) / diff + 4;break;
                }
                h /= 6;
            }

            return [h, s, l];
        }
    }, {
        key: 'swap',
        value: function swap(x, y) {
            var tmp = x;
            x = y;
            y = tmp;
        }
    }, {
        key: 'getNum',
        value: function getNum(arr) {
            if (arr.constructor !== Array) {
                if (isNaN(arr)) return 0;
            } else {
                for (var i = 0; i < arr.length; i++) {
                    if (!isNaN(arr[i])) return arr[i];
                }
            }

            return 0;
        }
    }, {
        key: '_ptRotate',
        value: function _ptRotate(x, y, cx, cy, angle) {
            var radius = Math.sqrt(Math.pow(Math.abs(x - cx), 2) + Math.pow(Math.abs(y - cy), 2));
            var currAngle = Math.asin((x - cx) / radius);
            var newAngle = currAngle + angle;

            x = cx + Math.cos(newAngle) * radius;
            y = cy + Math.sin(newAngle) * radius;

            return { x: x, y: y };
        }
    }, {
        key: 'log',
        value: function log(val, base) {
            return Math.log(val) / (base ? Math.log(base) : 1);
        }
    }, {
        key: '_mod',
        value: function _mod(a, b) {
            var min = Math.abs(a > b ? b : a);
            var scale = 1;
            if (min !== 0) {
                while (min * scale < 100) {
                    scale *= 10;
                }
            }

            a = a * scale;
            b = b * scale;

            return a % b / scale;
        }
    }, {
        key: 'createRenderer',
        value: function createRenderer(widgetInstance, host) {
            var self = widgetInstance;
            var renderer = self.renderer = null;

            if (document.createElementNS && self.renderEngine !== 'HTML5') {
                renderer = new JQX.Utilities.SvgRenderer(this);
            }

            if (renderer === null && (self.renderEngine === 'HTML5' || self.renderEngine === undefined)) {
                renderer = new JQX.Utilities.HTML5Renderer(this);
            }

            renderer.init(host);
            self.renderer = renderer;

            return renderer;
        }
    }, {
        key: 'getByPriority',
        value: function getByPriority(arr) {
            var value = undefined;
            for (var i = 0; i < arr.length; i++) {
                var current = arr[i];

                if (current !== undefined && current !== null && current !== '') {
                    value = current;
                    break;
                }
            }

            return value;
        }
    }, {
        key: 'get',
        value: function get(array, index, key) {
            return key !== undefined ? array[index][key] : array[index];
        }
    }, {
        key: 'min',
        value: function min(array, key) {
            var min = NaN;
            for (var i = 0; i < array.length; i++) {
                var val = this.get(array, i, key);

                if (isNaN(min) || val < min) min = val;
            }

            return min;
        }
    }, {
        key: 'max',
        value: function max(array, key) {
            var max = NaN;
            for (var i = 0; i < array.length; i++) {
                var val = this.get(array, i, key);

                if (isNaN(max) || val > max) max = val;
            }

            return max;
        }
    }, {
        key: 'sum',
        value: function sum(array, key) {
            var sum = 0;
            for (var i = 0; i < array.length; i++) {
                var val = this.get(array, i, key);
                if (!isNaN(val)) sum += val;
            }

            return sum;
        }
    }, {
        key: 'count',
        value: function count(array, key) {
            var count = 0;
            for (var i = 0; i < array.length; i++) {
                var val = this.get(array, i, key);
                if (!isNaN(val)) count++;
            }

            return count;
        }
    }, {
        key: 'avg',
        value: function avg(array, key) {
            return this.sum(array, key) / Math.max(1, this.count(array, key));
        }
    }, {
        key: 'filter',
        value: function filter(array, fn) {
            if (!fn) return array;

            var out = [];
            for (var i = 0; i < array.length; i++) {
                if (fn(array[i])) out.push(array[i]);
            }return out;
        }
    }, {
        key: 'scale',
        value: function scale(val, range, scale_range, params) {
            if (isNaN(val)) return NaN;

            if (val < Math.min(range.min, range.max) || val > Math.max(range.min, range.max)) {
                if (!params || params['ignore_range'] !== true) return NaN;
            }

            var outVal = NaN;

            var percent = 1;
            if (range.type === undefined || range.type !== 'logarithmic') {
                var denom = Math.abs(range.max - range.min);
                if (!denom) denom = 1;
                percent = Math.abs(val - Math.min(range.min, range.max)) / denom;
            } else if (range.type === 'logarithmic') {
                var logBase = range.base;
                if (isNaN(logBase)) logBase = 10;

                var min = Math.min(range.min, range.max);
                if (min <= 0) min = 1;

                var max = Math.max(range.min, range.max);
                if (max <= 0) max = 1;

                var maxPow = this.log(max, logBase);
                max = Math.pow(logBase, maxPow);

                var minPow = this.log(min, logBase);
                min = Math.pow(logBase, minPow);

                var valPow = this.log(val, logBase);

                percent = Math.abs(valPow - minPow) / (maxPow - minPow);
            }

            if (scale_range.type === 'logarithmic') {
                var _logBase = scale_range.base;
                if (isNaN(_logBase)) _logBase = 10;

                var _maxPow = this.log(scale_range.max, _logBase),
                    _minPow = this.log(scale_range.min, _logBase);

                if (scale_range.flip) percent = 1 - percent;

                var _valPow = Math.min(_minPow, _maxPow) + percent * Math.abs(_maxPow - _minPow);
                outVal = Math.pow(_logBase, _valPow);
            } else {
                outVal = Math.min(scale_range.min, scale_range.max) + percent * Math.abs(scale_range.max - scale_range.min);

                if (scale_range.flip) outVal = Math.max(scale_range.min, scale_range.max) - outVal + scale_range.min;
            }

            return outVal;
        }
    }, {
        key: 'axis',
        value: function axis(min, max, preferedCount) {
            if (preferedCount <= 1) return [max, min];

            if (isNaN(preferedCount) || preferedCount < 2) preferedCount = 2;

            var decimalPlaces = 0;
            while (Math.round(min) !== min && Math.round(max) !== max && decimalPlaces < 10) {
                min *= 10;
                max *= 10;
                decimalPlaces++;
            }

            var preferedIntSize = (max - min) / preferedCount;
            while (decimalPlaces < 10 && Math.round(preferedIntSize) !== preferedIntSize) {
                min *= 10;
                max *= 10;
                preferedIntSize *= 10;
                decimalPlaces++;
            }

            var scale = [1, 2, 5];

            var i = 0,
                intSizeNext = void 0;

            // eslint-disable-next-line
            while (true) {
                var idx = i % scale.length;
                var pow = Math.floor(i / scale.length);
                var intSizeCurr = Math.pow(10, pow) * scale[idx];

                idx = (i + 1) % scale.length;
                pow = Math.floor((i + 1) / scale.length);
                intSizeNext = Math.pow(10, pow) * scale[idx];

                if (preferedIntSize >= intSizeCurr && preferedIntSize < intSizeNext) break;

                i++;
            }

            var intSizeSelected = intSizeNext;

            var out = [];
            var curr = this.renderer._rnd(min, intSizeSelected, false);
            var denominator = decimalPlaces <= 0 ? 1 : Math.pow(10, decimalPlaces);
            while (curr < max + intSizeSelected) {
                out.push(curr / denominator);
                curr += intSizeSelected;
            }

            return out;
        }
    }, {
        key: '_widgetToImage',
        value: function _widgetToImage(widgetInstance, type, fileName, fnCallback, pageOrientation) {
            var self = widgetInstance;

            if (!self) return false;

            if (fileName === undefined || fileName === '') fileName = 'image.' + type;

            var renderEngineSaved = self.renderEngine;
            var enableAnimationsSaved = self.animation;

            self.animation = 'none';

            // try switching to HTML5
            self.renderEngine = 'HTML5';

            if (self.renderEngine !== renderEngineSaved) {
                try {
                    self.refresh();
                } catch (e) {
                    self.renderEngine = renderEngineSaved;
                    self.refresh();
                    self.animation = enableAnimationsSaved;

                    return false;
                }
            }

            var canvas = self.renderer.getContainer().firstElementChild;

            var continueExport = true;
            if (typeof fnCallback === 'function') {
                continueExport = fnCallback(widgetInstance, canvas);
            }

            var result = true;
            if (continueExport) result = this.exportImage(widgetInstance, canvas, type, fileName, pageOrientation);

            // switch back to existing engine
            if (self.renderEngine !== renderEngineSaved) {
                self.renderEngine = renderEngineSaved;
                self.refresh();
                self.animation = enableAnimationsSaved;
            }

            return result;
        }
    }, {
        key: '_saveAsImage',
        value: function _saveAsImage(type, fileName) {
            return this._widgetToImage(this, type, fileName);
        }
    }, {
        key: 'saveAsPNG',
        value: function saveAsPNG(filename) {
            return this._saveAsImage('png', filename);
        }
    }, {
        key: 'saveAsJPEG',
        value: function saveAsJPEG(filename) {
            return this._saveAsImage('jpeg', filename);
        }
    }, {
        key: 'exportImage',
        value: function exportImage(widgetInstance, canvas, type, fileName, pageOrientation) {
            if (!canvas) return false;

            var isPDF = type.toLowerCase() === 'pdf';
            if (isPDF) type = 'jpeg';
            if (fileName === undefined || fileName === '') fileName = 'image.' + type;

            var result = true;

            if (type === 'print') {
                var newWindow = window.open('', '', 'width=800,height=500'),
                    printDocument = newWindow.document.open(),
                    pageContent = '<!DOCTYPE html>' + '<html>' + '<head>' + '<meta charset="utf-8" />' + '<title>jQWidgets Chart</title>' + '</head>' + '<body><img src="' + canvas.toDataURL() + '" /></html>';

                try {
                    printDocument.write(pageContent);
                    printDocument.close();

                    setTimeout(function () {
                        newWindow.print();
                        newWindow.close();
                    }, 100);
                } catch (error) {
                    //
                }

                return;
            }

            try {
                if (canvas) {
                    if (isPDF) {
                        pageOrientation = pageOrientation || 'portrait';

                        var data = canvas.toDataURL('image/' + type),
                            docDefinition = {
                            content: {
                                image: data,
                                width: Math.min(canvas.width / 1.35, pageOrientation === 'portrait' ? 515 : 762)
                            },
                            pageOrientation: pageOrientation
                        };

                        try {
                            pdfMake.createPdf(docDefinition).download(fileName);
                        } catch (error) {
                            widgetInstance.error(widgetInstance.localize('missingReference', { files: 'pdfmake.min.js' }));
                        }
                    } else {
                        if (!JQX.Utilities.DataExporter) {
                            widgetInstance.error(widgetInstance.localize('missingReference', { files: 'jqxexport.js' }));
                        }

                        var dataExporter = new JQX.Utilities.DataExporter();

                        canvas.toBlob(function (blob) {
                            dataExporter.downloadFile(blob, type, fileName);
                        });
                    }
                }
            } catch (e) {
                result = false;
            }

            return result;
        }
    }]);
    return Draw;
}());

// SvgRenderer class
JQX.Utilities.Assign('Renderer', function () {
    function Renderer(draw) {
        babelHelpers.classCallCheck(this, Renderer);

        var that = this;

        that.draw = draw;
        that._gradients = {};
        that._toRadiansCoefficient = Math.PI * 2 / 360;
    }

    babelHelpers.createClass(Renderer, [{
        key: 'pieSlicePath',
        value: function pieSlicePath(x, y, innerRadius, outerRadius, angleFrom, angleTo, centerOffset) {
            if (!outerRadius) outerRadius = 1;

            var diff = Math.abs(angleFrom - angleTo);
            var lFlag = diff > 180 ? 1 : 0;
            if (diff >= 360) {
                angleTo = angleFrom + 359.99;
            }
            var radFrom = angleFrom * this._toRadiansCoefficient;
            var radTo = angleTo * this._toRadiansCoefficient;

            var x1 = x,
                x2 = x,
                y1 = y,
                y2 = y;

            var isDonut = !isNaN(innerRadius) && innerRadius > 0;

            if (isDonut) centerOffset = 0;

            var radFromCos = Math.cos(radFrom),
                radFromSin = Math.sin(radFrom),
                radToCos = Math.cos(radTo),
                radToSin = Math.sin(radTo);

            if (centerOffset + innerRadius > 0) {
                if (centerOffset > 0) {
                    var midAngle = diff / 2 + angleFrom;
                    var radMid = midAngle * this._toRadiansCoefficient;

                    x += centerOffset * Math.cos(radMid);
                    y -= centerOffset * Math.sin(radMid);
                }

                if (isDonut) {
                    x1 = x + innerRadius * radFromCos;
                    y1 = y - innerRadius * radFromSin;
                    x2 = x + innerRadius * radToCos;
                    y2 = y - innerRadius * radToSin;
                }
            }

            var x3 = x + outerRadius * radFromCos;
            var x4 = x + outerRadius * radToCos;
            var y3 = y - outerRadius * radFromSin;
            var y4 = y - outerRadius * radToSin;

            var path = '';

            var isPartialCircle = Math.abs(Math.abs(angleTo - angleFrom) - 360) > 0.02;

            if (isDonut) {
                path = 'M ' + x2 + ',' + y2;
                path += ' a' + innerRadius + ',' + innerRadius;
                path += ' 0 ' + lFlag + ',1 ' + (x1 - x2) + ',' + (y1 - y2);
                if (isPartialCircle) path += ' L' + x3 + ',' + y3;else path += ' M' + x3 + ',' + y3;

                path += ' a' + outerRadius + ',' + outerRadius;
                path += ' 0 ' + lFlag + ',0 ' + (x4 - x3) + ',' + (y4 - y3);

                if (isPartialCircle) path += ' Z';
            } else {
                path = 'M ' + x4 + ',' + y4;
                path += ' a' + outerRadius + ',' + outerRadius;
                path += ' 0 ' + lFlag + ',1 ' + (x3 - x4) + ',' + (y3 - y4);

                if (isPartialCircle) {
                    path += ' L' + x + ',' + y;
                    path += ' Z';
                }
            }

            return path;
        }
    }, {
        key: 'measureText',
        value: function measureText(text, angle, params, includeTextPartsInfo) {
            var textPartsInfo = this._getTextParts(text, angle, params);
            var tw = textPartsInfo.width;
            var th = textPartsInfo.height;

            if (false === includeTextPartsInfo) th /= 0.6;

            var retVal = {};

            if (isNaN(angle)) angle = 0;

            if (angle === 0) {
                retVal = { width: this._rup(tw), height: this._rup(th) };
            } else {
                var rads = angle * Math.PI * 2 / 360;
                var sn = Math.abs(Math.sin(rads));
                var cs = Math.abs(Math.cos(rads));
                var bh = Math.abs(tw * sn + th * cs);
                var bw = Math.abs(tw * cs + th * sn);

                retVal = { width: this._rup(bw), height: this._rup(bh) };
            }

            if (includeTextPartsInfo) retVal.textPartsInfo = textPartsInfo;

            //retVal.height += 5;
            return retVal;
        }
    }, {
        key: 'alignTextInRect',
        value: function alignTextInRect(x, y, width, height, textWidth, textHeight, halign, valign, angle, rotateAround) {
            var rads = angle * Math.PI * 2 / 360;
            var sn = Math.sin(rads);
            var cs = Math.cos(rads);

            var h2 = textWidth * sn;
            var w2 = textWidth * cs;

            if (halign === 'center' || halign === '' || halign === 'undefined') x = x + width / 2;else if (halign === 'right') x = x + width;

            if (valign === 'center' || valign === 'middle' || valign === '' || valign === 'undefined') y = y + height / 2;else if (valign === 'bottom') y += height - textHeight / 2;else if (valign === 'top') y += textHeight / 2;

            rotateAround = rotateAround || '';

            var adjustY = 'middle';
            if (rotateAround.indexOf('top') !== -1) adjustY = 'top';else if (rotateAround.indexOf('bottom') !== -1) adjustY = 'bottom';

            var adjustX = 'center';
            if (rotateAround.indexOf('left') !== -1) adjustX = 'left';else if (rotateAround.indexOf('right') !== -1) adjustX = 'right';

            if (adjustX === 'center') {
                x -= w2 / 2;
                y -= h2 / 2;
            } else if (adjustX === 'right') {
                x -= w2;
                y -= h2;
            }

            if (adjustY === 'top') {
                x -= textHeight * sn;
                y += textHeight * cs;
            } else if (adjustY === 'middle') {
                x -= textHeight * sn / 2;
                y += textHeight * cs / 2;
            }

            x = this._rup(x);
            y = this._rup(y);

            return { x: x, y: y };
        }
    }, {
        key: 'adjustColor',
        value: function adjustColor(color, adj) {
            if (typeof color !== 'string') return '#000000';

            if (color.indexOf('#') === -1) return color;

            var draw = this.draw;
            var rgb = draw.cssToRgb(color);
            var hsl = draw.rgbToHsl(rgb);
            hsl[2] = Math.min(1, hsl[2] * adj);
            hsl[1] = Math.min(1, hsl[1] * adj * 1.1);
            rgb = draw.hslToRgb(hsl);

            color = '#';
            for (var i = 0; i < 3; i++) {
                var c = Math.round(rgb[i]);
                c = draw.decToHex(c);
                if (c.toString().length === 1) color += '0';

                color += c;
            }

            return color.toUpperCase();
        }
    }, {
        key: '_rup',
        value: function _rup(n) {
            var nr = Math.round(n);
            if (n > nr) nr++;

            return nr;
        }
    }, {
        key: '_ptdist',
        value: function _ptdist(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        }
    }, {
        key: '_rnd',
        value: function _rnd(num, unit, toGreater, fast) {
            if (isNaN(num)) return num;

            if (undefined === fast) fast = true;

            var a = num - (fast === true ? num % unit : this._mod(num, unit));
            if (num === a) return a;

            if (toGreater) {
                if (num > a) a += unit;
            } else {
                if (a > num) a -= unit;
            }

            return unit === 1 ? Math.round(a) : a;
        }
    }, {
        key: '_ptrnd',
        value: function _ptrnd(val) {
            if (!document.createElementNS) {
                if (Math.round(val) === val) return val;
                return this._rnd(val, 1, false, true);
            }

            var rnd = this._rnd(val, 0.5, false, true);
            if (Math.abs(rnd - Math.round(rnd)) !== 0.5) {
                return rnd > val ? rnd - 0.5 : rnd + 0.5;
            }
            return rnd;
        }
    }, {
        key: '_getContrastColor',
        value: function _getContrastColor(color) {
            if (color === undefined) {
                return undefined;
            }

            var rgb = this.draw.hexToRgb(color.slice(1, 3), color.slice(3, 5), color.slice(5, 7)),
                luminance = (0.299 * rgb[0] + 0.587 * rgb[1] + 0.114 * rgb[2]) / 255;

            if (luminance > 0.6) {
                return '#000000';
            } else {
                return '#FFFFFF';
            }
        }
    }]);
    return Renderer;
}());

// SvgRenderer class
JQX.Utilities.Assign('SvgRenderer', function (_JQX$Utilities$Render) {
    babelHelpers.inherits(SvgRenderer, _JQX$Utilities$Render);

    function SvgRenderer(draw) {
        babelHelpers.classCallCheck(this, SvgRenderer);

        var _this = babelHelpers.possibleConstructorReturn(this, (SvgRenderer.__proto__ || Object.getPrototypeOf(SvgRenderer)).call(this, draw));

        var that = _this;

        that._svgns = 'http://www.w3.org/2000/svg';
        that._openGroups = [];
        that._clipId = 0;
        return _this;
    }

    babelHelpers.createClass(SvgRenderer, [{
        key: 'init',
        value: function init(host) {
            var container = document.createElement('div');

            container.className = 'drawContainer';
            container.onselectstart = function () {
                return false;
            };

            host.appendChild(container);

            this.host = host;
            this.container = container;

            try {
                var svg = document.createElementNS(this._svgns, 'svg');
                svg.setAttribute('version', '1.1');
                svg.setAttribute('width', '100%');
                svg.setAttribute('height', '100%');
                svg.setAttribute('overflow', 'hidden');
                container.appendChild(svg);
                this.canvas = svg;
            } catch (e) {
                return false;
            }

            this._id = new Date().getTime();
            this.clear();

            return true;
        }
    }, {
        key: 'getType',
        value: function getType() {
            return 'SVG';
        }
    }, {
        key: 'refresh',
        value: function refresh() {}
    }, {
        key: 'getRect',
        value: function getRect() {
            return { x: 0, y: 0, width: Math.max(this._rup(this.host.offsetWidth) - 1, 0), height: Math.max(this._rup(this.host.offsetHeight) - 1, 0) };
        }
    }, {
        key: 'getContainer',
        value: function getContainer() {
            return this.container;
        }
    }, {
        key: 'clear',
        value: function clear() {
            while (this.canvas.childNodes.length > 0) {
                this.removeElement(this.canvas.firstElementChild);
            }

            this._defaultParent = undefined;
            this._defs = document.createElementNS(this._svgns, 'defs');
            this._gradients = {};
            this.canvas.appendChild(this._defs);
        }
    }, {
        key: 'removeElement',
        value: function removeElement(element) {
            if (undefined === element) return;

            try {
                while (element.firstChild) {
                    this.removeElement(element.firstChild);
                }

                if (element.parentNode) element.parentNode.removeChild(element);else this.canvas.removeChild(element);
            } catch (error) {
                //
            }
        }
    }, {
        key: 'beginGroup',
        value: function beginGroup() {
            var parent = this._activeParent();
            var g = document.createElementNS(this._svgns, 'g');
            parent.appendChild(g);
            this._openGroups.push(g);

            return g;
        }
    }, {
        key: 'endGroup',
        value: function endGroup() {
            if (this._openGroups.length === 0) return;

            this._openGroups.pop();
        }
    }, {
        key: '_activeParent',
        value: function _activeParent() {
            return this._openGroups.length === 0 ? this.canvas : this._openGroups[this._openGroups.length - 1];
        }
    }, {
        key: 'createClipRect',
        value: function createClipRect(rect) {
            var c = document.createElementNS(this._svgns, 'clipPath');
            var r = document.createElementNS(this._svgns, 'rect');
            this.attr(r, { x: rect.x, y: rect.y, width: rect.width, height: rect.height, fill: 'none' });

            this._clipId = this._clipId || 0;
            c.id = 'cl' + this._id + '_' + (++this._clipId).toString();
            c.appendChild(r);

            this._defs.appendChild(c);

            return c;
        }
    }, {
        key: 'getWindowHref',
        value: function getWindowHref() {
            // Get modified href. This is needed to handle cases where the page uses <base> tags.

            var href = window.location.href;
            if (!href) return href;

            href = href.replace(/([\('\)])/g, '\\$1'); // escape brackets & quotes (Chrome)
            href = href.replace(/#.*$/, ''); // remove bookmark links

            return href;
        }
    }, {
        key: 'setClip',
        value: function setClip(elem, clip) {
            var url = 'url(' + this.getWindowHref() + '#' + clip.id + ')';
            return this.attr(elem, { 'clip-path': url });
        }
    }, {
        key: 'addHandler',
        value: function addHandler(element, event, fn) {
            element.addEventListener(event, fn);
        }
    }, {
        key: 'removeHandler',
        value: function removeHandler() /*element, event, fn*/{
            //if ($(element).off)
            //    $(element).off(event, fn);
            //else
            //    $(element).unbind(event, fn);
        }
    }, {
        key: 'on',
        value: function on(element, event, fn) {
            this.addHandler(element, event, fn);
        }
    }, {
        key: 'off',
        value: function off(element, event, fn) {
            this.removeHandler(element, event, fn);
        }
    }, {
        key: 'shape',
        value: function shape(name, params) {
            var s = document.createElementNS(this._svgns, name);
            if (!s) return undefined;

            for (var param in params) {
                s.setAttribute(param, params[param]);
            }this._activeParent().appendChild(s);

            return s;
        }
    }, {
        key: '_getTextParts',
        value: function _getTextParts(text, angle, params) {
            var textPartsInfo = { width: 0, height: 0, parts: [] };
            if (undefined === text) return textPartsInfo;

            var coeff = 0.6;
            var textParts = text.toString().split('<br>');

            var parent = this._activeParent();
            var txt = document.createElementNS(this._svgns, 'text');
            this.attr(txt, params);

            for (var i = 0; i < textParts.length; i++) {
                var textPart = textParts[i];

                var txtNode = txt.ownerDocument.createTextNode(textPart);
                txt.appendChild(txtNode);

                parent.appendChild(txt);
                var bbox = void 0;
                try {
                    bbox = txt.getBBox();
                } catch (e) {
                    //
                }

                var tw = this._rup(bbox.width);
                var th = this._rup(bbox.height * coeff);

                txt.removeChild(txtNode);

                textPartsInfo.width = Math.max(textPartsInfo.width, tw);
                textPartsInfo.height += th + (i > 0 ? 4 : 0);
                textPartsInfo.parts.push({ width: tw, height: th, text: textPart });
            }
            parent.removeChild(txt);

            return textPartsInfo;
        }
    }, {
        key: '_measureText',
        value: function _measureText(text, angle, params, includeTextPartsInfo) {
            return babelHelpers.get(SvgRenderer.prototype.__proto__ || Object.getPrototypeOf(SvgRenderer.prototype), 'measureText', this).call(this, text, angle, params, includeTextPartsInfo);
        }
    }, {
        key: 'measureText',
        value: function measureText(text, angle, params) {
            return this._measureText(text, angle, params, false);
        }
    }, {
        key: 'text',
        value: function text(_text, x, y, width, height, angle, params, clip, halign, valign, rotateAround) {
            var sz = this._measureText(_text, angle, params, true, this);
            var textPartsInfo = sz.textPartsInfo;
            var textParts = textPartsInfo.parts;
            var color = this._getContrastColor(arguments[11]);

            var gClip = void 0;
            if (!halign) halign = 'center';
            if (!valign) valign = 'center';

            if (textParts.length > 1 || clip) gClip = this.beginGroup();

            if (clip) {
                var crect = this.createClipRect({ x: this._rup(x) - 1, y: this._rup(y) - 1, width: this._rup(width) + 2, height: this._rup(height) + 2 });
                this.setClip(gClip, crect);
            }

            //this.rect(x, y, width, height, {fill: 'yellow', stroke: 'red'});

            var parent = this._activeParent();

            var tw = 0,
                th = 0;

            tw = textPartsInfo.width;
            th = textPartsInfo.height;

            if (isNaN(width) || width <= 0) width = tw;
            if (isNaN(height) || height <= 0) height = th;

            var w = width || 0;
            var h = height || 0;

            var yOffset = 0;

            if (!angle || angle === 0) {
                y += th;

                if (valign === 'center' || valign === 'middle') y += (h - th) / 2;else if (valign === 'bottom') y += h - th;

                if (!width) width = tw;

                if (!height) height = th;

                parent = this._activeParent();
                var txt = void 0;
                for (var i = textParts.length - 1; i >= 0; i--) {
                    txt = document.createElementNS(this._svgns, 'text');
                    this.attr(txt, params);
                    this.attr(txt, { cursor: 'default' });

                    var txtNode = txt.ownerDocument.createTextNode(textParts[i].text);
                    txt.appendChild(txtNode);

                    var xOffset = x;
                    var wPart = textParts[i].width;
                    var hPart = textParts[i].height;

                    if (halign === 'center') xOffset += (w - wPart) / 2;else if (halign === 'right') xOffset += w - wPart;

                    this.attr(txt, { x: this._rup(xOffset), y: this._rup(y + yOffset), width: this._rup(wPart), height: this._rup(hPart) });

                    if (color !== undefined) {
                        txt.style.fill = color;
                    }

                    parent.appendChild(txt);

                    yOffset -= textParts[i].height + 4;
                }

                if (gClip) {
                    this.endGroup();
                    return gClip;
                }

                return txt;
            }

            var point = this.alignTextInRect(x, y, width, height, tw, th, halign, valign, angle, rotateAround);
            x = point.x;
            y = point.y;

            var gTranslate = this.shape('g', { transform: 'translate(' + x + ',' + y + ')' });
            var gRotate = this.shape('g', { transform: 'rotate(' + angle + ')' });

            gTranslate.appendChild(gRotate);

            // add the text blocks
            yOffset = 0;

            for (var _i = textParts.length - 1; _i >= 0; _i--) {
                var tx = document.createElementNS(this._svgns, 'text');
                this.attr(tx, params);
                this.attr(tx, { cursor: 'default' });

                var _txtNode = tx.ownerDocument.createTextNode(textParts[_i].text);
                tx.appendChild(_txtNode);

                var _xOffset = 0;
                var _wPart = textParts[_i].width;
                var _hPart = textParts[_i].height;

                if (halign === 'center') _xOffset += (textPartsInfo.width - _wPart) / 2;else if (halign === 'right') _xOffset += textPartsInfo.width - _wPart;

                this.attr(tx, { x: this._rup(_xOffset), y: this._rup(yOffset), width: this._rup(_wPart), height: this._rup(_hPart) });
                gRotate.appendChild(tx);

                yOffset -= _hPart + 4;
            }

            parent.appendChild(gTranslate);

            if (gClip) this.endGroup();

            return gTranslate;
        }
    }, {
        key: 'line',
        value: function line(x1, y1, x2, y2, params) {
            var line = this.shape('line', { x1: x1, y1: y1, x2: x2, y2: y2 });
            this.attr(line, params);
            return line;
        }
    }, {
        key: 'path',
        value: function path(points, params) {
            var s = this.shape('path');
            s.setAttribute('d', points);
            if (params) {
                this.attr(s, params);
            }
            return s;
        }
    }, {
        key: 'rect',
        value: function rect(x, y, w, h, params) {
            x = this._ptrnd(x);
            y = this._ptrnd(y);
            w = Math.max(1, this._rnd(w, 1, false));
            h = Math.max(1, this._rnd(h, 1, false));
            var s = this.shape('rect', { x: x, y: y, width: w, height: h });
            if (params) this.attr(s, params);
            return s;
        }
    }, {
        key: 'circle',
        value: function circle(x, y, r, params) {
            var s = this.shape('circle', { cx: x, cy: y, r: r });
            if (params) this.attr(s, params);
            return s;
        }
    }, {
        key: 'pieslice',
        value: function pieslice(x, y, innerRadius, outerRadius, angleFrom, angleTo, centerOffset, params) {
            var pathCmd = this.pieSlicePath(x, y, innerRadius, outerRadius, angleFrom, angleTo, centerOffset);

            var s = this.shape('path');
            s.setAttribute('d', pathCmd);

            if (params) this.attr(s, params);

            return s;
        }
    }, {
        key: 'attr',
        value: function attr(element, params) {
            if (!element || !params) return;

            for (var param in params) {
                if (param === 'textContent') element.textContent = params[param];else {
                    element.setAttribute(param, params[param]);
                }
            }
        }
    }, {
        key: 'removeAttr',
        value: function removeAttr(element, params) {
            if (!element || !params) return;

            for (var param in params) {
                if (param === 'textContent') element.textContent = '';else {
                    element.removeAttribute(params[param]);
                }
            }
        }
    }, {
        key: 'getAttr',
        value: function getAttr(element, key) {
            return element['getAttribute'](key);
        }
    }, {
        key: '_toLinearGradient',
        value: function _toLinearGradient(color, isVertical, stops) {
            var id = 'grd' + this._id + color.replace('#', '') + (isVertical ? 'v' : 'h');
            var url = 'url(' + this.getWindowHref() + '#' + id + ')';
            if (this._gradients[url]) return url;

            var gr = document.createElementNS(this._svgns, 'linearGradient');
            this.attr(gr, { x1: '0%', y1: '0%', x2: isVertical ? '0%' : '100%', y2: isVertical ? '100%' : '0%', id: id });

            for (var i = 0; i < stops.length; i++) {
                var stop = stops[i];
                var s = document.createElementNS(this._svgns, 'stop');
                var st = 'stop-color:' + this.adjustColor(color, stop[1]);
                this.attr(s, { offset: stop[0] + '%', style: st });
                gr.appendChild(s);
            }

            this._defs.appendChild(gr);
            this._gradients[url] = true;

            return url;
        }
    }, {
        key: '_toRadialGradient',
        value: function _toRadialGradient(color, stops, coords) {
            var id = 'grd' + this._id + color.replace('#', '') + 'r' + (coords !== undefined ? coords.key : '');

            var url = 'url(' + this.getWindowHref() + '#' + id + ')';
            if (this._gradients[url]) return url;

            var gr = document.createElementNS(this._svgns, 'radialGradient');
            if (coords === undefined) this.attr(gr, { cx: '50%', cy: '50%', r: '100%', fx: '50%', fy: '50%', id: id });else this.attr(gr, { cx: coords.x, cy: coords.y, r: coords.outerRadius, id: id, gradientUnits: 'userSpaceOnUse' });

            for (var i = 0; i < stops.length; i++) {
                var stop = stops[i];
                var s = document.createElementNS(this._svgns, 'stop');
                var st = 'stop-color:' + this.adjustColor(color, stop[1]);
                this.attr(s, { offset: stop[0] + '%', style: st });
                gr.appendChild(s);
            }

            this._defs.appendChild(gr);
            this._gradients[url] = true;

            return url;
        }
    }]);
    return SvgRenderer;
}(JQX.Utilities.Renderer));

// HTML5Renderer class
JQX.Utilities.Assign('HTML5Renderer', function (_JQX$Utilities$Render2) {
    babelHelpers.inherits(HTML5Renderer, _JQX$Utilities$Render2);

    function HTML5Renderer(draw) {
        babelHelpers.classCallCheck(this, HTML5Renderer);

        var _this2 = babelHelpers.possibleConstructorReturn(this, (HTML5Renderer.__proto__ || Object.getPrototypeOf(HTML5Renderer)).call(this, draw));

        var that = _this2;

        that._renderers = new JQX.Utilities.HTML5RenderHelpers(that);
        return _this2;
    }

    babelHelpers.createClass(HTML5Renderer, [{
        key: 'init',
        value: function init(host) {
            try {
                this.host = host;

                var chartContainer = document.createElement('div'),
                    canvas = document.createElement('canvas');

                chartContainer.className = 'chartContainer';
                chartContainer.style.position = 'relative';
                chartContainer.onselectstart = function () {
                    return false;
                };

                canvas.id = '__jqxCanvasWrap';
                canvas.style.width = '100%';
                canvas.style.height = '100%';

                chartContainer.appendChild(canvas);
                host.appendChild(chartContainer);

                this.canvas = canvas;
                canvas.width = host.offsetWidth;
                canvas.height = host.offsetHeight;
                this.ctx = canvas.getContext('2d');

                this._elements = {};
                this._maxId = 0;
                this._gradientId = 0;
                this._gradients = {};
                this._currentPoint = { x: 0, y: 0 };
                this._lastCmd = '';
                this._pos = 0;
            } catch (e) {
                return false;
            }

            return true;
        }
    }, {
        key: 'getType',
        value: function getType() {
            return 'HTML5';
        }
    }, {
        key: 'getContainer',
        value: function getContainer() {
            var container = this.host.getElementsByClassName('chartContainer')[0];
            return container;
        }
    }, {
        key: 'getRect',
        value: function getRect() {
            return { x: 0, y: 0, width: this.canvas.width - 1, height: this.canvas.height - 1 };
        }
    }, {
        key: 'beginGroup',
        value: function beginGroup() {}
    }, {
        key: 'endGroup',
        value: function endGroup() {}
    }, {
        key: 'setClip',
        value: function setClip() {}
    }, {
        key: 'createClipRect',
        value: function createClipRect() {}
    }, {
        key: 'addHandler',
        value: function addHandler() {
            // unsupported
        }
    }, {
        key: 'removeHandler',
        value: function removeHandler() {
            // unsupported
        }
    }, {
        key: 'on',
        value: function on(element, event, fn) {
            this.addHandler(element, event, fn);
        }
    }, {
        key: 'off',
        value: function off(element, event, fn) {
            this.removeHandler(element, event, fn);
        }
    }, {
        key: 'clear',
        value: function clear() {
            this._elements = {};
            this._maxId = 0;
            this._renderers._gradients = {};
            this._gradientId = 0;
        }
    }, {
        key: 'removeElement',
        value: function removeElement(element) {
            if (undefined === element) return;
            if (this._elements[element.id]) delete this._elements[element.id];
        }
    }, {
        key: 'shape',
        value: function shape(name, params) {
            var s = { type: name, id: this._maxId++ };

            for (var param in params) {
                s[param] = params[param];
            }this._elements[s.id] = s;

            return s;
        }
    }, {
        key: 'attr',
        value: function attr(element, params) {
            for (var param in params) {
                element[param] = params[param];
            }
        }
    }, {
        key: 'removeAttr',
        value: function removeAttr(element, params) {
            for (var param in params) {
                delete element[params[param]];
            }
        }
    }, {
        key: 'rect',
        value: function rect(x, y, w, h, params) {
            if (isNaN(x)) throw 'Invalid value for "x"';
            if (isNaN(y)) throw 'Invalid value for "y"';
            if (isNaN(w)) throw 'Invalid value for "width"';
            if (isNaN(h)) throw 'Invalid value for "height"';

            var s = this.shape('rect', { x: x, y: y, width: w, height: h });
            if (params) this.attr(s, params);
            return s;
        }
    }, {
        key: 'path',
        value: function path(pathCmd, params) {
            var s = this.shape('path', params);
            this.attr(s, { d: pathCmd });
            return s;
        }
    }, {
        key: 'line',
        value: function line(x1, y1, x2, y2, params) {
            return this.path('M ' + x1 + ',' + y1 + ' L ' + x2 + ',' + y2, params);
        }
    }, {
        key: 'circle',
        value: function circle(x, y, r, params) {
            var s = this.shape('circle', { x: x, y: y, r: r });
            if (params) this.attr(s, params);
            return s;
        }
    }, {
        key: 'pieslice',
        value: function pieslice(x, y, innerRadius, outerRadius, angleFrom, angleTo, centerOffset, params) {
            var element = this.path(this.pieSlicePath(x, y, innerRadius, outerRadius, angleFrom, angleTo, centerOffset), params);
            this.attr(element, { x: x, y: y, innerRadius: innerRadius, outerRadius: outerRadius, angleFrom: angleFrom, angleTo: angleTo });
            return element;
        }
    }, {
        key: '_getCSSStyle',
        value: function _getCSSStyle(name) {
            var measureElement = document.createElement('div');

            measureElement.className = name;
            measureElement.style.position = 'absolute';
            measureElement.style.visibility = 'hidden';

            this.host.appendChild(measureElement);

            var style = window.getComputedStyle(measureElement);

            style = {
                color: style.color,
                fontFamily: style.fontFamily,
                fontSize: style.fontSize,
                fontWeight: style.fontWeight
            };

            this.host.removeChild(measureElement);

            return style;
        }
    }, {
        key: '_getTextParts',
        value: function _getTextParts(text, angle, params) {
            var fontFamily = 'Arial';
            var fontSize = '10pt';
            var fontWeight = '';
            if (params && params['class']) {
                var style = this._getCSSStyle(params['class']);

                if (style['fontSize']) fontSize = style['fontSize'];
                if (style['fontFamily']) fontFamily = style['fontFamily'];
                if (style['fontWeight']) fontWeight = style['fontWeight'];
            }

            this.ctx.font = fontWeight + ' ' + fontSize + ' ' + fontFamily;

            var textPartsInfo = { width: 0, height: 0, parts: [] };

            var coeff = 0.6;
            var textParts = text.toString().split('<br>');
            for (var i = 0; i < textParts.length; i++) {
                var textPart = textParts[i];

                var tw = this.ctx.measureText(textPart).width;
                var span = document.createElement('span');
                span.className = 'jqxchart';
                span.font = this.ctx.font;
                span.textContent = textPart;
                this.host.appendChild(span);
                var th = span.offsetHeight * coeff;
                this.host.removeChild(span);

                textPartsInfo.width = Math.max(textPartsInfo.width, this._rup(tw));
                textPartsInfo.height += th + (i > 0 ? 4 : 0);
                textPartsInfo.parts.push({ width: tw, height: th, text: textPart });
            }

            return textPartsInfo;
        }
    }, {
        key: '_measureText',
        value: function _measureText(text, angle, params, includeTextPartsInfo) {
            return babelHelpers.get(HTML5Renderer.prototype.__proto__ || Object.getPrototypeOf(HTML5Renderer.prototype), 'measureText', this).call(this, text, angle, params, includeTextPartsInfo);
        }
    }, {
        key: 'measureText',
        value: function measureText(text, angle, params) {
            return this._measureText(text, angle, params, false);
        }
    }, {
        key: 'text',
        value: function text(_text2, x, y, width, height, angle, params, clip, halign, valign, rotateAround) {
            var t = this.shape('text', { text: _text2, x: x, y: y, width: width, height: height, angle: angle, clip: clip, halign: halign, valign: valign, rotateAround: rotateAround });
            if (params) this.attr(t, params);

            t.fontFamily = 'Arial';
            t.fontSize = '10pt';
            t.fontWeight = '';
            t.color = this._getContrastColor(arguments[11]);

            if (params && params['class']) {
                var style = this._getCSSStyle(params['class']);
                t.fontFamily = style.fontFamily || t.fontFamily;
                t.fontSize = style.fontSize || t.fontSize;
                t.fontWeight = style['fontWeight'] || t.fontWeight;
                t.color = t.color || style.color;
            }

            t.color = t.color || '#000000';

            var sz = this._measureText(_text2, 0, params, true);
            this.attr(t, { textPartsInfo: sz.textPartsInfo, textWidth: sz.width, textHeight: sz.height });

            if (width <= 0 || isNaN(width)) this.attr(t, { width: sz.width });

            if (height <= 0 || isNaN(height)) this.attr(t, { height: sz.height });

            return t;
        }
    }, {
        key: '_toLinearGradient',
        value: function _toLinearGradient(color, isVertical, stops) {
            if (this._renderers._gradients[color]) return color;

            var colorStops = [];
            for (var i = 0; i < stops.length; i++) {
                colorStops.push({ percent: stops[i][0] / 100, color: this.adjustColor(color, stops[i][1]) });
            }var name = 'gr' + this._gradientId++;
            this.createGradient(name, isVertical ? 'vertical' : 'horizontal', colorStops);
            return name;
        }
    }, {
        key: '_toRadialGradient',
        value: function _toRadialGradient(color, stops) {
            if (this._renderers._gradients[color]) return color;

            var colorStops = [];
            for (var i = 0; i < stops.length; i++) {
                colorStops.push({ percent: stops[i][0] / 100, color: this.adjustColor(color, stops[i][1]) });
            }var name = 'gr' + this._gradientId++;
            this.createGradient(name, 'radial', colorStops);
            return name;
        }
    }, {
        key: 'createGradient',
        value: function createGradient(name, orientation, colorStops) {
            this._renderers.createGradient(this, name, orientation, colorStops);
        }
    }, {
        key: 'refresh',
        value: function refresh() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            for (var element in this._elements) {
                var params = this._elements[element];

                this._renderers.setFillStyle(this, params);
                this._renderers.setStroke(this, params);

                this._renderers[this._elements[element].type](this.ctx, params);
            }
        }
    }]);
    return HTML5Renderer;
}(JQX.Utilities.Renderer));

// HTML5RenderHelpers class
JQX.Utilities.Assign('HTML5RenderHelpers', function () {
    function HTML5RenderHelpers(HTML5Renderer) {
        babelHelpers.classCallCheck(this, HTML5RenderHelpers);

        this.HTML5Renderer = HTML5Renderer;
        this._cmds = 'mlcazq';
    }

    babelHelpers.createClass(HTML5RenderHelpers, [{
        key: 'ptrnd',
        value: function ptrnd(val) {
            if (Math.abs(Math.round(val) - val) === 0.5) return val;

            var rnd = Math.round(val);
            if (rnd < val) rnd = rnd - 1;

            return rnd + 0.5;
        }
    }, {
        key: 'createGradient',
        value: function createGradient(context, name, orientation, colorStops) {
            context._gradients[name] = { orientation: orientation, colorStops: colorStops };
        }
    }, {
        key: 'setStroke',
        value: function setStroke(context, params) {
            var ctx = context.ctx,
                strokeWidth = params['stroke-width'];

            ctx.strokeStyle = params['stroke'] || 'transparent';

            if (strokeWidth === 0) {
                ctx.lineWidth = 0.01;
            } else if (strokeWidth !== undefined) {
                ctx.lineWidth = strokeWidth;
            } else {
                ctx.lineWidth = 1;
            }

            if (params['fill-opacity'] !== undefined) {
                ctx.globalAlpha = params['fill-opacity'];
            } else if (params['opacity'] !== undefined) {
                ctx.globalAlpha = params['opacity'];
            } else {
                ctx.globalAlpha = 1;
            }

            if (ctx.setLineDash) {
                if (params['stroke-dasharray']) ctx.setLineDash(params['stroke-dasharray'].split(','));else ctx.setLineDash([]);
            }
        }
    }, {
        key: 'setFillStyle',
        value: function setFillStyle(context, params) {
            var ctx = context.ctx;

            ctx.fillStyle = 'transparent';

            if (params['fill-opacity'] !== undefined) {
                ctx.globalAlpha = params['fill-opacity'];
            } else if (params['opacity'] !== undefined) {
                ctx.globalAlpha = params['opacity'];
            } else {
                ctx.globalAlpha = 1;
            }

            if (params.fill && params.fill.indexOf('#') === -1 && context._gradients[params.fill]) {
                var isVertical = context._gradients[params.fill].orientation !== 'horizontal';
                var isRadial = context._gradients[params.fill].orientation === 'radial';
                var x1 = this.ptrnd(params.x);
                var y1 = this.ptrnd(params.y);
                var x2 = this.ptrnd(params.x + (isVertical ? 0 : params.width));
                var y2 = this.ptrnd(params.y + (isVertical ? params.height : 0));

                var gradient = void 0;

                if ((params.type === 'circle' || params.type === 'path' || params.type === 'rect') && isRadial) {
                    var x = this.ptrnd(params.x),
                        y = this.ptrnd(params.y);
                    var r1 = params.innerRadius || 0,
                        r2 = params.outerRadius || params.r || 0;

                    if (params.type === 'rect') {
                        x += params.width / 2;
                        y += params.height / 2;
                    }

                    gradient = ctx.createRadialGradient(x, y, r1, x, y, r2);
                }

                if (!isRadial) {
                    if (isNaN(x1) || isNaN(x2) || isNaN(y1) || isNaN(y2)) {
                        x1 = 0;
                        y1 = 0;
                        x2 = isVertical ? 0 : ctx.canvas.width;
                        y2 = isVertical ? ctx.canvas.height : 0;
                    }

                    gradient = ctx.createLinearGradient(x1, y1, x2, y2);
                }

                var colorStops = context._gradients[params.fill].colorStops;
                for (var i = 0; i < colorStops.length; i++) {
                    gradient.addColorStop(colorStops[i].percent, colorStops[i].color);
                }ctx.fillStyle = gradient;
            } else if (params.fill) {
                ctx.fillStyle = params.fill;
            }
        }
    }, {
        key: 'rect',
        value: function rect(ctx, params) {
            if (params.width === 0 || params.height === 0) return;
            ctx.fillRect(this.ptrnd(params.x), this.ptrnd(params.y), params.width, params.height);
            ctx.strokeRect(this.ptrnd(params.x), this.ptrnd(params.y), params.width, params.height);
        }
    }, {
        key: 'circle',
        value: function circle(ctx, params) {
            if (params.r === 0) return;
            ctx.beginPath();
            ctx.arc(this.ptrnd(params.x), this.ptrnd(params.y), params.r, 0, Math.PI * 2, false);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
    }, {
        key: '_parsePoint',
        value: function _parsePoint(str) {
            var x = this._parseNumber(str);
            var y = this._parseNumber(str);
            return { x: x, y: y };
        }
    }, {
        key: '_parseNumber',
        value: function _parseNumber(str) {
            var numStarted = false,
                i = void 0;
            for (i = this._pos; i < str.length; i++) {
                if (str[i] >= '0' && str[i] <= '9' || str[i] === '.' || str[i] === 'e' || str[i] === '-' && !numStarted || str[i] === '-' && i >= 1 && str[i - 1] === 'e') {
                    numStarted = true;
                    continue;
                }
                if (!numStarted && (str[i] === ' ' || str[i] === ',')) {
                    this._pos++;
                    continue;
                }

                break;
            }

            var val = parseFloat(str.substring(this._pos, i));
            if (isNaN(val)) return undefined;

            this._pos = i;
            return val;
        }
    }, {
        key: '_isRelativeCmd',
        value: function _isRelativeCmd(cmd) {
            return this._cmds.indexOf(cmd) !== -1;
        }
    }, {
        key: '_parseCmd',
        value: function _parseCmd(string) {
            for (var i = this._pos; i < string.length; i++) {
                if (this._cmds.toLowerCase().indexOf(string[i].toLowerCase()) !== -1) {
                    this._pos = i + 1;
                    this._lastCmd = string[i];
                    return this._lastCmd;
                }
                if (string[i] === ' ') {
                    this._pos++;
                    continue;
                }
                if (string[i] >= '0' && string[i] <= '9') {
                    this._pos = i;
                    if (this._lastCmd === '') break;else return this._lastCmd;
                }
            }

            return undefined;
        }
    }, {
        key: '_toAbsolutePoint',
        value: function _toAbsolutePoint(point) {
            return { x: this._currentPoint.x + point.x, y: this._currentPoint.y + point.y };
        }
    }, {
        key: 'path',
        value: function path(ctx, params) {
            var _this3 = this;

            var path = params.d;

            this._pos = 0;
            this._lastCmd = '';

            var firstPoint = undefined;
            this._currentPoint = { x: 0, y: 0 };

            ctx.beginPath();

            while (this._pos < path.length) {
                var cmd = this._parseCmd(path);
                if (cmd === undefined) break;

                if (cmd === 'M' || cmd === 'm') {
                    var point = this._parsePoint(path);
                    if (point === undefined) break;
                    ctx.moveTo(point.x, point.y);
                    this._currentPoint = point;
                    if (firstPoint === undefined) firstPoint = point;

                    continue;
                }

                if (cmd === 'L' || cmd === 'l') {
                    var _point = this._parsePoint(path);
                    if (_point === undefined) break;

                    ctx.lineTo(_point.x, _point.y);
                    this._currentPoint = _point;
                    continue;
                }

                if (cmd === 'A' || cmd === 'a') {
                    var _ret = function () {
                        var rx = _this3._parseNumber(path);
                        var ry = _this3._parseNumber(path);
                        var angle = _this3._parseNumber(path) * (Math.PI / 180.0);
                        var largeFlag = _this3._parseNumber(path);
                        var sweepFlag = _this3._parseNumber(path);
                        var endPoint = _this3._parsePoint(path);

                        if (_this3._isRelativeCmd(cmd)) {
                            endPoint = _this3._toAbsolutePoint(endPoint);
                        }

                        if (rx === 0 || ry === 0) return 'continue';

                        var cp = _this3._currentPoint;

                        /// START
                        // x1', y1'
                        var cp2 = {
                            x: Math.cos(angle) * (cp.x - endPoint.x) / 2.0 + Math.sin(angle) * (cp.y - endPoint.y) / 2.0,
                            y: -Math.sin(angle) * (cp.x - endPoint.x) / 2.0 + Math.cos(angle) * (cp.y - endPoint.y) / 2.0
                        };

                        // adjust radii
                        var adj = Math.pow(cp2.x, 2) / Math.pow(rx, 2) + Math.pow(cp2.y, 2) / Math.pow(ry, 2);
                        if (adj > 1) {
                            rx *= Math.sqrt(adj);
                            ry *= Math.sqrt(adj);
                        }

                        // cx', cy'
                        var s = (largeFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(cp2.y, 2) - Math.pow(ry, 2) * Math.pow(cp2.x, 2)) / (Math.pow(rx, 2) * Math.pow(cp2.y, 2) + Math.pow(ry, 2) * Math.pow(cp2.x, 2)));

                        if (isNaN(s)) s = 0;

                        var cp3 = { x: s * rx * cp2.y / ry, y: s * -ry * cp2.x / rx };

                        // cx, cy
                        var centerPoint = {
                            x: (cp.x + endPoint.x) / 2.0 + Math.cos(angle) * cp3.x - Math.sin(angle) * cp3.y,
                            y: (cp.y + endPoint.y) / 2.0 + Math.sin(angle) * cp3.x + Math.cos(angle) * cp3.y
                        };

                        // vector magnitude
                        var m = function m(v) {
                            return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));
                        };

                        // ratio between two vectors
                        var r = function r(u, v) {
                            return (u[0] * v[0] + u[1] * v[1]) / (m(u) * m(v));
                        };

                        // angle between two vectors
                        var a = function a(u, v) {
                            return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(r(u, v));
                        };

                        // initial angle
                        var startAngle = a([1, 0], [(cp2.x - cp3.x) / rx, (cp2.y - cp3.y) / ry]);

                        // angle delta
                        var u = [(cp2.x - cp3.x) / rx, (cp2.y - cp3.y) / ry];
                        var v = [(-cp2.x - cp3.x) / rx, (-cp2.y - cp3.y) / ry];
                        var deltaAngle = a(u, v);
                        if (r(u, v) <= -1) deltaAngle = Math.PI;

                        if (r(u, v) >= 1) deltaAngle = 0;

                        if (sweepFlag === 0 && deltaAngle > 0) deltaAngle = deltaAngle - 2 * Math.PI;

                        if (sweepFlag === 1 && deltaAngle < 0) deltaAngle = deltaAngle + 2 * Math.PI;

                        var r1 = rx > ry ? rx : ry;
                        var sx = rx > ry ? 1 : rx / ry;
                        var sy = rx > ry ? ry / rx : 1;

                        ctx.translate(centerPoint.x, centerPoint.y);
                        ctx.rotate(angle);
                        ctx.scale(sx, sy);
                        ctx.arc(0, 0, r1, startAngle, startAngle + deltaAngle, 1 - sweepFlag);
                        ctx.scale(1 / sx, 1 / sy);
                        ctx.rotate(-angle);

                        ctx.translate(-centerPoint.x, -centerPoint.y);

                        return 'continue';
                    }();

                    if (_ret === 'continue') continue;
                }

                if ((cmd === 'Z' || cmd === 'z') && firstPoint !== undefined) {
                    ctx.lineTo(firstPoint.x, firstPoint.y);
                    this._currentPoint = firstPoint;
                    continue;
                }

                if (cmd === 'C' || cmd === 'c') {
                    var p1 = this._parsePoint(path);
                    var p2 = this._parsePoint(path);
                    var p3 = this._parsePoint(path);

                    ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
                    this._currentPoint = p3;
                    continue;
                }

                if (cmd === 'Q' || cmd === 'q') {
                    var _p = this._parsePoint(path);
                    var _p2 = this._parsePoint(path);

                    ctx.quadraticCurveTo(_p.x, _p.y, _p2.x, _p2.y);
                    this._currentPoint = _p2;
                    continue;
                }
            }

            ctx.fill();
            ctx.stroke();
            ctx.closePath();
        }
    }, {
        key: 'text',
        value: function text(ctx, params) {
            var x = this.ptrnd(params.x);
            var y = this.ptrnd(params.y);
            var width = this.ptrnd(params.width);
            var height = this.ptrnd(params.height);
            var halign = params.halign;
            var valign = params.valign;
            var angle = params.angle;
            var rotateAround = params.rotateAround;
            var textPartsInfo = params.textPartsInfo;
            var textParts = textPartsInfo.parts;

            var clip = params.clip;
            if (clip === undefined) clip = true;

            ctx.save();

            if (!halign) halign = 'center';
            if (!valign) valign = 'center';

            if (clip) {
                ctx.rect(x, y, width, height);
                ctx.clip();
            }

            var tw = params.textWidth;
            var th = params.textHeight;

            var w = width || 0;
            var h = height || 0;

            ctx.fillStyle = params.color;
            ctx.font = params.fontWeight + ' ' + params.fontSize + ' ' + params.fontFamily;

            if (!angle || angle === 0) {
                y += th;

                if (valign === 'center' || valign === 'middle') y += (h - th) / 2;else if (valign === 'bottom') y += h - th;

                if (!width) width = tw;

                if (!height) height = th;

                var _yOffset = 0;

                for (var i = textParts.length - 1; i >= 0; i--) {
                    var textPart = textParts[i];
                    var xOffset = x;
                    var wPart = textParts[i].width;

                    if (halign === 'center') xOffset += (w - wPart) / 2;else if (halign === 'right') xOffset += w - wPart;

                    ctx.fillText(textPart.text, xOffset, y + _yOffset);
                    _yOffset -= textPart.height + (i > 0 ? 4 : 0);
                }
                ctx.restore();
                return;
            }

            var point = this.HTML5Renderer.alignTextInRect(x, y, width, height, tw, th, halign, valign, angle, rotateAround);
            x = point.x;
            y = point.y;

            var rads = angle * Math.PI * 2 / 360;
            ctx.translate(x, y);
            ctx.rotate(rads);

            var yOffset = 0;
            var maxW = textPartsInfo.width;

            for (var _i2 = textParts.length - 1; _i2 >= 0; _i2--) {
                var _xOffset2 = 0;

                if (halign === 'center') _xOffset2 += (maxW - textParts[_i2].width) / 2;else if (halign === 'right') _xOffset2 += maxW - textParts[_i2].width;

                ctx.fillText(textParts[_i2].text, _xOffset2, yOffset);

                yOffset -= textParts[_i2].height + 4;
            }

            ctx.restore();
        }
    }]);
    return HTML5RenderHelpers;
}());

// Plot class
JQX.Utilities.Assign('Plot', function () {
    function Plot(renderer) {
        babelHelpers.classCallCheck(this, Plot);

        this.renderer = renderer;
    }

    babelHelpers.createClass(Plot, [{
        key: 'get',
        value: function get(array, index, key) {
            return key !== undefined ? array[index][key] : array[index];
        }
    }, {
        key: 'min',
        value: function min(array, key) {
            var min = NaN;
            for (var i = 0; i < array.length; i++) {
                var val = this.get(array, i, key);

                if (isNaN(min) || val < min) min = val;
            }

            return min;
        }
    }, {
        key: 'max',
        value: function max(array, key) {
            var max = NaN;
            for (var i = 0; i < array.length; i++) {
                var val = this.get(array, i, key);

                if (isNaN(max) || val > max) max = val;
            }

            return max;
        }
    }, {
        key: 'sum',
        value: function sum(array, key) {
            var sum = 0;
            for (var i = 0; i < array.length; i++) {
                var val = this.get(array, i, key);
                if (!isNaN(val)) sum += val;
            }

            return sum;
        }
    }, {
        key: 'count',
        value: function count(array, key) {
            var count = 0;
            for (var i = 0; i < array.length; i++) {
                var val = this.get(array, i, key);
                if (!isNaN(val)) count++;
            }

            return count;
        }
    }, {
        key: 'avg',
        value: function avg(array, key) {
            return this.sum(array, key) / Math.max(1, this.count(array, key));
        }
    }, {
        key: 'filter',
        value: function filter(array, fn) {
            if (!fn) return array;

            var out = [];
            for (var i = 0; i < array.length; i++) {
                if (fn(array[i])) out.push(array[i]);
            }return out;
        }
    }, {
        key: 'scale',
        value: function scale(val, range, scale_range, params) {
            if (isNaN(val)) return NaN;

            if (val < Math.min(range.min, range.max) || val > Math.max(range.min, range.max)) {
                if (!params || params['ignore_range'] !== true) return NaN;
            }

            var outVal = NaN;

            var percent = 1;
            if (range.type === undefined || range.type !== 'logarithmic') {
                var denom = Math.abs(range.max - range.min);
                if (!denom) denom = 1;
                percent = Math.abs(val - Math.min(range.min, range.max)) / denom;
            } else if (range.type === 'logarithmic') {
                var logBase = range.base;
                if (isNaN(logBase)) logBase = 10;

                var min = Math.min(range.min, range.max);
                if (min <= 0) min = 1;

                var max = Math.max(range.min, range.max);
                if (max <= 0) max = 1;

                var maxPow = Math.log(max) / Math.log(logBase);
                max = Math.pow(logBase, maxPow);

                var minPow = Math.log(min) / Math.log(logBase);
                min = Math.pow(logBase, minPow);

                var valPow = Math.log(val) / Math.log(logBase);

                percent = Math.abs(valPow - minPow) / (maxPow - minPow);
            }

            if (scale_range.type === 'logarithmic') {
                var _logBase2 = scale_range.base;
                if (isNaN(_logBase2)) _logBase2 = 10;

                var _maxPow2 = Math.log(scale_range.max) / Math.log(_logBase2);
                var _minPow2 = Math.log(scale_range.min) / Math.log(_logBase2);

                if (scale_range.flip) percent = 1 - percent;

                var _valPow2 = Math.min(_minPow2, _maxPow2) + percent * Math.abs(_maxPow2 - _minPow2);
                outVal = Math.pow(_logBase2, _valPow2);
            } else {
                outVal = Math.min(scale_range.min, scale_range.max) + percent * Math.abs(scale_range.max - scale_range.min);

                if (scale_range.flip) outVal = Math.max(scale_range.min, scale_range.max) - outVal + scale_range.min;
            }

            return outVal;
        }
    }, {
        key: 'axis',
        value: function axis(min, max, preferedCount) {
            if (preferedCount <= 1) return [max, min];

            //let minSave = min;
            //let maxSave = max;

            if (isNaN(preferedCount) || preferedCount < 2) preferedCount = 2;

            var decimalPlaces = 0;
            while (Math.round(min) !== min && Math.round(max) !== max && decimalPlaces < 10) {
                min *= 10;
                max *= 10;
                decimalPlaces++;
            }

            var preferedIntSize = (max - min) / preferedCount;
            while (decimalPlaces < 10 && Math.round(preferedIntSize) !== preferedIntSize) {
                min *= 10;
                max *= 10;
                preferedIntSize *= 10;
                decimalPlaces++;
            }

            var scale = [1, 2, 5];

            //let itemsCount = 0;
            var i = 0;
            var intSizeNext = void 0;

            // eslint-disable-next-line
            while (true) {
                var idx = i % scale.length;
                var pow = Math.floor(i / scale.length);
                var intSizeCurr = Math.pow(10, pow) * scale[idx];

                idx = (i + 1) % scale.length;
                pow = Math.floor((i + 1) / scale.length);
                intSizeNext = Math.pow(10, pow) * scale[idx];

                if (preferedIntSize >= intSizeCurr && preferedIntSize < intSizeNext) break;

                i++;
            }

            var intSizeSelected = intSizeNext;

            var out = [];
            var curr = this.renderer._rnd(min, intSizeSelected, false);
            var denominator = decimalPlaces <= 0 ? 1 : Math.pow(10, decimalPlaces);
            while (curr < max + intSizeSelected) {
                out.push(curr / denominator);
                curr += intSizeSelected;
            }

            return out;
        }
    }]);
    return Plot;
}());