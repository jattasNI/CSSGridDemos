'use strict';

JQX.Utilities.Assign('DataExporter', function () {
    function DataExporter(exportDetails, groupBy, filterBy, conditionalFormatting) {
        babelHelpers.classCallCheck(this, DataExporter);

        var that = this;

        if (!exportDetails) {
            exportDetails = {};
        }

        /*
         * "style" object definition (all properties are optional):
         *
         * «any valid CSS property» - applied to whole table
         * header (Object)
         *      «any valid CSS property» - applied to header cells
         *      «any column name» (Object)
         *          «any valid CSS property» - applied to particular column header cell
         * columns (Object)
         *      «any valid CSS property» - applied to column cells
         *      «any column name» (Object)
         *          «any valid CSS property» - applied to the cells of particular column
         *          format - applicable to numeric and date columns
         *          «n» (Object), where «n» is a row index (related to use of "ConditionalFormatting" object)
         *              background
         *              border
         *              color
         * rows (Object)
         *      «any valid CSS property» - applied to rows
         *      alternationCount
         *      alternationStart
         *      alternationEnd
         *      alternationIndex«n»Color, where «n» is an integer
         *      alternationIndex«n»BorderColor, where «n» is an integer
         *      alternationIndex«n»BackgroundColor, where «n» is an integer
         *      «n» (Object), where «n» is a row index
         *          «any valid CSS property» - applied to particular row
         */
        that.style = exportDetails.style;

        that.header = exportDetails.header;
        that.exportHeader = exportDetails.exportHeader || true;
        that.hierarchical = exportDetails.hierarchical;
        that.expandChar = exportDetails.expandChar || '+';
        that.collapseChar = exportDetails.collapseChar || '-';
        that.pageOrientation = exportDetails.pageOrientation;

        if (!that.hierarchical && groupBy && groupBy.length > 0) {
            that.groupBy = groupBy;
        } else {
            that.mergedCells = exportDetails.mergedCells;
        }

        if (!that.groupBy && filterBy && Object.keys(filterBy).length > 0) {
            that.filterBy = filterBy;
        }

        if (conditionalFormatting) {
            that.conditionalFormatting = conditionalFormatting;
        }

        that.timeBetween1900And1970 = new Date(1970, 0, 1).getTime() - new Date(1900, 0, 1).getTime();
    }

    /**
     * Generates and downloads a file.
     */


    babelHelpers.createClass(DataExporter, [{
        key: 'downloadFile',
        value: function downloadFile(data, type, fileName) {
            var file = void 0;

            if (data instanceof Blob) {
                file = data;
            } else {
                file = new Blob([data], { type: type });
            }

            if (window.navigator.msSaveOrOpenBlob) {
                // Edge
                window.navigator.msSaveOrOpenBlob(file, fileName);
            } else {
                // Chrome, Firefox, Safari
                var a = document.createElement('a'),
                    url = URL.createObjectURL(file);

                a.href = url;
                a.download = fileName;
                a.style.position = 'absolute';
                a.style.visibility = 'hidden';

                document.body.appendChild(a);

                a.click();

                setTimeout(function () {
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                }, 0);
            }
        }

        /**
         * Exports data.
         */

    }, {
        key: 'exportData',
        value: function exportData(data, format, fileName) {
            var that = this;

            that.actualHierarchy = that.hierarchical;
            format = format.toLowerCase();

            if (that.exportHeader) {
                if (that.header) {
                    data = data.slice(0);

                    if (data.length === 0) {
                        that.actualHierarchy = false;
                    }

                    that.processComplexHeader(that.header, data, format);
                } else if (data.length === 1) {
                    that.actualHierarchy = false;
                }
            }

            if (data.length === 0) {
                // eslint-disable-next-line
                console.warn('No data to export.');
                return;
            }

            if (format === 'xlsx') {
                that.xlsxStartIndex = that.complexHeader ? that.complexHeader.length : +that.exportHeader;
            }

            if (that.actualHierarchy) {
                data = that.processHierarchicalData(data, format);
            }

            that.getDatafields(data);

            if (fileName.slice(fileName.length - format.length - 1, fileName.length) !== '.' + format) {
                fileName += '.' + format;
            }

            switch (format) {
                case 'csv':
                    that.exportToCSVAndTSV(data, { delimiter: ', ', MIME: 'text/csv', toRemove: 2 }, fileName);
                    break;
                case 'html':
                    that.exportToHTML(data, fileName);
                    break;
                case 'json':
                    that.exportToJSON(data, fileName);
                    break;
                case 'pdf':
                    that.exportToPDF(data, fileName);
                    break;
                case 'tsv':
                    that.exportToCSVAndTSV(data, { delimiter: '\t', MIME: 'text/tab-separated-values', toRemove: 1 }, fileName);
                    break;
                case 'xlsx':
                    that.exportToXLSX(data, fileName);
                    break;
                case 'xml':
                    that.exportToXML(data, fileName);
                    break;
            }

            delete that.complexHeader;
        }

        /**
         * Exports to CSV and TSV.
         */

    }, {
        key: 'exportToCSVAndTSV',
        value: function exportToCSVAndTSV(data, formatOptions, fileName) {
            var that = this,
                datafields = that.datafields;
            var stringResult = '';

            for (var i = 0; i < data.length; i++) {
                var currentRecord = data[i];
                var stringifiedCurrentRecord = '';

                for (var j = 0; j < datafields.length; j++) {
                    if (that.actualHierarchy && j === 0) {
                        stringifiedCurrentRecord += ('""' + formatOptions.delimiter).repeat(currentRecord._level - 1) + '"' + currentRecord[datafields[j]] + '"' + formatOptions.delimiter + ('""' + formatOptions.delimiter).repeat(that.maxLevel - currentRecord._level);
                        continue;
                    }

                    stringifiedCurrentRecord += '"' + currentRecord[datafields[j]] + '"' + formatOptions.delimiter;
                }

                stringifiedCurrentRecord = stringifiedCurrentRecord.slice(0, stringifiedCurrentRecord.length - formatOptions.toRemove) + '\n';
                stringResult += stringifiedCurrentRecord;
            }

            this.downloadFile(stringResult, formatOptions.MIME, fileName);
        }

        /**
         * Exports to HTML.
         */

    }, {
        key: 'exportToHTML',
        value: function exportToHTML(data, fileName) {
            var that = this,
                datafields = that.datafields,
                style = that.style;
            var header = '',
                startIndex = 0;

            data = that.processGroupingInformation(data);
            that.data = data;

            if (that.exportHeader) {
                header = that.getHTMLHeader(datafields, data);
                startIndex = 1;
            }

            var htmlContent = '<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <style type="text/css">\n' + that.getRowStyle() + that.getColumnStyle() + '\n    </style>' + that.toggleableFunctionality() + '\n</head>\n<body>\n    <table' + that.getTableStyle() + '>' + header + '\n        <tbody>\n';

            var mergedMainCells = {},
                mergedSecondaryCells = {},
                groupsHandled = [];

            that.getMergedCellsInfo(mergedMainCells, mergedSecondaryCells);

            mainLoop: for (var i = startIndex; i < data.length; i++) {
                var currentRecord = data[i],
                    row = i - startIndex;
                var n = that.getAlternationIndex(row, ' rowN'),
                    toCollapse = '',
                    level = '',
                    groupId = '',
                    outlineLevel = 0;

                if (that.actualHierarchy) {
                    if (currentRecord._collapsed) {
                        toCollapse = ' collapsed';
                    }

                    level = ' level="' + currentRecord._level + '"';
                } else if (that.groupBy) {
                    for (var k = 0; k < that.groupBy.length; k++) {
                        var datafield = that.groupBy[k],
                            currentGroup = currentRecord[datafield],
                            currentGroupLabel = that.groups[datafield][currentGroup];

                        groupId += currentGroup;

                        if (groupsHandled.indexOf(groupId) === -1) {
                            htmlContent += '            <tr class="row">\n                <td class="column group" style="padding-left: ' + outlineLevel * 25 + 'px;" colspan="' + that.datafields.length + '">' + currentGroupLabel + '</td>\n            </tr>';
                            groupsHandled.push(groupId);
                            i--;
                            continue mainLoop;
                        }

                        outlineLevel++;
                    }
                }

                var currentContent = '            <tr class="row row' + row + n + toCollapse + '"' + level + '>\n';

                for (var j = 0; j < datafields.length; j++) {
                    var cellCode = j + ',' + row;
                    var colspan = 1,
                        rowspan = 1;

                    if (mergedMainCells[cellCode]) {
                        colspan = mergedMainCells[cellCode].colspan;
                        rowspan = mergedMainCells[cellCode].rowspan;
                    } else if (mergedSecondaryCells[cellCode]) {
                        continue;
                    }

                    var _datafield = datafields[j];
                    var value = currentRecord[_datafield],
                        indent = '';

                    if (that.actualHierarchy && j === 0) {
                        var sign = '';

                        if (currentRecord._expanded) {
                            sign = that.collapseChar;
                        } else if (currentRecord._expanded === false) {
                            sign = that.expandChar;
                        }

                        indent = '<div class="toggle-element" style="margin-left: ' + (25 * (currentRecord._level - 1) + 5) + 'px;" expanded>' + sign + '</div>';
                    }

                    value = that.getFormattedValue(value, _datafield);

                    var css = '';

                    if (style && style.columns && style.columns[_datafield] && style.columns[_datafield][row]) {
                        var uniqueStyle = style.columns[_datafield][row];

                        css += 'border-color: ' + uniqueStyle.border + '; background-color: ' + uniqueStyle.background + '; color: ' + uniqueStyle.color + ';"';
                    }

                    if (j === 0 && outlineLevel > 1) {
                        css += 'padding-left: ' + (outlineLevel - 1) * 25 + 'px;"';
                    }

                    if (css) {
                        css = ' style="' + css + '"';
                    }

                    currentContent += '                <td class="column column' + _datafield + '"' + css + ' colspan="' + colspan + '" rowspan="' + rowspan + '">' + (indent + value) + '</td>\n';
                }

                htmlContent += currentContent + '            </tr>\n';
            }

            htmlContent += '        </tbody>\n    </table>\n</body>\n</html>';

            this.downloadFile(htmlContent, 'text/html', fileName);
        }

        /**
         * Gets merged cells information (for use in HTML and PDF export).
         */

    }, {
        key: 'getMergedCellsInfo',
        value: function getMergedCellsInfo(mergedMainCells, mergedSecondaryCells, mapping) {
            var that = this;

            if (!that.mergedCells) {
                return;
            }

            var multipleTables = mapping && mapping[that.datafields.length - 1] !== 0;

            that.mergedCellsPDF = that.mergedCells.slice(0);

            for (var i = 0; i < that.mergedCellsPDF.length; i++) {
                var cellDefinition = that.mergedCellsPDF[i];
                var colspan = cellDefinition.colspan,
                    rowspan = cellDefinition.rowspan;

                if (rowspan < 2 && colspan < 2) {
                    continue;
                }

                var row = cellDefinition.cell[1];
                var col = cellDefinition.cell[0];

                if (multipleTables && colspan > 1) {
                    var startTable = mapping[col],
                        endTable = mapping[col + colspan - 1],
                        splitCells = [];

                    if (endTable > startTable) {
                        var currentTable = startTable,
                            currentColumn = col,
                            overal = 0;

                        mainLoop: for (var _i = startTable; _i <= endTable; _i++) {
                            var start = currentColumn,
                                span = 0;

                            while (mapping[currentColumn] === currentTable) {
                                currentColumn++;
                                overal++;
                                span++;

                                if (overal === colspan) {
                                    splitCells.push({ start: start, span: span });
                                    break mainLoop;
                                }
                            }

                            splitCells.push({ start: start, span: span });
                            currentTable = mapping[currentColumn];
                        }

                        colspan = splitCells[0].span;

                        for (var _i2 = 1; _i2 < splitCells.length; _i2++) {
                            that.mergedCellsPDF.push({ cell: [splitCells[_i2].start, row], colspan: splitCells[_i2].span, rowspan: rowspan, originalCell: col });
                        }
                    }
                }

                for (var j = col; j < col + colspan; j++) {
                    for (var k = row; k < row + rowspan; k++) {
                        var code = j + ',' + k;

                        if (j === col && k === row) {
                            mergedMainCells[code] = { colspan: colspan, rowspan: rowspan, originalCell: cellDefinition.originalCell };
                            continue;
                        }

                        mergedSecondaryCells[code] = true;
                    }
                }
            }
        }

        /**
         * Gets alternation index.
         */

    }, {
        key: 'getAlternationIndex',
        value: function getAlternationIndex(row, prefix) {
            var that = this;

            if (!that.style) {
                return '';
            }

            var rowsDefinition = that.style.rows,
                alternationCount = rowsDefinition && rowsDefinition.alternationCount;

            if (alternationCount && !(rowsDefinition.alternationStart && row < rowsDefinition.alternationStart) && !(rowsDefinition.alternationEnd && row > rowsDefinition.alternationEnd)) {
                return prefix + row % rowsDefinition.alternationCount;
            }

            return '';
        }

        /**
         * Gets formatted numeric or date value (for use in HTML and PDF export).
         */

    }, {
        key: 'getFormattedValue',
        value: function getFormattedValue(value, datafield) {
            var that = this,
                style = that.style;

            if (datafield && style && style.columns && style.columns[datafield] && style.columns[datafield].format) {
                if (typeof value === 'number') {
                    return that.formatNumber(value, style.columns[datafield].format);
                } else if (value instanceof Date) {
                    return that.formatDate(value, style.columns[datafield].format);
                }
            } else if (value instanceof Date) {
                return that.formatDate(value, 'd');
            }

            return value;
        }

        /**
         * Exports to JSON.
         */

    }, {
        key: 'exportToJSON',
        value: function exportToJSON(data, fileName) {
            this.downloadFile(JSON.stringify(data, this.datafields.concat('rows')), 'application/json', fileName);
        }

        /**
         * Exports to PDF.
         */

    }, {
        key: 'exportToPDF',
        value: function exportToPDF(data, fileName) {
            var that = this,
                datafields = that.datafields,
                startIndex = +that.exportHeader,
                groupsHandled = [],
                mergedMainCells = {},
                mergedSecondaryCells = {},
                mapping = {},
                headerRows = startIndex ? that.complexHeader ? that.complexHeader.length : 1 : 0,
                docDefinition = {
                pageOrientation: that.pageOrientation || 'portrait'
            };
            var header = [],
                content = [],
                tables = void 0;

            function createTableRow() {
                var tableRow = [];

                for (var i = 0; i < tables.length; i++) {
                    tableRow.push([]);
                }

                return tableRow;
            }

            data = that.processGroupingInformation(data);
            that.data = data;
            that.headerRows = headerRows;
            that.getPDFStyle();

            var styleInfo = that.styleInfo;

            tables = styleInfo ? that.wrapPDFColumns(docDefinition, mapping) : [{ body: header, datafields: datafields }];

            if (startIndex) {
                header = that.getPDFHeader(datafields, tables, mapping);
            }

            that.getMergedCellsInfo(mergedMainCells, mergedSecondaryCells, mapping);

            mainLoop: for (var i = startIndex; i < data.length; i++) {
                var currentRecord = data[i];
                var groupId = '',
                    outlineLevel = 0;

                if (that.groupBy) {
                    for (var k = 0; k < that.groupBy.length; k++) {
                        var datafield = that.groupBy[k],
                            currentGroup = currentRecord[datafield],
                            currentGroupLabel = that.groups[datafield][currentGroup];

                        groupId += currentGroup;

                        if (groupsHandled.indexOf(groupId) === -1) {
                            that.createGroupHeaderRow(tables, { text: currentGroupLabel, style: ['row', 'cell', 'group'], marginLeft: outlineLevel * 7.5 });
                            groupsHandled.push(groupId);
                            i--;
                            continue mainLoop;
                        }

                        outlineLevel++;
                    }
                }

                var tableRow = createTableRow(),
                    row = i - startIndex;
                var n = that.getAlternationIndex(row, '');

                for (var j = 0; j < datafields.length; j++) {
                    var _datafield2 = datafields[j],
                        entry = { style: ['row', 'row' + row, 'cell', 'cell' + _datafield2] },
                        tableIndex = mapping[j] || 0;

                    if (n !== undefined) {
                        entry.style.splice(1, 0, 'rowN' + n);
                    }

                    if (that.mergedCellsPDF) {
                        var cellCode = j + ',' + row,
                            mergeInfo = mergedMainCells[cellCode];

                        if (mergeInfo) {
                            entry.colSpan = mergeInfo.colspan;
                            entry.rowSpan = mergeInfo.rowspan;

                            if (mergeInfo.originalCell !== undefined) {
                                entry.text = '';
                                entry.style[entry.style.length - 1] = 'cell' + datafields[mergeInfo.originalCell];
                                tableRow[tableIndex].push(entry);
                                continue;
                            }
                        } else if (mergedSecondaryCells[cellCode]) {
                            tableRow[tableIndex].push({});
                            continue;
                        }
                    }

                    var value = that.getFormattedValue(currentRecord[_datafield2], _datafield2);

                    entry.text = value.toString();
                    that.getUniqueStylePDF(entry, _datafield2, row);
                    that.setIndentation(entry, { j: j, currentRecord: currentRecord, value: value, outlineLevel: outlineLevel });
                    tableRow[tableIndex].push(entry);
                }

                for (var _k = 0; _k < tables.length; _k++) {
                    tables[_k].body.push(tableRow[_k]);
                }
            }

            if (styleInfo) {
                for (var _i3 = 0; _i3 < tables.length; _i3++) {
                    var body = tables[_i3].body;

                    for (var _j = headerRows - 1; _j >= 0; _j--) {
                        body.unshift(header[_i3][_j]);
                    }

                    content.push({
                        table: {
                            headerRows: headerRows,
                            widths: tables[_i3].widths,
                            heights: function heights(row) {
                                if (styleInfo.heights[row]) {
                                    return styleInfo.heights[row];
                                }

                                if (styleInfo.defaultHeight) {
                                    return styleInfo.defaultHeight;
                                }
                            },
                            body: body
                        },
                        pageBreak: 'after'
                    });
                }

                delete content[tables.length - 1].pageBreak;
                docDefinition.styles = styleInfo.styles;
            } else {
                var _body = tables[0].body;

                for (var _j2 = headerRows - 1; _j2 >= 0; _j2--) {
                    _body.unshift(header[0][_j2]);
                }

                content = [{ table: { headerRows: headerRows, body: _body } }];
                docDefinition.styles = { header: { bold: true }, group: { bold: true } };
            }

            docDefinition.content = content;
            pdfMake.createPdf(docDefinition).download(fileName);

            delete that.mergedCellsPDF;
            delete that.styleInfo;
        }

        /**
         * Gets the header content when exporting to PDF.
         */

    }, {
        key: 'getPDFStyle',
        value: function getPDFStyle() {
            var that = this,
                style = that.style;

            if (!style) {
                return '';
            }

            var sampleRecord = that.data[0],
                headerDefinition = style.header,
                columnsDefinition = style.columns,
                rowsDefinition = style.rows,
                styleInfo = {
                heights: [],
                widths: Array(that.datafields.length).fill('*'),
                styles: {
                    header: {},
                    row: {},
                    cell: {},
                    group: { fillColor: '#FFFFFF', color: '#000000', bold: true }
                }
            };

            that.styleInfo = styleInfo;

            function processStyleDefinition(definition, type) {
                if (!definition) {
                    return;
                }

                for (var prop in definition) {
                    if (!definition.hasOwnProperty(prop)) {
                        continue;
                    }

                    if (sampleRecord[prop] === undefined) {
                        if (prop === 'height' && type === 'header') {
                            for (var i = 0; i < that.headerRows; i++) {
                                styleInfo.heights[i] = parseInt(definition[prop], 10) / that.headerRows / 1.57;
                            }
                        } else {
                            that.storePDFStyle({ prop: prop, value: definition[prop], toUpdate: type });
                        }
                    } else {
                        for (var columnProp in definition[prop]) {
                            if (!isNaN(columnProp) || !definition[prop].hasOwnProperty(columnProp)) {
                                continue;
                            }

                            var value = definition[prop][columnProp],
                                index = that.datafields.indexOf(prop);

                            if (columnProp === 'width' && styleInfo.widths[index] === '*') {
                                styleInfo.widths[index] = parseFloat(value);
                            } else {
                                that.storePDFStyle({ prop: columnProp, value: value, toUpdate: type + prop });
                            }
                        }
                    }
                }
            }

            processStyleDefinition(headerDefinition, 'header');
            processStyleDefinition(columnsDefinition, 'cell');

            if (!rowsDefinition) {
                return;
            }

            for (var prop in rowsDefinition) {
                if (!rowsDefinition.hasOwnProperty(prop) || prop.indexOf('alt') !== -1) {
                    continue;
                }

                var value = rowsDefinition[prop];

                if (!isNaN(prop)) {
                    for (var rowProp in value) {
                        if (value.hasOwnProperty(rowProp)) {
                            if (rowProp === 'height') {
                                styleInfo.heights[parseFloat(prop) + that.headerRows] = parseFloat(value[rowProp]) / 1.57;
                            } else {
                                that.storePDFStyle({ prop: rowProp, value: value[rowProp], toUpdate: 'row' + prop });
                            }
                        }
                    }

                    continue;
                }

                if (prop === 'height') {
                    styleInfo.defaultHeight = parseFloat(value) / 1.57;
                } else {
                    that.storePDFStyle({ prop: prop, value: value, toUpdate: 'row' });
                }
            }

            if (!rowsDefinition.alternationCount) {
                return;
            }

            for (var i = 0; i < rowsDefinition.alternationCount; i++) {
                var styleN = {};

                if (rowsDefinition['alternationIndex' + i + 'Color']) {
                    styleN.color = rowsDefinition['alternationIndex' + i + 'Color'];
                }

                if (rowsDefinition['alternationIndex' + i + 'BackgroundColor']) {
                    styleN.fillColor = rowsDefinition['alternationIndex' + i + 'BackgroundColor'];
                }

                styleInfo.styles['rowN' + i] = styleN;
            }
        }

        /**
         * Stores style in object to be applied to generated PDF.
         */

    }, {
        key: 'storePDFStyle',
        value: function storePDFStyle(details) {
            var that = this;
            var objectToUpdate = that.styleInfo.styles[details.toUpdate];

            if (!objectToUpdate) {
                objectToUpdate = {};
                that.styleInfo.styles[details.toUpdate] = objectToUpdate;
            }

            var value = details.value;

            switch (details.prop) {
                case 'backgroundColor':
                    objectToUpdate.fillColor = value;
                    break;
                case 'color':
                    objectToUpdate.color = value;
                    break;
                case 'fontSize':
                    objectToUpdate.fontSize = parseFloat(value);
                    break;
                case 'fontStyle':
                    if (value === 'italic') {
                        objectToUpdate.italics = true;
                    }

                    break;
                case 'fontWeight':
                    if (value === 'bold') {
                        objectToUpdate.bold = true;
                    }

                    break;
                case 'textAlign':
                    objectToUpdate.alignment = value;
                    break;
            }
        }

        /**
         * Enables column wrapping when exporting to PDF.
         */

    }, {
        key: 'wrapPDFColumns',
        value: function wrapPDFColumns(docDefinition, mapping) {
            var that = this,
                styleInfo = this.styleInfo,
                maxPerPage = docDefinition.pageOrientation === 'portrait' ? 775 : 1155,
                // maximum of 775px (portrait) or 1155px (landscape) per A4 page
            tables = [];
            var currentPage = 0;

            for (var i = 0; i < styleInfo.widths.length; i++) {
                var currentWidth = styleInfo.widths[i],
                    numericWidth = currentWidth;

                if (currentWidth === '*') {
                    numericWidth = 150;
                } else if (currentWidth >= maxPerPage) {
                    numericWidth = maxPerPage;
                    currentWidth = '*';
                } else {
                    currentWidth /= 1.57;
                }

                if (tables[currentPage] === undefined) {
                    var body = [];

                    tables[currentPage] = {
                        body: body,
                        width: numericWidth,
                        widths: [currentWidth],
                        datafields: [that.datafields[i]]
                    };
                    mapping[i] = currentPage;
                    continue;
                }

                var table = tables[currentPage];

                if (table.width + numericWidth > maxPerPage) {
                    currentPage++;
                    i--;
                    continue;
                }

                mapping[i] = currentPage;
                table.width += numericWidth;
                table.widths.push(currentWidth);
                table.datafields.push(that.datafields[i]);
            }

            return tables;
        }

        /**
         * Gets the header content when exporting to PDF.
         */

    }, {
        key: 'getPDFHeader',
        value: function getPDFHeader(datafields, tables, mapping) {
            var that = this,
                headerArray = [],
                headerRows = that.headerRows,
                headerStructure = that.complexHeader ? that.complexHeader : [Object.values(that.data[0])],
                headers = [];
            var result = [];

            for (var i = 0; i < headerRows; i++) {
                var row = headerStructure[i];

                for (var k = 0; k < row.length; k++) {
                    var tableIndex = mapping[k] || 0;

                    if (!headers[tableIndex]) {
                        headers[tableIndex] = [];
                    }

                    if (!headers[tableIndex][i]) {
                        headers[tableIndex][i] = [];
                    }

                    headers[tableIndex][i].push(row[k]);
                }
            }

            function processHeader(header, result, table) {
                for (var j = 0; j < headerRows; j++) {
                    var _row = header[j];
                    var tableRow = [];

                    for (var _k2 = 0; _k2 < _row.length; _k2++) {
                        var currentLabel = _row[_k2];
                        var colspan = 1,
                            rowspan = 1;

                        if (_row[_k2 - 1] && _row[_k2 - 1] === currentLabel || header[j - 1] && header[j - 1][_k2] === currentLabel) {
                            tableRow.push({});
                            continue;
                        }

                        var iterator = _k2 + 1;

                        while (_row[iterator] && _row[iterator] === _row[iterator - 1]) {
                            colspan++;
                            iterator++;
                        }

                        iterator = j + 1;

                        while (header[iterator] && header[iterator][_k2] === currentLabel) {
                            rowspan++;
                            iterator++;
                        }

                        var datafield = j === headerRows - 1 || rowspan + j === headerRows ? table.datafields[_k2] : null,
                            entry = {
                            text: currentLabel, colSpan: colspan, rowSpan: rowspan
                        };

                        if (!datafield) {
                            entry.alignment = 'center';
                            entry.style = 'header';
                        } else {
                            entry.style = ['header', 'header' + datafield];
                        }

                        tableRow.push(entry);
                    }

                    result.push(tableRow);
                }
            }

            for (var _i4 = 0; _i4 < tables.length; _i4++) {
                result = [];
                processHeader(headers[_i4], result, tables[_i4]);
                headerArray.push(result);
            }

            return headerArray;
        }

        /**
         * Creates group header rows when exporting to PDF.
         */

    }, {
        key: 'createGroupHeaderRow',
        value: function createGroupHeaderRow(tables, entryTemplate) {
            for (var i = 0; i < tables.length; i++) {
                var entry = Object.assign({}, entryTemplate),
                    colspan = tables[i].datafields.length,
                    tableRow = [entry];

                entry.colSpan = colspan;
                tableRow.length = colspan;
                tableRow.fill({}, 1, colspan - 1);

                tables[i].body.push(tableRow);
            }
        }

        /**
         * Gets unique cell style when exporting to PDF.
         */

    }, {
        key: 'getUniqueStylePDF',
        value: function getUniqueStylePDF(entry, datafield, row) {
            var style = this.style;

            function toHex(background) {
                var parts = /rgba\((\d+),(\d+),(\d+)\,(\d*.\d+|\d+)\)/gi.exec(background.replace(/\s/g, '')),
                    r = parseFloat(parts[1]).toString(16).toUpperCase(),
                    g = parseFloat(parts[2]).toString(16).toUpperCase(),
                    b = parseFloat(parts[3]).toString(16).toUpperCase();

                return '#' + '0'.repeat(2 - r.length) + r + '0'.repeat(2 - g.length) + g + '0'.repeat(2 - b.length) + b;
            }

            if (!style || !style.columns || !style.columns[datafield]) {
                return;
            }

            var uniqueStyle = style.columns[datafield][row];

            if (!uniqueStyle) {
                return;
            }

            entry.fillColor = toHex(uniqueStyle.background);
            entry.color = uniqueStyle.color.toLowerCase();
        }

        /**
         * Sets the indentation of a PDF cell.
         */

    }, {
        key: 'setIndentation',
        value: function setIndentation(entry, details) {
            if (details.j !== 0) {
                return;
            }

            var that = this;

            if (that.actualHierarchy) {
                var currentRecord = details.currentRecord;

                if (currentRecord._expanded !== undefined) {
                    entry.marginLeft = 25 * (currentRecord._level - 1);
                    entry.text = that.collapseChar + ' ' + details.value;
                } else {
                    entry.marginLeft = 25 * (currentRecord._level - 1) + 6;
                }
            } else if (details.outlineLevel > 1) {
                entry.marginLeft = (details.outlineLevel - 1) * 7.5;
            }
        }

        /**
         * Exports to XLSX.
         */

    }, {
        key: 'exportToXLSX',
        value: function exportToXLSX(data, fileName) {
            var that = this;
            var style = that.style;

            data = that.processGroupingInformation(data, true);
            that.data = data;
            that.getColumnsArray();

            that.complexHeaderMergedCells = [];

            if (that.complexHeaderMergeInfo) {
                for (var cell in that.complexHeaderMergeInfo) {
                    if (that.complexHeaderMergeInfo.hasOwnProperty(cell)) {
                        var currentEntry = that.complexHeaderMergeInfo[cell];

                        if (currentEntry.from[0] === currentEntry.to[0] && currentEntry.from[1] === currentEntry.to[1]) {
                            continue;
                        }

                        that.complexHeaderMergedCells.push({
                            from: that.columnsArray[currentEntry.from[1]] + (currentEntry.from[0] + 1),
                            to: that.columnsArray[currentEntry.to[1]] + (currentEntry.to[0] + 1)
                        });
                    }
                }
            }

            that.getConditionalFormatting();

            if (!style) {
                style = that.generateDefaultStyle(data);
            }

            var sharedStrings = that.generateSharedStrings(data),
                sharedStringsCollection = sharedStrings.collection,
                sharedStringsXML = sharedStrings.xml,
                stylesXML = that.generateStyles(style),
                sheet1XML = that.groupBy ? that.generateSheet1WithGrouping(data, sharedStringsCollection) : that.generateSheet1(data, sharedStringsCollection),
                auxiliaryFiles = that.generateAuxiliaryFiles(),


            // eslint-disable-next-line
            zip = new JSZip(),
                _rels = zip.folder('_rels'),
                docProps = zip.folder('docProps'),
                xl = zip.folder('xl'),
                xl_rels = xl.folder('_rels'),
                theme = xl.folder('theme'),
                worksheets = xl.folder('worksheets');

            _rels.file('.rels', auxiliaryFiles._relsRels);
            docProps.file('app.xml', auxiliaryFiles.docPropsAppXml);
            docProps.file('core.xml', auxiliaryFiles.docPropsCoreXml);
            xl_rels.file('workbook.xml.rels', auxiliaryFiles.xl_relsWorkbookXmlRels);
            theme.file('theme1.xml', auxiliaryFiles.xlThemeTheme1Xml);
            worksheets.file('sheet1.xml', sheet1XML);
            xl.file('sharedStrings.xml', sharedStringsXML);
            xl.file('styles.xml', stylesXML);
            xl.file('workbook.xml', auxiliaryFiles.xlWorkbookXml);
            zip.file('[Content_Types].xml', auxiliaryFiles.Content_TypesXml);

            zip.generateAsync({
                type: 'blob',
                mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            }).then(function (content) {
                that.downloadFile(content, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', fileName);
            });

            delete that.conditionalFormattingXLSX;
            delete that.complexHeaderMergeInfo;
            delete that.defaultRowHeight;
            delete that.rowHeight;
        }

        /**
         * Processes grouping information.
         */

    }, {
        key: 'processGroupingInformation',
        value: function processGroupingInformation(data, xlsx) {
            var that = this;

            if (!that.groupBy) {
                return data;
            }

            var header = void 0;

            data = data.slice(0);

            if (that.exportHeader) {
                if (xlsx && that.complexHeader) {
                    header = data.slice(0, that.complexHeader.length);
                    data.splice(0, that.complexHeader.length);
                } else {
                    header = [data[0]];
                    data.splice(0, 1);
                }
            }

            if (data.length > 1) {
                var getCompareFunction = function getCompareFunction(a, knownDataType) {
                    // gets data type of column (not necessary if the Grid provides this information)
                    var dataType = knownDataType || (typeof a === 'undefined' ? 'undefined' : babelHelpers.typeof(a));
                    var compareFunction = void 0;

                    switch (dataType) {
                        case 'string':
                            compareFunction = new Intl.Collator().compare;
                            break;
                        case 'number':
                            compareFunction = function compareFunction(a, b) {
                                return a - b;
                            };
                            break;
                        case 'boolean':
                        case 'bool':
                            compareFunction = function compareFunction(a, b) {
                                if (a === b) {
                                    return 0;
                                } else if (a === false) {
                                    return -1;
                                } else {
                                    return 1;
                                }
                            };
                            break;
                        case 'date':
                        case 'time':
                        case 'dateTime':
                            if (a instanceof Date) {
                                compareFunction = function compareFunction(a, b) {
                                    return a.getTime() - b.getTime();
                                };
                            } else if (a instanceof JQX.Utilities.DateTime || a instanceof JQX.Utilities.BigNumber) {
                                compareFunction = function compareFunction(a, b) {
                                    return a.compare(b);
                                };
                            }
                            break;
                        case 'object':
                            if (a instanceof Date) {
                                compareFunction = function compareFunction(a, b) {
                                    return a.getTime() - b.getTime();
                                };
                            } else if (a instanceof JQX.Utilities.DateTime || a instanceof JQX.Utilities.BigNumber) {
                                compareFunction = function compareFunction(a, b) {
                                    return a.compare(b);
                                };
                            } else if (a instanceof JQX.Utilities.Complex || window.NIComplex && a instanceof window.NIComplex) {
                                var complexNumericProcessor = new JQX.Utilities.ComplexNumericProcessor();

                                compareFunction = function compareFunction(a, b) {
                                    return complexNumericProcessor.compareComplexNumbers(a, b);
                                };
                            }

                            break;
                    }

                    return compareFunction;
                };

                var sortByMultipleColumns = function sortByMultipleColumns(dataSource, sortColumns, directions, customSortingCallback) {
                    if (!dataSource || !Array.isArray(dataSource) || dataSource.length === 0 || !sortColumns || Array.isArray(sortColumns) && sortColumns.length === 0) {
                        return;
                    }

                    if (typeof sortColumns === 'string') {
                        sortColumns = [sortColumns];
                    }

                    var directionCoefficients = [],
                        compareFunctions = [];

                    if (directions === undefined) {
                        directions = [];
                    }

                    for (var i = 0; i < sortColumns.length; i++) {
                        if (directions[i] === undefined || directions[i] === 'asc' || directions[i] === 'ascending') {
                            directionCoefficients[i] = 1;
                        } else {
                            directionCoefficients[i] = -1;
                        }

                        compareFunctions[i] = getCompareFunction(dataSource[0][sortColumns[i]]);
                    }

                    if (customSortingCallback) {
                        customSortingCallback(dataSource, sortColumns, directions, compareFunctions);
                        return;
                    }

                    dataSource.sort(function (a, b) {
                        for (var _i5 = 0; _i5 < sortColumns.length; _i5++) {
                            var result = compareFunctions[_i5](a[sortColumns[_i5]], b[sortColumns[_i5]]);

                            if (result === 0) {
                                if (sortColumns[_i5 + 1]) {
                                    continue;
                                } else if (a._index !== undefined) {
                                    // makes sorting stable
                                    return (a._index - b._index) * directionCoefficients[_i5];
                                }

                                return 0;
                            }

                            return result * directionCoefficients[_i5];
                        }
                    });
                };

                sortByMultipleColumns(data, that.groupBy);
            }

            if (header) {
                data = header.concat(data);
            }

            that.getGroupLabels(data);

            return data;
        }

        /**
         * Exports to XML.
         */

    }, {
        key: 'exportToXML',
        value: function exportToXML(data, fileName) {
            var datafields = this.datafields.slice(0);
            var xmlContent = '<?xml version="1.0" encoding="UTF-8" ?>\n<table>\n';

            if (datafields.indexOf('rows') === -1) {
                datafields.push('rows');
            }

            function recursion(records, indent) {
                var content = '';

                for (var i = 0; i < records.length; i++) {
                    var currentRecord = records[i];

                    content += indent + '<row>\n';

                    for (var j = 0; j < datafields.length; j++) {
                        var datafield = datafields[j];

                        if (datafield === 'rows') {
                            if (!currentRecord.rows) {
                                continue;
                            }

                            content += indent + '    <rows>\n' + recursion(currentRecord.rows, indent + '        ') + indent + '    </rows>\n';
                            continue;
                        }

                        content += indent + ('    <' + datafield + '>' + currentRecord[datafield] + '</' + datafield + '>\n');
                    }

                    content += indent + '</row>\n';
                }

                return content;
            }

            xmlContent += recursion(data, '    ') + '</table>';

            this.downloadFile(xmlContent, 'application/xml', fileName);
        }

        /**
         * Formats a date.
         */

    }, {
        key: 'formatDate',
        value: function formatDate(value, format) {
            if (!JQX.Utilities.DateTime) {
                return value;
            }

            try {
                return new JQX.Utilities.DateTime(value).toString(format);
            } catch (e) {
                return value;
            }
        }

        /**
         * Formats a number.
         */

    }, {
        key: 'formatNumber',
        value: function formatNumber(value, format) {
            if (!JQX.Utilities.NumberRenderer) {
                return value;
            }

            var renderer = new JQX.Utilities.NumberRenderer(),
                result = renderer.formatNumber(value, format);

            if (result === undefined) {
                return value;
            }

            return result;
        }

        /**
         * Generates auxiliary files necessary for XLSX.
         */

    }, {
        key: 'generateAuxiliaryFiles',
        value: function generateAuxiliaryFiles() {
            // _rels\.rels
            var _relsRels = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>';

            // docProps\app.xml
            var docPropsAppXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"><Application>Microsoft Excel</Application><DocSecurity>0</DocSecurity><ScaleCrop>false</ScaleCrop><HeadingPairs><vt:vector size="2" baseType="variant"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant><vt:i4>1</vt:i4></vt:variant></vt:vector></HeadingPairs><TitlesOfParts><vt:vector size="1" baseType="lpstr"><vt:lpstr>Sheet1</vt:lpstr></vt:vector></TitlesOfParts><Company></Company><LinksUpToDate>false</LinksUpToDate><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0300</AppVersion></Properties>';

            // docProps\core.xml
            var now = new Date().toISOString(),
                docPropsCoreXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dc:creator>Smart HTML Elements</dc:creator><cp:lastModifiedBy>Smart HTML Elements</cp:lastModifiedBy><dcterms:created xsi:type="dcterms:W3CDTF">' + now + '</dcterms:created><dcterms:modified xsi:type="dcterms:W3CDTF">' + now + '</dcterms:modified></cp:coreProperties>';

            // xl\_rels\workbook.xml.rels
            var xl_relsWorkbookXmlRels = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="theme/theme1.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/><Relationship Id="rId4" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml"/></Relationships>';

            // xl\theme\theme1.xml
            var xlThemeTheme1Xml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="4472C4"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="5B9BD5"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Calibri Light" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="\u6E38\u30B4\u30B7\u30C3\u30AF Light"/><a:font script="Hang" typeface="\uB9D1\uC740 \uACE0\uB515"/><a:font script="Hans" typeface="\u7B49\u7EBF Light"/><a:font script="Hant" typeface="\u65B0\u7D30\u660E\u9AD4"/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/><a:font script="Armn" typeface="Arial"/><a:font script="Bugi" typeface="Leelawadee UI"/><a:font script="Bopo" typeface="Microsoft JhengHei"/><a:font script="Java" typeface="Javanese Text"/><a:font script="Lisu" typeface="Segoe UI"/><a:font script="Mymr" typeface="Myanmar Text"/><a:font script="Nkoo" typeface="Ebrima"/><a:font script="Olck" typeface="Nirmala UI"/><a:font script="Osma" typeface="Ebrima"/><a:font script="Phag" typeface="Phagspa"/><a:font script="Syrn" typeface="Estrangelo Edessa"/><a:font script="Syrj" typeface="Estrangelo Edessa"/><a:font script="Syre" typeface="Estrangelo Edessa"/><a:font script="Sora" typeface="Nirmala UI"/><a:font script="Tale" typeface="Microsoft Tai Le"/><a:font script="Talu" typeface="Microsoft New Tai Lue"/><a:font script="Tfng" typeface="Ebrima"/></a:majorFont><a:minorFont><a:latin typeface="Calibri" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="\u6E38\u30B4\u30B7\u30C3\u30AF"/><a:font script="Hang" typeface="\uB9D1\uC740 \uACE0\uB515"/><a:font script="Hans" typeface="\u7B49\u7EBF"/><a:font script="Hant" typeface="\u65B0\u7D30\u660E\u9AD4"/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/><a:font script="Armn" typeface="Arial"/><a:font script="Bugi" typeface="Leelawadee UI"/><a:font script="Bopo" typeface="Microsoft JhengHei"/><a:font script="Java" typeface="Javanese Text"/><a:font script="Lisu" typeface="Segoe UI"/><a:font script="Mymr" typeface="Myanmar Text"/><a:font script="Nkoo" typeface="Ebrima"/><a:font script="Olck" typeface="Nirmala UI"/><a:font script="Osma" typeface="Ebrima"/><a:font script="Phag" typeface="Phagspa"/><a:font script="Syrn" typeface="Estrangelo Edessa"/><a:font script="Syrj" typeface="Estrangelo Edessa"/><a:font script="Syre" typeface="Estrangelo Edessa"/><a:font script="Sora" typeface="Nirmala UI"/><a:font script="Tale" typeface="Microsoft Tai Le"/><a:font script="Talu" typeface="Microsoft New Tai Lue"/><a:font script="Tfng" typeface="Ebrima"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>';

            // xl\workbook.xml
            var xlWorkbookXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x15 xr xr6 xr10 xr2" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision" xmlns:xr6="http://schemas.microsoft.com/office/spreadsheetml/2016/revision6" xmlns:xr10="http://schemas.microsoft.com/office/spreadsheetml/2016/revision10" xmlns:xr2="http://schemas.microsoft.com/office/spreadsheetml/2015/revision2"><fileVersion appName="xl" lastEdited="7" lowestEdited="7" rupBuild="20325"/><workbookPr defaultThemeVersion="166925"/><mc:AlternateContent xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"><mc:Choice Requires="x15"><x15ac:absPath url="C:UsersjqwidgetsDesktop" xmlns:x15ac="http://schemas.microsoft.com/office/spreadsheetml/2010/11/ac"/></mc:Choice></mc:AlternateContent><xr:revisionPtr revIDLastSave="0" documentId="13_ncr:1_{0DEDCB6D-5403-4CD8-AAA5-59B6D238A8B6}" xr6:coauthVersionLast="34" xr6:coauthVersionMax="34" xr10:uidLastSave="{00000000-0000-0000-0000-000000000000}"/><bookViews><workbookView xWindow="0" yWindow="0" windowWidth="19200" windowHeight="6950" xr2:uid="{0CB664E6-3800-4A88-B158-B46A682E7484}"/></bookViews><sheets><sheet name="Sheet1" sheetId="1" r:id="rId1"/></sheets><calcPr calcId="179021"/><extLst><ext uri="{140A7094-0E35-4892-8432-C4D2E57EDEB5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:workbookPr chartTrackingRefBase="1"/></ext></extLst></workbook>';

            // [Content_Types].xml
            var Content_TypesXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types"><Default Extension="bin" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings"/><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/><Default Extension="xml" ContentType="application/xml"/><Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/><Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/><Override PartName="/xl/theme/theme1.xml" ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/><Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/><Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/><Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/><Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/></Types>';

            return {
                _relsRels: _relsRels,
                docPropsAppXml: docPropsAppXml,
                docPropsCoreXml: docPropsCoreXml,
                xl_relsWorkbookXmlRels: xl_relsWorkbookXmlRels,
                xlThemeTheme1Xml: xlThemeTheme1Xml,
                xlWorkbookXml: xlWorkbookXml,
                Content_TypesXml: Content_TypesXml
            };
        }

        /**
         * Generates default style object (for use in XLSX export).
         */

    }, {
        key: 'generateDefaultStyle',
        value: function generateDefaultStyle(data) {
            var that = this,
                defaultStyle = {},
                datafields = that.datafields,
                firstRecord = that.complexHeader ? data[that.complexHeader.length] : data[+that.exportHeader];

            if (!firstRecord) {
                return defaultStyle;
            }

            for (var i = 0; i < datafields.length; i++) {
                var sampleValue = firstRecord[datafields[i]];

                if (sampleValue instanceof Date) {
                    if (!defaultStyle.columns) {
                        defaultStyle.columns = [];
                    }

                    defaultStyle.columns[datafields[i]] = { format: 'd' };
                }
            }

            return defaultStyle;
        }

        /**
         * Generates group row.
         */

    }, {
        key: 'generateGroupRow',
        value: function generateGroupRow(details) {
            var rowNumber = details.rowNumber,
                from = 'A' + rowNumber,
                recordXML = '        <row r="' + rowNumber + '" outlineLevel="' + details.outlineLevel + '" spans="1:' + details.numberOfColumns + '"' + this.getCustomRowHeight(rowNumber - 1) + ' x14ac:dyDescent="0.45">\n            <c r="' + from + '" t="s" s="0">\n                <v>' + details.sharedStringIndex + '</v>\n            </c>\n        </row>\n';

            details.mergedCells.push({ from: from, to: this.columnsArray[details.numberOfColumns - 1] + rowNumber });

            return recordXML;
        }

        /**
         * Generates sharedStrings.xml.
         */

    }, {
        key: 'generateSharedStrings',
        value: function generateSharedStrings(data) {
            var that = this,
                datafields = that.datafields,
                collection = [];
            var xml = '',
                count = 0,
                uniqueCount = 0;

            function addSharedString(currentValue) {
                count++;

                if (collection.indexOf(currentValue) === -1) {
                    uniqueCount++;
                    collection.push(currentValue);

                    xml += '<si><t>' + currentValue + '</t></si>';
                }
            }

            for (var i = 0; i < data.length; i++) {
                var currentRecord = data[i];

                for (var j = 0; j < datafields.length; j++) {
                    var currentValue = currentRecord[datafields[j]];

                    if (typeof currentValue !== 'string') {
                        continue;
                    }

                    addSharedString(currentValue);
                }
            }

            if (that.groupLabels) {
                for (var _i6 = 0; _i6 < that.groupLabels.length; _i6++) {
                    addSharedString(that.groupLabels[_i6]);
                }
            }

            xml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="' + count + '" uniqueCount="' + uniqueCount + '">' + xml + '</sst>';

            return { collection: collection, xml: xml };
        }

        /**
         * Generates sheet1.xml.
         */

    }, {
        key: 'generateSheet1',
        value: function generateSheet1(data, sharedStrings) {
            var that = this,
                numberOfColumns = that.columnsArray.length,
                numberOfRows = data.length,
                dimensionEnd = that.columnsArray[numberOfColumns - 1] + numberOfRows,
                datafields = that.datafields,
                autoFilter = that.getFilters(),
                mergedCells = [].concat(that.complexHeaderMergedCells);

            var xmlContent = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac xr xr2 xr3" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision" xmlns:xr2="http://schemas.microsoft.com/office/spreadsheetml/2015/revision2" xmlns:xr3="http://schemas.microsoft.com/office/spreadsheetml/2016/revision3" xr:uid="{7F25248B-C640-4C64-AD47-C0EA0E5D90D0}">\n    <sheetPr filterMode="' + (autoFilter !== '') + '" />\n    <dimension ref="A1:' + dimensionEnd + '" />\n    <sheetViews>\n        <sheetView tabSelected="1" workbookViewId="0" />\n    </sheetViews>\n    <sheetFormatPr defaultRowHeight="14.5" x14ac:dyDescent="0.35" />' + that.getCustomColumnWidths() + '\n    <sheetData>\n';

            function r(col, row) {
                return that.columnsArray[col] + row;
            }

            for (var i = 0; i <= data.length; i++) {
                var currentRecord = data[i],
                    rowNumber = i + 1;
                var collapsed = '';

                if (that.actualHierarchy) {
                    var previousRecord = data[i - 1];

                    if (previousRecord && previousRecord._collapsed && (!currentRecord || previousRecord._level > currentRecord._level)) {
                        collapsed = ' collapsed="true"';
                    }
                }

                if (i === data.length) {
                    if (collapsed) {
                        xmlContent += '        <row r="' + rowNumber + '" outlineLevel="' + Math.max(data[i - 1]._level - 2, 0) + '" hidden="false" collapsed="true" />\n';
                    }

                    break;
                }

                var recordXML = '        <row r="' + rowNumber + '"' + that.getOutlineLevel(currentRecord) + ' hidden="' + (currentRecord._hidden || currentRecord._collapsed || false) + '"' + collapsed + ' spans="1:' + numberOfColumns + '"' + that.getCustomRowHeight(rowNumber - 1) + ' x14ac:dyDescent="0.45">\n';

                for (var j = 0; j < datafields.length; j++) {
                    var s = that.getXLSXCellStyle(r(j, rowNumber));

                    recordXML += that.getActualCellData(currentRecord[datafields[j]], { r: r(j, rowNumber), s: s }, sharedStrings);
                }

                recordXML += '        </row>\n';
                xmlContent += recordXML;
            }

            xmlContent += '    </sheetData>' + that.conditionalFormattingXLSX.conditions + autoFilter + that.getMergedCells(mergedCells) + '\n    <pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3" />\n    <pageSetup paperSize="9" orientation="portrait" r:id="rId1" />\n</worksheet>';

            return xmlContent;
        }

        /**
         * Generates sheet1.xml with grouping.
         */

    }, {
        key: 'generateSheet1WithGrouping',
        value: function generateSheet1WithGrouping(data, sharedStrings) {
            var that = this,
                numberOfColumns = that.columnsArray.length,
                numberOfRows = data.length,
                dimensionEnd = that.columnsArray[numberOfColumns - 1] + numberOfRows,
                datafields = that.datafields,
                mergedCells = [].concat(that.complexHeaderMergedCells);

            var xmlContent = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac xr xr2 xr3" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision" xmlns:xr2="http://schemas.microsoft.com/office/spreadsheetml/2015/revision2" xmlns:xr3="http://schemas.microsoft.com/office/spreadsheetml/2016/revision3" xr:uid="{7F25248B-C640-4C64-AD47-C0EA0E5D90D0}">\n    <dimension ref="A1:' + dimensionEnd + '" />\n    <sheetViews>\n        <sheetView tabSelected="1" workbookViewId="0" />\n    </sheetViews>\n    <sheetFormatPr defaultRowHeight="14.5" x14ac:dyDescent="0.35" />' + that.getCustomColumnWidths() + '\n    <sheetData>\n',
                rowNumberCorrection = 0,
                groupsHandled = [];

            function r(col, row) {
                return that.columnsArray[col] + row;
            }

            mainLoop: for (var i = 0; i < data.length; i++) {
                var currentRecord = data[i],
                    rowNumber = i + 1 + rowNumberCorrection;
                var outlineLevel = 0,
                    outlineXML = '';

                if (!that.exportHeader || !that.complexHeader && i !== 0 || that.complexHeader && i >= that.complexHeader.length) {
                    var groupId = '';

                    for (var k = 0; k < that.groupBy.length; k++) {
                        var datafield = that.groupBy[k],
                            currentGroup = currentRecord[datafield],
                            currentGroupLabel = that.groups[datafield][currentGroup];

                        groupId += currentGroup;

                        if (groupsHandled.indexOf(groupId) === -1) {
                            var sharedStringIndex = sharedStrings.indexOf(currentGroupLabel);

                            xmlContent += that.generateGroupRow({
                                rowNumber: rowNumber,
                                outlineLevel: outlineLevel,
                                numberOfColumns: numberOfColumns,
                                sharedStringIndex: sharedStringIndex,
                                mergedCells: mergedCells
                            });
                            groupsHandled.push(groupId);
                            i--;
                            rowNumberCorrection++;
                            continue mainLoop;
                        }

                        outlineLevel++;
                    }

                    outlineXML = ' outlineLevel="' + outlineLevel + '"';
                }

                var recordXML = '        <row r="' + rowNumber + '"' + outlineXML + ' spans="1:' + numberOfColumns + '"' + that.getCustomRowHeight(rowNumber - 1) + ' x14ac:dyDescent="0.45">\n';

                for (var j = 0; j < datafields.length; j++) {
                    var s = that.getXLSXCellStyle(r(j, i + 1));

                    recordXML += that.getActualCellData(currentRecord[datafields[j]], { r: r(j, rowNumber), s: s }, sharedStrings);
                }

                recordXML += '        </row>\n';
                xmlContent += recordXML;
            }

            xmlContent += '    </sheetData>' + that.getMergedCells(mergedCells) + '\n    <pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3" />\n    <pageSetup paperSize="9" orientation="portrait" r:id="rId1" />\n</worksheet>';

            return xmlContent;
        }

        /**
         * Gets actual spreadsheet cell data.
         */

    }, {
        key: 'getActualCellData',
        value: function getActualCellData(currentValue, details, sharedStrings) {
            var r = details.r,
                s = details.s || ' s="0"';

            if (typeof currentValue === 'string') {
                return '            <c r="' + r + '" t="s"' + s + '>\n                <v>' + sharedStrings.indexOf(currentValue) + '</v>\n            </c>\n';
            }

            if (typeof currentValue === 'boolean') {
                return '            <c r="' + r + '" t="b"' + s + '>\n                <v>' + +currentValue + '</v>\n            </c>\n';
            }

            if (currentValue instanceof Date) {
                var excelDate = (currentValue.getTime() + this.timeBetween1900And1970) / 86400000 + 2;

                return '            <c r="' + r + '"' + s + '>\n                <v>' + excelDate + '</v>\n            </c>\n';
            }

            // numeric cells
            return '            <c r="' + r + '"' + s + '>\n                <v>' + currentValue + '</v>\n            </c>\n';
        }

        /**
         * Gets column labels.
         */

    }, {
        key: 'getColumnsArray',
        value: function getColumnsArray() {
            var that = this,
                numberOfColumns = that.datafields.length,
                columnsCollection = [];

            function getIterator(i) {
                if (i < 26) {
                    return '';
                }

                return String.fromCharCode(64 + Math.floor(i / 26));
            }

            for (var i = 0; i < numberOfColumns; i++) {
                columnsCollection.push(getIterator(i) + String.fromCharCode(65 + (i < 26 ? i : i % 26)));
            }

            that.columnsArray = columnsCollection;
        }

        /**
         * Gets column style.
         */

    }, {
        key: 'getColumnStyle',
        value: function getColumnStyle() {
            var that = this,
                style = that.style;

            if (!style) {
                return '        .header { border: 1px solid black; padding: 5px; }\n        .column { border: 1px solid black; padding: 5px; }\n        .group { background-color: #FFFFFF; color: #000000; font-weight: bold; }';
            }

            var styles = {
                header: 'border: 1px solid black; padding: 5px; ',
                column: 'white-space: nowrap; overflow: hidden; border: 1px solid black; padding: 5px; ',
                group: 'background-color: #FFFFFF; color: #000000; font-weight: bold; '
            },
                sampleRecord = that.data[0];
            var generatedStyle = '';

            var headerDefinition = style.header || {};

            for (var prop in headerDefinition) {
                if (!headerDefinition.hasOwnProperty(prop)) {
                    continue;
                }

                var value = headerDefinition[prop];

                if (sampleRecord[prop]) {
                    if (!styles['header' + prop]) {
                        styles['header' + prop] = '';
                    }

                    for (var columnProp in value) {
                        if (value.hasOwnProperty(columnProp)) {
                            var css = JQX.Utilities.Core.toDash(columnProp) + ': ' + value[columnProp] + '; ';

                            styles['header' + prop] += css;

                            if (columnProp === 'width') {
                                if (!styles['column' + prop]) {
                                    styles['column' + prop] = '';
                                }

                                styles['column' + prop] += css;
                            }
                        }
                    }

                    continue;
                }

                if (prop === 'height' && that.complexHeader) {
                    styles.header += 'height: ' + parseInt(headerDefinition[prop], 10) / that.complexHeader.length + 'px; ';
                } else {
                    styles.header += JQX.Utilities.Core.toDash(prop) + ': ' + headerDefinition[prop] + '; ';
                }
            }

            var columnsDefinition = style.columns || {};

            for (var _prop in columnsDefinition) {
                if (!columnsDefinition.hasOwnProperty(_prop)) {
                    continue;
                }

                var _value = columnsDefinition[_prop];

                if (sampleRecord[_prop]) {
                    if (!styles['column' + _prop]) {
                        styles['column' + _prop] = '';
                    }

                    for (var _columnProp in _value) {
                        if (isNaN(_columnProp) && _value.hasOwnProperty(_columnProp) && _columnProp !== 'format') {
                            styles['column' + _prop] += JQX.Utilities.Core.toDash(_columnProp) + ': ' + _value[_columnProp] + '; ';
                        }
                    }

                    continue;
                }

                styles.column += JQX.Utilities.Core.toDash(_prop) + ': ' + _value + '; ';
            }

            for (var _prop2 in styles) {
                if (styles.hasOwnProperty(_prop2)) {
                    generatedStyle += '        .' + _prop2 + ' { ' + styles[_prop2] + '}\n';
                }
            }

            return generatedStyle;
        }

        /**
         * Gets custom column widths.
         */

    }, {
        key: 'getCustomColumnWidths',
        value: function getCustomColumnWidths() {
            var that = this;

            if (!that.style || !that.columnWidth || that.columnWidth.length === 0) {
                return '';
            }

            var xml = '\n    <cols>\n';

            for (var i = 0; i < that.columnWidth.length; i++) {
                var width = that.columnWidth[i];

                if (width !== undefined) {
                    width = Math.round(parseFloat(width)) / 11;
                    xml += '        <col min="' + (i + 1) + '" max="' + (i + 1) + '" width="' + width + '" customWidth="1" />\n';
                }
            }

            xml += '    </cols>';

            return xml;
        }

        /**
         * Returns customFilter tag.
         */

    }, {
        key: 'getCustomFilter',
        value: function getCustomFilter(value, condition) {
            var operator = 'equal',
                val = void 0;

            if (value instanceof Date) {
                value = (value.getTime() + this.timeBetween1900And1970) / 86400000 + 2;
            }

            condition = condition.toUpperCase();

            switch (condition) {
                case 'EMPTY':
                    val = '';
                    break;
                case 'NOT_EMPTY':
                    val = '';
                    operator = 'notEqual';
                    break;
                case 'CONTAINS':
                case 'CONTAINS_CASE_SENSITIVE':
                    val = '*' + value + '*';
                    break;
                case 'DOES_NOT_CONTAIN':
                case 'DOES_NOT_CONTAIN_CASE_SENSITIVE':
                    val = '*' + value + '*';
                    operator = 'notEqual';
                    break;
                case 'STARTS_WITH':
                case 'STARTS_WITH_CASE_SENSITIVE':
                    val = value + '*';
                    break;
                case 'ENDS_WITH':
                case 'ENDS_WITH_CASE_SENSITIVE':
                    val = '*' + value;
                    break;
                case 'EQUAL':
                case 'EQUAL_CASE_SENSITIVE':
                    val = value;
                    break;
                case 'NULL':
                    val = null;
                    break;
                case 'NOT_NULL':
                    val = null;
                    operator = 'notEqual';
                    break;
                case 'NOT_EQUAL':
                    val = value;
                    operator = 'notEqual';
                    break;
                case 'LESS_THAN':
                    val = value;
                    operator = 'lessThan';
                    break;
                case 'LESS_THAN_OR_EQUAL':
                    val = value;
                    operator = 'lessThanOrEqual';
                    break;
                case 'GREATER_THAN':
                    val = value;
                    operator = 'greaterThan';
                    break;
                case 'GREATER_THAN_OR_EQUAL':
                    val = value;
                    operator = 'greaterThanOrEqual';
                    break;
            }

            return '                <customFilter val="' + val + '" operator="' + operator + '"/>\n';
        }

        /**
         * Gets custom row height.
         */

    }, {
        key: 'getCustomRowHeight',
        value: function getCustomRowHeight(row) {
            var that = this;

            if (that.style) {
                return that.rowHeight[row] || that.defaultRowHeight || '';
            }

            return '';
        }

        /**
         * Gets datafields.
         */

    }, {
        key: 'getDatafields',
        value: function getDatafields(data) {
            var that = this,
                sampleRecord = data[0],
                datafields = [];

            for (var prop in sampleRecord) {
                if (sampleRecord.hasOwnProperty(prop) && prop.charAt(0) !== '_') {
                    datafields.push(prop);
                }
            }

            that.datafields = datafields;
        }

        /**
         * Returns autoFilter XML.
         */

    }, {
        key: 'getFilters',
        value: function getFilters() {
            var that = this,
                filterBy = that.filterBy;

            if (!filterBy) {
                return '';
            }

            var xml = '';

            for (var datafield in filterBy) {
                if (filterBy.hasOwnProperty(datafield)) {
                    var colId = that.datafields.indexOf(datafield);

                    if (colId === -1) {
                        continue;
                    }

                    var filterDetails = filterBy[datafield],
                        filters = filterDetails.filters;

                    xml += '        <filterColumn colId="' + colId + '">\n            <customFilters and="' + !filterDetails.operator + '">\n';

                    for (var i = 0; i < filters.length; i++) {
                        xml += that.getCustomFilter(filters[i].value, filters[i].condition);
                    }

                    xml += '            </customFilters>\n        </filterColumn>';
                }
            }

            if (!xml) {
                return '';
            }

            xml = '\n    <autoFilter ref="A1:' + (that.columnsArray[that.columnsArray.length - 1] + that.data.length) + '">\n' + xml + '\n    </autoFilter>';
            return xml;
        }

        /**
         * Gets group labels based on data.
         */

    }, {
        key: 'getGroupLabels',
        value: function getGroupLabels(data) {
            var that = this,
                startIndex = that.xlsxStartIndex !== undefined ? that.xlsxStartIndex : +that.exportHeader,
                groups = {},
                groupLabels = [];

            for (var i = startIndex; i < data.length; i++) {
                var currentRecord = data[i];

                for (var j = 0; j < that.groupBy.length; j++) {
                    var datafield = that.groupBy[j],
                        currentValue = currentRecord[datafield];
                    var group = groups[datafield];

                    if (group === undefined) {
                        groups[datafield] = {};
                        group = groups[datafield];
                    }

                    if (group[currentValue] === undefined) {
                        group[currentValue] = (that.exportHeader ? data[startIndex - 1][datafield] : datafield) + ': ' + currentValue;
                        groupLabels.push(group[currentValue]);
                    }
                }
            }

            that.groups = groups;
            that.groupLabels = groupLabels;
        }

        /**
         * Gets the header content when exporting to HTML.
         */

    }, {
        key: 'getHTMLHeader',
        value: function getHTMLHeader(datafields, data) {
            var that = this;
            var header = '\n        <thead>\n';

            if (!that.complexHeader) {
                header += '            <tr>\n';

                for (var j = 0; j < datafields.length; j++) {
                    var datafield = datafields[j];

                    header += '                <th class="header header' + datafield + '">' + data[0][datafield] + '</th>\n';
                }

                header += '            </tr>\n        </thead>';
                return header;
            }

            for (var _j3 = 0; _j3 < that.complexHeader.length; _j3++) {
                var row = that.complexHeader[_j3];

                header += '            <tr>\n';

                for (var k = 0; k < row.length; k++) {
                    var currentLabel = row[k];
                    var colspan = 1,
                        rowspan = 1;

                    if (row[k - 1] && row[k - 1] === currentLabel || that.complexHeader[_j3 - 1] && that.complexHeader[_j3 - 1][k] === currentLabel) {
                        continue;
                    }

                    var iterator = k + 1;

                    while (row[iterator] && row[iterator] === row[iterator - 1]) {
                        colspan++;
                        iterator++;
                    }

                    iterator = _j3 + 1;

                    while (that.complexHeader[iterator] && that.complexHeader[iterator][k] === currentLabel) {
                        rowspan++;
                        iterator++;
                    }

                    var _datafield3 = _j3 === that.complexHeader.length - 1 || rowspan + _j3 === that.complexHeader.length ? ' header' + datafields[k] : '';

                    header += '                <th class="header' + _datafield3 + '" colspan="' + colspan + '" rowspan="' + rowspan + '">' + currentLabel + '</th>\n';
                }

                header += '            </tr>\n';
            }

            header += '        </thead>';
            return header;
        }

        /**
         * Gets conditional formatting XML.
         */

    }, {
        key: 'getConditionalFormatting',
        value: function getConditionalFormatting() {
            var that = this,
                conditionalFormatting = that.conditionalFormatting;

            if (!conditionalFormatting) {
                that.conditionalFormattingXLSX = { conditions: '', styles: '' };
                return;
            }

            var dxfCodes = [];
            var conditionsXml = '',
                stylesXml = '';

            for (var i = conditionalFormatting.length - 1; i >= 0; i--) {
                var columnFormat = conditionalFormatting[i],
                    columnLetter = that.columnsArray[that.datafields.indexOf(columnFormat.column)],
                    startCell = columnLetter + (that.xlsxStartIndex + 1),
                    sqref = startCell + ':' + columnLetter + that.data.length,
                    dxfCode = columnFormat.background + columnFormat.color,
                    attr = that.getConditionalAttributes(columnFormat, startCell);
                var dxfId = dxfCodes.indexOf(dxfCode);

                if (dxfId === -1) {
                    var newDxf = '        <dxf>\n            <font>\n                <b val="0"/>\n                <i val="0"/>\n                <color rgb="' + (columnFormat.color === 'White' ? 'FFFFFFFF' : 'FF000000') + '"/>\n                <sz val="10"/>\n            </font>\n            <fill>\n                <patternFill>\n                    <bgColor rgb="' + that.toARGB(columnFormat.background) + '"/>\n                </patternFill>\n            </fill>\n        </dxf>\n';

                    stylesXml += newDxf;
                    dxfId = dxfCodes.length;
                    dxfCodes.push(dxfCode);
                }

                conditionsXml += '    <conditionalFormatting sqref="' + sqref + '">\n        <cfRule dxfId="' + dxfId + '" text="' + attr.text + '" rank="' + attr.rank + '" percent="' + attr.percent + '" bottom="' + attr.bottom + '" equalAverage="' + attr.equalAverage + '" aboveAverage="' + attr.aboveAverage + '"' + attr.operator + attr.timePeriod + ' priority="' + (i + 2) + '" type="' + attr.type + '">\n' + attr.formula + '        </cfRule>\n    </conditionalFormatting>\n';
            }

            stylesXml = '    <dxfs count="' + dxfCodes.length + '">\n' + stylesXml + '    </dxfs>';

            that.conditionalFormattingXLSX = { conditions: conditionsXml, styles: stylesXml };
        }

        /**
         * Gets conditional formatting XML attributes.
         */

    }, {
        key: 'getConditionalAttributes',
        value: function getConditionalAttributes(columnFormat, startCell) {
            var condition = columnFormat.condition,
                comparator = columnFormat.comparator,
                text = '',
                rank = 0,
                percent = 0,
                bottom = 0,
                equalAverage = 0,
                aboveAverage = 0,
                operator = '',
                timePeriod = '',
                type = '',
                formula = '';

            switch (condition) {
                case 'equal':
                    operator = 'equal';
                    type = 'cellIs';
                    formula = '            <formula>' + comparator + '</formula>\n';
                    break;
                case 'lessThan':
                    operator = 'lessThan';
                    type = 'cellIs';
                    formula = '            <formula>' + comparator + '</formula>\n';
                    break;
                case 'greaterThan':
                    operator = 'greaterThan';
                    type = 'cellIs';
                    formula = '            <formula>' + comparator + '</formula>\n';
                    break;
                case 'notEqual':
                    operator = 'notEqual';
                    type = 'cellIs';
                    formula = '            <formula>' + comparator + '</formula>\n';
                    break;
                case 'between':
                    operator = 'between';
                    type = 'cellIs';
                    formula = '            <formula>' + columnFormat.min + '</formula>\n            <formula>' + columnFormat.max + '</formula>\n';
                    break;
                case 'duplicate':
                    type = 'duplicateValues';
                    formula = '            <formula>0</formula>\n';
                    break;
                case 'topNItems':
                    rank = comparator;
                    type = 'top10';
                    break;
                case 'bottomNItems':
                    rank = comparator;
                    bottom = 1;
                    type = 'top10';
                    break;
                case 'topNPercent':
                    rank = comparator;
                    percent = 1;
                    type = 'top10';
                    break;
                case 'bottomNPercent':
                    rank = comparator;
                    percent = 1;
                    bottom = 1;
                    type = 'top10';
                    break;
                case 'aboveAverage':
                    aboveAverage = 1;
                    type = 'aboveAverage';
                    formula = '            <formula>0</formula>\n';
                    break;
                case 'belowAverage':
                    type = 'aboveAverage';
                    formula = '            <formula>0</formula>\n';
                    break;
                case 'contains':
                    text = comparator;
                    operator = 'containsText';
                    type = 'containsText';
                    formula = '            <formula>NOT(ISERROR(SEARCH("' + comparator + '",' + startCell + ')))</formula>\n';
                    break;
                case 'doesNotContain':
                    text = comparator;
                    operator = 'notContains';
                    type = 'notContainsText';
                    formula = '            <formula>ISERROR(SEARCH("' + comparator + '",' + startCell + '))</formula>\n';
                    break;
                case 'dateOccur':
                    timePeriod = ' timePeriod="' + comparator + '"';
                    type = 'timePeriod';
                    break;
            }

            if (operator) {
                operator = ' operator="' + operator + '" ';
            }

            return {
                text: text,
                rank: rank,
                percent: percent,
                bottom: bottom,
                equalAverage: equalAverage,
                aboveAverage: aboveAverage,
                operator: operator,
                timePeriod: timePeriod,
                type: type,
                formula: formula
            };
        }

        /**
         * Gets merged cells XML.
         */

    }, {
        key: 'getMergedCells',
        value: function getMergedCells(mergedCells) {
            var that = this;

            var mergeCellsXml = '';

            for (var i = 0; i < mergedCells.length; i++) {
                if (mergedCells[i].from === mergedCells[i].to) {
                    continue;
                }

                mergeCellsXml += '\n        <mergeCell ref="' + mergedCells[i].from + ':' + mergedCells[i].to + '" />\n';
            }

            if (that.mergedCells) {
                for (var _i7 = 0; _i7 < that.mergedCells.length; _i7++) {
                    var cellDefinition = that.mergedCells[_i7];

                    if (cellDefinition.rowspan < 2 && cellDefinition.colspan < 2) {
                        continue;
                    }

                    var from = that.columnsArray[cellDefinition.cell[0]] + (cellDefinition.cell[1] + that.xlsxStartIndex + 1),
                        to = that.columnsArray[cellDefinition.cell[0] + cellDefinition.colspan - 1] + (cellDefinition.cell[1] + that.xlsxStartIndex + cellDefinition.rowspan);

                    mergeCellsXml += '\n        <mergeCell ref="' + from + ':' + to + '" />\n';
                }
            }

            if (mergeCellsXml) {
                mergeCellsXml = '\n    <mergeCells count="' + mergedCells.length + '">' + mergeCellsXml + '    </mergeCells>';
            }

            return mergeCellsXml;
        }

        /**
         * Gets numFmt index.
         */

    }, {
        key: 'getNumFmtIndex',
        value: function getNumFmtIndex(format, numFmts) {
            var index = numFmts.collection.indexOf(format);

            if (index === -1) {
                index = numFmts.collection.length + 100;
                numFmts.collection.push(format);
                numFmts.xml += '<numFmt numFmtId="' + index + '" formatCode="' + format + '"/>';
            } else {
                index += 100;
            }

            return index;
        }

        /**
            * Returns outlineLevel.
            */

    }, {
        key: 'getOutlineLevel',
        value: function getOutlineLevel(record) {
            if (!this.actualHierarchy || record._level === 1) {
                return '';
            }

            return ' outlineLevel="' + (record._level - 1) + '"';
        }

        /**
         * Gets row style.
         */

    }, {
        key: 'getRowStyle',
        value: function getRowStyle() {
            var that = this,
                style = that.style;

            if (!style) {
                return '';
            }

            var rowsDefinition = style.rows;

            if (!rowsDefinition) {
                return '';
            }

            var styles = {
                row: ''
            };
            var generatedStyle = '';

            for (var prop in rowsDefinition) {
                if (!rowsDefinition.hasOwnProperty(prop) || prop === 'alternationCount' || prop === 'alternationStart' || prop === 'alternationEnd') {
                    continue;
                }

                var value = rowsDefinition[prop];

                if (prop.indexOf('alt') !== -1) {
                    var i = prop.slice(16, 17),
                        property = prop.slice(17);

                    if (!styles['rowN' + i]) {
                        styles['rowN' + i] = '';
                    }

                    if (property === 'Color') {
                        styles['rowN' + i] += 'color : ' + value + '; ';
                    } else if (property === 'BorderColor') {
                        styles['rowN' + i] += 'border-color : ' + value + '; ';
                    } else {
                        styles['rowN' + i] += 'background-color : ' + value + '; ';
                    }

                    continue;
                }

                if (!isNaN(prop)) {
                    if (!styles['row' + prop]) {
                        styles['row' + prop] = '';
                    }

                    for (var rowProp in value) {
                        if (value.hasOwnProperty(rowProp)) {
                            styles['row' + prop] += JQX.Utilities.Core.toDash(rowProp) + ': ' + value[rowProp] + '; ';
                        }
                    }

                    continue;
                }

                styles.row += JQX.Utilities.Core.toDash(prop) + ': ' + rowsDefinition[prop] + '; ';
            }

            var keys = Object.keys(styles);

            keys.sort(function (a, b) {
                if (a === 'row') {
                    return -1;
                }

                if (b === 'row') {
                    return 1;
                }

                var aIsNum = !isNaN(a.slice(3)),
                    bIsNum = !isNaN(b.slice(3));

                if (aIsNum && !bIsNum) {
                    return 1;
                }

                if (!aIsNum && bIsNum) {
                    return -1;
                }

                return +(a < b);
            });

            for (var _i8 = 0; _i8 < keys.length; _i8++) {
                generatedStyle += '        .' + keys[_i8] + ' { ' + styles[keys[_i8]] + '}\n';
            }

            return generatedStyle;
        }

        /**
         * Gets table style.
         */

    }, {
        key: 'getTableStyle',
        value: function getTableStyle() {
            var that = this,
                style = that.style;

            if (!style) {
                return ' style="table-layout: fixed; border: 1px solid black; border-collapse: collapse;"';
            }

            var generatedStyle = 'table-layout: fixed; ';

            for (var prop in style) {
                if (style.hasOwnProperty(prop) && ['header', 'columns', 'rows'].indexOf(prop) === -1) {
                    generatedStyle += JQX.Utilities.Core.toDash(prop) + ': ' + style[prop] + '; ';
                }
            }

            if (generatedStyle) {
                generatedStyle = ' style="' + generatedStyle + '"';
            }

            return generatedStyle;
        }

        /**
         * Gets the "s" (style) attribute of an XLSX cell.
         */

    }, {
        key: 'getXLSXCellStyle',
        value: function getXLSXCellStyle(r) {
            var that = this;

            if (that.cellStyleMapping[r] !== undefined) {
                return ' s="' + that.cellStyleMapping[r] + '"';
            }

            return '';
        }

        /**
         * Gets the "s" (style) attribute of an XLSX cell.
         */

    }, {
        key: 'getXLSXFormat',
        value: function getXLSXFormat(format, cellValue) {
            if (typeof cellValue === 'number') {
                var precision = parseFloat(format.slice(1)) || 0,
                    precisionCode = precision > 0 ? '.' + '0'.repeat(precision) : '';

                format = format.slice(0, 1);

                switch (format) {
                    case 'C':
                    case 'c':
                        return '\$#,0' + precisionCode;
                    case 'D':
                    case 'd':
                        if (precision) {
                            return '0'.repeat(precision);
                        }

                        return '0';
                    case 'E':
                    case 'e':
                        return '0' + precisionCode + format + '000';
                    case 'F':
                    case 'f':
                        return '0' + precisionCode;
                    case 'N':
                    case 'n':
                        return '#,0' + precisionCode;
                    case 'P':
                    case 'p':
                        return '#,0' + precisionCode + ' %';
                    default:
                        return;
                }
            } else if (cellValue instanceof Date) {
                switch (format) {
                    case 'd':
                        return 'm/d/yyyy';
                    case 'D':
                        return 'nnnnmmmm dd, yyyy';
                    case 't':
                        return 'h:m AM/PM';
                    case 'T':
                        return 'h:mm:ss AM/PM';
                    case 'f':
                        return 'nnnnmmmm dd, yyyy h:m AM/PM';
                    case 'F':
                        return 'nnnnmmmm dd, yyyy h:mm:ss AM/PM';
                    case 'M':
                        return 'mmmm d';
                    case 'Y':
                        return 'yyyy mmmm';
                    case 'FP':
                    case 'PP':
                        return 'yyyy-mm-dd hh:mm:ss';
                    case 'FT':
                    case 'PT':
                        return 'hh:mm:ss';
                }

                format = format.replace(/f|u|n|p|e|a|x|o/gi, '');
                format = format.replace(/tt/gi, 'AM/PM');
                format = format.replace(/:{2,}|:\s|:$|\.$/g, '');
                format = format.trim();
                return format;
            }
        }

        /**
         * Processes column styles.
         */

    }, {
        key: 'processColumnStyle',
        value: function processColumnStyle(style) {
            var that = this,
                headerDefinition = style.header,
                columnsDefinition = style.columns,
                sampleRecord = that.data[0],
                startIndex = that.xlsxStartIndex;

            that.columnWidth = [];

            if (startIndex && headerDefinition) {
                for (var i = 0; i < that.columnsArray.length; i++) {
                    var columnLetter = that.columnsArray[i],
                        cell = columnLetter + startIndex,
                        columnSpecific = headerDefinition[that.datafields[i]];

                    for (var prop in headerDefinition) {
                        if (headerDefinition.hasOwnProperty(prop) && sampleRecord[prop] === undefined) {
                            if (that.complexHeader) {
                                for (var j = 0; j < that.complexHeader.length; j++) {
                                    if (prop === 'height') {
                                        that.rowHeight[j] = ' ht="' + parseFloat(headerDefinition.height) / that.complexHeader.length / 2 + '"';
                                        continue;
                                    } else {
                                        that.storeCellStyle(columnLetter + (j + 1), prop, headerDefinition[prop]);
                                    }
                                }
                            } else {
                                if (prop === 'height') {
                                    that.rowHeight[0] = ' ht="' + parseFloat(headerDefinition.height) / 2 + '"';
                                    continue;
                                }

                                that.storeCellStyle(cell, prop, headerDefinition[prop]);
                            }
                        }
                    }

                    if (!columnSpecific) {
                        continue;
                    }

                    for (var _prop3 in columnSpecific) {
                        if (columnSpecific.hasOwnProperty(_prop3)) {
                            if (_prop3 === 'width') {
                                that.columnWidth[i] = columnSpecific.width;
                                continue;
                            }

                            that.storeCellStyle(cell, _prop3, columnSpecific[_prop3]);
                        }
                    }
                }
            } else if (headerDefinition) {
                for (var _i9 = 0; _i9 < that.columnsArray.length; _i9++) {
                    var _columnSpecific = headerDefinition[that.datafields[_i9]];

                    if (_columnSpecific && _columnSpecific.width !== undefined) {
                        that.columnWidth[_i9] = _columnSpecific.width;
                    }
                }
            }

            if (!columnsDefinition) {
                return '';
            }

            for (var _i10 = startIndex; _i10 < that.data.length; _i10++) {
                for (var _j4 = 0; _j4 < that.columnsArray.length; _j4++) {
                    var _columnLetter = that.columnsArray[_j4],
                        _cell = _columnLetter + (_i10 + 1),
                        datafield = that.datafields[_j4],
                        _columnSpecific2 = columnsDefinition[datafield];

                    for (var _prop4 in columnsDefinition) {
                        if (columnsDefinition.hasOwnProperty(_prop4) && sampleRecord[_prop4] === undefined) {
                            that.storeCellStyle(_cell, _prop4, columnsDefinition[_prop4]);
                        }
                    }

                    if (!_columnSpecific2) {
                        continue;
                    }

                    for (var _prop5 in _columnSpecific2) {
                        if (!isNaN(_prop5) || !_columnSpecific2.hasOwnProperty(_prop5)) {
                            continue;
                        }

                        that.storeCellStyle(_cell, _prop5, _columnSpecific2[_prop5], that.data[_i10][datafield]);
                    }
                }
            }
        }

        /**
         * Processes complex header object.
         */

    }, {
        key: 'processComplexHeader',
        value: function processComplexHeader(header, data, format) {
            var that = this,
                flatHeader = {},
                processGrouping = ['html', 'pdf', 'xlsx'].indexOf(format) !== -1 && header.columngroups,
                datafieldMapping = [],
                columnGroupHierarchy = {},
                complexHeader = [];
            var headerDepth = 0;

            function getColumnGroup(columnGroup) {
                for (var i = 0; i < header.columngroups.length; i++) {
                    var currentGroupDefinition = header.columngroups[i];

                    if (currentGroupDefinition.name === columnGroup) {
                        return currentGroupDefinition;
                    }
                }
            }

            function getColumnGroupHierarchy(groupDefinition) {
                var columnGroups = [];

                while (groupDefinition) {
                    columnGroups.unshift(groupDefinition.label);

                    if (groupDefinition.parentGroup) {
                        groupDefinition = getColumnGroup(groupDefinition.parentGroup);
                    } else {
                        return columnGroups;
                    }
                }
            }

            if (processGrouping) {
                for (var i = 0; i < header.columngroups.length; i++) {
                    var currentGroupDefinition = header.columngroups[i],
                        groupHierarchy = getColumnGroupHierarchy(currentGroupDefinition);

                    columnGroupHierarchy[currentGroupDefinition.name] = groupHierarchy;
                    headerDepth = Math.max(headerDepth, groupHierarchy.length);
                }

                headerDepth++;

                for (var _i11 = 0; _i11 < headerDepth; _i11++) {
                    complexHeader[_i11] = [];
                }
            }

            for (var _i12 = 0; _i12 < header.columns.length; _i12++) {
                var currentColumn = header.columns[_i12];

                flatHeader[currentColumn.dataField] = currentColumn.label;

                if (!processGrouping) {
                    continue;
                }

                datafieldMapping[_i12] = currentColumn.dataField;
                complexHeader[headerDepth - 1][_i12] = currentColumn.label;

                if (!currentColumn.columnGroup) {
                    continue;
                }

                var columnGroups = columnGroupHierarchy[currentColumn.columnGroup];

                for (var j = 0; j < columnGroups.length; j++) {
                    complexHeader[j][_i12] = columnGroups[j];
                }
            }

            if (complexHeader.length > 1) {
                var numberOfDatafields = Object.keys(flatHeader).length;

                for (var _i13 = 0; _i13 < headerDepth - 1; _i13++) {
                    var entry = {};

                    for (var _j5 = 0; _j5 < numberOfDatafields; _j5++) {
                        if (complexHeader[_i13][_j5] === undefined) {
                            var iterator = _i13 + 1;

                            while (complexHeader[iterator][_j5] === undefined) {
                                iterator++;
                            }

                            complexHeader[_i13][_j5] = complexHeader[iterator][_j5];
                        }

                        entry[datafieldMapping[_j5]] = complexHeader[_i13][_j5];
                    }

                    if (format === 'xlsx') {
                        data.splice(_i13, 0, entry);
                    }
                }

                that.complexHeader = complexHeader;

                if (format !== 'xlsx') {
                    data.unshift(flatHeader);
                } else {
                    data.splice(headerDepth - 1, 0, flatHeader);

                    var toMerge = {};

                    for (var _i14 = 0; _i14 < headerDepth; _i14++) {
                        for (var _j6 = 0; _j6 < numberOfDatafields; _j6++) {
                            var label = complexHeader[_i14][_j6];

                            if (!toMerge[label]) {
                                toMerge[label] = { from: [_i14, _j6] };
                                toMerge[label].to = toMerge[label].from;
                            } else {
                                toMerge[label].to = [_i14, _j6];
                            }
                        }
                    }

                    that.complexHeaderMergeInfo = toMerge;
                }
            } else {
                data.unshift(flatHeader);
            }
        }

        /**
         * Processes hierarchical data.
         */

    }, {
        key: 'processHierarchicalData',
        value: function processHierarchicalData(data, format) {
            var that = this,
                startIndex = format !== 'xlsx' ? +that.exportHeader : that.xlsxStartIndex,
                siblingGroups = {},
                processedData = [];
            var maxLevel = 0,
                actualHierarchy = false;

            function process(parentKey, level, collapsed) {
                var group = siblingGroups[parentKey];

                maxLevel = Math.max(maxLevel, level);

                if (group === undefined) {
                    return;
                }

                for (var i = 0; i < group.length; i++) {
                    var currentRecord = group[i],
                        keyDataField = currentRecord._keyDataField;

                    currentRecord._collapsed = collapsed;
                    currentRecord._level = level;
                    processedData.push(currentRecord);

                    if (siblingGroups[keyDataField]) {
                        actualHierarchy = true;
                        currentRecord._expanded = currentRecord._expanded !== undefined ? currentRecord._expanded : true;
                        process(keyDataField, level + 1, collapsed || !currentRecord._expanded);
                    }
                }
            }

            function processJSONXML(parentKey, level, parent) {
                var group = siblingGroups[parentKey];

                maxLevel = Math.max(maxLevel, level);

                if (group === undefined) {
                    return;
                }

                for (var i = 0; i < group.length; i++) {
                    var currentRecord = group[i],
                        keyDataField = currentRecord._keyDataField;
                    var cleanedRecord = void 0;

                    if (format === 'json') {
                        cleanedRecord = {};

                        for (var prop in currentRecord) {
                            if (currentRecord.hasOwnProperty(prop) && prop.charAt(0) !== '_') {
                                cleanedRecord[prop] = currentRecord[prop];
                            }
                        }
                    } else {
                        cleanedRecord = Object.assign({}, currentRecord);
                    }

                    parent.push(cleanedRecord);

                    if (siblingGroups[keyDataField]) {
                        actualHierarchy = true;
                        cleanedRecord.rows = [];
                        processJSONXML(keyDataField, level + 1, cleanedRecord.rows);
                    }
                }
            }

            if (data[startIndex]._keyDataField === undefined) {
                return that.processNestedData(data, format, startIndex);
            }

            for (var i = startIndex; i < data.length; i++) {
                var currentRecord = Object.assign({}, data[i]),
                    parentKey = currentRecord._parentDataField;

                if (siblingGroups[parentKey] === undefined) {
                    siblingGroups[parentKey] = [currentRecord];
                } else {
                    siblingGroups[parentKey].push(currentRecord);
                }
            }

            if (startIndex) {
                for (var _i15 = 0; _i15 < startIndex; _i15++) {
                    processedData.push(Object.assign({}, data[_i15]));

                    if (['json', 'pdf', 'xml'].indexOf(format) === -1) {
                        processedData[_i15]._level = 1;
                    }
                }
            }

            if (format !== 'json' && format !== 'xml') {
                process(null, 1, false);
            } else {
                processJSONXML(null, 1, processedData);
            }

            if (!actualHierarchy) {
                that.actualHierarchy = false;
            }

            that.maxLevel = maxLevel;
            return processedData;
        }

        /**
         * Processes nested hierarchical data.
         */

    }, {
        key: 'processNestedData',
        value: function processNestedData(data, format, startIndex) {
            var that = this,
                processedData = [];
            var maxLevel = 0,
                actualHierarchy = false;

            function process(start, children, level, collapsed) {
                maxLevel = Math.max(maxLevel, level);

                for (var i = start; i < children.length; i++) {
                    var currentRecord = Object.assign({}, children[i]);

                    currentRecord._collapsed = collapsed;
                    currentRecord._level = level;
                    processedData.push(currentRecord);

                    if (currentRecord.children && currentRecord.children.length > 0) {
                        actualHierarchy = true;
                        currentRecord._expanded = currentRecord._expanded !== undefined ? currentRecord._expanded : true;
                        process(0, currentRecord.children, level + 1, collapsed || !currentRecord._expanded);
                    }

                    delete currentRecord.children;
                }
            }

            function processJSONXML(start, children, rows, level) {
                maxLevel = Math.max(maxLevel, level);

                for (var i = start; i < children.length; i++) {
                    var currentRecord = Object.assign({}, children[i]);

                    if (level === 1) {
                        processedData[i] = currentRecord;
                    } else {
                        rows[i] = currentRecord;
                    }

                    if (currentRecord.children && currentRecord.children.length > 0) {
                        actualHierarchy = true;
                        currentRecord.rows = [];
                        processJSONXML(0, currentRecord.children, currentRecord.rows, level + 1);
                    }

                    delete currentRecord.children;
                }
            }

            if (startIndex) {
                for (var i = 0; i < startIndex; i++) {
                    processedData.push(Object.assign({}, data[i]));

                    if (['json', 'pdf', 'xml'].indexOf(format) === -1) {
                        processedData[i]._level = 1;
                    }
                }
            }

            if (format !== 'json' && format !== 'xml') {
                process(startIndex, data, 1, false);
            } else {
                processJSONXML(startIndex, data, undefined, 1);
            }

            if (!actualHierarchy) {
                that.actualHierarchy = false;
            }

            that.maxLevel = maxLevel;
            return processedData;
        }

        /**
         * Processes row styles.
         */

    }, {
        key: 'processRowStyle',
        value: function processRowStyle(style) {
            var that = this,
                rowsDefinition = style.rows;

            that.rowHeight = [];

            if (!rowsDefinition) {
                return;
            }

            var startIndex = that.xlsxStartIndex;

            function applyToRowCells(row, prop, value) {
                for (var j = 0; j < that.columnsArray.length; j++) {
                    var currentCell = that.columnsArray[j] + (row + 1 + startIndex);

                    that.storeCellStyle(currentCell, prop, value);
                }
            }

            if (rowsDefinition.height) {
                that.defaultRowHeight = ' ht="' + parseFloat(rowsDefinition.height) / 2 + '"';
            }

            for (var i = startIndex; i < that.data.length; i++) {
                var row = i - startIndex;

                for (var prop in rowsDefinition) {
                    if (rowsDefinition.hasOwnProperty(prop) && prop.indexOf('alt') === -1 && isNaN(prop) && prop !== 'height') {
                        applyToRowCells(row, prop, rowsDefinition[prop]);
                    }
                }

                if (rowsDefinition.alternationCount && !(rowsDefinition.alternationStart && row < rowsDefinition.alternationStart) && !(rowsDefinition.alternationEnd && row > rowsDefinition.alternationEnd)) {
                    var start = rowsDefinition.alternationStart || 0,
                        _i16 = (row - start) % rowsDefinition.alternationCount;

                    if (rowsDefinition['alternationIndex' + _i16 + 'Color']) {
                        applyToRowCells(row, 'color', rowsDefinition['alternationIndex' + _i16 + 'Color']);
                    }

                    if (rowsDefinition['alternationIndex' + _i16 + 'BorderColor']) {
                        applyToRowCells(row, 'borderColor', rowsDefinition['alternationIndex' + _i16 + 'BorderColor']);
                    }

                    if (rowsDefinition['alternationIndex' + _i16 + 'BackgroundColor']) {
                        applyToRowCells(row, 'backgroundColor', rowsDefinition['alternationIndex' + _i16 + 'BackgroundColor']);
                    }
                }

                if (rowsDefinition[row]) {
                    for (var _prop6 in rowsDefinition[row]) {
                        if (rowsDefinition[row].hasOwnProperty(_prop6)) {
                            if (_prop6 === 'height') {
                                that.rowHeight[i] = ' ht="' + parseFloat(rowsDefinition[row].height) / 2 + '"';
                                continue;
                            }

                            applyToRowCells(row, _prop6, rowsDefinition[row][_prop6]);
                        }
                    }
                }
            }
        }

        /**
         * Stores cell style in "styleMap" object.
         */

    }, {
        key: 'storeCellStyle',
        value: function storeCellStyle(cell, prop, value) {
            var that = this,
                cellMap = that.styleMap[cell];

            switch (prop) {
                case 'backgroundColor':
                    cellMap.fills.fgColor = value;
                    break;
                case 'color':
                    cellMap.fonts.color = value;
                    break;
                case 'fontFamily':
                    cellMap.fonts.name = value.replace(/"/g, '\'');
                    break;
                case 'fontSize':
                    cellMap.fonts.sz = parseFloat(value);
                    break;
                case 'fontStyle':
                    if (value === 'italic') {
                        cellMap.fonts.i = true;
                    } else {
                        delete cellMap.fonts.i;
                    }

                    break;
                case 'fontWeight':
                    if (value === 'bold') {
                        cellMap.fonts.b = true;
                    } else {
                        delete cellMap.fonts.b;
                    }

                    break;
                case 'numFmt':
                    {
                        cellMap.numFmt = value;
                        break;
                    }
                case 'textAlign':
                    cellMap.alignment.horizontal = value;
                    break;
                case 'textDecoration':
                    if (value === 'underline') {
                        cellMap.fonts.u = true;
                    } else {
                        delete cellMap.fonts.u;
                    }

                    break;
                case 'verticalAlign':
                    if (value === 'middle') {
                        value = 'center';
                    }

                    cellMap.alignment.vertical = value;
                    break;
            }
        }

        /**
         * Returns an Alpha Red Green Blue color value.
         */

    }, {
        key: 'toARGB',
        value: function toARGB(color) {
            color = color.replace(/\s/g, '');

            var rgbResult = /rgb\((\d+),(\d+),(\d+)\)/gi.exec(color);

            if (rgbResult !== null) {
                var r = parseFloat(rgbResult[1]).toString(16).toUpperCase(),
                    g = parseFloat(rgbResult[2]).toString(16).toUpperCase(),
                    b = parseFloat(rgbResult[3]).toString(16).toUpperCase();

                return 'FF' + '0'.repeat(2 - r.length) + r + '0'.repeat(2 - g.length) + g + '0'.repeat(2 - b.length) + b;
            }

            var rgbaResult = /rgba\((\d+),(\d+),(\d+)\,(\d*.\d+|\d+)\)/gi.exec(color);

            if (rgbaResult !== null) {
                var a = Math.round(parseFloat(rgbaResult[4]) * 255).toString(16).toUpperCase(),
                    _r = parseFloat(rgbaResult[1]).toString(16).toUpperCase(),
                    _g = parseFloat(rgbaResult[2]).toString(16).toUpperCase(),
                    _b = parseFloat(rgbaResult[3]).toString(16).toUpperCase();

                return '0'.repeat(2 - a.length) + a + '0'.repeat(2 - _r.length) + _r + '0'.repeat(2 - _g.length) + _g + '0'.repeat(2 - _b.length) + _b;
            }

            var shortHexResult = /^#(.)(.)(.)$/gi.exec(color);

            if (shortHexResult !== null) {
                var _r2 = shortHexResult[1].toUpperCase(),
                    _g2 = shortHexResult[2].toUpperCase(),
                    _b2 = shortHexResult[3].toUpperCase();

                return 'FF' + _r2 + _r2 + _g2 + _g2 + _b2 + _b2;
            }

            return 'FF' + color.toUpperCase().slice(1);
        }

        /**
         * Adds toggleable functionality.
         */

    }, {
        key: 'toggleableFunctionality',
        value: function toggleableFunctionality() {
            var that = this;

            if (!that.actualHierarchy) {
                return '';
            }

            return '\n    <style type="text/css">\n        .toggle-element {\n            width: 5px;\n            height: 1px;\n            padding-right: 5px;\n            float: left;\n            text-align: right;\n            cursor: pointer;\n            user-select: none;\n        }\n\n        .collapsed {\n            display: none;\n        }\n    </style>\n    <script type="text/javascript">\n        window.onload = function () {\n            var expandChar = \'' + that.expandChar + '\',\n                collapseChar = \'' + that.collapseChar + '\',\n                toggleElements = document.getElementsByClassName(\'toggle-element\');\n\n            function getParent(child) {\n                var prevSibling = child.previousElementSibling;\n\n                while (prevSibling) {\n                    if (child.getAttribute(\'level\') > prevSibling.getAttribute(\'level\')) {\n                        return prevSibling;\n                    }\n\n                    prevSibling = prevSibling.previousElementSibling;\n                }\n\n            }\n\n            function getFirstCollapsedAncestor(child) {\n                var parent = getParent(child);\n\n                while (parent) {\n                    if (parent.firstElementChild.firstElementChild.innerHTML === expandChar) {\n                        return parent;\n                    }\n\n                    parent = getParent(parent);\n                }\n            }\n\n            for (var i = 0; i < toggleElements.length; i++) {\n                toggleElements[i].addEventListener(\'click\', function (event) {\n                    var expanded = this.innerHTML === collapseChar,\n                        row = this.parentElement.parentElement,\n                        sibling = row.nextElementSibling;\n\n                    if (expanded) {\n                        this.innerHTML = expandChar;\n                    }\n                    else {\n                        this.innerHTML = collapseChar;\n                    }\n\n                    while (sibling && row.getAttribute(\'level\') < sibling.getAttribute(\'level\')) {\n                        if (expanded) {\n                            sibling.style.display = \'none\';\n                        }\n                        else {\n                            var firstCollapsedAncestor = getFirstCollapsedAncestor(sibling);\n\n                            if (!firstCollapsedAncestor || firstCollapsedAncestor === row) {\n                                sibling.classList.remove(\'collapsed\');\n                                sibling.style.display = null;\n                            }\n\n                        }\n\n                        sibling = sibling.nextElementSibling;\n                    }\n                });\n            }\n        }\n    </script>';
        }

        /**
         * Generates styles.xml.
         */

    }, {
        key: 'generateStyles',
        value: function generateStyles(style) {
            var that = this;

            that.cellStyleMapping = {};

            if (Object.keys(style).length === 0 && !that.complexHeader) {
                // default style
                return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac x16r2 xr" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:x16r2="http://schemas.microsoft.com/office/spreadsheetml/2015/02/main" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision"><fonts count="1" x14ac:knownFonts="1"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><charset val="204"/><scheme val="minor"/></font></fonts><fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills><borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/></cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>' + (that.conditionalFormattingXLSX.styles || '<dxfs count="0"/>') + '<tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleLight16"/><extLst><ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"><x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/></ext><ext uri="{9260A510-F301-46a8-8635-F512D64BE5F5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:timelineStyles defaultTimelineStyle="TimeSlicerStyleLight1"/></ext></extLst></styleSheet>';
            }

            that.styleMap = {};

            for (var i = 0; i < that.data.length; i++) {
                for (var j = 0; j < that.columnsArray.length; j++) {
                    that.styleMap[that.columnsArray[j] + (i + 1)] = {
                        numFmts: {}, fonts: {}, fills: {}, borders: {}, alignment: {}
                    };
                }
            }

            if (style && style.columns) {
                for (var _i17 = 0; _i17 < that.columnsArray.length; _i17++) {
                    var datafield = that.datafields[_i17];

                    if (!style.columns[datafield] || !style.columns[datafield].format) {
                        continue;
                    }

                    var XLSXFormat = that.getXLSXFormat(style.columns[datafield].format, that.data[that.data.length - 1][datafield]);

                    if (XLSXFormat) {
                        style.columns[datafield].numFmt = XLSXFormat;
                    }
                }
            }

            that.processRowStyle(style);
            that.processColumnStyle(style);

            var cellAliases = {};

            for (var _i18 = 0; _i18 < that.complexHeaderMergedCells.length; _i18++) {
                var currentCell = that.complexHeaderMergedCells[_i18];

                if (parseFloat(currentCell.to[1]) === that.complexHeader.length) {
                    cellAliases[currentCell.to] = currentCell.from;
                    continue;
                }

                that.styleMap[currentCell.from].alignment.horizontal = 'center';
                that.styleMap[currentCell.from].alignment.vertical = 'center';
            }

            var fonts = {
                xml: '<font><sz val="11" /><color theme="1" /><name val="Calibri" /><family val="2" /><charset val="204" /><scheme val="minor" /></font>',
                collection: ['default']
            },
                fills = {
                xml: '<fill><patternFill patternType="none" /></fill><fill><patternFill patternType="gray125" /></fill>',
                collection: ['default', 'gray125']
            },
                numFmts = {
                xml: '',
                collection: []
            },
                cellXfs = {
                xml: '<xf fontId="0" fillId="0" borderId="1"/>',
                collection: ['default']
            };

            for (var _i19 = 0; _i19 < that.data.length; _i19++) {
                // iterate rows
                for (var _j7 = 0; _j7 < that.columnsArray.length; _j7++) {
                    // iterate columns
                    var _currentCell = that.columnsArray[_j7] + (_i19 + 1),
                        currentCellStyle = that.styleMap[_currentCell];
                    var currentFont = '',
                        currentFill = '',
                        currentAlignment = '',
                        currentFontCode = [],
                        currentFillCode = [],
                        currentAlignmentCode = [],
                        xf = [];

                    for (var prop in currentCellStyle.fonts) {
                        if (currentCellStyle.fonts.hasOwnProperty(prop)) {
                            var value = currentCellStyle.fonts[prop];

                            switch (prop) {
                                case 'color':
                                    currentFontCode[0] = value;
                                    currentFont += '<color rgb="' + that.toARGB(value) + '" />';
                                    break;
                                case 'name':
                                    currentFontCode[1] = value;
                                    currentFont += '<name val="' + value + '" />';
                                    break;
                                case 'sz':
                                    currentFontCode[2] = value;
                                    currentFont += '<sz val="' + value + '" />';
                                    break;
                                case 'i':
                                    currentFontCode[3] = value;
                                    currentFont += '<i />';
                                    break;
                                case 'b':
                                    currentFontCode[4] = value;
                                    currentFont += '<b />';
                                    break;
                                case 'u':
                                    currentFontCode[5] = value;
                                    currentFont += '<u />';
                                    break;
                            }
                        }
                    }

                    for (var _prop7 in currentCellStyle.fills) {
                        if (currentCellStyle.fills.hasOwnProperty(_prop7)) {
                            var _value2 = currentCellStyle.fills[_prop7];

                            switch (_prop7) {
                                case 'fgColor':
                                    currentFillCode[0] = _value2;
                                    currentFill += '<fgColor rgb="' + that.toARGB(_value2) + '" />';
                                    break;
                            }
                        }
                    }

                    for (var _prop8 in currentCellStyle.alignment) {
                        if (currentCellStyle.alignment.hasOwnProperty(_prop8)) {
                            var _value3 = currentCellStyle.alignment[_prop8];

                            switch (_prop8) {
                                case 'horizontal':
                                    currentAlignmentCode[0] = _value3;
                                    currentAlignment += 'horizontal="' + _value3 + '" ';
                                    break;
                                case 'vertical':
                                    currentAlignmentCode[1] = _value3;
                                    currentAlignment += 'vertical="' + _value3 + '" ';
                                    break;
                            }
                        }
                    }

                    currentFontCode = currentFontCode.toString();
                    currentFillCode = currentFillCode.toString();

                    if (currentFont !== '') {
                        var fontIndex = fonts.collection.indexOf(currentFontCode);

                        if (fontIndex === -1) {
                            fontIndex = fonts.collection.length;

                            fonts.xml += '<font>' + currentFont + '</font>';
                            fonts.collection.push(currentFontCode);
                        }

                        xf[0] = fontIndex;
                    }

                    if (currentFill !== '') {
                        var fillIndex = fills.collection.indexOf(currentFillCode);

                        if (fillIndex === -1) {
                            fillIndex = fills.collection.length;

                            fills.xml += '<fill><patternFill patternType="solid">' + currentFill + '</patternFill></fill>';
                            fills.collection.push(currentFillCode);
                        }

                        xf[1] = fillIndex;
                    }

                    if (currentAlignmentCode.length > 0) {
                        xf[2] = currentAlignment;
                    }

                    if (currentCellStyle.numFmt !== undefined) {
                        xf[3] = that.getNumFmtIndex(currentCellStyle.numFmt, numFmts);
                    }

                    var xfCode = xf.toString();

                    if (xfCode !== '') {
                        var xfIndex = cellXfs.collection.indexOf(xfCode);

                        if (xfIndex === -1) {
                            var newXfXML = '<xf ';

                            xfIndex = cellXfs.collection.length;

                            if (xf[0] !== undefined) {
                                newXfXML += 'fontId="' + xf[0] + '" ';
                            }

                            if (xf[1] !== undefined) {
                                newXfXML += 'fillId="' + xf[1] + '" ';
                            }

                            if (xf[3] !== undefined) {
                                newXfXML += 'numFmtId="' + xf[3] + '" ';
                            }

                            if (xf[2] !== undefined) {
                                newXfXML += 'applyAlignment="1" borderId="1"><alignment ' + currentAlignment + '/></xf>';
                            } else {
                                newXfXML += ' borderId="1"/>';
                            }

                            cellXfs.xml += newXfXML;
                            cellXfs.collection.push(xfCode);
                        }

                        that.cellStyleMapping[cellAliases[_currentCell] || _currentCell] = xfIndex;
                    }
                }
            }

            if (numFmts.collection.length) {
                numFmts.xml = '<numFmts count="' + numFmts.collection.length + '">' + numFmts.xml + '</numFmts>';
            }

            return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac x16r2 xr" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:x16r2="http://schemas.microsoft.com/office/spreadsheetml/2015/02/main" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision">' + numFmts.xml + '<fonts count="' + fonts.collection.length + '" x14ac:knownFonts="1">' + fonts.xml + '</fonts><fills count="' + fills.collection.length + '">' + fills.xml + '</fills><borders count="2"><border><left/><right/><top/><bottom/></border><border><left style="hair"/><right style="hair"/><top style="hair"/><bottom style="hair"/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="' + cellXfs.collection.length + '">' + cellXfs.xml + '</cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>' + that.conditionalFormattingXLSX.styles + '<dxfs count="0"/><tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleLight16"/><extLst><ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"><x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/></ext><ext uri="{9260A510-F301-46a8-8635-F512D64BE5F5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:timelineStyles defaultTimelineStyle="TimeSlicerStyleLight1"/></ext></extLst></styleSheet>';
        }
    }]);
    return DataExporter;
}());