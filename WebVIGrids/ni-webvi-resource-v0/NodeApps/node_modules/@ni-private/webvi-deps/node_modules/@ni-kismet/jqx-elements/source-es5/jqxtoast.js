'use strict';

/**
* jqxToast custom element.
*/
JQX('jqx-toast', function (_JQX$ContentElement) {
    babelHelpers.inherits(Toast, _JQX$ContentElement);

    function Toast() {
        babelHelpers.classCallCheck(this, Toast);
        return babelHelpers.possibleConstructorReturn(this, (Toast.__proto__ || Object.getPrototypeOf(Toast)).apply(this, arguments));
    }

    babelHelpers.createClass(Toast, [{
        key: 'template',


        /**
        * Tab Items Group's HTML template.
        */
        value: function template() {
            return '';
        }

        /**
        * Updates the element when a property is changed.
        * @param {string} propertyName The name of the property.
        * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
        * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
        */

    }, {
        key: 'propertyChangedHandler',
        value: function propertyChangedHandler(propertyName, oldValue, newValue) {
            var that = this;

            switch (propertyName) {
                case 'value':
                    {
                        var item = that._instances[that._instances.length - 1];

                        if (item) {
                            (that.enableShadowDOM ? item.shadowRoot : item).querySelector('.jqx-toast-item-content').innerHTML = newValue;
                        }

                        break;
                    }
                case 'appendTo':
                case 'modal':
                case 'position':
                    that._handleContainers();
                    break;
                default:
                    babelHelpers.get(Toast.prototype.__proto__ || Object.getPrototypeOf(Toast.prototype), 'propertyChangedHandler', this).call(this, propertyName, oldValue, newValue);
                    break;
            }
        }

        /**
         * Called when the element is attached to the DOM.
         */

    }, {
        key: 'attached',
        value: function attached() {
            babelHelpers.get(Toast.prototype.__proto__ || Object.getPrototypeOf(Toast.prototype), 'attached', this).call(this);

            var that = this,
                containers = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight', 'Custom', 'Modal'];

            for (var i = 0; i < containers.length; i++) {
                var itemContainer = that.$['toastContainer' + containers[i]];

                if (itemContainer && itemContainer.children.length) {
                    if (containers[i] === 'Custom') {
                        that._appendTo.appendChild(that._container);
                    } else {
                        document.body.appendChild(itemContainer);
                    }
                }
            }
        }

        /**
        * Called when the element is detached from the DOM.
        */

    }, {
        key: 'detached',
        value: function detached() {
            babelHelpers.get(Toast.prototype.__proto__ || Object.getPrototypeOf(Toast.prototype), 'detached', this).call(this);

            var that = this,
                containers = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight', 'Custom', 'Modal'];

            for (var i = 0; i < containers.length; i++) {
                var itemContainer = that.$['toastContainer' + containers[i]];

                if (itemContainer) {
                    that._removeContainerListeners(itemContainer);
                    itemContainer.parentElement.removeChild(itemContainer);
                }

                that.closeAll();
            }
        }

        /**
        * Element's ready method.
        */

    }, {
        key: 'ready',
        value: function ready() {
            babelHelpers.get(Toast.prototype.__proto__ || Object.getPrototypeOf(Toast.prototype), 'ready', this).call(this);

            var that = this;

            that.value = that.innerHTML = that.value ? that.value : that.innerHTML;
            that._instances = [];

            if (that.autoOpen) {
                that.open();
            }
        }

        /**
        * Closes all opened toast items
        */

    }, {
        key: 'closeAll',
        value: function closeAll() {
            var that = this;

            for (var i = that._instances.length - 1; i > -1; i--) {
                that._close(that._instances[i]);
            }
        }

        /**
        * Closes particular item
        */

    }, {
        key: 'closeItem',
        value: function closeItem(instance) {
            var that = this;

            if (!instance || that._instances.length === 0) {
                return;
            }

            if (typeof instance === 'string') {
                instance = document.getElementById(instance);
            } else if (instance instanceof HTMLElement) {
                instance = instance.closest('.jqx-toast-item');
            }

            if (!instance || that._instances.indexOf(instance) === -1) {
                return;
            }

            that._close(instance);
        }

        /**
        * Closes the last opened toast item
        */

    }, {
        key: 'closeLast',
        value: function closeLast() {
            var that = this;

            if (that._instances.length > 0) {
                that._close(that._instances[that._instances.length - 1]);
            }
        }

        /**
         * Opens a new toast item instance
         */

    }, {
        key: 'open',
        value: function open() {
            var that = this;

            if (that.disabled) {
                return;
            }

            that._handleContainers();

            var item = document.createElement('div');

            item.className = 'jqx-toast-item';

            if (that.value instanceof HTMLElement) {
                item.innerHTML = that._defaultItemTemplate('');
                item.getElementsByClassName('jqx-toast-item-content')[0].appendChild(that.value);
            } else {
                item.innerHTML = that._handleItemTemplate() || that._defaultItemTemplate(that.value);
            }

            if (that.showCloseButton) {
                item.setAttribute('show-close-button', '');
            }

            for (var i = 0; i < that.classList.length; i++) {
                if (that.classList[i].indexOf('jqx-') < 0) {
                    item.classList.add(that.classList[i]);
                }
            }

            if (that.type) {
                item.classList.add(that.type);
            }

            item.setAttribute('animation', that.animation);

            if (that.enableShadowDOM) {
                if (!item.shadowRoot) {
                    var itemContent = document.createDocumentFragment();

                    while (item.childNodes.length) {
                        itemContent.appendChild(item.firstChild);
                    }

                    //Create ShadowRoot
                    item.attachShadow({ mode: 'open' });

                    //Append Styles
                    var styleUrls = [].slice.call(that.shadowRoot.children).filter(function (el) {
                        return el.tagName === 'LINK';
                    });

                    for (var _i = 0; _i < styleUrls.length; _i++) {
                        item.shadowRoot.insertBefore(styleUrls[_i].cloneNode(), item.shadowRoot.firstChild);
                    }

                    item.shadowRoot.appendChild(itemContent);
                }
            }

            that._container.appendChild(item);

            item._parent = that._container;

            that._instances.push(item);

            that.$.fireEvent('open', { 'instance': item });

            setTimeout(function () {
                item.setAttribute('opened', '');
            }, 10);

            if (that.autoClose) {
                item._autoCloseTimeout = setTimeout(function () {
                    that._close(item);
                }, that.autoCloseDelay);
            }
        }

        /**
         * Container's click handler. Common for all toast containers
         */

    }, {
        key: '_containerClickHandler',
        value: function _containerClickHandler(event) {
            var that = this,
                target = that.enableShadowDOM ? event.composedPath()[0] : event.target,
                clickedButton = target.closest('.jqx-toast-item-close-button'),
                clickedItem = (target.getRootNode().host || target).closest('.jqx-toast-item');

            if (clickedButton || clickedItem) {
                that.$.fireEvent('click', { 'instance': clickedItem });

                if (clickedButton) {
                    that._close(clickedItem);
                }
            } else if (that.modal) {
                that.closeAll();
            }
        }

        /**
         * Closes (removes) an toast item instance
         */

    }, {
        key: '_close',
        value: function _close(instance) {
            var that = this;

            if (that._instances.indexOf(instance) > -1) {
                var closeTransitionDuration = window.getComputedStyle(instance, null).getPropertyValue('transition-duration'),
                    interval = closeTransitionDuration.indexOf('ms') > -1 ? parseInt(closeTransitionDuration) : parseFloat(closeTransitionDuration) * 1000;

                instance.removeAttribute('opened');
                that._instances.splice(that._instances.indexOf(instance), 1);

                setTimeout(function () {
                    clearTimeout(instance._autoCloseTimeout);
                    that.$.fireEvent('close', { 'instance': instance });

                    if (instance.parentNode) {
                        instance.parentNode.removeChild(instance);
                    }

                    var parentContainer = instance._parent;

                    if (parentContainer && !parentContainer.children.length && parentContainer.parentElement) {
                        that._removeContainerListeners(parentContainer);
                        parentContainer.parentElement.removeChild(parentContainer);
                    }
                }, interval);
            }
        }

        /**
        * Returns the default item template
        */

    }, {
        key: '_defaultItemTemplate',
        value: function _defaultItemTemplate(value) {
            return '<div class ="jqx-toast-item-header">\n                    <span class ="jqx-toast-item-close-button"></span>\n                </div>\n                <div class ="jqx-toast-item-container">\n                    <span class ="jqx-toast-item-icon"></span><span class ="jqx-toast-item-content">' + value + '</span>\n                </div>';
        }

        /**
         * Handles the contaner in use, where all new items will be stored
         */

    }, {
        key: '_handleContainers',
        value: function _handleContainers() {
            var that = this;
            var customContainer = void 0;

            if (typeof that.appendTo === 'string') {
                customContainer = document.getElementById(that.appendTo);
            } else if (that.appendTo instanceof HTMLElement) {
                customContainer = that.appendTo;
            }

            //Get or create the toast items container
            that._container = that._getToastContainer(customContainer);

            if (customContainer) {
                that._appendTo = customContainer;

                if (!that._container.parentElement) {
                    //Add events listeners
                    that._addContainerListeners(that._container);
                    that._appendTo.appendChild(that._container);
                }

                return;
            }

            if (!customContainer && that.$.toastContainerCustom && !that.$.toastContainerCustom.children.length) {
                that._removeContainerListeners(that.$.toastContainerCustom);

                if (that.$.toastContainerCustom.parentElement) {
                    that.$.toastContainerCustom.parentElement.removeChild(that.$.toastContainerCustom);
                }
            }

            if (!that._container.parentElement) {
                //Add events listeners
                that._addContainerListeners(that._container);
                document.body.appendChild(that._container);
            }
        }

        /**
         * Adds event listeners to the toast item container
         * @param {any} container
         */

    }, {
        key: '_addContainerListeners',
        value: function _addContainerListeners(container) {
            var that = this;

            if (!container) {
                return;
            }

            var containerId = container.getAttribute('jqx-id'),
                containerEvents = that['$' + containerId];

            if (containerEvents) {
                containerEvents.listen('click', that._containerClickHandler.bind(that));
                containerEvents.listen('swipeleft', that._swipeHandler.bind(that));
                containerEvents.listen('swiperight', that._swipeHandler.bind(that));
                containerEvents.listen('swipetop', that._swipeHandler.bind(that));
                containerEvents.listen('swipebottom', that._swipeHandler.bind(that));
            }
        }

        /**
         * Removes the event listeners from the toast item container
         * @param {any} container
         */

    }, {
        key: '_removeContainerListeners',
        value: function _removeContainerListeners(container) {
            var that = this;

            if (!container) {
                return;
            }

            var containerId = container.getAttribute('jqx-id'),
                containerEvents = that['$' + containerId];

            if (containerEvents) {
                containerEvents.unlisten('click');
                containerEvents.unlisten('swipeleft');
                containerEvents.unlisten('swiperight');
                containerEvents.unlisten('swipetop');
                containerEvents.unlisten('swipebottom');
            }
        }

        /**
         * Returns a toast items container
         * @param {any} customContainer
         */

    }, {
        key: '_getToastContainer',
        value: function _getToastContainer(customContainer) {
            var that = this;

            var type = void 0;

            if (customContainer) {
                type = 'Custom';
            } else if (that.modal) {
                type = 'Modal';
            } else {
                type = JQX.Utilities.Core.toCamelCase(that.position);
                type = type.charAt(0).toUpperCase() + type.slice(1);
            }

            var containerName = 'toastContainer' + type;

            if (!that.$[containerName]) {
                //Create it
                var container = document.createElement('div');

                container.setAttribute('jqx-id', containerName);
                container.classList.add('jqx-toast-container');
                container.classList.add('jqx-toast-container-' + JQX.Utilities.Core.toDash(type));

                that.$['toastContainer' + type] = container;
                that['$toastContainer' + type] = JQX.Utilities.Extend(container);
            }

            return that.$[containerName];
        }

        /**
        * Apply the template to the toast.
        */

    }, {
        key: '_handleItemTemplate',
        value: function _handleItemTemplate() {
            var that = this;
            var template = that.itemTemplate;

            if (!('content' in document.createElement('template'))) {
                that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() }));
                return;
            }

            if (!template) {
                return that._defaultItemTemplate(that.value);
            }

            template = document.getElementById(template);

            if (template === null || !('content' in template)) {
                that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: 'template' }));
                return;
            }

            var content = template.innerHTML,
                regex = /{{\w+}}/g;

            return content.replace(regex, that.value);
        }

        /**
        * SwipeLeft and SwipeRight event handler.
        **/

    }, {
        key: '_swipeHandler',
        value: function _swipeHandler(event) {
            var that = this,
                instance = event.originalEvent.target.closest('.jqx-toast-item');

            event.stopPropagation();

            if (!instance) {
                return;
            }

            that.$.fireEvent(event.type, { 'instance': instance });
        }
    }], [{
        key: 'properties',


        /**
        * Element's properties
        */
        get: function get() {
            return {
                'appendTo': {
                    value: null,
                    type: 'any'
                },
                'autoClose': {
                    value: false,
                    type: 'boolean'
                },
                'autoCloseDelay': {
                    value: 3000,
                    type: 'number'
                },
                'autoOpen': {
                    value: false,
                    type: 'boolean'
                },
                'itemTemplate': {
                    value: null,
                    type: 'string?'
                },
                'modal': {
                    value: false,
                    type: 'boolean'
                },
                'position': {
                    allowedValues: ['top-left', 'top-right', 'bottom-left', 'bottom-right'],
                    value: 'top-right',
                    type: 'string'
                },
                'showCloseButton': {
                    value: false,
                    type: 'boolean'
                },
                'type': {
                    allowedValues: ['info', 'warning', 'success', 'error', 'mail', 'time', null],
                    value: 'info',
                    type: 'string?'
                },
                'value': {
                    value: '',
                    type: 'any'
                }
            };
        }

        /**
        * CSS files needed for the element (ShadowDOM)
        */

    }, {
        key: 'styleUrls',
        get: function get() {
            return ['jqx.toast.css'];
        }
    }]);
    return Toast;
}(JQX.ContentElement));