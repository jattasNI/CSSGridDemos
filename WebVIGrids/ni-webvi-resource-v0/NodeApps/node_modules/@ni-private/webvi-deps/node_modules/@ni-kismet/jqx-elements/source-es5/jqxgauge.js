'use strict';

/**
 * Gauge custom element.
 */
JQX('jqx-gauge', function (_JQX$Tank) {
    babelHelpers.inherits(Gauge, _JQX$Tank);

    function Gauge() {
        babelHelpers.classCallCheck(this, Gauge);
        return babelHelpers.possibleConstructorReturn(this, (Gauge.__proto__ || Object.getPrototypeOf(Gauge)).apply(this, arguments));
    }

    babelHelpers.createClass(Gauge, [{
        key: 'template',


        /**
         * Gauge's HTML template.
         */
        value: function template() {
            var template = '<div id="container">\n                <div id="svgContainer" class="jqx-svg-container"></div>\n                <div class="jqx-digital-display-container">\n                    <jqx-numeric-text-box id="digitalDisplay"\n                                            class="jqx-digital-display"\n                                            decimal-separator="[[decimalSeparator]]"\n                                            max="[[max]]"\n                                            min="[[min]]"\n                                            name="[[name]]"\n                                            readonly\n                                            input-format="[[scaleType]]"\n                                            scientific-notation="[[scientificNotation]]"\n                                            show-unit="[[showUnit]]"\n                                            unit="[[unit]]"\n                                            unfocusable\n                                            validation="interaction"\n                                            word-length="[[wordLength]]">\n                    </jqx-numeric-text-box>\n                </div>\n            </div>';

            return template;
        }

        /**
         * Called when the element is attached to the DOM.
         */

    }, {
        key: 'attached',
        value: function attached() {
            var that = this;

            babelHelpers.get(Gauge.prototype.__proto__ || Object.getPrototypeOf(Gauge.prototype), 'attached', this).call(this);

            if (!that.isCompleted) {
                return;
            }

            if (that._trackListener) {
                that._trackListener = new JQX.Utilities.InputEvents(that._track);
                that._trackListener.down(function (event) {
                    that._SVGElementDownHandler(event);
                });
            }

            if (that._fillListener) {
                that._fillListener = new JQX.Utilities.InputEvents(that._fill);
                that._fillListener.down(function (event) {
                    that._SVGElementDownHandler(event);
                });
            }

            if (that._lineListener) {
                that._lineListener = new JQX.Utilities.InputEvents(that._line);
                that._lineListener.down(function (event) {
                    that._SVGElementDownHandler(event);
                });
            }
        }

        /**
         * Called when the element is detached from the DOM.
         */

    }, {
        key: 'detached',
        value: function detached() {
            var that = this;

            babelHelpers.get(Gauge.prototype.__proto__ || Object.getPrototypeOf(Gauge.prototype), 'detached', this).call(this);

            that._unlisten();
        }

        /**
         * Invoked when an instance of custom element is attached to the DOM for the first time.
         */

    }, {
        key: 'ready',
        value: function ready() {
            babelHelpers.get(Gauge.prototype.__proto__ || Object.getPrototypeOf(Gauge.prototype), 'ready', this).call(this);
        }

        /**
         * Gets the optimal size of the Gauge.
         */

    }, {
        key: 'getOptimalSize',
        value: function getOptimalSize() {
            var that = this;

            if (that._renderingSuspended) {
                return { width: 0, height: 0 };
            }

            if (that.sizeMode === 'circle') {
                return { width: that.offsetWidth, height: that._updateSize(true) };
            } else {
                return { width: that.offsetWidth, height: that.offsetHeight };
            }
        }

        /**
         * Sets or gets the value of the Gauge.
         *
         * @param {Number/String} value Optional value to be set to the Gauge. If this parameter is not set, the method gets the value.
         */

    }, {
        key: 'val',
        value: function val(value) {
            var that = this;

            if (value !== undefined) {
                // use as value setter
                if (that.mode === 'date') {
                    value = JQX.Utilities.DateTime.validateDate(value);
                    value = value.getTimeStamp();
                }

                // eslint-disable-next-line
                if (that._numericProcessor.compare(value, that.value)) {
                    var oldValue = that.value;

                    that._validateValue(value, that.value);

                    if (!that._isVisible() || that._renderingSuspended) {
                        that._renderingSuspended = true;
                        return;
                    }

                    that._animate(oldValue);
                }
            } else {
                // use as value getter
                return that._getEventValue();
            }
        }

        /**
         * Applies initial settings to the Gauge element.
         */

    }, {
        key: '_createElement',
        value: function _createElement() {
            var that = this;

            if (that.mode === 'numeric') {
                that._getEventValue = function () {
                    return that.value;
                };
            } else {
                that._handleDateScale();
                that.digitalDisplay = false;
            }

            //Creating instances of NumericProcessor, NumberRenderer and Draw
            that._numericProcessor = new JQX.Utilities.NumericProcessor(that, 'scaleType');
            that._numberRenderer = new JQX.Utilities.NumberRenderer();
            that._draw = new JQX.Utilities.Draw(that.$.svgContainer);

            if (!that._isVisible()) {
                that._renderingSuspended = true;
                return;
            }

            that._renderingSuspended = false;

            that._setSettingsObject();

            that._wordLengthNumber = that._numericProcessor.getWordLength(that.wordLength);

            that._measurements = {};
            that._validateInitialPropertyValues();
            that._getMeasurements();

            that._setDrawVariables();
            that._getRange();
            that._numericProcessor.getAngleRangeCoefficient();

            if (that.mode === 'numeric' || !that.coerce) {
                that._validateValue();
            } else {
                that._coerceInitialDateValue = true;
            }

            that._initTickIntervalHandler();

            that._renderAnalogItems();
            delete that._preventResizeHandler;

            that._setFocusable();

            that._setUpdatePointerMethod();
        }

        /**
         * Invoked when the value of a public property has been changed by the user.
         */

    }, {
        key: 'propertyChangedHandler',
        value: function propertyChangedHandler(key, oldValue, value) {
            function validateMinMax(validateMin, validateMax, oldMin, oldMax) {
                var toValidate = validateMin && validateMax ? 'both' : key;

                that._validateMinMax(toValidate, false, oldValue);

                if (key !== 'logarithmicScale' && key !== 'scaleType' && (key !== 'wordLength' && that[key] === oldValue || key === 'wordLength' && that.min === oldMin && that.max === oldMax)) {
                    return;
                }

                that._setDrawVariables();
                that._getRange();
                that._numericProcessor.getAngleRangeCoefficient();
                that._initTickIntervalHandler();
                that._renderAnalogItems();

                that._validateValue(that.value, that.value);
                that._updatePointer();
            }

            var that = this;

            if (!that._isVisible() || that._renderingSuspended) {
                that._renderingSuspended = true;
                return;
            }

            switch (key) {
                case 'analogDisplayType':
                    delete that._customSVGElements;

                    that._getMeasurements();

                    if (value === 'needle' && that.digitalDisplayPosition === 'center') {
                        that.digitalDisplayPosition = 'bottom';
                    } else if (oldValue === 'needle' && that.digitalDisplayPosition === 'bottom') {
                        that.digitalDisplayPosition = 'center';
                    }

                    that._renderAnalogItems();
                    that._setUpdatePointerMethod();
                    break;
                case 'coerce':
                    if (value) {
                        var valueBeforeCoercion = that.value;
                        that._validateValue(valueBeforeCoercion);
                        that._updatePointer();
                        that._valueBeforeCoercion = valueBeforeCoercion; // stores value before coercion
                    } else {
                        if (that._valueBeforeCoercion !== undefined) {
                            that._validateValue(that._valueBeforeCoercion); // restores the value from before coercion
                            that._updatePointer();
                        }
                    }
                    break;
                case 'customInterval':
                    if (value) {
                        if (that._customTicks) {
                            that.customTicks = that._customTicks;
                        }

                        that._numericProcessor.validateCustomTicks();
                    } else if (that.mode === 'date') {
                        that._customTicks = that.customTicks;
                    }

                    that._initTickIntervalHandler();
                    that._renderAnalogItems();
                    that._coerceCustomInterval();
                    break;
                case 'customTicks':
                    if (that.mode === 'date' && !that.customInterval) {
                        that._customTicks = value;
                        that.customTicks = oldValue;
                        return;
                    }

                    that._numericProcessor.validateCustomTicks();

                    if (that.customInterval) {
                        that._initTickIntervalHandler();
                        that._renderAnalogItems();
                        that._coerceCustomInterval();
                    }

                    break;
                case 'dateLabelFormatString':
                case 'showUnit':
                case 'unit':
                    that._initTickIntervalHandler();
                    that._renderAnalogItems();
                    break;
                case 'decimalSeparator':
                case 'scientificNotation':
                    if (that.mode === 'date') {
                        return;
                    }

                    that._initTickIntervalHandler();
                    that._renderAnalogItems();
                    break;
                case 'digitalDisplay':
                case 'digitalDisplayPosition':
                    if (that.mode === 'date') {
                        if (key === 'digitalDisplay') {
                            that.digitalDisplay = false;
                        }

                        return;
                    }

                    that._updateSize();
                    break;
                case 'mechanicalAction':
                case 'messages':
                case 'readonly':
                    break;
                case 'disabled':
                case 'unfocusable':
                    that._setFocusable();
                    break;
                case 'drawNeedle':
                    if (that.analogDisplayType !== 'needle') {
                        return;
                    }

                    if (oldValue === null) {
                        that._draw.removeElement(that._needle);
                    }

                    if (value !== null) {
                        that._updatePointer();
                    } else {
                        that._renderAnalogItems();
                        delete that._customSVGElements;
                    }

                    break;
                case 'endAngle':
                case 'startAngle':
                    that._validateAngles();
                    that._numericProcessor.getAngleRangeCoefficient();
                    that._renderAnalogItems();
                    break;
                case 'interval':
                    that._numericProcessor.validateInterval(that.interval);
                    that._validateValue();
                    that._updatePointer();
                    break;
                case 'inverted':
                case 'labelFormatFunction':
                case 'showRanges':
                    that._renderAnalogItems();
                    break;
                case 'labelsVisibility':
                    if (oldValue === 'all' && value === 'endPoints' || oldValue === 'endPoints' && value === 'all') {
                        return;
                    }
                    that._getMeasurements();
                    that._renderAnalogItems();
                    break;
                case 'logarithmicScale':
                    if (that.mode === 'date') {
                        that.logarithmicScale = false;
                        return;
                    }

                    that._initTickIntervalHandler();
                    validateMinMax(true, true);
                    break;
                case 'max':
                case 'min':
                    if (that.mode === 'date') {
                        delete that._dateInterval;

                        that[key] = JQX.Utilities.DateTime.validateDate(value).getTimeStamp();
                    }

                    validateMinMax(key === 'min', key === 'max');
                    break;
                case 'mode':
                    that.mode = oldValue;
                    break;
                case 'needlePosition':
                    if (that.analogDisplayType === 'needle') {
                        that._updatePointer();
                    }
                    break;
                case 'precisionDigits':
                case 'significantDigits':
                    if (that.mode === 'date') {
                        return;
                    }

                    if (key === 'precisionDigits' && that.scaleType === 'integer') {
                        that.error(that.localize('noInteger', { elementType: that.nodeName.toLowerCase(), property: key }));
                    }

                    if (key === 'significantDigits' && that.precisionDigits !== null) {
                        that.precisionDigits = null;
                    } else if (key === 'precisionDigits' && that.significantDigits !== null) {
                        that.significantDigits = null;
                    }

                    if (value !== null) {
                        that.$.digitalDisplay.precisionDigits = that.precisionDigits;
                        that.$.digitalDisplay.significantDigits = that.significantDigits;
                    }
                    that._initTickIntervalHandler();
                    that._renderAnalogItems();
                    break;
                case 'ranges':
                    if (!that.showRanges) {
                        return;
                    }

                    that._renderAnalogItems();
                    break;
                case 'scaleType':
                    if (that.mode === 'date') {
                        that.scaleType = 'integer';
                        return;
                    }

                    that._numericProcessor = new JQX.Utilities.NumericProcessor(that, 'scaleType');

                    validateMinMax(true, true);
                    break;
                case 'scalePosition':
                case 'ticksPosition':
                    that._getMeasurements();
                    that._renderAnalogItems();
                    break;
                case 'sizeMode':
                    that._preventResizeHandler = true;

                    if (value === 'circle') {
                        that.$.container.removeAttribute('style');
                        that.style.height = that.offsetWidth + 'px';
                        that._measurements.cachedHeight = that.offsetHeight;
                    } else {
                        that.$.container.style.height = that.offsetWidth + 'px';
                        that._updateSize();
                    }

                    break;
                case 'theme':
                    babelHelpers.get(Gauge.prototype.__proto__ || Object.getPrototypeOf(Gauge.prototype), 'propertyChangedHandler', this).call(this, key, oldValue, value);
                    that._getMeasurements();
                    that._renderAnalogItems();
                    break;
                case 'ticksVisibility':
                    if (oldValue === 'minor' && value === 'major' || oldValue === 'major' && value === 'minor') {
                        return;
                    }
                    that._getMeasurements();
                    that._renderAnalogItems();
                    break;
                case 'validation':
                    if (value === 'strict') {
                        that._validateValue(that.value, that.value);
                    }

                    break;
                case 'value':
                    {
                        if (that.mode === 'date') {
                            value = JQX.Utilities.DateTime.validateDate(value);
                            value = value.getTimeStamp();
                        }

                        that._validateValue(value, oldValue);

                        var stringValue = value.toString();

                        if (that.value.toString() === stringValue) {
                            that._drawValue = that.logarithmicScale ? Math.log10(stringValue).toString() : stringValue;
                        }

                        that._animate(oldValue);
                        break;
                    }
                case 'wordLength':
                    if (that.mode === 'date') {
                        that.wordLength = 'uint64';
                        return;
                    }

                    that._wordLengthNumber = that._numericProcessor.getWordLength(that.wordLength);
                    if (that.scaleType === 'integer') {
                        validateMinMax(true, true, that.min, that.max);
                    }
                    break;
            }
        }

        /**
         * Draws the Gauge's analog display.
         */

    }, {
        key: '_addAnalogDisplay',
        value: function _addAnalogDisplay() {
            var that = this,
                measurements = that._measurements,
                radius = measurements.radius,
                draw = that._draw;

            if (that.analogDisplayType === 'needle') {
                // needle
                that._drawNeedle(false);
                // central circle
                var centralCircleRadius = (measurements.needleWidth + 5) / 2;

                that._centralCircle = draw.circle(radius, radius, centralCircleRadius, { 'class': 'jqx-needle-central-circle' });
                that._minCoordinates.push(radius - centralCircleRadius);
                that._maxCoordinates.push(radius + centralCircleRadius);
            } else {
                var distance = radius - that._distance.trackDistance - measurements.trackBorderWidth / 2 - 1;
                // track
                that._track = draw.pieslice(radius, radius, distance - measurements.trackWidth, distance, that.startAngle, that.endAngle, 0, { 'class': 'jqx-track' });
                that._trackListener = new JQX.Utilities.InputEvents(that._track);
                that._trackListener.down(function (event) {
                    that._SVGElementDownHandler(event);
                });
            }
        }

        /**
         * Calculates the tick drawing distance.
         */

    }, {
        key: '_calculateTickAndLabelDistance',
        value: function _calculateTickAndLabelDistance() {
            var that = this,
                measurements = that._measurements;

            if (that.scalePosition === 'none') {
                that._plotLabels = false;
                that._plotTicks = false;

                measurements.innerRadius = measurements.radius;

                return { majorTickDistance: 0, minorTickDistance: 0, labelDistance: 0, needleDistance: 0, trackDistance: 0 };
            }

            var labelsSize = that._tickIntervalHandler.labelsSize,
                labelSizeCoefficient = that._largestLabelSize || Math.max(labelsSize.minLabelSize, labelsSize.minLabelOtherSize, labelsSize.maxLabelSize, labelsSize.maxLabelOtherSize);
            var majorTickDistance = 1,
                minorTickDistance = void 0,
                labelDistance = void 0,
                needleDistance = void 0,
                trackDistance = 0;

            that._largestLabelSize = labelSizeCoefficient;

            if (that.scalePosition === 'outside') {
                majorTickDistance = labelSizeCoefficient;
                minorTickDistance = majorTickDistance + measurements.majorTickSize - measurements.minorTickSize;
                labelDistance = 0;
            }

            if (that.analogDisplayType === 'needle') {
                if (that.scalePosition === 'outside') {
                    needleDistance = majorTickDistance + measurements.majorTickSize;
                } else {
                    needleDistance = majorTickDistance + measurements.majorTickSize + labelSizeCoefficient;
                }

                if (that.ticksVisibility === 'none') {
                    labelDistance = 0;
                    needleDistance -= measurements.majorTickSize;
                }
                if (that.labelsVisibility === 'none') {
                    needleDistance -= labelSizeCoefficient;
                    if (that.scalePosition === 'outside') {
                        majorTickDistance -= labelSizeCoefficient;
                        minorTickDistance -= labelSizeCoefficient;
                    }
                }
            } else {
                if (that.labelsVisibility === 'none' && that.ticksVisibility === 'none') {
                    trackDistance = 0;
                } else {
                    if (that.scalePosition === 'outside') {
                        if (that.ticksPosition === 'scale') {
                            if (that.labelsVisibility === 'none') {
                                majorTickDistance = 1;
                                minorTickDistance = 1 + measurements.majorTickSize - measurements.minorTickSize;
                            }
                            if (that.ticksVisibility !== 'none') {
                                trackDistance = majorTickDistance + measurements.majorTickSize + 2;
                            } else {
                                trackDistance = labelSizeCoefficient;
                            }
                        } else {
                            if (that.labelsVisibility !== 'none') {
                                minorTickDistance = minorTickDistance - (measurements.trackWidth + measurements.trackBorderWidth) / 4;
                                trackDistance = majorTickDistance - 1;
                            } else {
                                majorTickDistance = 1;
                                minorTickDistance = (measurements.trackWidth + measurements.trackBorderWidth) / 4 + 1;
                                trackDistance = 0;
                            }
                        }
                    } else {
                        if (that.ticksPosition === 'scale') {
                            majorTickDistance = measurements.trackWidth + 1.5 * measurements.trackBorderWidth + 2;
                            if (that.ticksVisibility === 'none') {
                                labelDistance = majorTickDistance;
                            }
                        } else {
                            minorTickDistance = (measurements.trackWidth + measurements.trackBorderWidth) / 4 + 1;
                        }
                    }
                }
            }

            if (minorTickDistance === undefined) {
                minorTickDistance = majorTickDistance;
            }

            if (labelDistance === undefined) {
                labelDistance = majorTickDistance + measurements.majorTickSize;
            }

            measurements.innerRadius = measurements.radius - labelDistance;

            delete that._plotLabels;
            delete that._plotTicks;
            delete that._equalToHalfRadius;
            if (that.scalePosition === 'inside') {
                if (measurements.innerRadius < labelSizeCoefficient) {
                    that._plotLabels = false;

                    if (that.ticksPosition === 'scale') {
                        if (that.analogDisplayType !== 'needle' && measurements.innerRadius < measurements.majorTickSize) {
                            that._plotTicks = false;
                        }
                    } else {
                        that._equalToHalfRadius = true;
                        measurements.innerRadius = measurements.radius / 2;
                    }
                }
            } else if (measurements.radius - trackDistance - measurements.trackBorderWidth < measurements.trackWidth) {
                measurements.trackWidth = measurements.radius - trackDistance - measurements.trackBorderWidth;
                measurements.lineSize = measurements.trackWidth + measurements.trackBorderWidth;
                if (that.ticksPosition === 'track') {
                    measurements.majorTickSize = measurements.lineSize;
                    measurements.minorTickSize = measurements.majorTickSize / 2;
                    minorTickDistance = majorTickDistance + (measurements.majorTickSize - measurements.minorTickSize) / 2;
                }
            }

            return { majorTickDistance: majorTickDistance, minorTickDistance: minorTickDistance, labelDistance: labelDistance, needleDistance: needleDistance, trackDistance: trackDistance };
        }

        /**
         * Calculates the tank's major and minor ticks intervals.
         */

    }, {
        key: '_calculateTickInterval',
        value: function _calculateTickInterval() {
            var that = this,
                intervals = that._tickIntervalHandler.getInterval('radial', that._drawMin, that._drawMax, that.$.container, that.logarithmicScale);

            if (intervals.major !== that._majorTicksInterval) {
                that._intervalHasChanged = true;
                that._majorTicksInterval = intervals.major;
            } else {
                that._intervalHasChanged = true;
            }

            that._minorTicksInterval = intervals.minor;

            if (that.mode === 'date') {
                that._calculateDateInterval(intervals.major);
            }
        }

        /**
         * Computes the points of a needle (needlePosition: 'center').
         */

    }, {
        key: '_computeNeedlePointsCenter',
        value: function _computeNeedlePointsCenter(pointerWidth, angle) {
            var that = this,
                measurements = that._measurements,
                innerRadius = measurements.innerRadius,
                radius = measurements.radius,
                sin = Math.sin(angle),
                cos = Math.cos(angle);
            var pointerLength = void 0;

            if (that.scalePosition === 'inside') {
                pointerLength = (innerRadius - that._largestLabelSize) * 0.9;
            } else {
                pointerLength = (innerRadius - that._distance.needleDistance) * 0.9;
            }

            var x = radius + pointerLength * sin,
                y = radius + pointerLength * cos,
                startX1 = radius + pointerWidth * cos,
                startY1 = radius - pointerWidth * sin,
                startX2 = radius - pointerWidth * cos,
                startY2 = radius + pointerWidth * sin,
                points = 'M ' + startX1 + ',' + startY1 + ' L ' + startX2 + ',' + startY2 + ' L ' + x + ',' + y + ' Z';

            return points;
        }

        /**
         * Computes the points of a needle (needlePosition: 'edge').
         */

    }, {
        key: '_computeNeedlePointsEdge',
        value: function _computeNeedlePointsEdge(pointerWidth, angle, pointerLength) {
            var that = this,
                radius = that._measurements.radius,
                distance = radius - that._distance.needleDistance,
                distanceMinusPointerLength = distance - pointerLength,
                sin = Math.sin(angle),
                cos = Math.cos(angle),
                hPointX = radius + distanceMinusPointerLength * sin,
                hPointY = radius + distanceMinusPointerLength * cos,
                startPointX1 = hPointX + pointerWidth * cos,
                startPointY1 = hPointY - pointerWidth * sin,
                startPointX2 = hPointX - pointerWidth * cos,
                startPointY2 = hPointY + pointerWidth * sin,
                endPointX = radius + distance * sin,
                endPointY = radius + distance * cos,
                points = 'M ' + startPointX1 + ',' + startPointY1 + ' L ' + startPointX2 + ',' + startPointY2 + ' L ' + endPointX + ',' + endPointY + ' Z';

            return points;
        }

        /**
         * Document (mouse)move event handler.
         */

    }, {
        key: '_documentMoveHandler',
        value: function _documentMoveHandler(event) {
            if (!this._dragging) {
                return;
            }

            var that = this,
                angle = that._getAngleByCoordinate(event.pageX, event.pageY),
                quadrant = that._getQuadrant(angle),
                rotationDirection = that._getRotationDirection();

            if (that._normalizedStartAngle === that.endAngle) {
                var normalizedReferentAngle = void 0;

                if (!that.inverted) {
                    if (that._lockCW && rotationDirection === 'ccw') {
                        normalizedReferentAngle = that.endAngle;
                        that._unlockRotation('_lockCW', angle, quadrant, normalizedReferentAngle, { firstCondition: angle > normalizedReferentAngle, secondCondition: angle < normalizedReferentAngle });
                    } else if (that._lockCCW && rotationDirection === 'cw') {
                        normalizedReferentAngle = that._normalizedStartAngle;
                        that._unlockRotation('_lockCCW', angle, quadrant, normalizedReferentAngle, { firstCondition: angle < normalizedReferentAngle, secondCondition: angle > normalizedReferentAngle });
                    }
                } else {
                    if (that._lockCW && rotationDirection === 'cw') {
                        normalizedReferentAngle = that._normalizedStartAngle;
                        that._unlockRotation('_lockCW', angle, quadrant, normalizedReferentAngle, { firstCondition: angle < normalizedReferentAngle, secondCondition: angle > normalizedReferentAngle });
                    } else if (that._lockCCW && rotationDirection === 'ccw') {
                        normalizedReferentAngle = that.endAngle;
                        that._unlockRotation('_lockCCW', angle, quadrant, normalizedReferentAngle, { firstCondition: angle > normalizedReferentAngle, secondCondition: angle < normalizedReferentAngle });
                    }
                }
            } else {
                if (that._lockCW && rotationDirection === 'ccw' && !that._outsideRange && that._numericProcessor._getAngleDifference(angle, that._normalizedStartAngle) < 10) {
                    that._lockCW = false;
                } else if (that._lockCCW && rotationDirection === 'cw' && !that._outsideRange && that._numericProcessor._getAngleDifference(angle, that.endAngle) < 10) {
                    that._lockCCW = false;
                }
            }

            that._angle = angle;
            that._quadrant = quadrant;

            if (event.originalEvent) {
                event.originalEvent.stopPropagation();
                event.originalEvent.preventDefault();
            }

            if (that._lockCW || that._lockCCW) {
                return;
            }

            var newValue = that._numericProcessor.getValueByAngle(angle);

            if (that._normalizedStartAngle === that.endAngle) {
                var lockedValue = that._numericProcessor.lockRotation(rotationDirection === 'cw' && !that.inverted || rotationDirection === 'ccw' && that.inverted, newValue);

                if (lockedValue !== undefined) {
                    newValue = lockedValue;
                }
            } else {
                if (rotationDirection === 'ccw' && that._outsideEnd) {
                    that._lockCCW = true;
                } else if (rotationDirection === 'cw' && that._outsideStart) {
                    that._lockCW = true;
                }
            }

            if (newValue !== undefined && that._numericProcessor.compare(newValue, that.value)) {
                cancelAnimationFrame(that._animationFrameId);
                that._updatePointer(newValue);

                if (that.mechanicalAction !== 'switchWhenReleased') {
                    that._numericProcessor.updateGaugeValue(newValue);
                } else {
                    that._valueAtMoveEnd = newValue;
                }
            }
        }

        /**
         * Gauge (mouse)up event handler.
         */

    }, {
        key: '_documentUpHandler',
        value: function _documentUpHandler() {
            var that = this;

            if (that._dragging) {
                that._lockCW = false;
                that._lockCCW = false;

                that._dragging = false;
                that.removeAttribute('dragged');

                if (that.mechanicalAction !== 'switchWhileDragging') {
                    var newValue = that.mechanicalAction === 'switchUntilReleased' ? that._valueAtDragStart : that._valueAtMoveEnd;

                    if (that._numericProcessor.compare(newValue, that.value)) {
                        if (that.mechanicalAction === 'switchUntilReleased') {
                            that._animate(that.value, newValue);
                        }

                        that._numericProcessor.updateGaugeValue(newValue);
                    }
                }
            }
        }

        /**
         * Gauge (mouse)down event handler.
         */

    }, {
        key: '_downHandler',
        value: function _downHandler(event, targetIsTrack) {
            var that = this,
                target = that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target;

            if (that.analogDisplayType !== 'needle' && !targetIsTrack || that.disabled || that.readonly || (that.enableShadowDOM ? target.getRootNode().host === that.$.digitalDisplay : that.$.digitalDisplay.contains(target)) || !JQX.Utilities.Core.isMobile && ('buttons' in event && event.buttons !== 1 || event.which !== 1)) {
                event.stopPropagation();
                return;
            }

            var x = event.pageX,
                y = event.pageY;

            that._measurements.center = that._getCenterCoordinates();

            if (that.analogDisplayType === 'needle') {
                var distanceFromCenter = Math.sqrt(Math.pow(that._measurements.center.x - x, 2) + Math.pow(that._measurements.center.y - y, 2));
                if (distanceFromCenter > that._measurements.radius) {
                    event.stopPropagation();
                    return;
                }
            }

            if (that.mechanicalAction === 'switchUntilReleased') {
                that._valueAtDragStart = that.value;
            }

            that._angle = that._getAngleByCoordinate(x, y);
            that._quadrant = that._getQuadrant(that._angle);

            var newValue = that._numericProcessor.getValueByAngle(that._angle);

            if (newValue !== undefined && that._numericProcessor.compare(newValue, that.value)) {
                that._animate(that.value, newValue);

                if (that.mechanicalAction !== 'switchWhenReleased') {
                    that._numericProcessor.updateGaugeValue(newValue);
                } else {
                    that._valueAtMoveEnd = newValue;
                }
            }

            that._dragging = true;
            that.setAttribute('dragged', '');
        }

        /**
         * Animates pointer.
         */

    }, {
        key: '_animate',
        value: function _animate(oldValue, newValue) {
            var that = this,
                logarithmicScale = that.logarithmicScale,
                totalIterations = Math.max(1, Math.round(that.animationDuration / 15));

            cancelAnimationFrame(that._animationFrameId);

            if (!that.hasAnimation || totalIterations === 1) {
                that._updatePointer(newValue);
                return;
            }

            var numericProcessor = that._numericProcessor;
            var i = 1,
                nextValue = void 0,
                getNextValue = void 0,
                oldDrawValue = void 0,
                newDrawValue = void 0;

            if (newValue === undefined) {
                newValue = that.value;
            }

            oldValue = parseFloat(numericProcessor.validate(numericProcessor.createDescriptor(oldValue), that._minObject, that._maxObject));
            newValue = parseFloat(numericProcessor.validate(numericProcessor.createDescriptor(newValue), that._minObject, that._maxObject));

            if (logarithmicScale) {
                oldDrawValue = Math.log10(oldValue);
                newDrawValue = Math.log10(newValue);
            } else {
                oldDrawValue = oldValue;
                newDrawValue = newValue;
            }

            var total = Math.abs(newDrawValue - oldDrawValue);

            if (newValue > oldValue) {
                getNextValue = function getNextValue() {
                    return Math.min(JQX.Utilities.Animation.Easings.easeInOutSine(i, oldDrawValue, total, totalIterations), newDrawValue);
                };
            } else {
                getNextValue = function getNextValue() {
                    return Math.max(2 * oldDrawValue - JQX.Utilities.Animation.Easings.easeInOutSine(i, oldDrawValue, total, totalIterations), newDrawValue);
                };
            }

            function getNextDrawValue() {
                nextValue = getNextValue();

                if (logarithmicScale) {
                    nextValue = Math.pow(10, nextValue);
                }
            }

            function animate() {
                i++;

                if (i === totalIterations) {
                    nextValue = newValue;
                    that._updatePointer(nextValue);
                    return;
                }

                that._updatePointer(nextValue);
                getNextDrawValue();
                that._animationFrameId = requestAnimationFrame(animate);
            }

            getNextDrawValue();
            that._animationFrameId = requestAnimationFrame(animate);
        }

        /**
         * Draws/updates the fill or line.
         */

    }, {
        key: '_drawFill',
        value: function _drawFill(update, value) {
            var that = this;

            if (that.analogDisplayType === 'needle') {
                return;
            }

            if (value === undefined) {
                value = that._number;
            }

            var measurements = that._measurements,
                radius = measurements.radius,
                distance = radius - that._distance.trackDistance - measurements.trackBorderWidth / 2 - 1;

            if (that.analogDisplayType === 'fill') {
                var angle = that._numericProcessor.getAngleByValue(value, true, true);
                var startAngle = void 0,
                    endAngle = void 0;

                if (!that.inverted) {
                    startAngle = angle;
                    endAngle = that.endAngle;
                } else {
                    startAngle = that.startAngle;
                    endAngle = angle;
                }

                if (update) {
                    that._fill.setAttribute('d', that._draw.pieSlicePath(radius, radius, distance - measurements.trackWidth, distance, startAngle, endAngle, 0));
                } else {
                    that._fill = that._draw.pieslice(radius, radius, distance - measurements.trackWidth, distance, startAngle, endAngle, 0, { 'class': 'jqx-value' });
                    that._fillListener = new JQX.Utilities.InputEvents(that._fill);
                    that._fillListener.down(function (event) {
                        that._SVGElementDownHandler(event);
                    });
                }
            } else {
                var width = distance + measurements.trackBorderWidth / 2,
                    innerWidth = width - measurements.lineSize,
                    _angle = that._numericProcessor.getAngleByValue(value),
                    angleSin = Math.sin(_angle),
                    angleCos = Math.cos(_angle),
                    x1 = radius + width * angleSin,
                    y1 = radius + width * angleCos,
                    x2 = radius + innerWidth * angleSin,
                    y2 = radius + innerWidth * angleCos;

                if (update) {
                    that._line.setAttribute('x1', x1);
                    that._line.setAttribute('y1', y1);
                    that._line.setAttribute('x2', x2);
                    that._line.setAttribute('y2', y2);
                } else {
                    that._line = that._draw.line(x1, y1, x2, y2, { 'class': 'jqx-line' });
                    that._lineListener = new JQX.Utilities.InputEvents(that._line);
                    that._lineListener.down(function (event) {
                        that._SVGElementDownHandler(event);
                    });
                }
            }
        }

        /**
         * Draws a label.
         */

    }, {
        key: '_drawLabel',
        value: function _drawLabel(angle, value, distance, middle) {
            var that = this,
                measurements = that._measurements,
                r = measurements.radius,
                stylingObj = {
                'class': 'jqx-label' + (middle !== false ? ' jqx-label-middle' : ''),
                'font-size': measurements.fontSize,
                'font-family': measurements.fontFamily,
                'font-weight': measurements.fontWeight,
                'font-style': measurements.fontStyle
            };

            value = that._formatLabel(value.toString(), false);

            var textSize = that._draw.measureText(value, 0, stylingObj),
                w = r - distance - that._largestLabelSize / 2,
                x = Math.round(r + w * Math.sin(angle)) - textSize.width / 2,
                y = Math.round(r + w * Math.cos(angle)) - textSize.height / 2,
                label = that._draw.text(value, x, y, textSize.width, textSize.height, 0, stylingObj);

            that._minCoordinates.push(y);
            that._maxCoordinates.push(y + label.getBBox().height);
        }

        /**
         * Draws/updates the needle.
         */

    }, {
        key: '_drawNeedle',
        value: function _drawNeedle(update, value) {
            var that = this,
                measurements = that._measurements;

            if (value === undefined) {
                value = that._number;
            }

            var angle = that._numericProcessor.getAngleByValue(value);

            if (!that.drawNeedle) {
                var points = void 0;

                if (that.needlePosition === 'center') {
                    points = that._computeNeedlePointsCenter(measurements.needleWidth / 2, angle);
                } else {
                    points = that._computeNeedlePointsEdge(measurements.needleWidth / 2, angle, measurements.needleLength);
                }

                if (update) {
                    that._needle.setAttribute('d', points);
                } else {
                    that._needle = that._draw.path(points, { 'class': 'jqx-needle' });
                }
            } else {
                that._customSVGElements = that.drawNeedle(that, that._draw, measurements.radius, angle, that._distance.needleDistance);
                if (that._customSVGElements) {
                    var parent = that._customSVGElements[0].parentElement || that._customSVGElements[0].parentNode;
                    for (var i = 0; i < that._customSVGElements.length; i++) {
                        parent.insertBefore(that._customSVGElements[i], that._centralCircle);
                    }
                }
            }
        }

        /**
         * Draws ranges.
         */

    }, {
        key: '_drawRanges',
        value: function _drawRanges() {
            var that = this,
                numericProcessor = that._numericProcessor,
                ranges = that.ranges;

            if (!that.showRanges || ranges.length === 0) {
                return;
            }

            var measurements = that._measurements,
                radius = measurements.radius;
            var distance = void 0,
                rangeSize = void 0,
                startValue = void 0,
                endValue = void 0;

            if (that.analogDisplayType === 'needle') {
                rangeSize = measurements.rangeSize;
                if (that.scalePosition === 'inside') {
                    distance = radius - 1;
                } else {
                    distance = radius - that._distance.needleDistance - 2;
                    if (that.labelsVisibility === 'none' && that.ticksVisibility === 'none') {
                        distance += 1;
                    }
                }
            } else {
                distance = radius - that._distance.trackDistance - measurements.trackBorderWidth / 2 - 1;
                rangeSize = measurements.trackWidth;
            }

            if (!that.inverted) {
                startValue = 'startValue';
                endValue = 'endValue';
            } else {
                startValue = 'endValue';
                endValue = 'startValue';
            }

            for (var i = 0; i < ranges.length; i += 1) {
                var currentRange = ranges[i],
                    validStartValue = numericProcessor.validateColorRange(currentRange[startValue]),
                    validEndValue = numericProcessor.validateColorRange(currentRange[endValue]);

                var range = that._draw.pieslice(radius, radius, distance - rangeSize, distance, numericProcessor.getAngleByValue(validEndValue, true, true), numericProcessor.getAngleByValue(validStartValue, true, true), 0, { 'class': 'jqx-range ' + currentRange.className });

                that._ranges.push(range);
            }
        }

        /**
         * Draws a tick.
         */

    }, {
        key: '_drawTick',
        value: function _drawTick(angle, width, type) {
            var that = this,
                measurements = that._measurements,
                r = measurements.radius;

            var className = 'jqx-tick',
                size = void 0;

            if (type === 'major') {
                size = measurements.majorTickSize;
            } else {
                size = measurements.minorTickSize;
                className += ' jqx-tick-minor';
            }

            var innerWidth = width - size,
                x1 = r + width * Math.sin(angle),
                y1 = r + width * Math.cos(angle),
                x2 = r + innerWidth * Math.sin(angle),
                y2 = r + innerWidth * Math.cos(angle);
            that._draw.line(x1, y1, x2, y2, { 'class': className });

            that._minCoordinates.push(Math.min(y1, y2));
            that._maxCoordinates.push(Math.max(y1, y2));
        }

        /**
         * Returns the angle equivalent of coordinates.
         */

    }, {
        key: '_getAngleByCoordinate',
        value: function _getAngleByCoordinate(x, y) {
            function isInRange(from, to, angle) {
                while (to < from) {
                    to += 360;
                }while (angle < from) {
                    angle += 360;
                }return angle >= from && angle <= to;
            }

            var that = this,
                center = that._measurements.center,
                angleRadians = Math.atan2(y - center.y, x - center.x);
            var angleDeg = -1 * angleRadians * 180 / Math.PI;

            if (angleDeg < 0) {
                angleDeg += 360;
            }

            that._actualAngle = angleDeg;

            if (that._normalizedStartAngle !== that.endAngle && !isInRange(that._normalizedStartAngle, that.endAngle, angleDeg)) {
                // coordinates are outside the range
                if (that._numericProcessor._getAngleDifference(angleDeg, that._normalizedStartAngle) <= that._numericProcessor._getAngleDifference(angleDeg, that.endAngle)) {
                    angleDeg = that._normalizedStartAngle;
                    that._outsideStart = true;
                    that._outsideEnd = false;
                } else {
                    angleDeg = that.endAngle;
                    that._outsideEnd = true;
                    that._outsideStart = false;
                }

                that._outsideRange = true;
            } else {
                that._outsideRange = false;
                that._outsideStart = false;
                that._outsideEnd = false;
            }

            return angleDeg;
        }

        /**
         * Returns the coordinates of the Gauge's center.
         */

    }, {
        key: '_getCenterCoordinates',
        value: function _getCenterCoordinates() {
            var that = this,
                offset = that.$.container.getBoundingClientRect(),
                radius = that._measurements.radius,
                scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft,
                scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
            return { x: offset.left + scrollLeft + radius, y: offset.top + scrollTop + radius };
        }

        /**
         * Gets inline "fill"/"stroke" set to _track, _fill or _line.
         */

    }, {
        key: '_getInlineColors',
        value: function _getInlineColors() {
            var that = this;
            var trackColor = '',
                fillColor = '',
                lineColor = '';

            if (that._track) {
                trackColor = that._track.style.fill;
            }

            if (that._fill) {
                fillColor = that._fill.style.fill;
            }

            if (that._line) {
                lineColor = that._line.style.stroke;
            }

            return [trackColor, fillColor, lineColor];
        }

        /**
         * Measures some elements of the Gauge and stores the results.
         */

    }, {
        key: '_getMeasurements',
        value: function _getMeasurements() {
            var that = this;

            if (!that._isVisible() || that._renderingSuspended) {
                that._renderingSuspended = true;
                return;
            }

            var measurements = that._measurements;

            measurements.cachedWidth = that.offsetWidth;
            measurements.cachedHeight = that.offsetHeight;

            measurements.radius = measurements.cachedWidth / 2;

            var measureElement = document.createElement('div');

            if (that.enableShadowDOM) {
                that.shadowRoot.appendChild(measureElement);
            } else {
                that.appendChild(measureElement);
            }

            // ticks
            measureElement.className = 'jqx-tick';
            measurements.majorTickSize = measureElement.offsetWidth;
            measureElement.className += ' jqx-tick-minor';
            measurements.minorTickSize = measureElement.offsetWidth;

            // labels
            measureElement.className = 'jqx-label';
            var measureElementStyle = window.getComputedStyle(measureElement);
            measurements.fontSize = measureElementStyle.fontSize;
            measurements.fontFamily = measureElementStyle.fontFamily;
            measurements.fontWeight = measureElementStyle.fontWeight;
            measurements.fontStyle = measureElementStyle.fontStyle;

            measurements.trackWidth = 0;
            measurements.trackBorderWidth = 0;

            if (that.analogDisplayType === 'needle') {
                // needle
                measureElement.className = 'jqx-needle';
                measurements.needleWidth = measureElement.offsetWidth;
                measurements.needleLength = measureElement.offsetHeight;

                // ranges
                measureElement.className = 'jqx-range';
                measurements.rangeSize = measureElement.offsetWidth;
            } else {
                // 'fill' and 'line' case
                // track
                measureElement.className = 'jqx-track';
                measurements.trackBorderWidth = parseFloat(measureElementStyle.strokeWidth);
                measurements.trackWidth = Math.min(measureElement.offsetWidth, measurements.radius - measurements.trackBorderWidth);
                measurements.lineSize = measurements.trackWidth + measurements.trackBorderWidth;

                if (that.ticksPosition === 'track') {
                    measurements.majorTickSize = measurements.lineSize;
                    measurements.minorTickSize = measurements.majorTickSize / 2;
                }
            }

            if (that.enableShadowDOM) {
                that.shadowRoot.removeChild(measureElement);
            } else {
                that.removeChild(measureElement);
            }
        }

        /**
         * Returns the quadrant of an angle.
         */

    }, {
        key: '_getQuadrant',
        value: function _getQuadrant(angle) {
            if (angle > 270) {
                return 4;
            } else if (angle > 180) {
                return 3;
            } else if (angle > 90) {
                return 2;
            } else {
                return 1;
            }
        }

        /**
         * Returns the rotation direction.
         */

    }, {
        key: '_getRotationDirection',
        value: function _getRotationDirection() {
            var that = this,
                quadrant = that._getQuadrant(that._actualAngle);

            if (that._actualAngle < that._angle && (quadrant !== 1 || that._quadrant !== 4) || that._actualAngle > that._angle && quadrant === 4 && that._quadrant === 1) {
                return 'cw';
            } else {
                return 'ccw';
            }
        }

        /**
         * Creates a new TickIntervalHandler instance.
         */

    }, {
        key: '_initTickIntervalHandler',
        value: function _initTickIntervalHandler() {
            var that = this;

            if (!that._isVisible() || that._renderingSuspended) {
                that._renderingSuspended = true;
                return;
            }

            var minLabel = that._formatLabel(that.min, false),
                maxLabel = that._formatLabel(that.max, false);

            that._tickIntervalHandler = new JQX.Utilities.TickIntervalHandler(that, minLabel, maxLabel, 'jqx-label', that._settings.size, that.scaleType === 'integer', that.logarithmicScale);
        }

        /**
         * Gauge keydown event handler.
         */

    }, {
        key: '_keydownHandler',
        value: function _keydownHandler(event) {
            var that = this,
                oldValue = that._getEventValue(),
                stringValue = that._number.toString();

            if (that.mode === 'numeric') {
                if (that.value.toString() !== stringValue) {
                    that.value = stringValue;
                    that.$.digitalDisplay.value = stringValue;
                }

                babelHelpers.get(Gauge.prototype.__proto__ || Object.getPrototypeOf(Gauge.prototype), '_keydownHandler', this).call(this, event);

                if (that.value.toString() !== oldValue) {
                    that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValue });
                }
            } else {
                if (that.value.toString() !== stringValue) {
                    that._valueDate = JQX.Utilities.DateTime.fromFullTimeStamp(stringValue);
                    that.value = that._number;
                    that.$.digitalDisplay.$.input.value = that._valueDate;
                }

                babelHelpers.get(Gauge.prototype.__proto__ || Object.getPrototypeOf(Gauge.prototype), '_keydownHandler', this).call(this, event);

                if (that._valueDate.compare(oldValue) !== 0) {
                    that.$.fireEvent('change', { 'value': that._getEventValue(), 'oldValue': oldValue });
                }
            }
        }

        /**
         * Normalizes the value of an angle.
         */

    }, {
        key: '_normalizeAngle',
        value: function _normalizeAngle(angle) {
            angle = angle % 360;

            if (angle < 0) {
                angle += 360;
            }

            return angle;
        }

        /**
         * Renders the analog display, ticks and labels in the correct order
         */

    }, {
        key: '_renderAnalogItems',
        value: function _renderAnalogItems(distanceCalculation) {
            var that = this;

            if (!that._isVisible() || that._renderingSuspended) {
                that._renderingSuspended = true;
                return;
            }

            var colors = that._getInlineColors();

            that._unlisten();
            that._draw.clear();
            delete that._needle;
            delete that._centralCircle;
            delete that._track;
            delete that._trackListener;
            delete that._fill;
            delete that._fillListener;
            delete that._line;
            delete that._lineListener;
            that._ranges = [];
            that._minCoordinates = [];
            that._maxCoordinates = [];

            if (distanceCalculation !== false) {
                delete that._largestLabelSize;
                that._distance = that._calculateTickAndLabelDistance();
            }

            if (that._plotTicks !== false || that._plotLabels !== false) {
                that._calculateTickInterval();

                var cachedLabelsSize = that._cachedLabelsSize,
                    alternativeLargestLabelSize = Math.max(cachedLabelsSize.minLabelSize, cachedLabelsSize.minLabelOtherSize, cachedLabelsSize.maxLabelSize, cachedLabelsSize.maxLabelOtherSize);
                if (distanceCalculation !== false && that._largestLabelSize !== alternativeLargestLabelSize) {
                    that._largestLabelSize = alternativeLargestLabelSize;

                    that._distance = that._calculateTickAndLabelDistance();
                    that._calculateTickInterval();
                }
            }

            if (that._coerceInitialDateValue) {
                that._validateValue();
                delete that._coerceInitialDateValue;
            }

            that._drawRanges();
            that._addAnalogDisplay();

            if (that.ticksVisibility !== 'none' && that._plotTicks !== false || that.labelsVisibility !== 'none' && that._plotLabels !== false) {
                if (!(that.customInterval || that._dateInterval)) {
                    that._numericProcessor.addGaugeTicksAndLabels();
                } else {
                    that._numericProcessor.addGaugeCustomTicks();
                }
            }

            that._drawFill(false);

            that._updateSize();

            that._restoreInlineColors(colors[0], colors[1], colors[2]);
        }

        /**
         * Gauge resize event handler. Ensures the Gauge's bounding box always has the correct proportions.
         */

    }, {
        key: '_resizeHandler',
        value: function _resizeHandler() {
            var that = this;

            if (that._preventResizeHandler) {
                delete that._preventResizeHandler;
                return;
            }

            if (!that._isVisible()) {
                that._renderingSuspended = true;
                return;
            } else if (that._renderingSuspended) {
                that._createElement();
                return;
            }

            var measurements = that._measurements;

            if (that._renderingSuspended || measurements.cachedWidth === that.offsetWidth && measurements.cachedHeight === that.offsetHeight) {
                return;
            }

            if (that.sizeMode === 'circle') {
                if (that.offsetWidth !== that.offsetHeight) {
                    if (measurements.cachedWidth !== that.offsetWidth) {
                        that.style.height = that.offsetWidth + 'px';
                        that._preventResizeHandler = true;
                    } else if (measurements.cachedHeight !== that.offsetHeight) {
                        that.style.width = that.offsetHeight + 'px';
                        that._preventResizeHandler = true;
                    }
                }
            } else {
                if (measurements.cachedHeight !== that.offsetHeight && measurements.cachedWidth === that.offsetWidth) {
                    that.style.height = measurements.cachedHeight + 'px';
                    that._preventResizeHandler = true;
                    return;
                }

                that.$.container.style.height = that.offsetWidth + 'px';
            }

            measurements.cachedWidth = that.offsetWidth;
            measurements.cachedHeight = that.offsetHeight;
            measurements.radius = measurements.cachedWidth / 2;

            if (!that._equalToHalfRadius) {
                measurements.innerRadius = measurements.radius - that._distance.labelDistance;
            } else {
                measurements.innerRadius = measurements.radius / 2;
            }

            that._renderAnalogItems(false);
        }

        /**
         * Restores inline "fill"/"stroke" previously set to _track, _fill or _line.
         */

    }, {
        key: '_restoreInlineColors',
        value: function _restoreInlineColors(trackColor, fillColor, lineColor) {
            var that = this;

            if (that._track && trackColor !== '') {
                that._track.style.fill = trackColor;
            }

            if (that._fill && fillColor !== '') {
                that._fill.style.fill = fillColor;
            }

            if (that._line && lineColor !== '') {
                that._line.style.stroke = lineColor;
            }
        }

        /**
         * Document select start handler.
         */

    }, {
        key: '_selectStartHandler',
        value: function _selectStartHandler(event) {
            if (this._dragging) {
                event.preventDefault();
            }
        }

        /**
         * Specifies the behaviour of the method "_updatePointer".
         */

    }, {
        key: '_setUpdatePointerMethod',
        value: function _setUpdatePointerMethod() {
            var that = this;

            if (that.analogDisplayType === 'needle') {
                that._updatePointer = function (value) {
                    if (that._customSVGElements) {
                        for (var i = 0; i < that._customSVGElements.length; i++) {
                            that._draw.removeElement(that._customSVGElements[i]);
                        }
                    }

                    that._drawNeedle(true, value);
                };
            } else {
                that._updatePointer = function (value) {
                    that._drawFill(true, value);
                };
            }
        }

        /**
         * styleChanged event handler.
         */

    }, {
        key: '_styleChangedHandler',
        value: function _styleChangedHandler(event) {
            var that = this;

            if (event.detail.styleProperties && event.detail.styleProperties['min-height']) {
                return;
            }

            if (!that._isVisible()) {
                that._renderingSuspended = true;
                return;
            } else if (that._renderingSuspended) {
                that._createElement();
                return;
            }

            that._getMeasurements();
            that._initTickIntervalHandler();
            that._renderAnalogItems();
        }

        /**
         * (Mouse)down event handler for the track, fill and line SVG elements.
         */

    }, {
        key: '_SVGElementDownHandler',
        value: function _SVGElementDownHandler(event) {
            var that = this,
                oldContext = that.context;

            that.context = that;
            that._downHandler(event, true);
            that.context = oldContext;
        }

        /**
         * Unlocks rotation of the analog display.
         */

    }, {
        key: '_unlockRotation',
        value: function _unlockRotation(lockName, angle, quadrant, referentAngle, conditions) {
            var that = this,
                firstCondition = conditions.firstCondition,
                secondCondition = conditions.secondCondition,
                angleQuadrant = that._getQuadrant(referentAngle);

            if ((firstCondition && (quadrant !== 4 || angleQuadrant !== 1) || secondCondition && quadrant === 4 && angleQuadrant === 1) && that._numericProcessor._getAngleDifference(angle, referentAngle) < 10) {
                that[lockName] = false;
            }
        }

        /**
         * Updates the size of the Gauge when "sizeMode" is 'circle'.
         */

    }, {
        key: '_updateSize',
        value: function _updateSize(getter) {
            var that = this;

            if (that.sizeMode === 'circle' && getter === undefined) {
                return;
            }

            var minCoordinates = that._minCoordinates,
                maxCoordinates = that._maxCoordinates;
            var top = minCoordinates[0],
                bottom = maxCoordinates[0];

            for (var i = 1; i < minCoordinates.length; i++) {
                top = Math.min(top, minCoordinates[i]);
            }

            for (var _i = 1; _i < maxCoordinates.length; _i++) {
                bottom = Math.max(bottom, maxCoordinates[_i]);
            }

            var gaugeClientRect = that.getBoundingClientRect();

            if (that.digitalDisplay) {
                var digitalDisplayClientRect = that.$.digitalDisplay.getBoundingClientRect();

                top = Math.min(top, digitalDisplayClientRect.top - gaugeClientRect.top);
                bottom = Math.max(bottom, digitalDisplayClientRect.bottom - gaugeClientRect.top);
            }

            if (that.analogDisplayType !== 'needle') {
                var trackBBox = that._track.getBBox();

                top = Math.min(top, trackBBox.y);
                bottom = Math.max(bottom, trackBBox.y + trackBBox.height);
            }

            for (var _i2 = 0; _i2 < that._ranges.length; _i2++) {
                var rangeBBox = that._ranges[_i2].getBBox();

                top = Math.min(top, rangeBBox.y - gaugeClientRect.top);
                bottom = Math.max(bottom, rangeBBox.y + rangeBBox.height - gaugeClientRect.top);
            }

            top -= 2;

            var newHeight = bottom - top;

            if (getter === undefined) {
                that._preventResizeHandler = true;

                that.style.height = newHeight + 'px';
                that.$.container.style.marginTop = -1 * top + 'px';

                that._measurements.cachedHeight = newHeight;
            } else {
                return Math.round(newHeight);
            }
        }

        /**
         * Updates the values of the Gauge and its digital display and fires the "change" event.
         */

    }, {
        key: '_updateValue',
        value: function _updateValue(newValue) {
            this._numericProcessor.updateGaugeValue(newValue);
        }

        /**
         * Validates the value and updates the pointer.
         */

    }, {
        key: '_validate',
        value: function _validate(initialValidation, programmaticValue, keyCode) {
            var that = this,
                oldValue = that.value;

            that._validateValue(programmaticValue);

            if (keyCode && (keyCode === 35 || keyCode === 36)) {
                that._animate(oldValue);
            } else {
                that._updatePointer();
            }
        }

        /**
         * Validates the startAngle and endAngle properties.
         */

    }, {
        key: '_validateAngles',
        value: function _validateAngles() {
            var that = this;

            that._normalizedStartAngle = that._normalizeAngle(that.startAngle);
            that.endAngle = that._normalizeAngle(that.endAngle);

            if (that._normalizedStartAngle < that.endAngle) {
                that.startAngle = that._normalizedStartAngle;
            } else {
                that.startAngle = that._normalizedStartAngle - 360;
            }

            that._angleDifference = that.endAngle - that.startAngle;
        }

        /**
         * Validates initial property values.
         */

    }, {
        key: '_validateInitialPropertyValues',
        value: function _validateInitialPropertyValues() {
            babelHelpers.get(Gauge.prototype.__proto__ || Object.getPrototypeOf(Gauge.prototype), '_validateInitialPropertyValues', this).call(this);

            var that = this;

            if (that.sizeMode === 'circle') {
                if (that.offsetWidth < that.offsetHeight) {
                    that.style.height = that.offsetWidth + 'px';
                } else if (that.offsetWidth > that.offsetHeight) {
                    that.style.width = that.offsetHeight + 'px';
                }
            } else {
                if (that.offsetHeight !== that.offsetWidth) {
                    that.style.height = that.offsetWidth + 'px';
                }

                that.$.container.style.height = that.offsetWidth + 'px';
            }

            that._validateAngles();

            if (that.significantDigits !== null) {
                that.$.digitalDisplay.significantDigits = that.significantDigits;
            } else if (that.precisionDigits !== null) {
                that.$.digitalDisplay.precisionDigits = that.precisionDigits;
            }
        }

        /**
         * Validates the Gauge's value.
         */

    }, {
        key: '_validateValue',
        value: function _validateValue(value, oldValue) {
            var that = this,
                numericProcessor = that._numericProcessor,
                logarithmicGauge = that.logarithmicScale,
                strictValidation = that.validation === 'strict';
            var fireEvent = strictValidation && oldValue !== undefined;

            if (value === undefined) {
                fireEvent = false;
                value = that.value;
            } else {
                value = value.toString();
            }

            if (numericProcessor.regexScientificNotation.test(value)) {
                value = numericProcessor.scientificToDecimal(value);
            }

            if (isNaN(value)) {
                value = oldValue || 0;
            }

            var valueNoRangeValidation = void 0,
                stringValueNoRangeValidation = void 0,
                stringValue = void 0;

            if (that.coerce) {
                valueNoRangeValidation = numericProcessor.getCoercedValue(numericProcessor.createDescriptor(value, true, true, true), false, logarithmicGauge);
                that._number = valueNoRangeValidation;
                stringValueNoRangeValidation = valueNoRangeValidation.toString();
                stringValue = stringValueNoRangeValidation;
            } else if (strictValidation) {
                valueNoRangeValidation = numericProcessor.getCoercedValue(numericProcessor.createDescriptor(value, true, true, true), false, logarithmicGauge);
                that._number = valueNoRangeValidation;
                stringValueNoRangeValidation = valueNoRangeValidation.toString();
                stringValue = stringValueNoRangeValidation;
            } else {
                fireEvent = false;
                valueNoRangeValidation = numericProcessor.getCoercedValue(numericProcessor.createDescriptor(value, true, true, false), false, logarithmicGauge);
                that._number = numericProcessor.validate(valueNoRangeValidation, numericProcessor.createDescriptor(that._minObject), numericProcessor.createDescriptor(that._maxObject));
                stringValueNoRangeValidation = valueNoRangeValidation.toString();
                stringValue = that._number.toString();
            }

            var oldValueDetail = void 0,
                valueDetail = void 0;

            if (that.mode === 'numeric') {
                oldValueDetail = oldValue;
                valueDetail = stringValueNoRangeValidation;
                that.value = stringValueNoRangeValidation; // the "value" property continues to return the value set by the user
                that.$.digitalDisplay.value = stringValueNoRangeValidation;
            } else {
                oldValueDetail = that._valueDate;
                that._valueDate = JQX.Utilities.DateTime.fromFullTimeStamp(stringValueNoRangeValidation);
                valueDetail = that._valueDate;
                that.value = valueNoRangeValidation;
                that.$.digitalDisplay.$.input.value = that._valueDate;
            }

            that._drawValue = logarithmicGauge ? Math.log10(stringValue).toString() : stringValue;

            if (fireEvent && numericProcessor.compare(that._number, oldValue)) {
                that.$.fireEvent('change', { 'value': valueDetail, 'oldValue': oldValueDetail });
            }

            delete that._valueBeforeCoercion;
        }

        /**
         * Removes custom event listeners.
         */

    }, {
        key: '_unlisten',
        value: function _unlisten() {
            var that = this;

            if (that._trackListener) {
                that._trackListener.unlisten();
            }

            if (that._fillListener) {
                that._fillListener.unlisten();
            }

            if (that._lineListener) {
                that._lineListener.unlisten();
            }
        }
    }], [{
        key: 'properties',

        /**
         * Gauge's properties.
         */
        get: function get() {
            return {
                'analogDisplayType': {
                    value: 'needle',
                    allowedValues: ['needle', 'fill', 'line'],
                    type: 'string'
                },
                'animationDuration': {
                    value: 300,
                    type: 'number'
                },
                'digitalDisplay': {
                    value: false,
                    type: 'boolean'
                },
                'digitalDisplayPosition': {
                    value: 'bottom',
                    allowedValues: ['top', 'bottom', 'right', 'left', 'center'],
                    type: 'string'
                },
                'drawNeedle': {
                    value: null,
                    type: 'function?'
                },
                'endAngle': {
                    value: 210,
                    type: 'number'
                },
                'needlePosition': {
                    value: 'center',
                    allowedValues: ['center', 'edge'],
                    type: 'string'
                },
                'ranges': {
                    value: [],
                    type: 'array'
                },
                'scalePosition': {
                    value: 'inside',
                    allowedValues: ['outside', 'inside', 'none'],
                    type: 'string'
                },
                'showRanges': {
                    value: false,
                    type: 'boolean'
                },
                'sizeMode': {
                    value: 'circle',
                    allowedValues: ['circle', 'auto'],
                    type: 'string'
                },
                'startAngle': {
                    value: -30,
                    type: 'number'
                }
            };
        }

        /**
         * Gauge's event listeners.
         */

    }, {
        key: 'listeners',
        get: function get() {
            return {
                'down': '_downHandler',
                'resize': '_resizeHandler',
                'styleChanged': '_styleChangedHandler',
                'document.move': '_documentMoveHandler',
                'document.up': '_documentUpHandler',
                'document.selectstart': '_selectStartHandler',
                'keydown': '_keydownHandler',
                'move': '_trackMoveHandler'
            };
        }

        /**
         * Gauge's required files.
         */

    }, {
        key: 'requires',
        get: function get() {
            return {
                'JQX.Utilities.Draw': 'jqxdraw.js',
                'JQX.NumericTextBox': 'jqxnumerictextbox.js'
            };
        }

        /**
        * CSS files needed for the element (ShadowDOM)
        */

    }, {
        key: 'styleUrls',
        get: function get() {
            return ['jqx.gauge.css'];
        }
    }]);
    return Gauge;
}(JQX.Tank));