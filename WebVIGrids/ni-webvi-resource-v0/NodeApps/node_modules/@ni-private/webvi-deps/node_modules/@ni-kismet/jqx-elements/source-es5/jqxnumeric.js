'use strict';

/**
 * A class for instantiating a number processor object.
 */
JQX.Utilities.Assign('NumericProcessor', function NumericProcessor(context, numericFormatProperty) {
    babelHelpers.classCallCheck(this, NumericProcessor);

    switch (context[numericFormatProperty]) {
        case 'integer':
            return new JQX.Utilities.IntegerNumericProcessor(context, numericFormatProperty);
        case 'floatingPoint':
            return new JQX.Utilities.DecimalNumericProcessor(context, numericFormatProperty);
        case 'complex':
            return new JQX.Utilities.ComplexNumericProcessor(context, numericFormatProperty);
    }
});

/**
 * A base class for processesing numbers.
 */
JQX.Utilities.Assign('BaseNumericProcessor', function () {
    function BaseNumericProcessor(context, numericFormatProperty) {
        babelHelpers.classCallCheck(this, BaseNumericProcessor);

        var that = this;

        that.context = context;
        that._longestLabelSize = 0;
        that.numericFormatProperty = numericFormatProperty;
        that.regexScientificNotation = new RegExp(/^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)(Y|Z|E|P|T|G|M|k|c|m|u|n|p|f|a|z|y){1}$/); // regular expressions for scientific notation
        that.regexNoLeadingZero = new RegExp(/^(-)?[.]\d+$/);
        that.regexLeadingZero = new RegExp(/^[+\-]?(0+)[1-9]+|^[+\-]?(0{2,})[.]|^(0{2,})$/);
        that.prefixesToPowers = { 'Y': 24, 'Z': 21, 'E': 18, 'P': 15, 'T': 12, 'G': 9, 'M': 6, 'k': 3, 'c': -2, 'm': -3, 'u': -6, 'n': -9, 'p': -12, 'f': -15, 'a': -18, 'z': -21, 'y': -24 };

        if (window.NIComplex) {
            that.complexConstructor = window.NIComplex;
        } else {
            that.complexConstructor = JQX.Utilities.Complex;
        }
    }

    babelHelpers.createClass(BaseNumericProcessor, [{
        key: 'prepareForValidation',
        value: function prepareForValidation(initialValidation, programmaticValue, value) {
            var that = this.context,
                initialOrProgrammatic = initialValidation || programmaticValue !== undefined;

            value = value.toString();
            value = value.replace(/\s/g, '');
            value = that._discardDecimalSeparator(value);

            if (this.regexLeadingZero.test(value)) {
                var testResult = this.regexLeadingZero.exec(value);

                if (testResult[1]) {
                    value = value.replace(testResult[1], '');
                } else if (testResult[2]) {
                    value = value.replace(testResult[2], '0');
                } else {
                    value = value.replace(testResult[3], '0');
                }
            }

            if (this.regexNoLeadingZero.test(value)) {
                if (value.charAt(0) === '-') {
                    value = '-0' + value.slice(1);
                } else {
                    value = '0' + value;
                }
            } else if ((that[this.numericFormatProperty] === 'integer' && (that._radixNumber === 10 || initialOrProgrammatic) || that[this.numericFormatProperty] === 'floatingPoint') && this.regexScientificNotation.test(value)) {
                // scientific notation test
                value = this.scientificToDecimal(value);
            }

            var complexNumberIsEntered = false,
                enteredComplexNumber = void 0;

            if (that[this.numericFormatProperty] === 'complex' && that._regexSpecial.nonNumericValue.test(value) === false) {
                try {
                    if (that._regexSpecial.exaValue.test(value)) {
                        // handles ambiguous "exa" case
                        var indexOfExa = value.indexOf('E'),
                            realPart = parseFloat(value.slice(0, indexOfExa)) * Math.pow(10, 18),
                            imaginaryPart = parseFloat(value.slice(indexOfExa + 1, -1));

                        enteredComplexNumber = new this.complexConstructor(realPart, imaginaryPart);
                    } else {
                        enteredComplexNumber = new this.complexConstructor(value);
                    }
                    complexNumberIsEntered = true;
                } catch (error) {
                    complexNumberIsEntered = false;
                }
            }

            // if the entered value is not a number
            if (complexNumberIsEntered === false && (!initialOrProgrammatic && that._regex[that._radixNumber].test(value) === false || initialOrProgrammatic && that._regex[10].test(value) === false)) {
                that._handleNonNumericValue(initialValidation, programmaticValue, value);
                return;
            }

            return { value: value, enteredComplexNumber: enteredComplexNumber };
        }

        /**
         * Checks if a number is in exponential notation.
         */

    }, {
        key: 'isENotation',
        value: function isENotation(value) {
            var eNotationRegex = new RegExp(/e/i);

            return eNotationRegex.test(value.toString());
        }

        /**
         * Converts a number in scientific notation to a plain number.
         */

    }, {
        key: 'scientificToDecimal',
        value: function scientificToDecimal(scientificValue) {
            var parts = this.regexScientificNotation.exec(scientificValue),
                numericPart = parts[1],
                prefix = parts[2],
                number = parseFloat(numericPart) * Math.pow(10, this.prefixesToPowers[prefix]);

            return number;
        }

        /**
         * Creates a label dummy element.
         */

    }, {
        key: '_createMeasureLabel',
        value: function _createMeasureLabel() {
            var context = this.context,
                measureLabel = document.createElement('div');

            measureLabel.className = 'jqx-label';
            measureLabel.style.position = 'absolute';
            measureLabel.style.visibility = 'hidden';
            if (context.scalePosition !== 'far') {
                context._measureLabelScale = context.$.scaleNear;
            } else {
                context._measureLabelScale = context.$.scaleFar;
            }
            context._measureLabelScale.appendChild(measureLabel);

            return measureLabel;
        }

        /**
         * Adds a major tick and its respective label.
         */

    }, {
        key: '_addMajorTickAndLabel',
        value: function _addMajorTickAndLabel(htmlValue, labelSize, plot, value, middle) {
            var that = this.context,
                leftOrTop = that._settings.leftOrTop,
                offset = this.valueToPx(value);

            var currentTick = '',
                currentLabel = '';

            if (parseInt(offset) > parseInt(that._measurements.trackLength)) {
                return { tick: currentTick, label: currentLabel };
            }

            if (that.logarithmicScale) {
                htmlValue = that._formatLabel(Math.pow(10, value));
            }

            if (that.nodeName.toLowerCase() === 'jqx-tank' || that._intervalHasChanged) {
                var tickIntervalLabelSize = that._tickIntervalHandler.labelsSize;

                if (middle) {
                    that._labelDummy.innerHTML = htmlValue;

                    var tickPosition = this.valueToPx(value),
                        maxPosition = this.valueToPx(that._drawMax),
                        minPosition = this.valueToPx(that._drawMin),
                        _labelSize = that._labelDummy[that._settings.size],
                        labelOtherSize = that.orientation === 'vertical' ? that._labelDummy.offsetWidth : that._labelDummy.offsetHeight,
                        distanceToMin = (_labelSize + tickIntervalLabelSize.minLabelSize) / 2,
                        distanceToMax = (_labelSize + tickIntervalLabelSize.maxLabelSize) / 2;

                    that._normalLayout ? plot = tickPosition + distanceToMax < maxPosition && tickPosition - distanceToMin > minPosition : plot = tickPosition - distanceToMax > maxPosition && tickPosition + distanceToMin < minPosition;

                    if (labelOtherSize > this._longestLabelSize) {
                        this._longestLabelSize = labelOtherSize;
                    }
                } else {
                    this._longestLabelSize = Math.max(tickIntervalLabelSize.minLabelOtherSize, tickIntervalLabelSize.maxLabelOtherSize, this._longestLabelSize);
                }
            }

            that._tickValues.push(value);

            currentTick = '<div style="' + leftOrTop + ': ' + offset + 'px;" class="jqx-tick"></div>';

            if (plot !== false) {
                if (labelSize === undefined) {
                    that._labelDummy.innerHTML = htmlValue;
                    labelSize = that._labelDummy[that._settings.size];
                }
                var labelOffset = offset - labelSize / 2;

                currentLabel += '<div class="jqx-label' + (middle ? ' jqx-label-middle' : '') + '" style="' + leftOrTop + ': ' + labelOffset + 'px;">' + htmlValue + '</div>';
            }

            return { tick: currentTick, label: currentLabel };
        }

        /**
         * Gets the internal numeric word length based on the "wordLength" property.
         */

    }, {
        key: 'getWordLength',
        value: function getWordLength(wordLength) {
            this.context._unsigned = wordLength.charAt(0) === 'u';

            switch (wordLength) {
                case 'int8':
                case 'uint8':
                    return 8;
                case 'int16':
                case 'uint16':
                    return 16;
                case 'int32':
                case 'uint32':
                    return 32;
                case 'int64':
                case 'uint64':
                    return 64;
            }
        }

        /**
         * Returns the angle equivalent of a value.
         */

    }, {
        key: 'getAngleByValue',
        value: function getAngleByValue(value, calculateDrawValue, returnDegrees) {
            var that = this.context;

            if (calculateDrawValue !== false && that.logarithmicScale) {
                value = Math.log10(value);
            }

            var angleOffset = (value - that._drawMin) * that._angleRangeCoefficient;
            var degrees = void 0;

            if (!that.inverted) {
                degrees = that.endAngle - angleOffset;
            } else {
                degrees = that.startAngle + angleOffset;
            }

            if (returnDegrees) {
                return degrees;
            }
            return degrees * Math.PI / 180 + Math.PI / 2;
        }

        /**
         * Returns the value equivalent of an angle.
         */

    }, {
        key: 'getValueByAngle',
        value: function getValueByAngle(angle, integer) {
            var that = this.context;
            var minuendAngle = void 0,
                subtrahendAngle = void 0,
                value = void 0;

            if (!that.inverted) {
                minuendAngle = that.endAngle;
                subtrahendAngle = angle;
            } else {
                minuendAngle = angle;
                subtrahendAngle = that._normalizedStartAngle;
            }

            while (minuendAngle < subtrahendAngle) {
                minuendAngle += 360;
            }value = (minuendAngle - subtrahendAngle) / that._angleDifference * that._range + parseFloat(that._drawMin);

            if (that.logarithmicScale) {
                if (that.customInterval) {
                    return parseFloat(Math.pow(10, this.getCoercedValue(value, true)).toFixed(12));
                }

                value = Math.pow(10, value);
            }

            if (integer && !that.coerce) {
                return Math.round(value);
            }

            value = this.createDescriptor(value, undefined, true, true);

            return this.getCoercedValue(value, false);
        }

        /**
         * Updates the values of the Gauge and its digital display and fires the "change" event.
         */

    }, {
        key: 'updateGaugeValue',
        value: function updateGaugeValue(newValue) {
            var that = this.context,
                oldValue = that.value;

            that.value = newValue;
            that._drawValue = that.logarithmicScale ? Math.log10(newValue).toString() : newValue;
            that._number = this.createDescriptor(that.value);
            that.$.digitalDisplay.value = newValue;
            that.$.fireEvent('change', { 'value': newValue, 'oldValue': oldValue });

            delete that._valueBeforeCoercion;
        }

        /**
         * Validates the start or end value of a Gauge color range.
         */

    }, {
        key: 'validateColorRange',
        value: function validateColorRange(value) {
            var that = this.context;

            return Math.min(Math.max(value, that.min), that.max);
        }

        /**
         * Returns a value based on the passed "draw" value.
         */

    }, {
        key: 'getActualValue',
        value: function getActualValue(value) {
            if (!this.context.logarithmicScale) {
                return value;
            } else {
                return Math.pow(10, value);
            }
        }

        /**
         * Draws minor ticks on a Gauge logarithmic scale.
         */

    }, {
        key: 'drawGaugeLogarithmicScaleMinorTicks',
        value: function drawGaugeLogarithmicScaleMinorTicks(majorTickValues, majorStep, drawMinor) {
            var that = this.context;
            var firstWholePower = void 0;

            if (majorStep instanceof JQX.Utilities.BigNumber) {
                majorStep = parseFloat(majorStep.toString());
            }

            for (var i in majorTickValues) {
                firstWholePower = i;
                if (i >= 0 && i % 1 === 0) {
                    break;
                }
            }

            // positive powers
            for (var _i = parseFloat(firstWholePower); _i < that._drawMax; _i += majorStep) {
                for (var j = 2; j <= 9; j++) {
                    var value = j * Math.pow(10, _i + majorStep - 1);

                    if (value < that.max) {
                        drawMinor(value);
                    }
                }
            }

            // negative powers
            for (var _i2 = parseFloat(firstWholePower); _i2 > that._drawMin; _i2 -= majorStep) {
                for (var _j = 2; _j <= 9; _j++) {
                    var _value = _j * Math.pow(10, _i2 - 1);

                    if (_value > that.min) {
                        drawMinor(_value);
                    }
                }
            }
        }

        /**
         * Returns the difference between two angles.
         */

    }, {
        key: '_getAngleDifference',
        value: function _getAngleDifference(angle1, angle2) {
            var phi = Math.abs(angle2 - angle1) % 360,
                distance = phi > 180 ? 360 - phi : phi;

            return distance;
        }

        /**
         * Plots custom ticks.
         */

    }, {
        key: 'addCustomTicks',
        value: function addCustomTicks() {
            var numericProcessor = this,
                that = numericProcessor.context,
                normalScale = !that.logarithmicScale;
            var ticks = '',
                labels = '';

            function createTickAndLabel(i) {
                var currentLabel = that.customTicks[i],
                    value = normalScale ? numericProcessor.createDescriptor(currentLabel) : Math.log10(currentLabel),
                    middle = i > 0 && i < that.customTicks.length - 1,
                    currentTickAndLabel = numericProcessor._addMajorTickAndLabel(that._formatLabel(currentLabel), undefined, true, value, middle);

                ticks += currentTickAndLabel.tick;
                labels += currentTickAndLabel.label;
            }

            numericProcessor._longestLabelSize = 0;
            that._tickValues = [];
            that._labelDummy = numericProcessor._createMeasureLabel();

            if (!that._normalLayout) {
                for (var i = that.customTicks.length - 1; i >= 0; i--) {
                    createTickAndLabel(i);
                }
            } else {
                for (var _i3 = 0; _i3 < that.customTicks.length; _i3++) {
                    createTickAndLabel(_i3);
                }
            }

            if (that.nodeName.toLowerCase() === 'jqx-tank') {
                that._updateScaleWidth(numericProcessor._longestLabelSize);
            }

            that._appendTicksAndLabelsToScales(ticks, labels);
        }

        /**
         * Plots the Gauge's custom ticks.
         */

    }, {
        key: 'addGaugeCustomTicks',
        value: function addGaugeCustomTicks() {
            var numericProcessor = this,
                that = numericProcessor.context,
                distance = that._distance,
                majorTickWidth = that._measurements.radius - distance.majorTickDistance;
            var drawTick = void 0,
                drawLabel = void 0;

            if (that.ticksVisibility !== 'none' && that._plotTicks !== false) {
                drawTick = function drawTick(angle) {
                    that._drawTick(angle, majorTickWidth, 'major');
                };
            } else {
                drawTick = function drawTick() {};
            }

            if (that.labelsVisibility !== 'none' && that._plotLabels !== false) {
                drawLabel = function drawLabel(angle, currentLabel, middle) {
                    that._drawLabel(angle, currentLabel, distance.labelDistance, middle);
                };
            } else {
                drawLabel = function drawLabel() {};
            }

            function createTickAndLabel(i) {
                var currentLabel = that.customTicks[i],
                    value = numericProcessor.createDescriptor(currentLabel),
                    angle = numericProcessor.getAngleByValue(value, true),
                    middle = i > 0 && i < that.customTicks.length - 1;

                drawTick(angle);
                drawLabel(angle, currentLabel, middle);
            }

            for (var i = that.customTicks.length - 1; i >= 0; i--) {
                createTickAndLabel(i);
            }
        }
    }]);
    return BaseNumericProcessor;
}());

/**
 * A class for processesing integer numbers.
 */
JQX.Utilities.Assign('IntegerNumericProcessor', function (_JQX$Utilities$BaseNu) {
    babelHelpers.inherits(IntegerNumericProcessor, _JQX$Utilities$BaseNu);

    function IntegerNumericProcessor(context, numericFormatProperty) {
        babelHelpers.classCallCheck(this, IntegerNumericProcessor);

        var _this = babelHelpers.possibleConstructorReturn(this, (IntegerNumericProcessor.__proto__ || Object.getPrototypeOf(IntegerNumericProcessor)).call(this, context, numericFormatProperty));

        var that = _this;

        that.context = context;
        that.defaultMins = { int8: '-128', uint8: '0', int16: '-32768', uint16: '0', int32: '-2147483648', uint32: '0', int64: '-9223372036854775808', uint64: '0' };
        that.defaultMaxs = { int8: '127', uint8: '255', int16: '32767', uint16: '65535', int32: '2147483647', uint32: '4294967295', int64: '9223372036854775807', uint64: '18446744073709551615' };
        return _this;
    }

    babelHelpers.createClass(IntegerNumericProcessor, [{
        key: 'createDescriptor',
        value: function createDescriptor(initialValue, supportsENotation, validateConstruction, validateMinMax, discardRadix) {
            var that = this.context;
            var returnValue = void 0;

            if (initialValue.constructor !== JQX.Utilities.BigNumber) {
                var radix = !discardRadix && that._radixNumber ? that._radixNumber : 10;

                if (radix === 10 && supportsENotation && initialValue.constructor !== JQX.Utilities.BigNumber && this.isENotation(initialValue)) {
                    if (JQX.Utilities.BigNumber.bigIntSupport) {
                        initialValue = new JQX.Utilities.BigNumber(Math.round(initialValue));
                    } else {
                        initialValue = new JQX.Utilities.NumberRenderer(initialValue).largeExponentialToDecimal();
                    }
                }
                if (that._toBigNumberDecimal) {
                    returnValue = that._toBigNumberDecimal(initialValue.toString(radix, that._wordLengthNumber), radix);
                } else {
                    returnValue = new JQX.Utilities.BigNumber(initialValue);
                }
            } else {
                returnValue = new JQX.Utilities.BigNumber(initialValue);
            }
            if (validateConstruction) {
                // if the entered number is negative and the "wordLength" is "uint", the number is set to 0
                if (that._unsigned && returnValue.compare(0) === -1) {
                    returnValue = returnValue.set(0);
                }
                if (validateMinMax) {
                    // if the entered number is outside the range defined by "min" and "max", the number is changed to the value of "min" or "max"
                    returnValue = this.validate(returnValue, that._minObject, that._maxObject);
                }
                returnValue = this.round(returnValue);
            }
            return returnValue;
        }

        /**
        * Returns a rounded BigNumber object
        */

    }, {
        key: 'round',
        value: function round(value) {
            var context = this.context;

            // eslint-disable-next-line
            if (value instanceof window.JQX.Utilities.BigNumber && typeof value._d === 'bigint') {
                return value;
            } else if (value instanceof window.JQX.Utilities.BigNumber === false || !context._wordLengthNumber || context._wordLengthNumber < 64) {
                return new JQX.Utilities.BigNumber(Math.round(value.toString()));
            }

            var fraction = value.mod(1);

            if (!(fraction._d.length === 1 && fraction._d[0] === 0)) {
                // if the entered number is with a decimal value, it is rounded up or down to its nearest integer equivalent

                value = value.intPart();
                if (!value._s) {
                    // round positive number
                    if (fraction._d[1] > 4) {
                        value = value.add(1);
                    }
                } else {
                    // round negative number
                    if (fraction._d[1] > 5 || fraction._d[1] === 5 && fraction._d[2]) {
                        value = value.add(-1);
                    }
                }
            }
            return value;
        }

        /**
         * Validates value.
         */

    }, {
        key: 'validate',
        value: function validate(initialValue, min, max) {
            var returnValue = void 0;

            if (initialValue.compare(min) === -1) {
                returnValue = min;
            } else if (initialValue.compare(max) === 1) {
                returnValue = max;
            } else {
                returnValue = initialValue;
            }
            return returnValue;
        }

        /**
         * Validates min/max.
         */

    }, {
        key: 'validateMinMax',
        value: function validateMinMax(validateMin, validateMax) {
            var that = this.context;

            var defaultMin = this.defaultMins[that.wordLength],
                defaultBigMin = new JQX.Utilities.BigNumber(defaultMin),
                defaultMax = this.defaultMaxs[that.wordLength],
                defaultBigMax = new JQX.Utilities.BigNumber(defaultMax),
                numericScale = that.mode !== 'date';

            if (that._numberRenderer === undefined) {
                that._numberRenderer = new JQX.Utilities.NumberRenderer();
            }

            if (validateMin && numericScale) {
                if (that.min !== null) {
                    that.min = that.min.toString().replace(/\s/g, '');
                    if (this.regexScientificNotation.test(that.min)) {
                        that.min = this.scientificToDecimal(that.min);
                    }
                }
                var currentBigMin = this.round(new JQX.Utilities.BigNumber(that.min));

                if (that.min !== null && (!that._minIsNull || !that._initialized) && currentBigMin.compare(defaultBigMin) >= 0) {
                    that._minObject = currentBigMin;
                } else {
                    that._minIsNull = true;
                    that.min = defaultMin;
                    that._minObject = defaultBigMin;
                }
            }

            if (validateMax && numericScale) {
                if (that.max !== null) {
                    that.max = that.max.toString().replace(/\s/g, '');
                    if (this.regexScientificNotation.test(that.max)) {
                        that.max = this.scientificToDecimal(that.max);
                    }
                }
                var currentBigMax = this.round(new JQX.Utilities.BigNumber(that.max));

                if (that.max !== null && (!that._maxIsNull || !that._initialized) && currentBigMax.compare(defaultBigMax) <= 0) {
                    that._maxObject = currentBigMax;
                } else {
                    that._maxIsNull = true;
                    that.max = defaultMax;
                    that._maxObject = defaultBigMax;
                }
            }

            if (!numericScale) {
                that._minObject = new JQX.Utilities.BigNumber(that.min);
                that._maxObject = new JQX.Utilities.BigNumber(that.max);
            }

            if (!this.compare(that._minObject, that._maxObject)) {
                //Set default values
                that._minObject = defaultBigMin;
                that._maxObject = defaultBigMax;
                that._drawMin = that.logarithmicScale ? 0 : defaultMin;
                that._drawMax = that.logarithmicScale ? 10 : defaultMax;
                that.min = defaultMin;
                that.max = defaultMax;
            }

            if (!numericScale) {
                that._minDate = JQX.Utilities.DateTime.fromFullTimeStamp(that.min);
                that._maxDate = JQX.Utilities.DateTime.fromFullTimeStamp(that.max);
            }
        }

        /**
         * Converts value to pixels.
         */

    }, {
        key: 'valueToPx',
        value: function valueToPx(value) {
            var ignored = JQX.Utilities.BigNumber.ignoreBigIntNativeSupport;

            JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = true;

            var that = this.context,
                lengthRangeRatio = new JQX.Utilities.BigNumber(that._measurements.trackLength).divide(new JQX.Utilities.BigNumber(that._range));

            var result = void 0;

            if (that._normalLayout) {
                var drawMin = that._drawMin instanceof JQX.Utilities.BigNumber ? that._drawMin : new JQX.Utilities.BigNumber(that._drawMin);

                value = new JQX.Utilities.BigNumber(value);
                result = parseFloat(lengthRangeRatio.multiply(value.subtract(drawMin)).toString());
            } else {
                var drawMax = that._drawMax instanceof JQX.Utilities.BigNumber ? that._drawMax : new JQX.Utilities.BigNumber(that._drawMax);

                result = parseFloat(this.round(drawMax.subtract(value).multiply(lengthRangeRatio)).toString());
            }

            JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;
            return result;
        }

        /**
        * Returns the value equivalent of a pixel offset.
        */

    }, {
        key: 'pxToValue',
        value: function pxToValue(px) {
            var that = this.context,
                ignored = JQX.Utilities.BigNumber.ignoreBigIntNativeSupport;
            var result = void 0;

            JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = true;

            if (that._normalLayout) {
                result = that._valuePerPx.multiply(px - that._trackStart);
            } else {
                result = that._valuePerPx.multiply(that._trackEnd - px);
            }

            result = this.round(result).toString();

            JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;

            if (that.logarithmicScale) {
                var power = parseFloat(result) + parseFloat(that._drawMin);

                //that._drawValue = power;
                return new JQX.Utilities.BigNumber(Math.round(Math.pow(10, power)));
            }

            var returnedValue = this.createDescriptor(that._minObject.add(result), false, true, true);
            //that._drawValue = returnedValue;

            return returnedValue;
        }

        /**
         * BigNumber compare method.
         */

    }, {
        key: 'compare',
        value: function compare(initialValue, otherValue, thorough) {
            if ((initialValue === null || otherValue === null) && initialValue !== otherValue) {
                return true;
            }

            if (initialValue.constructor !== JQX.Utilities.BigNumber) {
                initialValue = new JQX.Utilities.BigNumber(initialValue);
            }

            var result = initialValue.compare(otherValue);

            if (thorough !== true) {
                return result !== 0;
            }

            return result;
        }

        /**
         * Increments/Decrements value. Keyboard navigation operations.
         */

    }, {
        key: 'incrementDecrement',
        value: function incrementDecrement(initialValue, operation, stepObject) {
            var that = this.context;

            var returnValue = void 0;

            if (initialValue.constructor !== JQX.Utilities.BigNumber) {
                initialValue = new JQX.Utilities.BigNumber(initialValue);
            }

            if (operation === 'add') {
                returnValue = initialValue.add(stepObject);
                if (that._drawMax !== undefined) {
                    return returnValue.compare(that._drawMax) > 0 ? new JQX.Utilities.BigNumber(that._drawMax) : returnValue;
                }
            } else {
                returnValue = initialValue.subtract(stepObject);
                if (that._drawMin !== undefined) {
                    return returnValue.compare(that._drawMin) < 0 ? new JQX.Utilities.BigNumber(that._drawMin) : returnValue;
                }
            }
            return returnValue;
        }

        /**
         * Renders the value. Scientific notation renderer.
         */

    }, {
        key: 'render',
        value: function render(initialValue, ignoreRadixNumber) {
            var context = this.context;

            if (!context.scientificNotation && ignoreRadixNumber === true) {
                return new JQX.Utilities.NumberRenderer(new JQX.Utilities.BigNumber(initialValue)).bigNumberToExponent(context.significantDigits);
            }

            // scientific notation
            var returnValue = initialValue;

            if (context.scientificNotation && ignoreRadixNumber === true) {
                returnValue = new JQX.Utilities.NumberRenderer(returnValue).toScientific(context.significantDigits, context.precisionDigits);
            } else if (typeof initialValue !== 'string') {
                returnValue = initialValue.toString(context._radixNumber, context._wordLengthNumber, context.leadingZeros);
            }

            return returnValue;
        }

        /**
         * Adds tank\'s ticks and labels.
         */

    }, {
        key: 'addTicksAndLabels',
        value: function addTicksAndLabels() {
            var ignored = JQX.Utilities.BigNumber.ignoreBigIntNativeSupport;

            JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = true;

            var that = this.context,
                trackLength = that._measurements.trackLength,
                normalLayout = that._normalLayout,
                ticksFrequency = that._majorTicksInterval,
                tickscount = this.round(new JQX.Utilities.BigNumber(that._range).divide(ticksFrequency)),
                ticksDistance = trackLength / tickscount,
                min = new JQX.Utilities.BigNumber(that._drawMin),
                max = new JQX.Utilities.BigNumber(that._drawMax);

            var first = void 0,
                second = void 0,
                distanceModifier = void 0,
                last = void 0,
                firstLabelValue = void 0,
                firstLabelSize = void 0,
                lastLabelValue = void 0,
                lastLabelSize = void 0,
                currentTickAndLabel = void 0,
                ticks = '',
                labels = '';

            that._tickValues = [];
            this._longestLabelSize = 0;

            if (normalLayout) {
                first = min;
                second = ticksFrequency.add(first.subtract(first.mod(ticksFrequency)));
                distanceModifier = second.subtract(first);
                firstLabelValue = that._formatLabel(min);
                firstLabelSize = that._tickIntervalHandler.labelsSize.minLabelSize;
                last = max;
                lastLabelValue = that._formatLabel(max);
                lastLabelSize = that._tickIntervalHandler.labelsSize.maxLabelSize;
            } else {
                first = max;
                second = first.subtract(first.mod(ticksFrequency));
                distanceModifier = first.subtract(second);
                firstLabelValue = that._formatLabel(max);
                firstLabelSize = that._tickIntervalHandler.labelsSize.maxLabelSize;
                last = min;
                lastLabelValue = that._formatLabel(min);
                lastLabelSize = that._tickIntervalHandler.labelsSize.minLabelSize;
            }

            that._labelDummy = this._createMeasureLabel();

            currentTickAndLabel = this._addMajorTickAndLabel(firstLabelValue, firstLabelSize, true, first); // first tick and label
            ticks += currentTickAndLabel.tick;
            labels += currentTickAndLabel.label;

            // special case for second tick and label
            var distanceFromFirstToSecond = distanceModifier.divide(ticksFrequency).multiply(ticksDistance);

            if (second.compare(that.max) !== 0 && distanceFromFirstToSecond.compare(trackLength) < 0) {
                // second item rendering
                var secondItemHtmlValue = that._formatLabel(second.toString()),
                    plotSecond = distanceFromFirstToSecond.compare(firstLabelSize) > 0;

                currentTickAndLabel = this._addMajorTickAndLabel(secondItemHtmlValue, undefined, plotSecond, second, true);
                ticks += currentTickAndLabel.tick;
                labels += currentTickAndLabel.label;
            }
            currentTickAndLabel = this.addMiddleMajorTicks(tickscount, ticksDistance, distanceFromFirstToSecond, distanceModifier, normalLayout, ticksFrequency);
            ticks += currentTickAndLabel.tick;
            labels += currentTickAndLabel.label;
            currentTickAndLabel = this._addMajorTickAndLabel(lastLabelValue, lastLabelSize, true, last); // last tick and label
            ticks += currentTickAndLabel.tick;
            labels += currentTickAndLabel.label;

            if (that.mode !== 'date') {
                ticks += this.addMinorTicks(normalLayout);
            }

            that._measureLabelScale.removeChild(that._labelDummy);
            delete that._labelDummy;
            delete that._measureLabelScale;

            if (that.nodeName.toLowerCase() === 'jqx-tank') {
                that._updateScaleWidth(this._longestLabelSize);
            }

            that._appendTicksAndLabelsToScales(ticks, labels);
            JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;
        }

        /**
        * Adds the middle major ticks and their respective labels.
        */

    }, {
        key: 'addMiddleMajorTicks',
        value: function addMiddleMajorTicks(tickscount, ticksDistance, distanceFromFirstToSecond, distanceModifier, normalLayout, ticksFrequency) {
            var that = this.context;

            var majorTicks = '',
                majorLabels = '',
                valuePlusExponent = void 0;

            for (var i = 1; i < tickscount; i++) {
                var number = distanceFromFirstToSecond.add(i * ticksDistance),
                    value = void 0;

                if (normalLayout) {
                    value = ticksFrequency.multiply(i).add(distanceModifier.add(new JQX.Utilities.BigNumber(that._drawMin)));
                } else {
                    value = new JQX.Utilities.BigNumber(that._drawMax).subtract(distanceModifier).subtract(ticksFrequency.multiply(i));

                    // if the value of the penultimate is 0 we add the exponent to accurately calculate its size
                    if (i === tickscount - 1 && value.compare(0) === 0) {
                        that._numberRenderer.numericValue = that._tickIntervalHandler.nearestPowerOfTen;
                        valuePlusExponent = that._numberRenderer.bigNumberToExponent(1);
                    }
                }
                if (value.compare(that._drawMax) !== 0) {
                    var htmlValue = that._formatLabel(value.toString()),
                        plot = true;

                    that._labelDummy.innerHTML = valuePlusExponent ? valuePlusExponent : htmlValue;
                    var dimensionValue = that._labelDummy[that._settings.size];

                    if (number.add(dimensionValue).compare(tickscount * ticksDistance) >= 0) {
                        // + 5 is an experimental value
                        plot = false; // does not plot the second to last label if it intersects with the last one
                    }

                    var currentTickAndLabel = this._addMajorTickAndLabel(htmlValue, undefined, plot, value, true);

                    majorTicks += currentTickAndLabel.tick;
                    majorLabels += currentTickAndLabel.label;
                }
            }
            return { tick: majorTicks, label: majorLabels };
        }

        /**
         * Adds minor ticks.
         */

    }, {
        key: 'addMinorTicks',
        value: function addMinorTicks(normalLayout) {
            function addMinorTick(i) {
                if (tickValues.indexOf(i) === -1 && i % minorTicksInterval === 0) {
                    minorTicks += '<div style="' + leftOrTop + ': ' + that._numericProcessor.valueToPx(i) + 'px;" class="jqx-tick jqx-tick-minor"></div>';
                }
            }

            var that = this.context,
                tickValues = that._tickValues,
                nearestPowerOfTen = that._tickIntervalHandler.nearestPowerOfTen,
                minorTicksInterval = that._minorTicksInterval,
                leftOrTop = that._settings.leftOrTop;

            var firstTickValue = void 0,
                secondTickValue = void 0,
                lastTickValue = void 0,
                minorTicks = '';

            if (normalLayout) {
                firstTickValue = tickValues[0];
                secondTickValue = tickValues[1];
                lastTickValue = tickValues[tickValues.length - 1];
            } else {
                firstTickValue = tickValues[tickValues.length - 1];
                secondTickValue = tickValues[tickValues.length - 2];
                lastTickValue = tickValues[0];
            }

            if (that.logarithmicScale) {
                addMinorTickOnLogarithmicScale();
            } else {
                // minor ticks from the beginning to the second major tick
                for (var i = secondTickValue; firstTickValue.compare(i) < 0; i = i.subtract(nearestPowerOfTen)) {
                    addMinorTick(i);
                }

                // minor ticks from the second major tick to the end
                for (var _i4 = secondTickValue.add(nearestPowerOfTen); lastTickValue.compare(_i4) > 0; _i4 = _i4.add(nearestPowerOfTen)) {
                    addMinorTick(_i4);
                }
            }

            function addMinorTickOnLogarithmicScale() {
                var trackLength = that._measurements.trackLength,
                    partialTrackLength = trackLength / tickValues.length,
                    modifierCoef = 0.1;

                if (partialTrackLength < 20) {
                    modifierCoef = 1;
                } else if (partialTrackLength >= 20 && partialTrackLength < 40) {
                    modifierCoef = secondTickValue - firstTickValue > 1 ? 1 : 0.5;
                } else if (partialTrackLength >= 40 && partialTrackLength < 80) {
                    modifierCoef = 0.2;
                }

                var nearestPowerOf10BelowMax = Math.floor(that._drawMax),
                    distanceToNearestPowerOf10 = that._drawMax - nearestPowerOf10BelowMax,
                    ticksOnPowerOf10 = that._drawMax - that._drawMin > tickValues.length;

                for (var j = that._drawMax; j > 0; j = j - 1) {
                    var range = distanceToNearestPowerOf10 > 0 ? Math.pow(10, j - distanceToNearestPowerOf10 + 1) : Math.pow(10, j),
                        modifier = range * modifierCoef;

                    for (var _i5 = range; _i5 > 0; _i5 = _i5 - modifier) {
                        if (_i5 < that.max && _i5 > that.min) {
                            var value = new JQX.Utilities.BigNumber(Math.log10(_i5));

                            if (value % 1 === 0 && ticksOnPowerOf10 || !ticksOnPowerOf10) {
                                minorTicks += '<div style="' + leftOrTop + ': ' + that._numericProcessor.valueToPx(value) + 'px;" class="jqx-tick jqx-tick-minor"></div>';
                            }
                        }
                    }
                }
            }

            return minorTicks;
        }

        /**
         * Validates custom ticks.
         */

    }, {
        key: 'validateCustomTicks',
        value: function validateCustomTicks() {
            var that = this.context,
                numericScale = that.mode !== 'date';
            var validCustomTicks = [];

            for (var i = 0; i < that.customTicks.length; i++) {
                var currentTick = that.customTicks[i];

                if (numericScale) {
                    currentTick = this.createDescriptor(currentTick, false, true);
                } else if (currentTick._d === undefined) {
                    currentTick = JQX.Utilities.DateTime.validateDate(currentTick).getTimeStamp();
                }

                if (currentTick.compare(that._minObject) >= 0 && currentTick.compare(that._maxObject) <= 0) {
                    validCustomTicks.push(currentTick);
                }
            }

            validCustomTicks.sort(function (a, b) {
                return a.compare(b);
            });

            if (numericScale) {
                for (var _i6 = 0; _i6 < validCustomTicks.length; _i6++) {
                    validCustomTicks[_i6] = validCustomTicks[_i6].toString();
                }

                validCustomTicks = validCustomTicks.filter(function (element, index, array) {
                    return !index || element !== array[index - 1];
                });
            }

            that.customTicks = validCustomTicks.slice(0);
        }

        /**
         * Plots the Gauge's ticks and labels.
         */

    }, {
        key: 'addGaugeTicksAndLabels',
        value: function addGaugeTicksAndLabels() {
            var ignored = JQX.Utilities.BigNumber.ignoreBigIntNativeSupport;

            JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = true;

            var that = this.context,
                numericProcessor = this,
                maxLabelHeight = Math.max(that._tickIntervalHandler.labelsSize.minLabelSize, that._tickIntervalHandler.labelsSize.maxLabelSize),
                majorStep = that._majorTicksInterval,
                minorStep = that._minorTicksInterval,
                majorTickValues = {},
                distance = that._distance,
                radius = that._measurements.radius,
                majorTickWidth = radius - distance.majorTickDistance,
                minorTickWidth = radius - distance.minorTickDistance,
                bigDrawMin = new JQX.Utilities.BigNumber(that._drawMin),
                bigDrawMax = new JQX.Utilities.BigNumber(that._drawMax);
            var drawMajor = void 0,
                drawMinor = void 0,
                addLabel = void 0,
                currentAngle = void 0,
                angleAtMin = void 0,
                angleAtMax = void 0;

            if (that.ticksVisibility !== 'none' && that._plotTicks !== false) {
                drawMajor = function drawMajor(angle) {
                    that._drawTick(angle, majorTickWidth, 'major');
                };

                drawMinor = function drawMinor(value) {
                    that._drawTick(numericProcessor.getAngleByValue(value, true), minorTickWidth, 'minor');
                };
            } else {
                drawMajor = function drawMajor() {};
                drawMinor = function drawMinor() {};
            }

            if (that.labelsVisibility !== 'none' && that._plotLabels !== false) {
                addLabel = function addLabel(angle, currentLabel, middle) {
                    that._drawLabel(angle, currentLabel, distance.labelDistance, middle);
                };
            } else {
                addLabel = function addLabel() {};
            }

            if (!that.inverted) {
                angleAtMin = that.endAngle;
                angleAtMax = that.startAngle;
            } else {
                angleAtMin = that.startAngle;
                angleAtMax = that.endAngle;
            }

            // first major tick and label
            currentAngle = numericProcessor.getAngleByValue(bigDrawMin, false);
            drawMajor(currentAngle);
            majorTickValues[that._drawMin.toString()] = true;
            addLabel(currentAngle, that.min, false);

            var second = bigDrawMin.subtract(bigDrawMin.mod(majorStep)),
                firstMinTick = void 0;

            if (bigDrawMin.compare(0) !== -1) {
                second = second.add(majorStep);
            }

            // determines the value at the first minor tick
            for (var _i7 = new JQX.Utilities.BigNumber(second); _i7.compare(bigDrawMin) !== -1; _i7 = _i7.subtract(minorStep)) {
                firstMinTick = _i7;
            }

            // second major tick and label
            currentAngle = numericProcessor.getAngleByValue(second, false);
            drawMajor(currentAngle);
            majorTickValues[second.toString()] = true;
            if (2 * Math.PI * that._measurements.innerRadius * (this._getAngleDifference(angleAtMin, numericProcessor.getAngleByValue(second, false, true)) / 360) > maxLabelHeight) {
                addLabel(currentAngle, this.getActualValue(second), second.compare(bigDrawMax) === -1);
            }

            var i = void 0;
            // middle major ticks and labels
            for (i = second.add(majorStep); i.compare(bigDrawMax.subtract(majorStep)) === -1; i = i.add(majorStep)) {
                currentAngle = numericProcessor.getAngleByValue(i, false);
                drawMajor(currentAngle);
                majorTickValues[i.toString()] = true;
                addLabel(currentAngle, this.getActualValue(i), true);
            }

            if (majorTickValues[i.toString()] === undefined && i.compare(bigDrawMax) !== 1) {
                // second-to-last major tick and label
                currentAngle = numericProcessor.getAngleByValue(i, false);
                drawMajor(currentAngle);
                majorTickValues[i.toString()] = true;
                if (2 * Math.PI * that._measurements.innerRadius * (this._getAngleDifference(angleAtMax, numericProcessor.getAngleByValue(i, false, true)) / 360) >= maxLabelHeight) {
                    addLabel(currentAngle, this.getActualValue(i), true);
                }

                if (that._normalizedStartAngle !== that.endAngle) {
                    // last major tick and label
                    currentAngle = numericProcessor.getAngleByValue(bigDrawMax, false);
                    drawMajor(currentAngle);
                    if (2 * Math.PI * that._measurements.innerRadius * (this._getAngleDifference(angleAtMax, angleAtMin) / 360) >= maxLabelHeight) {
                        addLabel(currentAngle, that.max, false);
                    }
                }
            }

            if (that.mode === 'date') {
                JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;
                return;
            }

            // minor ticks
            if (!that.logarithmicScale) {
                for (var j = firstMinTick; j.compare(bigDrawMax) === -1; j = j.add(minorStep)) {
                    if (majorTickValues[j.toString()]) {
                        continue; // does not plot minor ticks over major ones
                    }
                    drawMinor(j);
                }
            } else {
                this.drawGaugeLogarithmicScaleMinorTicks(majorTickValues, majorStep, drawMinor);
            }

            JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;
        }

        /**
         * Sets toolTip's value and updates the value of the element.
         */

    }, {
        key: 'updateToolTipAndValue',
        value: function updateToolTipAndValue(value, oldValue, changeValue) {
            var that = this.context,
                logarithmicScale = that.logarithmicScale;

            that._updateTooltipValue(value.toString());
            if (logarithmicScale) {
                value = parseFloat(Math.pow(10, parseFloat(value)).toFixed(11));
            }

            value = value instanceof JQX.Utilities.BigNumber ? value : new JQX.Utilities.BigNumber(value);

            var stringifiedValue = value.toString();

            that._number = value;
            that._drawValue = logarithmicScale ? Math.log10(stringifiedValue) : value;

            // eslint-disable-next-line
            if (value.compare(oldValue) !== 0 && changeValue) {
                if (that.mode === 'numeric') {
                    that.value = stringifiedValue;
                    value = stringifiedValue;
                } else {
                    oldValue = that._valueDate;
                    that._valueDate = JQX.Utilities.DateTime.fromFullTimeStamp(stringifiedValue);
                    that.value = value;
                    value = that._valueDate;
                }

                if (!that._programmaticValueIsSet) {
                    that.$.fireEvent('change', { 'value': value, 'oldValue': oldValue });
                }

                if (that.$.hiddenInput) {
                    that.$.hiddenInput.value = value;
                }
            }
        }

        /**
         * Validates the interval property.
         */

    }, {
        key: 'validateInterval',
        value: function validateInterval(interval) {
            var that = this.context,
                range = that._maxObject.subtract(that._minObject);

            that._validInterval = new JQX.Utilities.BigNumber(interval);
            that._validInterval = this.round(that._validInterval);

            if (that._validInterval.compare(range) === 1) {
                that._validInterval = range;
            }

            that.interval = that._validInterval.toString();
        }

        /**
         * Returns a coerced value based on the interval.
         */

    }, {
        key: 'getCoercedValue',
        value: function getCoercedValue(value, useDrawVariables, logarithmicGauge) {
            var that = this.context;

            if (!that.coerce) {
                return value;
            }

            var normalScale = !that.logarithmicScale;

            value = value instanceof JQX.Utilities.BigNumber ? value : new JQX.Utilities.BigNumber(value);

            var minValue = void 0,
                maxValue = void 0;

            if (that.customInterval) {
                var customTicks = that.customTicks;

                if (customTicks.length === 0) {
                    return value;
                }

                var difference = void 0,
                    closestValue = void 0;

                if (normalScale || logarithmicGauge) {
                    minValue = that._minObject;
                    difference = minValue.subtract(value).abs();
                    closestValue = minValue;

                    for (var i = 0; i < customTicks.length; i++) {
                        var currentTickObject = this.createDescriptor(customTicks[i]),
                            currentDifference = currentTickObject.subtract(value).abs();

                        if (currentDifference.compare(difference) === -1) {
                            difference = currentDifference;
                            closestValue = currentTickObject;
                        }
                    }
                } else {
                    minValue = that._drawMin;
                    difference = Math.abs(minValue - parseFloat(value.toString()));
                    closestValue = minValue;

                    for (var _i8 = 0; _i8 < customTicks.length; _i8++) {
                        var _currentTickObject = Math.log10(customTicks[_i8]),
                            _currentDifference = Math.abs(_currentTickObject - value);

                        if (_currentDifference < difference) {
                            difference = _currentDifference;
                            closestValue = _currentTickObject;
                        }
                    }

                    closestValue = new JQX.Utilities.BigNumber(closestValue);
                }

                return closestValue;
            }

            var interval = that._validInterval;

            if (that.mode === 'date') {
                if (that._dateIncrementMethod === 'addYears') {
                    return this.coerceYear(value);
                } else if (that._dateIncrementMethod === 'addMonths') {
                    return this.coerceMonth(value);
                } else {
                    interval = new JQX.Utilities.BigNumber(that._dateIntervalNumber).multiply(interval);
                }
            }

            if (useDrawVariables !== false) {
                minValue = new JQX.Utilities.BigNumber(that._drawMin);
                maxValue = new JQX.Utilities.BigNumber(that._drawMax);
            } else {
                minValue = new JQX.Utilities.BigNumber(that.min);
                maxValue = new JQX.Utilities.BigNumber(that.max);
            }

            var noMin = value.subtract(minValue),
                remainder = noMin.mod(interval);

            if (remainder.compare(0) === 0) {
                return value;
            }

            var lowerValue = noMin.subtract(remainder),
                greaterValue = lowerValue.add(interval);

            if (noMin.subtract(lowerValue).abs().compare(noMin.subtract(greaterValue).abs()) < 0) {
                return lowerValue.add(minValue);
            } else {
                var biggerValue = greaterValue.add(minValue);

                return biggerValue.compare(maxValue) <= 0 ? biggerValue : lowerValue.add(minValue);
            }
        }
    }, {
        key: 'coerceMonth',
        value: function coerceMonth(value) {
            var that = this.context,
                interval = parseFloat(that._validInterval),
                date = JQX.Utilities.DateTime.fromFullTimeStamp(value),
                year = date.year(),
                month = date.month(),
                day = date.day(),
                minYear = that._minDate.year(),
                minMonth = that._minDate.month(),
                totalMonths = (that._maxDate.year() - minYear - 1) * 12 + 12 - minMonth + that._maxDate.month();
            var currentMonths = (year - 1 - minYear) * 12 + (12 - minMonth) + month;

            if (interval === 1) {
                if ([1, 3, 5, 7, 8, 10, 12].indexOf(month) !== -1) {
                    if (day > 16 || day === 16 && date.hour() > 11) {
                        currentMonths++;
                    }
                } else if (month === 2) {
                    if (date.isLeapYear(year)) {
                        if (day > 15 || day === 15 && date.hour() > 11) {
                            currentMonths++;
                        }
                    } else if (day > 14) {
                        currentMonths++;
                    }
                } else if (day > 15) {
                    currentMonths++;
                }
            }

            currentMonths = this.getCoercedTimePart(0, totalMonths, currentMonths, interval);

            var result = that._minDate.addMonths(currentMonths, true);

            if (result.compare(that._maxDate) === 1) {
                result = that._minDate.addMonths(currentMonths - interval, true);
            }

            that._drawValue = new JQX.Utilities.BigNumber(result.getTimeStamp());
            return that._drawValue;
        }
    }, {
        key: 'coerceYear',
        value: function coerceYear(value) {
            var that = this.context,
                interval = parseFloat(that._validInterval),
                date = JQX.Utilities.DateTime.fromFullTimeStamp(value),
                maxYear = that._maxDate.year(),
                updatedValueConstructorParameters = JQX.Utilities.DateTime.getConstructorParameters(that._minDate);
            var year = date.year();

            if (date.month() > 6) {
                year++;
            }

            var coercedTimePart = this.getCoercedTimePart(that._minDate.year(), maxYear, year, interval);

            if (coercedTimePart > maxYear) {
                coercedTimePart -= interval;
            }

            updatedValueConstructorParameters[0] = coercedTimePart;
            updatedValueConstructorParameters.unshift(null);

            var valueDate = new (Function.prototype.bind.apply(JQX.Utilities.DateTime, updatedValueConstructorParameters))();

            that._drawValue = new JQX.Utilities.BigNumber(valueDate.getTimeStamp());
            return that._drawValue;
        }
    }, {
        key: 'getCoercedTimePart',
        value: function getCoercedTimePart(min, max, value, interval) {
            var noMin = value - min,
                remainder = noMin % interval;

            if (remainder === 0) {
                return value;
            }

            var lowerValue = parseFloat((noMin - remainder).toFixed(12)),
                greaterValue = lowerValue + interval;

            if (max - min <= interval) {
                return value >= min + (max - min) / 2 ? max : min;
            }

            if (Math.abs(noMin - lowerValue) < Math.abs(noMin - greaterValue)) {
                return lowerValue + min;
            } else {
                var biggerValue = greaterValue + min;

                return biggerValue > max ? lowerValue + min : biggerValue;
            }
        }

        /**
         * Updates the value of the Tank and the "value" property and triggers the respective events.
         */

    }, {
        key: 'updateValue',
        value: function updateValue(value) {
            var that = this.context;

            value = value instanceof JQX.Utilities.BigNumber ? value : new JQX.Utilities.BigNumber(value);

            var renderedValue = this.validate(value, that._minObject, that._maxObject);
            var oldValue = that.value,
                valueDetail = void 0,
                difference = void 0;

            that._number = renderedValue;
            that._drawValue = that.logarithmicScale ? Math.log10(renderedValue) : renderedValue;

            if (that.mode === 'numeric') {
                valueDetail = value.toString();
                that.value = valueDetail;
                difference = this.compare(value, oldValue);
            } else {
                oldValue = JQX.Utilities.DateTime.fromFullTimeStamp(oldValue);
                that._valueDate = JQX.Utilities.DateTime.fromFullTimeStamp(value);
                that.value = value;
                value = that._valueDate;
                valueDetail = value;
                difference = value.compare(oldValue) !== 0;
            }

            if (!that._programmaticValueIsSet && (difference || that._scaleTypeChangedFlag)) {
                that.$.fireEvent('change', { 'value': valueDetail, 'oldValue': oldValue });
            }

            if (that.$.hiddenInput) {
                that.$.hiddenInput.value = value;
            }

            that._moveThumbBasedOnValue(that._drawValue);
        }

        /**
         * Returns value per pixel.
         */

    }, {
        key: 'getValuePerPx',
        value: function getValuePerPx(range, pxRange) {
            var ignored = JQX.Utilities.BigNumber.ignoreBigIntNativeSupport;

            JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = true;

            var result = new JQX.Utilities.BigNumber(range).divide(pxRange);

            JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;
            return result;
        }

        /**
         * Restricts the thumbs to not pass each other.
         */

    }, {
        key: 'restrictValue',
        value: function restrictValue(values) {
            if (values[1].constructor === JQX.Utilities.BigNumber) {
                if (values[1].compare(values[0]) === -1) {
                    values[1].set(values[0]);
                }
            } else {
                if (values[1] < values[0]) {
                    values[1] = values[0];
                }
            }
        }

        /**
         * Returns the angle equivalent of a value.
         */

    }, {
        key: 'getAngleByValue',
        value: function getAngleByValue(value, calculateDrawValue, returnDegrees) {
            var that = this.context,
                ignored = JQX.Utilities.BigNumber.ignoreBigIntNativeSupport;

            JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = true;

            if (that._wordLengthNumber < 64) {
                JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;
                return babelHelpers.get(IntegerNumericProcessor.prototype.__proto__ || Object.getPrototypeOf(IntegerNumericProcessor.prototype), 'getAngleByValue', this).call(this, parseFloat(value.toString()), calculateDrawValue, returnDegrees);
            }

            if (value instanceof JQX.Utilities.BigNumber === false) {
                value = new JQX.Utilities.BigNumber(value);
            }

            if (calculateDrawValue !== false && that.logarithmicScale) {
                value = new JQX.Utilities.BigNumber(Math.log10(value.toString()));
            }

            var angleOffset = value.subtract(that._drawMin).multiply(that._angleRangeCoefficient);
            var degrees = void 0;

            if (!that.inverted) {
                degrees = angleOffset.multiply(-1).add(that.endAngle);
            } else {
                degrees = angleOffset.add(that.startAngle);
            }

            degrees = parseFloat(degrees.toString());
            JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;

            if (returnDegrees) {
                return degrees;
            }

            return degrees * Math.PI / 180 + Math.PI / 2;
        }

        /**
         * Returns the value equivalent of an angle.
         */

    }, {
        key: 'getValueByAngle',
        value: function getValueByAngle(angle) {
            var that = this.context;

            if (that._wordLengthNumber < 64) {
                return babelHelpers.get(IntegerNumericProcessor.prototype.__proto__ || Object.getPrototypeOf(IntegerNumericProcessor.prototype), 'getValueByAngle', this).call(this, angle, true);
            }

            var ignored = JQX.Utilities.BigNumber.ignoreBigIntNativeSupport;
            var minuendAngle = void 0,
                subtrahendAngle = void 0,
                value = void 0;

            JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = true;

            if (!that.inverted) {
                minuendAngle = that.endAngle;
                subtrahendAngle = angle;
            } else {
                minuendAngle = angle;
                subtrahendAngle = that._normalizedStartAngle;
            }

            while (minuendAngle < subtrahendAngle) {
                minuendAngle += 360;
            }value = new JQX.Utilities.BigNumber((minuendAngle - subtrahendAngle) / that._angleDifference).multiply(that._range).add(that._drawMin);

            if (that.logarithmicScale) {
                value = new JQX.Utilities.BigNumber(Math.pow(10, value.toString()));
            }

            var result = void 0;

            if (that.coerce) {
                result = this.getCoercedValue(value, false);
            } else {
                result = this.round(value);
            }

            JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;
            return new JQX.Utilities.BigNumber(result);
        }

        /**
         * Updates the values of the Gauge and its digital display and fires the "change" event.
         */

    }, {
        key: 'updateGaugeValue',
        value: function updateGaugeValue(newValue) {
            if (newValue instanceof JQX.Utilities.BigNumber === false) {
                return babelHelpers.get(IntegerNumericProcessor.prototype.__proto__ || Object.getPrototypeOf(IntegerNumericProcessor.prototype), 'updateGaugeValue', this).call(this, newValue);
            }

            var that = this.context,
                oldValue = that._getEventValue();

            if (that.mode === 'numeric') {
                that.value = newValue.toString();
                that.$.digitalDisplay.value = that.value;
            } else {
                that._valueDate = JQX.Utilities.DateTime.fromFullTimeStamp(newValue);
                that.value = newValue;
                that.$.digitalDisplay.$.input.value = that._valueDate;
            }

            that._drawValue = that.logarithmicScale ? Math.log10(that.value).toString() : that.value;
            that._number = newValue;

            that.$.fireEvent('change', { 'value': that._getEventValue(), 'oldValue': oldValue });
        }

        /**
         * Validates the start or end value of a Gauge color range.
         */

    }, {
        key: 'validateColorRange',
        value: function validateColorRange(value) {
            var that = this.context;

            if (that._wordLengthNumber < 64) {
                return babelHelpers.get(IntegerNumericProcessor.prototype.__proto__ || Object.getPrototypeOf(IntegerNumericProcessor.prototype), 'validateColorRange', this).call(this, value);
            }

            if (that.mode === 'numeric') {
                value = new JQX.Utilities.BigNumber(value);
            } else {
                value = JQX.Utilities.DateTime.validateDate(value);
                value = value.getTimeStamp();
            }

            var bigMin = new JQX.Utilities.BigNumber(that.min),
                bigMax = new JQX.Utilities.BigNumber(that.max);

            if (value.compare(bigMin) === -1) {
                value = bigMin;
            }

            if (value.compare(bigMax) === 1) {
                value = bigMax;
            }

            return value;
        }

        /**
         * Locks the Gauge's interaction with the mouse.
         */

    }, {
        key: 'lockRotation',
        value: function lockRotation(directionCondition, newValue) {
            var that = this.context;

            if (newValue instanceof JQX.Utilities.BigNumber === false) {
                newValue = new JQX.Utilities.BigNumber(newValue);
            }

            if (directionCondition && newValue.compare(that._number) === -1) {
                that._lockCW = true;
                if (newValue.compare(that._maxObject) === -1) {
                    return new JQX.Utilities.BigNumber(that._maxObject);
                }
            } else if (!directionCondition && newValue.compare(that._number) === 1) {
                that._lockCCW = true;
                if (newValue.compare(that._minObject) === 1) {
                    return new JQX.Utilities.BigNumber(that._minObject);
                }
            }
        }

        /**
         * Gets the angle-range coefficient.
         */

    }, {
        key: 'getAngleRangeCoefficient',
        value: function getAngleRangeCoefficient() {
            var that = this.context,
                ignored = JQX.Utilities.BigNumber.ignoreBigIntNativeSupport;

            JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = true;
            that._angleRangeCoefficient = new JQX.Utilities.BigNumber(that._angleDifference).divide(that._range);
            JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;
        }
    }]);
    return IntegerNumericProcessor;
}(JQX.Utilities.BaseNumericProcessor));

/**
 * A class for processesing floating point numbers.
 */
JQX.Utilities.Assign('DecimalNumericProcessor', function (_JQX$Utilities$BaseNu2) {
    babelHelpers.inherits(DecimalNumericProcessor, _JQX$Utilities$BaseNu2);

    function DecimalNumericProcessor(context, numericFormatProperty) {
        babelHelpers.classCallCheck(this, DecimalNumericProcessor);

        var _this2 = babelHelpers.possibleConstructorReturn(this, (DecimalNumericProcessor.__proto__ || Object.getPrototypeOf(DecimalNumericProcessor)).call(this, context, numericFormatProperty));

        _this2.context = context;
        return _this2;
    }

    /**
     * Returns the precise modulo of the mod operation.
     */


    babelHelpers.createClass(DecimalNumericProcessor, [{
        key: 'getPreciseModulo',
        value: function getPreciseModulo(dividend, divisor, moduloCoefficient) {
            var sign = dividend >= 0 ? 1 : -1;

            dividend = Math.abs(dividend);
            divisor = Math.abs(divisor);

            if (typeof moduloCoefficient === 'undefined') {
                var dividendExponential = dividend.toExponential(),
                    divisorExponential = divisor.toExponential(),
                    dividendExponent = parseInt(dividendExponential.slice(dividendExponential.indexOf('e') + 1), 10),
                    divisorExponent = parseInt(divisorExponential.slice(divisorExponential.indexOf('e') + 1), 10),
                    dividendRoundCoefficient = dividendExponent < 0 ? Math.abs(dividendExponent) : 0,
                    divisorRoundCoefficient = divisorExponent < 0 ? Math.abs(divisorExponent) : 0,
                    _roundCoefficient = Math.max(dividendRoundCoefficient, divisorRoundCoefficient);

                this.roundCoefficient = _roundCoefficient;

                if (dividend < divisor) {
                    return sign * dividend;
                }
                if (dividend === divisor) {
                    return 0;
                }
                if ((dividend < -1 || dividend > 1) && (divisor < -1 || divisor > 1 || divisor === 1)) {
                    if (dividend % 1 === 0 && divisor % 1 === 0) {
                        return sign * (dividend % divisor);
                    } else {
                        var ignored = JQX.Utilities.BigNumber.ignoreBigIntNativeSupport;

                        JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = true;

                        var result = sign * parseFloat(new JQX.Utilities.BigNumber(dividend).mod(divisor).toString());

                        JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;
                        return result;
                    }
                }

                var _moduloCoefficient = Math.pow(10, _roundCoefficient);

                return sign * (dividend * _moduloCoefficient % (divisor * _moduloCoefficient) / _moduloCoefficient);
            }
            return sign * (Math.round(dividend * moduloCoefficient) % Math.round(divisor * moduloCoefficient));
        }

        /**
         * Creates a descriptor.
         */

    }, {
        key: 'createDescriptor',
        value: function createDescriptor(initialValue, supportsENotation, validateConstruction, validateMinMax) {
            var returnValue = parseFloat(initialValue);

            if (validateMinMax) {
                returnValue = this.validate(returnValue, this.context._minObject, this.context._maxObject);
            }
            return returnValue;
        }

        /**
         * Returns a rounded number
         */

    }, {
        key: 'round',
        value: function round(value) {
            return Math.round(value);
        }

        /**
         * Validates the value.
         */

    }, {
        key: 'validate',
        value: function validate(initialValue, min, max) {
            var returnValue = void 0;

            if (initialValue < min) {
                returnValue = min;
            } else if (initialValue > max) {
                returnValue = max;
            } else {
                returnValue = initialValue;
            }
            return returnValue;
        }

        /**
         * Validates min/max.
         */

    }, {
        key: 'validateMinMax',
        value: function validateMinMax(validateMin, validateMax) {
            var that = this.context,
                checkSpecialRegexMin = typeof that._regexSpecial !== 'undefined' ? that._regexSpecial.inf.test(that.min) : false,
                checkSpecialRegexMax = typeof that._regexSpecial !== 'undefined' ? that._regexSpecial.inf.test(that.max) : false;

            if (validateMin) {
                if (that.min === null || checkSpecialRegexMin) {
                    that.min = -Infinity;
                    that._minObject = -Infinity;
                } else {
                    that.min = that.min.toString().replace(/\s/g, '');
                    if (this.regexScientificNotation.test(that.min)) {
                        that.min = this.scientificToDecimal(that.min);
                    }

                    that._minObject = that._discardDecimalSeparator(that.min);
                }
            }
            if (validateMax) {
                if (that.max === null || checkSpecialRegexMax) {
                    that.max = Infinity;
                    that._maxObject = Infinity;
                } else {
                    that.max = that.max.toString().replace(/\s/g, '');
                    if (this.regexScientificNotation.test(that.max)) {
                        that.max = this.scientificToDecimal(that.max);
                    }

                    that._maxObject = that._discardDecimalSeparator(that.max);
                }
            }

            if (!this.compare(that._minObject, that._maxObject)) {

                //Set default values
                that._maxObject = parseFloat(that._maxObject) + 1;
                that.max = that._maxObject;
            }
        }

        /**
         * Returns the pixel equivalent of a value.
         */

    }, {
        key: 'valueToPx',
        value: function valueToPx(value) {
            var that = this.context,
                lengthRangeRatio = that._measurements.trackLength / that._range;

            var result = void 0;

            if (that._normalLayout) {
                result = lengthRangeRatio * (value - that._drawMin);
            } else {
                result = lengthRangeRatio * (that._drawMax - value);
            }

            return Math.round(result);
        }

        /**
         * Returns the value equivalent of a pixel offset.
         */

    }, {
        key: 'pxToValue',
        value: function pxToValue(px) {
            var that = this.context;

            var result = void 0;

            if (that._normalLayout) {
                result = (px - that._trackStart) * that._valuePerPx;
            } else {
                result = (that._trackEnd - px) * that._valuePerPx;
            }

            if (that.logarithmicScale) {
                var power = result + parseFloat(that._drawMin);

                return Math.pow(10, power);
            }

            return this.validate(result + that._minObject, that._minObject, that._maxObject);
        }

        /**
         * Decimal compare method.
         */

    }, {
        key: 'compare',
        value: function compare(initialValue, otherValue, thorough) {
            initialValue = parseFloat(initialValue);
            otherValue = parseFloat(otherValue);

            if (thorough !== true) {
                return initialValue !== otherValue;
            }

            if (initialValue < otherValue) {
                return -1;
            }

            if (initialValue > otherValue) {
                return 1;
            }

            return 0;
        }

        /**
         * Increments/Decrements value. Keyboard navigation operations.
         */

    }, {
        key: 'incrementDecrement',
        value: function incrementDecrement(initialValue, operation, stepObject) {
            var that = this.context;

            var returnValue = void 0;

            if (operation === 'add') {
                returnValue = parseFloat(initialValue) + parseFloat(stepObject);
                if (that._drawMax !== undefined) {
                    return returnValue > parseFloat(that._drawMax) ? that._drawMax : returnValue;
                }
            } else {
                returnValue = parseFloat(initialValue) - parseFloat(stepObject);
                if (that._drawMin !== undefined) {
                    return returnValue < parseFloat(that._drawMin) ? that._drawMin : returnValue;
                }
            }
            return returnValue;
        }

        /**
         * Renders the value.
         */

    }, {
        key: 'render',
        value: function render(initialValue) {
            var that = this.context,
                checkSpecialRegex = typeof that._regexSpecial !== 'undefined' ? that._regexSpecial.nonNumericValue.test(initialValue) : false;

            if (checkSpecialRegex) {
                return initialValue;
            } else {
                var numberRenderer = new JQX.Utilities.NumberRenderer(initialValue);

                if (that.scientificNotation) {
                    return numberRenderer.toScientific(that.significantDigits, that.precisionDigits);
                } else {
                    return numberRenderer.toDigits(that.significantDigits, that.precisionDigits);
                }
            }
        }

        /**
         * Adds tank's ticks and labels.
         */

    }, {
        key: 'addTicksAndLabels',
        value: function addTicksAndLabels() {
            var that = this.context,
                trackLength = that._measurements.trackLength,
                normalLayout = that._normalLayout,
                ticksFrequency = that._majorTicksInterval,
                tickscount = Math.round(that._range / parseFloat(ticksFrequency.toString())),
                ticksDistance = trackLength / tickscount,
                min = parseFloat(that._drawMin),
                max = parseFloat(that._drawMax);

            var first = void 0,
                second = void 0,
                distanceModifier = void 0,
                last = void 0,
                firstLabelValue = void 0,
                firstLabelSize = void 0,
                lastLabelValue = void 0,
                lastLabelSize = void 0,
                currentTickAndLabel = void 0,
                ticks = '',
                labels = '';

            that._tickValues = [];
            this._longestLabelSize = 0;

            if (normalLayout) {
                first = min;

                //handling specific case
                if (that.logarithmicScale && min < 0 && min !== -1) {
                    second = parseFloat(first - this.getPreciseModulo(first, ticksFrequency));
                } else {
                    second = parseFloat(first - this.getPreciseModulo(first, ticksFrequency) + parseFloat(ticksFrequency));
                }

                distanceModifier = second - first;
                firstLabelValue = that._formatLabel(min);
                firstLabelSize = that._tickIntervalHandler.labelsSize.minLabelSize;
                last = max;
                lastLabelValue = that._formatLabel(max);
                lastLabelSize = that._tickIntervalHandler.labelsSize.maxLabelSize;
            } else {
                first = max;
                second = parseFloat(first - this.getPreciseModulo(first, ticksFrequency));
                distanceModifier = first - second;
                firstLabelValue = that._formatLabel(max);
                firstLabelSize = that._tickIntervalHandler.labelsSize.maxLabelSize;
                last = min;
                lastLabelValue = that._formatLabel(min);
                lastLabelSize = that._tickIntervalHandler.labelsSize.minLabelSize;
            }

            that._labelDummy = this._createMeasureLabel();

            currentTickAndLabel = this._addMajorTickAndLabel(firstLabelValue, firstLabelSize, true, first); // first tick and label
            ticks += currentTickAndLabel.tick;
            labels += currentTickAndLabel.label;

            // special case for second tick and label
            var distanceFromFirstToSecond = distanceModifier / ticksFrequency * ticksDistance;

            if (second.toString() !== that._drawMax.toString() && distanceFromFirstToSecond < trackLength) {
                // second item rendering
                var secondItemHtmlValue = that._formatLabel(second.toString()),
                    plotSecond = firstLabelSize < distanceFromFirstToSecond;

                currentTickAndLabel = this._addMajorTickAndLabel(secondItemHtmlValue, undefined, plotSecond, second, true);
                ticks += currentTickAndLabel.tick;
                labels += currentTickAndLabel.label;
            }

            currentTickAndLabel = this.addMiddleMajorTicks(tickscount, ticksDistance, distanceFromFirstToSecond, distanceModifier, normalLayout, ticksFrequency);
            ticks += currentTickAndLabel.tick;
            labels += currentTickAndLabel.label;
            currentTickAndLabel = this._addMajorTickAndLabel(lastLabelValue, lastLabelSize, true, last); // last tick and label
            ticks += currentTickAndLabel.tick;
            labels += currentTickAndLabel.label;
            ticks += this.addMinorTicks(normalLayout);

            that._measureLabelScale.removeChild(that._labelDummy);
            delete that._labelDummy;
            delete that._measureLabelScale;

            if (that.nodeName.toLowerCase() === 'jqx-tank') {
                that._updateScaleWidth(this._longestLabelSize);
            }

            that._appendTicksAndLabelsToScales(ticks, labels);
        }

        /**
        * Adds the middle major ticks and their respective labels.
        */

    }, {
        key: 'addMiddleMajorTicks',
        value: function addMiddleMajorTicks(tickscount, ticksDistance, distanceFromFirstToSecond, distanceModifier, normalLayout, ticksFrequency) {
            var that = this.context;

            var majorTicks = '',
                majorLabels = '';

            for (var i = 1; i < tickscount; i++) {
                var number = i * ticksDistance + distanceFromFirstToSecond,
                    value = void 0;

                if (normalLayout) {
                    value = parseFloat(that._drawMin) + ticksFrequency * i + distanceModifier;
                } else {
                    value = parseFloat(that._drawMax) - ticksFrequency * i - distanceModifier;
                }
                if (value.toString() !== that._drawMax.toString()) {
                    var htmlValue = that._formatLabel(value.toString()),
                        plot = true;

                    that._labelDummy.innerHTML = htmlValue;
                    var dimensionValue = that._labelDummy[that._settings.size];

                    if (number + dimensionValue >= tickscount * ticksDistance) {
                        // + 32 is an Experimental value
                        plot = false;
                    }
                    var currentTickAndLabel = this._addMajorTickAndLabel(htmlValue, undefined, plot, value, true);

                    majorTicks += currentTickAndLabel.tick;
                    majorLabels += currentTickAndLabel.label;
                }
            }
            return { tick: majorTicks, label: majorLabels };
        }

        /**
         * Adds minor ticks.
         */

    }, {
        key: 'addMinorTicks',
        value: function addMinorTicks(normalLayout) {
            function getPreciseFraction(i) {
                return parseFloat(i.toFixed(roundCoefficient));
            }

            function addMinorTick(i) {
                if (tickValues.indexOf(i) === -1 && that._numericProcessor.getPreciseModulo(i, minorTicksInterval, moduloCoefficient) === 0) {
                    minorTicks += '<div style="' + leftOrTop + ': ' + that._numericProcessor.valueToPx(i) + 'px;" class="jqx-tick jqx-tick-minor"></div>';
                }
            }
            var that = this.context,
                tickValues = that._tickValues,
                nearestPowerOfTen = that._tickIntervalHandler.nearestPowerOfTen,
                minorTicksInterval = that._minorTicksInterval,
                roundCoefficient = Math.log10(nearestPowerOfTen) < 0 ? Math.round(Math.abs(Math.log10(nearestPowerOfTen))) : 0,
                moduloCoefficient = Math.pow(10, roundCoefficient),
                leftOrTop = that._settings.leftOrTop;

            var firstTickValue = void 0,
                secondTickValue = void 0,
                lastTickValue = void 0,
                minorTicks = '';

            if (normalLayout) {
                firstTickValue = tickValues[0];
                secondTickValue = tickValues[1];
                lastTickValue = tickValues[tickValues.length - 1];
            } else {
                firstTickValue = tickValues[tickValues.length - 1];
                secondTickValue = tickValues[tickValues.length - 2];
                lastTickValue = tickValues[0];
            }

            if (that.logarithmicScale) {
                addMinorTickOnLogarithmicScale();
            } else {
                // minor ticks from the beginning to the second major tick
                for (var i = secondTickValue; i > firstTickValue; i = getPreciseFraction(i - nearestPowerOfTen)) {
                    addMinorTick(i);
                }

                // minor ticks from the second major tick to the end
                for (var _i9 = getPreciseFraction(secondTickValue + nearestPowerOfTen); _i9 < lastTickValue; _i9 = getPreciseFraction(_i9 + nearestPowerOfTen)) {
                    addMinorTick(_i9);
                }
            }

            function addMinorTickOnLogarithmicScale() {
                var trackLength = that._measurements.trackLength,
                    partialTrackLength = trackLength / tickValues.length,
                    modifierCoef = 0.1;

                if (partialTrackLength < 20) {
                    modifierCoef = 1;
                } else if (partialTrackLength >= 20 && partialTrackLength < 40) {
                    modifierCoef = secondTickValue - firstTickValue > 1 ? 1 : 0.5;
                } else if (partialTrackLength >= 40 && partialTrackLength < 80) {
                    modifierCoef = 0.2;
                }

                var nearestPowerOf10BelowMax = Math.floor(that._drawMax),
                    distanceToNearestPowerOf10 = that._drawMax - nearestPowerOf10BelowMax,
                    ticksOnPowerOf10 = that._drawMax - that._drawMin > tickValues.length;

                for (var j = that._drawMax; j > that._drawMin - 1; j = j - 1) {
                    var range = distanceToNearestPowerOf10 > 0 ? Math.pow(10, j - distanceToNearestPowerOf10 + 1) : Math.pow(10, j),
                        modifier = range * modifierCoef;

                    for (var _i10 = range; _i10 > 0; _i10 = _i10 - modifier) {
                        if (_i10 < that.max && _i10 > that.min) {
                            var value = new JQX.Utilities.BigNumber(Math.log10(_i10));

                            if (value % 1 === 0 && ticksOnPowerOf10 || !ticksOnPowerOf10) {
                                minorTicks += '<div style="' + leftOrTop + ': ' + that._numericProcessor.valueToPx(value) + 'px;" class="jqx-tick jqx-tick-minor"></div>';
                            }
                        }
                    }
                }
            }
            return minorTicks;
        }

        /**
         * Validates custom ticks.
         */

    }, {
        key: 'validateCustomTicks',
        value: function validateCustomTicks() {
            var that = this.context;
            var validCustomTicks = [];

            for (var i = 0; i < that.customTicks.length; i++) {
                var currentTick = that.customTicks[i],
                    currentTickObject = this.createDescriptor(currentTick);

                if (currentTickObject >= that._minObject && currentTickObject <= that._maxObject) {
                    validCustomTicks.push(currentTickObject.toString());
                }
            }

            validCustomTicks.sort(function (a, b) {
                return a - b;
            });

            validCustomTicks = validCustomTicks.filter(function (element, index, array) {
                return !index || element !== array[index - 1];
            });

            that.customTicks = validCustomTicks.slice(0);
        }

        /**
         * Plots the Gauge's ticks and labels.
         */

    }, {
        key: 'addGaugeTicksAndLabels',
        value: function addGaugeTicksAndLabels() {
            var that = this.context,
                numericProcessor = this,
                maxLabelHeight = Math.max(that._tickIntervalHandler.labelsSize.minLabelSize, that._tickIntervalHandler.labelsSize.maxLabelSize),
                majorStep = that._majorTicksInterval,
                minorStep = that._minorTicksInterval,
                majorTickValues = {},
                distance = that._distance,
                radius = that._measurements.radius,
                majorTickWidth = radius - distance.majorTickDistance,
                minorTickWidth = radius - distance.minorTickDistance;
            var drawMajor = void 0,
                drawMinor = void 0,
                addLabel = void 0,
                currentAngle = void 0,
                angleAtMin = void 0,
                angleAtMax = void 0;

            if (that.ticksVisibility !== 'none' && that._plotTicks !== false) {
                drawMajor = function drawMajor(angle) {
                    that._drawTick(angle, majorTickWidth, 'major');
                };

                drawMinor = function drawMinor(value) {
                    that._drawTick(numericProcessor.getAngleByValue(value, true), minorTickWidth, 'minor');
                };
            } else {
                drawMajor = function drawMajor() {};
                drawMinor = function drawMinor() {};
            }

            if (that.labelsVisibility !== 'none' && that._plotLabels !== false) {
                addLabel = function addLabel(angle, currentLabel, middle) {
                    that._drawLabel(angle, currentLabel, distance.labelDistance, middle);
                };
            } else {
                addLabel = function addLabel() {};
            }

            if (!that.inverted) {
                angleAtMin = that.endAngle;
                angleAtMax = that.startAngle;
            } else {
                angleAtMin = that.startAngle;
                angleAtMax = that.endAngle;
            }

            // first major tick and label
            currentAngle = numericProcessor.getAngleByValue(that._drawMin, false);
            drawMajor(currentAngle);
            majorTickValues[that._drawMin] = true;
            addLabel(currentAngle, that.min, false);

            var second = that._drawMin - numericProcessor.getPreciseModulo(that._drawMin, majorStep),
                firstMinTick = void 0;

            if (that._drawMin >= 0) {
                second += majorStep;
            }

            // determines the value at the first minor tick
            for (var _i11 = second; _i11 >= that._drawMin; _i11 = _i11 - minorStep) {
                firstMinTick = _i11;
            }

            // second major tick and label
            currentAngle = numericProcessor.getAngleByValue(second, false);
            drawMajor(currentAngle);
            majorTickValues[second] = true;
            if (2 * Math.PI * that._measurements.innerRadius * (this._getAngleDifference(angleAtMin, numericProcessor.getAngleByValue(second, false, true)) / 360) > maxLabelHeight) {
                addLabel(currentAngle, this.getActualValue(second), second < that._drawMax);
            }

            var i = void 0;
            // middle major ticks and labels
            for (i = second + majorStep; i < that._drawMax - majorStep; i += majorStep) {
                currentAngle = numericProcessor.getAngleByValue(i, false);
                drawMajor(currentAngle);
                majorTickValues[i] = true;
                addLabel(currentAngle, this.getActualValue(i), true);
            }

            if (majorTickValues[i] === undefined && i <= that._drawMax) {
                // second-to-last major tick and label
                currentAngle = numericProcessor.getAngleByValue(i, false);
                drawMajor(currentAngle);
                majorTickValues[i] = true;
                if (2 * Math.PI * that._measurements.innerRadius * (this._getAngleDifference(angleAtMax, numericProcessor.getAngleByValue(i, false, true)) / 360) >= maxLabelHeight) {
                    addLabel(currentAngle, this.getActualValue(i), true);
                }

                if (that._normalizedStartAngle !== that.endAngle) {
                    // last major tick and label
                    currentAngle = numericProcessor.getAngleByValue(that._drawMax, false);
                    drawMajor(currentAngle);
                    majorTickValues[that._drawMax] = true;
                    if (2 * Math.PI * that._measurements.innerRadius * (this._getAngleDifference(angleAtMax, angleAtMin) / 360) >= maxLabelHeight) {
                        addLabel(currentAngle, that.max, false);
                    }
                }
            }

            // minor ticks
            if (!that.logarithmicScale) {
                for (var j = firstMinTick; j < that._drawMax; j += minorStep) {
                    if (majorTickValues[j]) {
                        continue; // does not plot minor ticks over major ones
                    }
                    drawMinor(j);
                }
            } else {
                this.drawGaugeLogarithmicScaleMinorTicks(majorTickValues, majorStep, drawMinor);
            }
        }

        /**
         * Sets toolTip's value and updates the value of the element.
         */

    }, {
        key: 'updateToolTipAndValue',
        value: function updateToolTipAndValue(value, oldValue, changeValue) {
            var that = this.context,
                logarithmicScale = that.logarithmicScale;

            that._updateTooltipValue(value);
            if (logarithmicScale) {
                value = parseFloat(Math.pow(10, parseFloat(value)).toFixed(11));
            }

            var stringifiedValue = value.toString();

            that._number = value;
            that._drawValue = logarithmicScale ? Math.log10(stringifiedValue) : value;

            // eslint-disable-next-line
            if (stringifiedValue !== oldValue && changeValue) {
                that.value = that._discardDecimalSeparator(stringifiedValue);

                if (!that._programmaticValueIsSet) {
                    that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValue });
                }

                if (that.$.hiddenInput) {
                    that.$.hiddenInput.value = that.value;
                }
            }
        }

        /**
         * Validates the interval property.
         */

    }, {
        key: 'validateInterval',
        value: function validateInterval(interval) {
            var that = this.context,
                range = that._maxObject - that._minObject;

            that._validInterval = Math.min(parseFloat(interval), range);
            that.interval = that._validInterval;
        }

        /**
         * Returns a coerced value based on the interval.
         */

    }, {
        key: 'getCoercedValue',
        value: function getCoercedValue(value, useDrawVariables, logarithmicGauge) {
            var that = this.context;

            if (!that.coerce) {
                return value;
            }

            var normalScale = !that.logarithmicScale,
                minValue = void 0,
                maxValue = void 0;

            if (that.customInterval) {
                var customTicks = that.customTicks;

                if (customTicks.length === 0) {
                    return value;
                }

                normalScale = normalScale || logarithmicGauge;

                if (useDrawVariables !== false) {
                    minValue = parseFloat(that._drawMin);
                } else {
                    minValue = that._minObject;
                }

                var difference = Math.abs(minValue - value),
                    closestValue = minValue;

                for (var i = 0; i < customTicks.length; i++) {
                    var currentTickObject = this.createDescriptor(customTicks[i]),
                        currentTickValue = normalScale ? currentTickObject : Math.log10(currentTickObject),
                        currentDifference = Math.abs(currentTickValue - value);

                    if (currentDifference < difference) {
                        difference = currentDifference;
                        closestValue = currentTickValue;
                    }
                }

                return closestValue;
            }

            if (useDrawVariables !== false) {
                minValue = parseFloat(that._drawMin);
                maxValue = parseFloat(that._drawMax);
            } else {
                minValue = parseFloat(that.min);
                maxValue = parseFloat(that.max);
            }

            var noMin = value - minValue,
                remainder = this.getPreciseModulo(noMin, parseFloat(that.interval)),
                coef = this.roundCoefficient;

            if (remainder === 0) {
                return value;
            }

            if (this.roundCoefficient === 0) {
                coef = 12;
            }

            var lowerValue = parseFloat((noMin - remainder).toFixed(coef)),
                greaterValue = lowerValue + parseFloat(that.interval);

            if (that.max - that.min <= parseFloat(that.interval) && normalScale) {
                var min = minValue,
                    max = maxValue;

                return value >= min + (max - min) / 2 ? max : min;
            }

            if (Math.abs(noMin - lowerValue) < Math.abs(noMin - greaterValue)) {
                return lowerValue + minValue;
            } else {
                var biggerValue = greaterValue + minValue;

                return biggerValue > maxValue ? lowerValue + minValue : biggerValue;
            }
        }

        /**
           * Updates the value of the Tank and the "value" property and triggers the respective events.
           */

    }, {
        key: 'updateValue',
        value: function updateValue(value) {
            var that = this.context,
                renderedValue = this.validate(value, that._minObject, that._maxObject),
                oldActualValue = that.value;

            if (value.toString() !== oldActualValue.toString() || that._scaleTypeChangedFlag) {
                that.value = value.toString();
                that._number = renderedValue;

                if (!that._programmaticValueIsSet) {
                    that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldActualValue });
                }
            } else {
                that.value = typeof value === 'string' ? value : value.toString();
            }

            that._drawValue = that.logarithmicScale ? Math.log10(renderedValue).toString() : renderedValue.toString();
            that._moveThumbBasedOnValue(that._drawValue);

            if (that.$.hiddenInput) {
                that.$.hiddenInput.value = that.value;
            }
        }

        /**
         * Returns value per pixel.
         */

    }, {
        key: 'getValuePerPx',
        value: function getValuePerPx(range, pxRange) {
            return parseFloat(range) / pxRange;
        }

        /**
         * Restricts the thumbs to not pass each other.
         */

    }, {
        key: 'restrictValue',
        value: function restrictValue(values) {
            if (values[1] < values[0]) {
                values[1] = values[0];
            }
        }

        /**
         * Locks the Gauge's interaction with the mouse.
         */

    }, {
        key: 'lockRotation',
        value: function lockRotation(directionCondition, newValue) {
            var that = this.context;

            if (directionCondition && newValue < that._number) {
                that._lockCW = true;
                if (newValue < that._maxObject) {
                    return that._maxObject;
                }
            } else if (!directionCondition && newValue > that._number) {
                that._lockCCW = true;
                if (newValue > that._minObject) {
                    return that._minObject;
                }
            }
        }

        /**
         * Gets the angle-range coefficient.
         */

    }, {
        key: 'getAngleRangeCoefficient',
        value: function getAngleRangeCoefficient() {
            var that = this.context;

            that._angleRangeCoefficient = that._angleDifference / that._range;
        }
    }]);
    return DecimalNumericProcessor;
}(JQX.Utilities.BaseNumericProcessor));

/**
 * A class for processesing complex numbers.
 */
JQX.Utilities.Assign('ComplexNumericProcessor', function (_JQX$Utilities$BaseNu3) {
    babelHelpers.inherits(ComplexNumericProcessor, _JQX$Utilities$BaseNu3);

    function ComplexNumericProcessor(context, numericFormatProperty) {
        babelHelpers.classCallCheck(this, ComplexNumericProcessor);

        var _this3 = babelHelpers.possibleConstructorReturn(this, (ComplexNumericProcessor.__proto__ || Object.getPrototypeOf(ComplexNumericProcessor)).call(this, context, numericFormatProperty));

        _this3.context = context;
        return _this3;
    }

    /**
     * Creates a Complex number descriptor.
     */


    babelHelpers.createClass(ComplexNumericProcessor, [{
        key: 'createDescriptor',
        value: function createDescriptor(initialValue, supportsENotation, validateConstruction, validateMinMax, discardRadix, presetComplexNumber) {
            var returnValue = void 0;

            if (presetComplexNumber) {
                returnValue = presetComplexNumber;
            } else {
                if (initialValue.constructor === this.complexConstructor) {
                    returnValue = new this.complexConstructor(initialValue.realPart, initialValue.imaginaryPart);
                } else {
                    returnValue = new this.complexConstructor(initialValue);
                }
            }
            if (validateMinMax) {
                returnValue = this.validate(returnValue, this.context._minObject, this.context._maxObject);
            }
            return returnValue;
        }

        /**
         * Validates value.
         */

    }, {
        key: 'validate',
        value: function validate(initialValue, min, max) {
            var returnValue = initialValue;

            if (min !== -Infinity) {
                if (this.compareComplexNumbers(initialValue, min) === -1) {
                    returnValue = new this.complexConstructor(min.realPart, min.imaginaryPart);
                }
            } else if (max !== Infinity) {
                if (this.compareComplexNumbers(initialValue, max) === 1) {
                    returnValue = new this.complexConstructor(max.realPart, max.imaginaryPart);
                }
            }
            return returnValue;
        }

        /**
         * Complex number compare method.
         */

    }, {
        key: 'compare',
        value: function compare(initialValue, otherValue, thorough) {
            if (thorough !== true) {
                return this.compareComplexNumbers(initialValue, otherValue) !== 0;
            }

            return this.compareComplexNumbers(initialValue, otherValue);
        }

        /**
         * Validates min/max.
         */

    }, {
        key: 'validateMinMax',
        value: function validateMinMax(validateMin, validateMax) {
            var that = this.context;

            if (validateMin) {
                if (that.min === null || that._regexSpecial.inf.test(that.min)) {
                    that.min = -Infinity;
                    that._minObject = -Infinity;
                } else {
                    that._minObject = new this.complexConstructor(that.min);
                }
            }

            if (validateMax) {
                if (that.max === null || that._regexSpecial.inf.test(that.max)) {
                    that.max = Infinity;
                    that._maxObject = Infinity;
                } else {
                    that._maxObject = new this.complexConstructor(that.max);
                }
            }
        }

        /**
         * Increments/Decrements value. Keyboard navigation operations.
         */

    }, {
        key: 'incrementDecrement',
        value: function incrementDecrement(initialValue, operation) {
            var returnValue = new this.complexConstructor(initialValue.realPart, initialValue.imaginaryPart),
                spinButtonsStepObject = this.context._spinButtonsStepObject;

            if (operation === 'add') {
                returnValue.realPart += spinButtonsStepObject.realPart;
                returnValue.imaginaryPart += spinButtonsStepObject.imaginaryPart;
            } else {
                returnValue.realPart -= spinButtonsStepObject.realPart;
                returnValue.imaginaryPart -= spinButtonsStepObject.imaginaryPart;
            }
            return returnValue;
        }

        /**
         * Renders the value. Complex number renderer.
         */

    }, {
        key: 'render',
        value: function render(initialValue) {
            var returnValue = initialValue;

            if (this.context._regexSpecial.nonNumericValue.test(initialValue) === false) {
                var realPart = returnValue.realPart,
                    imaginaryPart = returnValue.imaginaryPart,
                    sign = void 0,
                    significantDigits = this.context.significantDigits,
                    precisionDigits = this.context.precisionDigits;

                if (imaginaryPart >= 0) {
                    sign = '+';
                } else {
                    sign = '-';
                    imaginaryPart = Math.abs(imaginaryPart);
                }

                var realPartRenderer = new JQX.Utilities.NumberRenderer(realPart),
                    imaginaryPartRenderer = new JQX.Utilities.NumberRenderer(imaginaryPart);

                if (this.context.scientificNotation) {
                    realPart = realPartRenderer.toScientific(significantDigits, precisionDigits);
                    imaginaryPart = imaginaryPartRenderer.toScientific(significantDigits, precisionDigits);
                } else {
                    realPart = realPartRenderer.toDigits(significantDigits, precisionDigits);
                    imaginaryPart = imaginaryPartRenderer.toDigits(significantDigits, precisionDigits);
                }

                returnValue = realPart + ' ' + sign + ' ' + imaginaryPart + 'i';
            }
            return returnValue;
        }

        /**
         * Complex number compare method.
         */

    }, {
        key: 'compareComplexNumbers',
        value: function compareComplexNumbers(left, right) {
            if (left instanceof this.complexConstructor === false || right instanceof this.complexConstructor === false) {
                // if at least one of the numbers is not an JQX.Utilities.Complex object, the numbers are different
                return -1;
            }

            var leftReal = left.realPart,
                rightReal = right.realPart;

            if (leftReal < rightReal) {
                return -1;
            } else if (leftReal > rightReal) {
                return 1;
            } else {
                var leftImaginary = left.imaginaryPart,
                    rightImaginary = right.imaginaryPart;

                if (leftImaginary < rightImaginary) {
                    return -1;
                } else if (leftImaginary > rightImaginary) {
                    return 1;
                } else {
                    return 0;
                }
            }
        }
    }]);
    return ComplexNumericProcessor;
}(JQX.Utilities.BaseNumericProcessor));

JQX.Utilities.Assign('NumberRenderer', function () {
    function NumberRenderer(numericValue) {
        babelHelpers.classCallCheck(this, NumberRenderer);

        var that = this;

        that.numericValue = numericValue;

        that.powersToPrefixes = { '24': 'Y', '21': 'Z', '18': 'E', '15': 'P', '12': 'T', '9': 'G', '6': 'M', '3': 'k', '0': '', '-2': 'c', '-3': 'm', '-6': 'u', '-9': 'n', '-12': 'p', '-15': 'f', '-18': 'a', '-21': 'z', '-24': 'y' };

        // dummy localization object
        that.localizationObject = {
            currencysymbol: '$',
            currencysymbolposition: 'before',
            decimalseparator: '.',
            thousandsseparator: ',',
            defaultPrecision: 2
        };
    }

    babelHelpers.createClass(NumberRenderer, [{
        key: 'isENotation',
        value: function isENotation(value) {
            return new RegExp(/e/i).test(value);
        }

        /**
         * Converts a large exponential value to its decimal representation (used when "inputFormat" is 'integer').
         */

    }, {
        key: 'largeExponentialToDecimal',
        value: function largeExponentialToDecimal(exponential) {
            var validateExponent = void 0;

            if (exponential === undefined) {
                exponential = this.numericValue;
                validateExponent = true;
            }

            var stringExponential = exponential.toString().toLowerCase(),
                indexOfE = stringExponential.indexOf('e'),
                mantissa = new JQX.Utilities.BigNumber(stringExponential.slice(0, indexOfE)),
                sign = stringExponential.slice(indexOfE + 1, indexOfE + 2);

            if (sign !== '+' && sign !== '-') {
                stringExponential = stringExponential.slice(0, indexOfE) + 'e+' + stringExponential.slice(indexOfE + 1);
                sign = '+';
            }

            var exponent = stringExponential.slice(indexOfE + 2),
                bigTen = new JQX.Utilities.BigNumber(10),
                multyplyBy = bigTen.pow(sign + (validateExponent ? Math.min(20, exponent) : exponent)),
                result = mantissa.multiply(multyplyBy);

            return result.toString();
        }

        /**
         * Converts a BigNumber integer value to an exponential value
         */

    }, {
        key: 'bigNumberToExponent',
        value: function bigNumberToExponent(significantDigits, forceExponentialResult) {
            var value = this.numericValue;

            if (value.constructor !== JQX.Utilities.BigNumber) {
                value = new JQX.Utilities.BigNumber(value);
            }

            var numberLength = value._f;
            var numericString = value.toString();

            if (numberLength <= 10) {
                // 32-bit or lower
                if (forceExponentialResult) {
                    return parseFloat(numericString).toExponential(significantDigits !== null ? significantDigits - 1 : undefined);
                } else {
                    return new JQX.Utilities.NumberRenderer(parseFloat(numericString)).toDigits(significantDigits);
                }
            } else {
                // 64-bit
                if (significantDigits >= numberLength && !forceExponentialResult) {
                    return numericString;
                } else {
                    var sign = void 0;
                    if (value._s === false) {
                        sign = '';
                    } else {
                        sign = '-';
                        numericString = numericString.slice(1);
                    }

                    var nextDigit = parseFloat(numericString.slice(significantDigits, significantDigits + 1));

                    if (nextDigit >= 5) {
                        numericString = new JQX.Utilities.BigNumber(numericString.slice(0, significantDigits)).add(1).toString();
                    }

                    var digitsAfterDecimalSeparator = numericString.slice(1, significantDigits);

                    if (forceExponentialResult) {
                        significantDigits--;

                        if (digitsAfterDecimalSeparator.length > 0 && significantDigits > digitsAfterDecimalSeparator.length) {
                            digitsAfterDecimalSeparator = digitsAfterDecimalSeparator + '0'.repeat(significantDigits - digitsAfterDecimalSeparator.length);
                        } else if (digitsAfterDecimalSeparator.length === 0) {
                            digitsAfterDecimalSeparator = '0'.repeat(significantDigits);
                        }
                    } else {
                        while (digitsAfterDecimalSeparator.length > 0 && digitsAfterDecimalSeparator.charAt(digitsAfterDecimalSeparator.length - 1) === '0') {
                            digitsAfterDecimalSeparator = digitsAfterDecimalSeparator.slice(0, digitsAfterDecimalSeparator.length - 1);
                        }
                    }

                    var decimalSeparator = digitsAfterDecimalSeparator.length > 0 ? '.' : '',
                        power = numberLength - 1;

                    return sign + numericString.slice(0, 1) + decimalSeparator + digitsAfterDecimalSeparator + 'E+' + power;
                }
            }
        }

        /**
         * Converts a plain number to scientific notation.
         */

    }, {
        key: 'toScientific',
        value: function toScientific() {
            var that = this;

            var exponentialValue = void 0;

            if (that.numericValue._d) {
                exponentialValue = that.bigNumberToExponent(arguments[0] !== null ? arguments[0] : arguments[1] + 1, true).toLowerCase();
            } else {
                exponentialValue = Number(that.numericValue.toString()).toExponential();
            }

            var indexOfE = exponentialValue.indexOf('e'),
                power = exponentialValue.slice(indexOfE + 1);
            var coefficient = parseFloat(exponentialValue.slice(0, indexOfE));

            if (power === '-2') {
                return coefficient + 'c';
            }

            var remainderPower = parseInt(power, 10) % 3;

            if (remainderPower > 0) {
                for (var i = 0; i < remainderPower; i++) {
                    coefficient = coefficient * 10;
                }
            } else if (remainderPower < 0) {
                var ignored = JQX.Utilities.BigNumber.ignoreBigIntNativeSupport;

                JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = true;
                coefficient = parseFloat(new JQX.Utilities.BigNumber(coefficient).multiply(Math.pow(10, remainderPower)).toString());
                JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;
            }

            if (power > 0) {
                var removeSign = coefficient >= 0 ? 0 : 1,
                    floatFix = exponentialValue.slice(removeSign, indexOfE).length - remainderPower - 2;
                if (floatFix >= 0) {
                    coefficient = coefficient.toFixed(floatFix);
                }
            }

            var coefficientRenderer = new JQX.Utilities.NumberRenderer(coefficient);

            coefficient = coefficientRenderer.toDigits(arguments[0], arguments[1]);

            var finalPower = parseInt(power, 10) - remainderPower,
                scientificValue = coefficient + that.powersToPrefixes[finalPower.toString()];

            return scientificValue;
        }

        /**
         * Converts a BigNumber to scientific notation.
         */

    }, {
        key: 'bigNumberToScientific',
        value: function bigNumberToScientific() {
            var that = this,
                power = that.numericValue._f - 1,
                remainderPower = parseInt(power, 10) % 3,
                finalPower = parseInt(power, 10) - remainderPower;
            var stringRepresentation = that.numericValue.toString(),
                sign = void 0,
                scientificValue = void 0;

            if (stringRepresentation.charAt(0) === '-') {
                sign = '-';
                stringRepresentation = stringRepresentation.slice(1);
            } else {
                sign = '';
            }

            if (arguments[0] !== null) {
                scientificValue = stringRepresentation.slice(0, arguments[0]);

                if (parseFloat(stringRepresentation.slice(arguments[0], arguments[0] + 1)) >= 5) {
                    scientificValue = new JQX.Utilities.BigNumber(scientificValue).add(1).toString();
                }

                while (scientificValue.length > 1 + remainderPower && scientificValue.charAt(scientificValue.length - 1) === '0') {
                    scientificValue = scientificValue.slice(0, scientificValue.length - 1);
                }
            } else if (arguments[1] !== null) {
                scientificValue = stringRepresentation.slice(0, arguments[1] + 1);

                if (parseFloat(stringRepresentation.slice(arguments[1] + 1, arguments[1] + 2)) >= 5) {
                    scientificValue = new JQX.Utilities.BigNumber(scientificValue).add(1).toString();
                }

                if (arguments[1] + remainderPower > scientificValue.length - 1) {
                    scientificValue = scientificValue + '0'.repeat(arguments[1] + remainderPower - scientificValue.length + 1);
                }
            }

            if (scientificValue.length > 1 + remainderPower) {
                scientificValue = scientificValue.slice(0, 1 + remainderPower) + '.' + scientificValue.slice(1 + remainderPower);
            }

            return sign + scientificValue + that.powersToPrefixes[finalPower.toString()];
        }

        /**
         * Applies the significant digits or precision digits settings to the number.
         */

    }, {
        key: 'toDigits',
        value: function toDigits(significantDigits, precisionDigits) {
            var that = this;
            var renderedValue = void 0;

            if (significantDigits !== null) {
                renderedValue = that.applySignificantDigits(significantDigits);
            } else if (precisionDigits !== null) {
                renderedValue = that.applyPrecisionDigits(precisionDigits);
            } else {
                renderedValue = that.applySignificantDigits(8);
            }
            return renderedValue;
        }

        /**
         * Returns the number with a specified number of significant digits.
         */

    }, {
        key: 'applySignificantDigits',
        value: function applySignificantDigits(significantDigits) {
            var that = this;

            significantDigits = Math.max(1, Math.min(significantDigits, 21));

            // removes insignificant trailing zeroes
            function removeTrailingZeroes(value) {
                while (value.charAt(value.length - 1) === '0') {
                    value = value.slice(0, -1);
                }
                if (value.charAt(value.length - 1) === '.') {
                    value = value.slice(0, -1);
                }
                return value;
            }

            var renderedValue = parseFloat(that.numericValue).toPrecision(significantDigits).toUpperCase();

            if (renderedValue.indexOf('.') !== -1) {
                if (that.isENotation(renderedValue)) {
                    var indexOfDecimalSeparator = renderedValue.indexOf('.'),
                        indexOfE = renderedValue.indexOf('E');

                    var digitsAfterDecimalSeparator = renderedValue.slice(indexOfDecimalSeparator, indexOfE);
                    digitsAfterDecimalSeparator = removeTrailingZeroes(digitsAfterDecimalSeparator);
                    renderedValue = renderedValue.slice(0, indexOfDecimalSeparator) + digitsAfterDecimalSeparator + renderedValue.slice(indexOfE);
                } else {
                    renderedValue = removeTrailingZeroes(renderedValue);
                }
            }

            return renderedValue;
        }

        /**
         * Returns the number with a specified number of precision digits.
         */

    }, {
        key: 'applyPrecisionDigits',
        value: function applyPrecisionDigits(precisionDigits) {
            var that = this;

            precisionDigits = Math.max(0, Math.min(precisionDigits, 20));

            var renderedValue = parseFloat(that.numericValue).toFixed(precisionDigits);

            if (that.isENotation(renderedValue)) {
                renderedValue = that.largeExponentialToDecimal(renderedValue) + '.' + '0'.repeat(precisionDigits);
            }

            return renderedValue;
        }

        /**
         * Returns the logarithm of a value (for use in logarithmic scales).
         */

    }, {
        key: 'getLogarithm',
        value: function getLogarithm(base) {
            var value = this.numericValue;
            var result = void 0;

            if (base === undefined) {
                base = 10;
            }

            if (base === 10) {
                try {
                    result = Math.log10(value);
                } catch (error) {
                    result = Math.log(value) / Math.log(10);
                }
            } else {
                result = Math.log(value) / Math.log(base);
            }

            return result;
        }

        /**
         * Applies separators.
         */

    }, {
        key: 'applySeparators',
        value: function applySeparators(number, noThousandsSeparator) {
            var that = this;

            number = number.toString();

            var dotIndex = number.indexOf('.');

            if (dotIndex !== -1) {
                var integerPart = number.slice(0, dotIndex),
                    fractionalPart = number.slice(dotIndex + 1);

                return that.applyThousandsSeparator(integerPart, noThousandsSeparator) + that.localizationObject.decimalseparator + fractionalPart;
            } else {
                return that.applyThousandsSeparator(number, noThousandsSeparator);
            }
        }

        /**
         * Applies thousands separator.
         */

    }, {
        key: 'applyThousandsSeparator',
        value: function applyThousandsSeparator(number, noThousandsSeparator) {
            if (noThousandsSeparator) {
                return number;
            }

            var sign = '';

            number = number.toString();

            if (number.charAt(0) === '-') {
                sign = '-';
                number = number.slice(1);
            }

            var digits = number.split('').reverse();

            for (var i = 2; i < digits.length - 1; i += 3) {
                digits[i] = this.localizationObject.thousandsseparator + digits[i];
            }

            digits.reverse();
            digits = digits.join('');

            return sign + digits;
        }

        /**
         * Returns a formatted representation of a number.
         */

    }, {
        key: 'formatNumber',
        value: function formatNumber(number, formatSpecifier, wordLength) {
            var that = this;

            if (arguments[3] === undefined) {
                delete that._ignoreMinus;
            }

            delete that._wordLengthNumber;

            if (!/^([a-zA-Z]\d*)$/g.test(formatSpecifier)) {
                try {
                    var _result = that.applyCustomFormat(number, formatSpecifier);

                    return _result;
                } catch (error) {
                    return number.toString();
                }
            }

            var format = formatSpecifier.slice(0, 1);
            var precision = formatSpecifier.slice(1);

            if (precision !== '') {
                if (isNaN(parseFloat(precision)) || parseFloat(precision) < 0 || parseFloat(precision) > 99) {
                    precision = '';
                } else if (parseFloat(precision) % 1 !== 0) {
                    precision = Math.round(precision);
                }
            }

            if (number._d) {
                that.inputFormat = 'integer';
            } else if (number.imaginaryPart) {
                return that.formatComplexNumber(number, formatSpecifier, format, precision);
            } else {
                that.inputFormat = 'floatingPoint';
            }

            var numericProcessor = new JQX.Utilities.NumericProcessor(that, 'inputFormat'),
                numericObject = numericProcessor.createDescriptor(number),
                result = void 0;

            that._wordLengthNumber = numericProcessor.getWordLength(wordLength ? wordLength : 'int32');

            if (that.inputFormat === 'integer') {
                numericObject = numericProcessor.round(numericObject);
            }

            that.numericValue = numericObject;

            switch (format) {
                case 'C':
                case 'c':
                    // Currency
                    if (precision === '') {
                        precision = that.localizationObject.defaultPrecision;
                    }

                    precision = parseFloat(precision);

                    if (that.inputFormat === 'floatingPoint') {
                        result = that.applyPrecisionDigits(precision);
                    } else {
                        result = numericObject.toString() + (precision > 0 ? '.' + '0'.repeat(precision) : '');
                    }

                    result = that.applySeparators(result);

                    if (that.localizationObject.currencysymbolposition === 'before') {
                        if (result.charAt(0) === '-') {
                            return '-' + that.localizationObject.currencysymbol + result.slice(1);
                        }

                        return that.localizationObject.currencysymbol + result;
                    }

                    return result + ' ' + that.localizationObject.currencysymbol;
                case 'D':
                case 'd':
                    {
                        // Decimal; integer-only
                        result = numericObject;

                        if (that.inputFormat === 'floatingPoint') {
                            result = Math.round(numericObject);
                        }

                        result = result.toString();

                        if (precision === '') {
                            return result;
                        }

                        var sign = '';

                        if (result.charAt(0) === '-') {
                            sign = '-';
                            result = result.slice(1);
                        }

                        var difference = precision - result.length;

                        if (difference > 0) {
                            result = '0'.repeat(difference) + result;
                        }

                        return sign + result;
                    }
                case 'E':
                case 'e':
                case 'U':
                case 'u':
                    {
                        // Exponential (scientific)
                        if (precision === '') {
                            precision = 6;
                        }

                        if (that.inputFormat === 'floatingPoint') {
                            result = numericObject.toExponential(precision);
                        } else {
                            result = that.bigNumberToExponent(parseFloat(precision) + 1, true).toLowerCase();
                        }

                        var indexOfE = result.indexOf('e'),
                            numbersInExponent = result.slice(indexOfE + 2).length;

                        if (numbersInExponent < 3) {
                            result = result.slice(0, indexOfE + 2) + '0'.repeat(3 - numbersInExponent) + result.slice(indexOfE + 2);
                        }

                        if (format.toLowerCase() === 'u') {
                            return that.exponentialToSuperscript(that.applySeparators(result, true));
                        }

                        if (format === 'E') {
                            result = result.toUpperCase();
                        }

                        return that.applySeparators(result, true);
                    }
                case 'F':
                case 'f':
                case 'N':
                case 'n':
                    // Fixed-point and Number
                    if (precision === '') {
                        precision = that.localizationObject.defaultPrecision;
                    }

                    precision = parseFloat(precision);

                    if (that.inputFormat === 'floatingPoint') {
                        result = that.applyPrecisionDigits(precision);
                    } else {
                        result = numericObject.toString() + (precision > 0 ? '.' + '0'.repeat(precision) : '');
                    }

                    return that.applySeparators(result, format.toLowerCase() === 'f');
                case 'G':
                case 'g':
                    {
                        // General
                        if (precision === '' || precision === '0') {
                            if (that.inputFormat === 'floatingPoint') {
                                precision = 15;
                            } else {
                                switch (wordLength) {
                                    case 'int8':
                                    case 'uint8':
                                        precision = 3;
                                        break;
                                    case 'int16':
                                    case 'uint16':
                                        precision = 5;
                                        break;
                                    case 'int64':
                                        precision = 19;
                                        break;
                                    case 'uint64':
                                        precision = 20;
                                        break;
                                    default:
                                        precision = 10;
                                }
                            }
                        }

                        precision = parseFloat(precision);

                        var scientificRepresentation = that.formatNumber(number, 'E' + precision, wordLength),
                            eIndex = scientificRepresentation.indexOf('E');
                        var exponent = parseInt(scientificRepresentation.slice(eIndex + 1), 10);

                        if (exponent > -5 && exponent < precision) {
                            if (that.inputFormat === 'floatingPoint') {
                                return that.applySeparators(that.applySignificantDigits(precision), true);
                            } else {
                                return numericObject.toString();
                            }
                        }

                        // removes leading zero in exponent
                        if (exponent > -100 && exponent < 100) {
                            scientificRepresentation = scientificRepresentation.slice(0, eIndex + 2) + scientificRepresentation.slice(eIndex + 3);
                        }

                        // removes trailing zeros
                        if (scientificRepresentation.indexOf(that.localizationObject.decimalseparator) !== -1) {
                            while (scientificRepresentation.charAt(eIndex - 1) === '0') {
                                scientificRepresentation = scientificRepresentation.slice(0, eIndex - 1) + scientificRepresentation.slice(eIndex);
                                eIndex = scientificRepresentation.indexOf('E');
                            }

                            if (scientificRepresentation.charAt(eIndex - 1) === that.localizationObject.decimalseparator) {
                                scientificRepresentation = scientificRepresentation.slice(0, eIndex - 1) + scientificRepresentation.slice(eIndex);
                            }
                        }

                        if (format === 'g') {
                            scientificRepresentation = scientificRepresentation.toLowerCase();
                        }

                        return scientificRepresentation;
                    }
                case 'P':
                case 'p':
                    // Percent
                    if (precision === '') {
                        precision = that.localizationObject.defaultPrecision;
                    }

                    precision = parseFloat(precision);

                    if (that.inputFormat === 'floatingPoint') {
                        that.numericValue = numericObject * 100;
                        result = that.applyPrecisionDigits(precision);
                    } else {
                        result = numericObject.multiply(100).toString() + (precision > 0 ? '.' + '0'.repeat(precision) : '');
                    }

                    return that.applySeparators(result) + ' %';
                case 'B':
                case 'b':
                case 'O':
                case 'o':
                case 'X':
                case 'x':
                    {
                        // Binary, Octal, and Hexadecimal; integer-only
                        if (that.inputFormat !== 'integer') {
                            that.inputFormat = 'integer';
                            numericProcessor = new JQX.Utilities.NumericProcessor(that, 'inputFormat');
                            numericObject = numericProcessor.round(numericProcessor.createDescriptor(number));
                        }

                        var radix = void 0;

                        switch (format) {
                            case 'B':
                            case 'b':
                                radix = 2;
                                break;
                            case 'O':
                            case 'o':
                                radix = 8;
                                break;
                            default:
                                radix = 16;
                        }

                        result = numericObject.toString(radix, that._wordLengthNumber);

                        if (precision !== '') {
                            var leadingZeros = parseFloat(precision) - result.length;

                            if (leadingZeros > 0) {
                                result = '0'.repeat(leadingZeros) + result;
                            }
                        }

                        if (format === 'x') {
                            result = result.toLowerCase();
                        }

                        return result;
                    }
                case 'S':
                case 's':
                    if (precision === '') {
                        precision = that.localizationObject.defaultPrecision;
                    }

                    precision = parseFloat(precision);

                    return that.toScientific(null, precision).replace('.', that.localizationObject.decimalseparator);
                default:
                    return number.toString();
            }
        }

        /**
         * Returns a formatted representation of a complex number.
         */

    }, {
        key: 'formatComplexNumber',
        value: function formatComplexNumber(number, formatSpecifier, format) {
            var that = this;

            switch (format) {
                case 'E':
                case 'e':
                case 'U':
                case 'u':
                case 'F':
                case 'f':
                case 'G':
                case 'g':
                case 'N':
                case 'n':
                case 'S':
                case 's':
                    if (number.imaginaryPart >= 0) {
                        return that.formatNumber(number.realPart, formatSpecifier) + ' + ' + that.formatNumber(number.imaginaryPart, formatSpecifier) + 'i';
                    } else {
                        return that.formatNumber(number.realPart, formatSpecifier) + ' - ' + that.formatNumber(Math.abs(number.imaginaryPart), formatSpecifier) + 'i';
                    }
                default:
                    return number.toString();
            }
        }

        /**
         * Returns a formatted representation of a number.
         */

    }, {
        key: 'toString',
        value: function toString(number, formatSpecifier, wordLength) {
            if (formatSpecifier) {
                return this.formatNumber(number, formatSpecifier, wordLength);
            } else {
                return number.toString();
            }
        }

        /**
         * Applies a custom number format.
         */

    }, {
        key: 'applyCustomFormat',
        value: function applyCustomFormat(number, formatSpecifier) {
            var that = this;

            //formatSpecifier = formatSpecifier.replace(/_.|\[\w*\]|.\*|\*./g, '');
            formatSpecifier = formatSpecifier.replace(/_.|\[\w*\]|\*/g, '');
            formatSpecifier = formatSpecifier.replace(/\?/g, '#');

            var sections = formatSpecifier.split(';');

            if (typeof number === 'string' && isNaN(number)) {
                return sections[sections.length - 1].replace(/"/g, '').replace(/@/g, number.toString());
            }

            if (number._d) {
                that.inputFormat = 'integer';
            } else if (number.imaginaryPart) {
                return number.toString();
            } else {
                number = parseFloat(number);
                that.inputFormat = 'floatingPoint';
            }

            var numericProcessor = new JQX.Utilities.NumericProcessor(that, 'inputFormat'),
                numericObject = numericProcessor.createDescriptor(number);

            if (that.inputFormat === 'integer') {
                numericObject = numericProcessor.round(numericObject);
            }

            that.numericProcessor = numericProcessor;

            var currentSection = that.getRelevantFormatSection(sections, numericObject);

            if (currentSection === undefined) {
                return number.toString();
            }

            if (currentSection.indexOf('@') !== -1) {
                return sections[sections.length - 1].replace(/"/g, '').replace(/@/g, number.toString());
            }

            var percentage = currentSection.replace(/".*"/g, '').indexOf('%') !== -1,
                textParts = that.getTextParts(currentSection);

            if (textParts.main.toLowerCase().indexOf('e') !== -1) {
                return that.applyCustomExponentialFormat(numericObject, textParts, numericProcessor);
            }

            if (textParts.main.indexOf('/') !== -1) {
                return that.applyCustomFractionalFormat(numericObject, textParts, numericProcessor);
            }

            if (percentage) {
                if (that.inputFormat === 'integer') {
                    numericObject = numericObject.multiply(100);
                } else {
                    numericObject = numericObject * 100;
                }
            }

            if (textParts.main === '') {
                if (!percentage) {
                    return textParts.suffix;
                }

                var stringifiedNumber = numericObject.toString();

                if (that._ignoreMinus && stringifiedNumber.charAt(0) === '-') {
                    stringifiedNumber = stringifiedNumber.slice(1);
                }

                return stringifiedNumber + textParts.suffix;
            }

            var numberFormat = textParts.main.replace(/[^0#,. \/]/g, ''),
                indexOfPoint = numberFormat.indexOf('.');

            if (indexOfPoint !== -1) {
                numberFormat = numberFormat.substring(0, indexOfPoint + 1) + numberFormat.substring(indexOfPoint + 1).replace(/\./g, '');

                // removes unnecessary trailing zero
                if (numberFormat.charAt(numberFormat.length - 1) === '.') {
                    numberFormat = numberFormat.slice(0, numberFormat.length - 1);
                }

                if (indexOfPoint === 0) {
                    numberFormat = '#' + numberFormat;
                }
            }

            // scales the number down by 1000 for every trailing comma
            while (numberFormat.charAt(numberFormat.length - 1) === ',') {
                numberFormat = numberFormat.slice(0, numberFormat.length - 1);

                if (that.inputFormat === 'floatingPoint') {
                    numericObject /= 1000;
                } else {
                    numericObject = numericObject.multiply(0.001);
                }
            }

            if (that.inputFormat === 'integer') {
                numericObject = numericProcessor.round(numericObject);
            }

            var thousandsSeparator = numberFormat.indexOf(',') !== -1;

            numberFormat = numberFormat.replace(/,/g, '');

            var numberFormatParts = numberFormat.split('.'),
                wholePartFormat = numberFormatParts[0];
            var decimalPartFormat = numberFormatParts[1],
                result = '';

            if (numberFormatParts.length === 1) {
                if (that.inputFormat === 'floatingPoint') {
                    numericObject = numericProcessor.round(numericObject);
                }

                result = numericObject.toString();

                return that.setTextParts(that.formatWholeNumber(result, wholePartFormat, thousandsSeparator), textParts);
            }

            result = numericObject.toString();

            var numberParts = result.split('.'),
                formattedWholeNumber = that.formatWholeNumber(numberParts[0], wholePartFormat, thousandsSeparator),
                decimalNumber = numberParts[1] || '';

            if (decimalPartFormat.length <= decimalNumber.length) {
                result = parseFloat(numericObject.toFixed(decimalPartFormat.length)).toString();
                numberParts = result.split('.');
                formattedWholeNumber = that.formatWholeNumber(numberParts[0], wholePartFormat, thousandsSeparator);
                decimalNumber = numberParts[1] || '';

                if (decimalNumber) {
                    return that.setTextParts(formattedWholeNumber + that.localizationObject.decimalseparator + decimalNumber.slice(0, decimalPartFormat.length), textParts);
                }
            }

            decimalPartFormat = decimalPartFormat.slice(decimalNumber.length - decimalPartFormat.length);

            var lastZeroIndex = decimalPartFormat.lastIndexOf('0');

            if (lastZeroIndex === -1) {
                if (decimalNumber === '') {
                    return that.setTextParts(formattedWholeNumber, textParts);
                }

                return that.setTextParts(formattedWholeNumber + that.localizationObject.decimalseparator + decimalNumber, textParts);
            } else {
                return that.setTextParts(formattedWholeNumber + that.localizationObject.decimalseparator + decimalNumber + '0'.repeat(lastZeroIndex + 1), textParts);
            }
        }

        /**
         * Returns relevant section of custom format specifier.
         */

    }, {
        key: 'getRelevantFormatSection',
        value: function getRelevantFormatSection(sections, number) {
            var that = this,
                compareResult = that.numericProcessor.compare(number, 0, true);

            if (compareResult === 1) {
                return sections[0];
            }

            var negativeNumberGroup = void 0,
                zeroGroup = void 0;

            if (sections.length >= 3) {
                that._ignoreMinus = true;
                negativeNumberGroup = 1;
                zeroGroup = 2;
            } else if (sections.length === 2) {
                that._ignoreMinus = true;
                zeroGroup = 0;
                negativeNumberGroup = 1;
            } else if (sections.length === 1) {
                zeroGroup = 0;
                negativeNumberGroup = 0;
            }

            if (compareResult === 0) {
                return sections[zeroGroup];
            }

            if (compareResult === -1) {
                return sections[negativeNumberGroup];
            }
        }

        /**
         * Gets text parts of custom number format.
         */

    }, {
        key: 'getTextParts',
        value: function getTextParts(currentSection) {
            var withoutQuotedText = currentSection.replace(/"[^"]*"/g, ''),
                quotedSections = currentSection.match(/"[^"]*"/g),
                firstMainIndex = withoutQuotedText.search(/0|#|\./g),
                lastMainIndex = Math.max(withoutQuotedText.lastIndexOf('0'), withoutQuotedText.lastIndexOf('#'), withoutQuotedText.lastIndexOf('.'), withoutQuotedText.lastIndexOf(',')),
                main = withoutQuotedText.slice(firstMainIndex, lastMainIndex + 1);

            if (main === '') {
                return { prefix: '', main: '', suffix: currentSection.replace(/"/g, '') };
            }

            var firstIndex = currentSection.indexOf(main),
                lastIndex = firstIndex + main.length;

            if (quotedSections) {
                for (var i = 0; i < quotedSections.length; i++) {
                    var sectionIndex = currentSection.indexOf(quotedSections[i]);

                    if (firstIndex >= sectionIndex && lastIndex <= sectionIndex + quotedSections[i].length) {
                        firstIndex = currentSection.indexOf(main, sectionIndex + quotedSections[i].length);
                        lastIndex = firstIndex + main.length;
                    }
                }
            }

            var prefix = currentSection.slice(0, firstIndex).replace(/"/g, ''),
                suffix = currentSection.slice(lastIndex).replace(/"/g, '');

            return { prefix: prefix, main: main, suffix: suffix };
        }

        /**
         * Applies custom exponential format.
         */

    }, {
        key: 'applyCustomExponentialFormat',
        value: function applyCustomExponentialFormat(number, textParts, numericProcessor) {
            var that = this;
            var format = textParts.main,
                result = void 0;
            var thousandsSeparator = format.indexOf(',') !== -1;

            // format validation - start
            format = format.replace(/[^0#.eE+-]/g, '');

            var indexOfE = format.toLowerCase().indexOf('e');

            format = format.substring(0, indexOfE + 1) + format.substring(indexOfE + 1).replace(/[eE\.]/g, '');

            var eLetter = format.charAt(indexOfE),
                indexOfPoint = format.indexOf('.');

            if (indexOfPoint !== -1) {
                format = format.substring(0, indexOfPoint + 1) + format.substring(indexOfPoint + 1).replace(/\./g, '');
            }

            if (format.charAt(format.length - 1) === '.') {
                format = format.slice(0, format.length - 1);
            }
            // format validation - end

            var parts = format.split(eLetter);
            var firstPart = parts[0];
            var significantParts = firstPart.split('.'),
                significantPart1 = significantParts[0],
                significantPart2 = significantParts[1],
                secondPart = parts[1];
            var numberWholePart = number.toString().split('.')[0].replace(/-/, ''),
                exponentModifier = 0;

            if (numberWholePart === '0' && numericProcessor.compare(number, 0)) {
                var difference = significantPart1.length - 1;

                while (parseInt(number) === 0) {
                    exponentModifier++;
                    number *= 10;
                }

                numberWholePart = number.toString().split('.')[0].replace(/-/, '');
                exponentModifier += difference;
                number *= Math.pow(10, difference);
            }

            if (thousandsSeparator) {
                firstPart = firstPart.slice(0, 1) + ',' + firstPart.slice(1);
            }

            if (numberWholePart.length <= significantPart1.length) {
                result = that.formatNumber(number, firstPart, undefined, true) + eLetter + that.formatExponent(0 - exponentModifier, secondPart);
            } else {
                var exponent = numberWholePart.length - significantPart1.length;
                var visibleNumber = that.inputFormat === 'floatingPoint' ? number / Math.pow(10, exponent) : number.divide(Math.pow(10, exponent));

                if (!significantPart2) {
                    var roundedVisibleNumber = that.applyThousandsSeparator(numericProcessor.round(visibleNumber).toString(), !thousandsSeparator);

                    result = roundedVisibleNumber + eLetter + that.formatExponent(exponent - exponentModifier, secondPart);
                }

                var decimalPartofVisibleNumber = visibleNumber.toString().split('.')[1] || '';

                if (decimalPartofVisibleNumber.length === significantPart2.length) {
                    result = that.applySeparators(visibleNumber, !thousandsSeparator) + eLetter + that.formatExponent(exponent - exponentModifier, secondPart);
                } else if (decimalPartofVisibleNumber.length < significantPart2.length) {
                    result = that.formatNumber(visibleNumber, firstPart, undefined, true) + eLetter + that.formatExponent(exponent - exponentModifier, secondPart);
                } else {
                    visibleNumber = that.inputFormat === 'floatingPoint' ? visibleNumber.toFixed(significantPart2.length) : visibleNumber = numericProcessor.round(number.divide(Math.pow(10, exponent - significantPart2.length))).divide(Math.pow(10, significantPart2.length));
                    result = that.formatNumber(parseFloat(visibleNumber), firstPart, undefined, true) + eLetter + that.formatExponent(exponent - exponentModifier, secondPart);
                }
            }

            return that.setTextParts(result, textParts);
        }

        /**
         * Formats exponent.
         */

    }, {
        key: 'formatExponent',
        value: function formatExponent(exponent, format) {
            var sign = void 0;

            if (['+', '-'].indexOf(format.charAt(0)) !== -1) {
                sign = format.charAt(0);

                if (exponent > 0 && sign === '-' || exponent < 0 && sign === '+') {
                    sign = undefined;
                }
            }

            if (exponent < 0) {
                exponent = Math.abs(exponent);
                sign = '-';
            }

            format = format.replace(/[+-]/g, '');
            exponent = this.formatNumber(exponent, format, undefined, true);
            return (sign ? sign : '') + exponent;
        }

        /**
         * Formats a whole number.
         */

    }, {
        key: 'formatWholeNumber',
        value: function formatWholeNumber(wholeNumber, format, thousandsSeparator) {
            var that = this;
            var sign = '';

            if (wholeNumber.charAt(0) === '-') {
                if (!that._ignoreMinus) {
                    sign = '-';
                }

                wholeNumber = wholeNumber.slice(1);
            }

            if (wholeNumber === '0') {
                if (format === '#'.repeat(format.length)) {
                    return sign;
                }

                wholeNumber = '';
            }

            if (format.length <= wholeNumber.length) {
                return sign + that.applyThousandsSeparator(wholeNumber, !thousandsSeparator);
            }

            format = format.slice(0, format.length - wholeNumber.length);

            for (var i = format.length - 1; i >= 0; i--) {
                if (format.charAt(i) === '0') {
                    wholeNumber = '0' + '' + wholeNumber;
                }
            }

            return sign + that.applyThousandsSeparator(wholeNumber, !thousandsSeparator);
        }

        /**
         * Sets prefix and suffix around formatted number.
         */

    }, {
        key: 'setTextParts',
        value: function setTextParts(result, textParts) {
            return textParts.prefix + result + textParts.suffix;
        }

        /**
         * Applies custom format with fraction.
         */

    }, {
        key: 'applyCustomFractionalFormat',
        value: function applyCustomFractionalFormat(numericObject, textParts, numericProcessor) {
            var that = this,
                regex = /^([0#,]+[ ]+)?([0#,]+\/[0#,]+)$/;
            var format = textParts.main.trim(),
                result = void 0;

            if (!regex.test(format)) {
                return numericObject.toString();
            }

            var formatParts = regex.exec(format);

            formatParts[2] = formatParts[2].replace(/,/g, '');

            if (that.inputFormat === 'integer') {
                var fractionFormatParts = formatParts[2].split('/');

                if (formatParts[1] === undefined) {
                    result = that.formatNumber(numericObject, fractionFormatParts[0], undefined, true) + '/' + that.formatNumber(1, fractionFormatParts[1], undefined, true);
                } else {
                    result = that.formatNumber(numericObject, formatParts[1].trim(), undefined, true);

                    if (formatParts[2].indexOf('0') !== -1) {
                        result += ' ' + that.formatNumber(0, fractionFormatParts[0], undefined, true) + '/' + that.formatNumber(1, fractionFormatParts[1], undefined, true);
                    }
                }

                return that.setTextParts(result, textParts);
            }

            if (formatParts[1] === undefined) {
                result = (numericObject < 0 ? '-' : '') + that.formatAsFraction(Math.abs(numericObject), formatParts[2]);
            } else {
                var wholePartFormat = formatParts[1].trim(),
                    decimalPartFormat = formatParts[2];

                result = that.formatNumber(parseInt(numericObject, 10), wholePartFormat, undefined, true) + ' ' + that.formatAsFraction(numericProcessor.getPreciseModulo(Math.abs(numericObject), 1), decimalPartFormat);
            }

            return that.setTextParts(result.trim(), textParts);
        }

        /**
         * Formats a decimal number as a fraction.
         */

    }, {
        key: 'formatAsFraction',
        value: function formatAsFraction(number, format) {
            var that = this,
                formatParts = format.split('/');

            if (number === 0) {
                if (format.indexOf('0') === -1) {
                    return '';
                }

                return that.formatNumber(0, formatParts[0], undefined, true) + '/' + that.formatNumber(1, formatParts[1], undefined, true);
            }

            if (number % 1 === 0) {
                return that.formatNumber(number, formatParts[0], undefined, true) + '/' + that.formatNumber(1, formatParts[1], undefined, true);
            }

            var approximations = [];

            that.approximateFractions(number, approximations);

            var length = formatParts[1].length >= 2 ? 2 : 1;
            var bestApproximationDifference = [],
                bestApproximationIndex = [];

            approximations.forEach(function (approximation, index) {
                var length = approximation.denominator.toString().length,
                    currentDifference = Math.abs(number - approximation.numerator / approximation.denominator);

                if (bestApproximationDifference[length] === undefined) {
                    bestApproximationIndex[length] = index;
                    bestApproximationDifference[length] = currentDifference;
                    return;
                }

                if (currentDifference < bestApproximationDifference[length]) {
                    bestApproximationIndex[length] = index;
                    bestApproximationDifference[length] = currentDifference;
                }
            });

            var bestApproximation = bestApproximationIndex[length] ? approximations[bestApproximationIndex[length]] : approximations[bestApproximationIndex[1]];

            return that.formatNumber(bestApproximation.numerator, formatParts[0], undefined, true) + '/' + that.formatNumber(bestApproximation.denominator, formatParts[1], undefined, true);
        }

        /**
         * Approximates fractions.
         */

    }, {
        key: 'approximateFractions',
        value: function approximateFractions(d, approximations) {
            var numerators = [0, 1];
            var denominators = [1, 0];

            var maxNumerator = this.getMaxNumerator(d);
            var d2 = d;
            var calcD = void 0,
                prevCalcD = NaN;
            for (var i = 2; i < 1000; i++) {
                var L2 = Math.floor(d2);
                numerators[i] = L2 * numerators[i - 1] + numerators[i - 2];
                if (Math.abs(numerators[i]) > maxNumerator) return;

                denominators[i] = L2 * denominators[i - 1] + denominators[i - 2];

                calcD = numerators[i] / denominators[i];
                if (calcD === prevCalcD) return;

                approximations.push({ numerator: numerators[i], denominator: denominators[i] });

                if (calcD === d) return;

                prevCalcD = calcD;

                d2 = 1 / (d2 - L2);
            }
        }

        /**
         * Gets maximal numerator.
         */

    }, {
        key: 'getMaxNumerator',
        value: function getMaxNumerator(f) {
            var f2 = null;
            var ixe = f.toString().indexOf('E');
            if (ixe === -1) ixe = f.toString().indexOf('e');
            if (ixe === -1) f2 = f.toString();else f2 = f.toString().substring(0, ixe);

            var digits = null;
            var ix = f2.toString().indexOf('.');
            if (ix === -1) digits = f2;else if (ix === 0) digits = f2.substring(1, f2.length);else if (ix < f2.length) digits = f2.substring(0, ix) + f2.substring(ix + 1, f2.length);

            var L = digits;

            var numDigits = L.toString().length;
            var L2 = f;
            var numIntDigits = L2.toString().length;
            if (L2 === 0) numIntDigits = 0;
            var numDigitsPastDecimal = numDigits - numIntDigits;

            for (var i = numDigitsPastDecimal; i > 0 && L % 2 === 0; i--) {
                L /= 2;
            }for (var _i12 = numDigitsPastDecimal; _i12 > 0 && L % 5 === 0; _i12--) {
                L /= 5;
            }return L;
        }

        /**
         * Represents an exponential value with superscripts.
         */

    }, {
        key: 'exponentialToSuperscript',
        value: function exponentialToSuperscript(exponentialValue) {
            var indexOfE = exponentialValue.indexOf('e'),
                power = exponentialValue.slice(indexOfE + 1).replace(/0{1,2}/, '');
            var scientificValue = exponentialValue.slice(0, indexOfE + 1);

            scientificValue = scientificValue.replace('e', '×10');
            scientificValue += this.toSuperscript(power);
            scientificValue = scientificValue.replace('+', '');

            return scientificValue;
        }

        /**
         * Converts a number to superscript.
         */

    }, {
        key: 'toSuperscript',
        value: function toSuperscript(value, supToNormal) {
            var chars = '-0123456789',
                sup = '⁻⁰¹²³⁴⁵⁶⁷⁸⁹';
            var result = '';

            for (var i = 0; i < value.length; i++) {
                if (supToNormal === true) {
                    var m = sup.indexOf(value.charAt(i));

                    result += m !== -1 ? chars[m] : value[i];
                } else {
                    var n = chars.indexOf(value.charAt(i));

                    result += n !== -1 ? sup[n] : value[i];
                }
            }

            return result;
        }
    }]);
    return NumberRenderer;
}());