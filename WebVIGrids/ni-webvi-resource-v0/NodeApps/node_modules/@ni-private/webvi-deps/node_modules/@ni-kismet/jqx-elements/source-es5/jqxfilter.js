'use strict';

JQX.Utilities.Assign('FilterGroup', function () {
    function FilterGroup() {
        babelHelpers.classCallCheck(this, FilterGroup);

        var that = this;

        that.stringConditions = ['EMPTY', 'NOT_EMPTY', 'CONTAINS', 'CONTAINS_CASE_SENSITIVE', 'DOES_NOT_CONTAIN', 'DOES_NOT_CONTAIN_CASE_SENSITIVE', 'STARTS_WITH', 'STARTS_WITH_CASE_SENSITIVE', 'ENDS_WITH', 'ENDS_WITH_CASE_SENSITIVE', 'EQUAL', 'EQUAL_CASE_SENSITIVE', 'NULL', 'NOT_NULL'];
        that.numericConditions = ['EQUAL', 'NOT_EQUAL', 'LESS_THAN', 'LESS_THAN_OR_EQUAL', 'GREATER_THAN', 'GREATER_THAN_OR_EQUAL', 'NULL', 'NOT_NULL'];
        that.dateConditions = ['EQUAL', 'NOT_EQUAL', 'LESS_THAN', 'LESS_THAN_OR_EQUAL', 'GREATER_THAN', 'GREATER_THAN_OR_EQUAL', 'NULL', 'NOT_NULL'];
        that.booleanConditions = ['EQUAL', 'NOT_EQUAL', 'NULL', 'NOT_NULL'];

        that.filters = new Array();
        that.logicalOperators = new Array();
    }

    babelHelpers.createClass(FilterGroup, [{
        key: 'evaluate',
        value: function evaluate(value) {
            var that = this;
            var result = true;

            for (var i = 0; i < that.filters.length; i++) {
                var currentResult = that.filters[i].evaluate(value);

                if (i === 0) {
                    result = currentResult;
                } else {
                    if (that.logicalOperators[i] === 1 || that.logicalOperators[i] === 'or') {
                        result = result || currentResult;
                    } else {
                        result = result && currentResult;
                    }
                }
            }

            return result;
        }
    }, {
        key: 'getFiltersCount',
        value: function getFiltersCount() {
            return this.filters.length;
        }
    }, {
        key: 'setConditions',
        value: function setConditions(filterType, conditions) {
            var that = this;

            switch (filterType) {
                case 'numeric':
                    that.numericConditions = conditions;
                    break;
                case 'string':
                    that.stringConditions = conditions;
                    break;
                case 'date':
                case 'time':
                    that.dateConditions = conditions;
                    break;
                case 'bool':
                case 'boolean':
                    that.booleanConditions = conditions;
                    break;
            }
        }
    }, {
        key: 'getConditions',
        value: function getConditions(filterType) {
            var that = this;
            var array = new Array();

            switch (filterType) {
                case 'numeric':
                    array = that.numericConditions.slice(0);
                    break;
                case 'string':
                    array = that.stringConditions.slice(0);
                    break;
                case 'date':
                case 'time':
                    array = that.dateConditions.slice(0);
                    break;
                case 'bool':
                case 'boolean':
                    array = that.booleanConditions.slice(0);
                    break;
            }
            return array;
        }
    }, {
        key: 'generateFilterKey',
        value: function generateFilterKey() {
            var S4 = function S4() {
                return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);
            };
            return S4() + '-' + S4() + '-' + S4();
        }
    }, {
        key: 'createFilter',
        value: function createFilter(filterType, filterValue, filterCondition, customfilter, formatString, locale, timeOnly) {
            if (filterType === null || filterType === undefined) {
                return null;
            }

            switch (filterType) {
                case 'int':
                case 'float':
                case 'int64':
                case 'double':
                case 'numeric':
                case 'number':
                case 'numericFilter':
                    return new JQX.Utilities.NumericFilter(filterValue, filterCondition.toUpperCase());
                case 'string':
                case 'stringFilter':
                    return new JQX.Utilities.StringFilter(filterValue, filterCondition.toUpperCase(), locale);
                case 'date':
                case 'time':
                case 'dateFilter':
                    return new JQX.Utilities.DateFilter(filterValue, filterCondition.toUpperCase(), formatString, locale, timeOnly);
                case 'bool':
                case 'boolean':
                case 'booleanFilter':
                    return new JQX.Utilities.BooleanFilter(filterValue, filterCondition.toUpperCase());
                case 'custom':
                    return new JQX.Utilities.CustomFilter(filterValue, filterCondition.toUpperCase(), customfilter);
            }

            throw new Error('jqxGrid: There is no such filter type. The available filter types are: "numericFilter", "stringFilter", "dateFilter" and "booleanFilter"');
        }
    }, {
        key: 'getFilters',
        value: function getFilters() {
            var that = this;
            var filtersArray = new Array();

            for (var i = 0; i < that.filters.length; i++) {
                var filter = that.filters[i];

                if (filter instanceof FilterGroup) {
                    var filters = filter.getFilters();

                    filtersArray.push({ value: filters, logicalOperator: that.logicalOperators[i], type: 'FilterGroup' });
                } else {
                    var filterObject = { value: filter.value, condition: filter.condition, logicalOperator: that.logicalOperators[i], type: filter.type };

                    if (filter.data) {
                        filterObject.id = filter.data;
                    }

                    filtersArray.push(filterObject);
                }
            }

            return filtersArray;
        }
    }, {
        key: 'addFilter',
        value: function addFilter(logicalOperator, filter) {
            var that = this;

            that.filters[that.filters.length] = filter;
            filter.key = that.generateFilterKey();
            that.logicalOperators[that.logicalOperators.length] = logicalOperator;
        }
    }, {
        key: 'removeFilter',
        value: function removeFilter(filter) {
            var that = this;

            for (var i = 0; i < that.filters.length; i++) {
                if (that.filters[i].key === filter.key) {
                    that.filters.splice(i, 1);
                    that.logicalOperators.splice(i, 1);
                    break;
                }
            }
        }
    }, {
        key: 'getOperatorAt',
        value: function getOperatorAt(index) {
            var that = this;

            if (index === undefined || index === null) {
                return null;
            }

            if (index < 0 || index > that.filters.length) {
                return null;
            }

            return that.logicalOperators[index];
        }
    }, {
        key: 'setOperatorAt',
        value: function setOperatorAt(index, logicalOperator) {
            var that = this;

            if (index === undefined || index === null) {
                return null;
            }

            if (index < 0 || index > that.filters.length) {
                return null;
            }

            that.logicalOperators[logicalOperator] = logicalOperator;
        }
    }, {
        key: 'getFilterAt',
        value: function getFilterAt(index) {
            var that = this;

            if (index === undefined || index === null) {
                return null;
            }

            if (index < 0 || index > that.filters.length) {
                return null;
            }

            return that.filters[index];
        }
    }, {
        key: 'setFilterAt',
        value: function setFilterAt(index, filter) {
            var that = this;

            if (index === undefined || index === null) {
                return null;
            }

            if (index < 0 || index > that.filters.length) {
                return null;
            }

            filter.key = that.generateFilterKey();
            that.filters[index] = filter;
        }
    }, {
        key: 'clear',
        value: function clear() {
            var that = this;

            that.filters = new Array();
            that.logicalOperators = new Array();
        }
    }, {
        key: 'getUniqueValues',
        value: function getUniqueValues(details, context) {
            var data = details.data,
                uniqueValues = [],
                treeViewSource = [],
                timeOnly = details.filterType === 'dateFilter' && details.displayMode === 'timePicker';
            var compareFunction = void 0,
                blanks = false;

            for (var i = 0; i < data.length; i++) {
                var currentValue = data[i][details.dataField];

                if (currentValue === '' || currentValue === null || currentValue === undefined) {
                    blanks = true;
                    continue;
                }

                var label = void 0;

                if (timeOnly) {
                    label = new JQX.Utilities.DateTime(currentValue).toString(details.formatString);
                } else {
                    label = currentValue.toString();
                }

                if (uniqueValues.indexOf(label) === -1) {
                    uniqueValues.push(label);
                    treeViewSource.push({ label: label, value: currentValue, customAttribute: 'default-item' });
                }
            }

            switch (details.filterType) {
                case 'numericFilter':
                case 'booleanFilter':
                    compareFunction = function compareFunction(a, b) {
                        return a.value - b.value;
                    };
                    break;
                case 'stringFilter':
                    compareFunction = function compareFunction(a, b) {
                        return new Intl.Collator().compare(a.value, b.value);
                    };
                    break;
                case 'dateFilter':
                    if (timeOnly) {
                        compareFunction = function compareFunction(a, b) {
                            try {
                                var aHours = a.value.getHours(),
                                    bHours = b.value.getHours();

                                if (aHours !== bHours) {
                                    return aHours - bHours;
                                }

                                var aMinutes = a.value.getMinutes(),
                                    bMinutes = b.value.getMinutes();

                                if (aMinutes !== bMinutes) {
                                    return aMinutes - bMinutes;
                                }

                                var aSeconds = a.value.getSeconds(),
                                    bSeconds = b.value.getSeconds();

                                if (aSeconds !== bSeconds) {
                                    return aSeconds - bSeconds;
                                }

                                return 0;
                            } catch (error) {
                                return -1;
                            }
                        };
                    } else {
                        compareFunction = function compareFunction(a, b) {
                            try {
                                return a.value.getTime() - b.value.getTime();
                            } catch (error) {
                                return -1;
                            }
                        };
                    }

                    break;
            }

            treeViewSource.sort(compareFunction);

            if (details.filterType === 'booleanFilter') {
                treeViewSource.map(function (item) {
                    item.label = item.label.toUpperCase();
                });
            }

            if (blanks) {
                treeViewSource.push({ label: context.localize('blanks'), value: '', customAttribute: 'default-item' });
            }

            return treeViewSource;
        }
    }]);
    return FilterGroup;
}());

JQX.Utilities.Assign('StringFilter', function () {
    function StringFilter(filterValue, condition, locale) {
        babelHelpers.classCallCheck(this, StringFilter);

        var that = this;

        that.value = filterValue;
        that.condition = condition;
        that.locale = locale || 'en';
        that.type = 'stringFilter';
    }

    babelHelpers.createClass(StringFilter, [{
        key: 'evaluate',
        value: function evaluate(value) {
            var that = this,
                filterValue = that.value,
                condition = that.condition;

            if (value === null || value === undefined || value === '') {
                if (condition === 'NULL') return true;

                if (condition === 'EQUAL' && value === filterValue) {
                    return true;
                }

                if (condition === 'NOT_EQUAL' && value !== filterValue) {
                    return true;
                }

                if (condition !== 'EMPTY') return false;else if (value === '') return true;
            }

            var val = '';

            try {
                val = value.toString();
            } catch (error) {
                return true;
            }

            var compare = function compare(val, filterValue) {
                var locale = that.locale;

                switch (condition) {
                    case 'EQUAL':
                        return val.localeCompare(filterValue, locale, { sensitivity: 'accent' }) === 0;
                    case 'EQUAL_CASE_SENSITIVE':
                        return val.localeCompare(filterValue, locale, { sensitivity: 'variant' }) === 0;
                    case 'NOT_EQUAL':
                        return val.localeCompare(filterValue, locale, { sensitivity: 'accent' }) !== 0;
                    case 'NOT_EQUAL_CASE_SENSITIVE':
                        return val.localeCompare(filterValue, locale, { sensitivity: 'variant' }) !== 0;
                    case 'CONTAINS':
                        return val.toLowerCase().indexOf(filterValue.toLowerCase()) !== -1;
                    case 'CONTAINS_CASE_SENSITIVE':
                        return val.indexOf(filterValue) !== -1;
                    case 'DOES_NOT_CONTAIN':
                        return val.toLowerCase().indexOf(filterValue.toLowerCase()) === -1;
                    case 'DOES_NOT_CONTAIN_CASE_SENSITIVE':
                        return val.indexOf(filterValue) === -1;
                    case 'EMPTY':
                        return val === '';
                    case 'NOT_EMPTY':
                        return val !== '';
                    case 'NOT_NULL':
                        return val !== null;
                    case 'STARTS_WITH':
                        val = val.substring(0, filterValue.length);
                        return val.localeCompare(filterValue, locale, { sensitivity: 'accent' }) === 0;
                    case 'ENDS_WITH':
                        val = val.substring(val.length - filterValue.length, val.length);
                        return val.localeCompare(filterValue, locale, { sensitivity: 'accent' }) === 0;
                    case 'ENDS_WITH_CASE_SENSITIVE':
                        val = val.substring(val.length - filterValue.length, val.length);
                        return val.localeCompare(filterValue, locale, { sensitivity: 'variant' }) === 0;
                    case 'STARTS_WITH_CASE_SENSITIVE':
                        val = val.substring(0, filterValue.length);
                        return val.localeCompare(filterValue, locale, { sensitivity: 'variant' }) === 0;
                    default:
                        return false;
                }
            };

            var filterValues = new Array();

            if (filterValue && filterValue.indexOf) if (filterValue.indexOf('|') >= 0 || filterValue.indexOf(' AND ') >= 0 || filterValue.indexOf(' OR ') >= 0 || filterValue.indexOf(' and ') >= 0 || filterValue.indexOf(' or ') >= 0) {
                var result = compare(val, filterValue);

                if (result) {
                    return result;
                }

                var andLowerCaseFilters = filterValue.indexOf(' and ') >= 0 ? filterValue.split(' and ') : new Array(),
                    orLowerCaseFilters = filterValue.indexOf(' or ') >= 0 ? filterValue.split(' or ') : new Array(),
                    delimiterFilters = filterValue.indexOf('|') >= 0 ? filterValue.split('|') : new Array();
                var andFilters = filterValue.indexOf(' AND ') >= 0 ? filterValue.split(' AND ') : new Array(),
                    orFilters = filterValue.indexOf(' OR ') >= 0 ? filterValue.split(' OR ') : new Array();

                if (delimiterFilters.length > 0) {
                    for (var i = 0; i < delimiterFilters.length; i++) {
                        delimiterFilters[i] = delimiterFilters[i].trim;
                    }
                }

                var commaFilters = filterValue.indexOf(' ') >= 0 ? filterValue.split(' ') : new Array();

                if (commaFilters.length > 0) {
                    for (var _i = 0; _i < commaFilters.length; _i++) {
                        commaFilters[_i] = commaFilters[_i].trim;
                    }
                }

                andFilters = andFilters.concat(commaFilters);
                andFilters = andFilters.concat(andLowerCaseFilters);
                orFilters = orFilters.concat(delimiterFilters);
                orFilters = orFilters.concat(orLowerCaseFilters);

                if (andFilters.length > 0) {
                    for (var _i2 = 0; _i2 < andFilters.length; _i2++) {
                        if (!andFilters[_i2].indexOf(' OR ') >= 0) {
                            filterValues.push(andFilters[_i2]);
                        }
                    }
                }
                if (orFilters.length > 0) {
                    for (var _i3 = 0; _i3 < orFilters.length; _i3++) {
                        if (!orFilters[_i3].indexOf(' AND ') >= 0) {
                            filterValues.push(orFilters[_i3]);
                        }
                    }
                }

                var filterresult = undefined;

                for (var j = 0; j < filterValues.length; j++) {
                    var _value = filterValues[j],
                        _result = compare(val, _value),
                        filteroperator = j < andFilters.length ? 'and' : 'or';

                    if (filterresult === undefined) {
                        filterresult = _result;
                    } else {
                        if (filteroperator === 'or') {
                            filterresult = filterresult || _result;
                        } else {
                            filterresult = filterresult && _result;
                        }
                    }
                }
                return filterresult;
            }

            return compare(val, filterValue);
        }
    }]);
    return StringFilter;
}());

JQX.Utilities.Assign('BooleanFilter', function () {
    function BooleanFilter(filterValue, condition) {
        babelHelpers.classCallCheck(this, BooleanFilter);

        var that = this;

        that.value = filterValue;
        that.condition = condition;
        that.type = 'booleanFilter';
    }

    babelHelpers.createClass(BooleanFilter, [{
        key: 'evaluate',
        value: function evaluate(value) {
            var that = this,
                filterValue = that.value,
                condition = that.condition;

            var val = value;

            switch (condition) {
                case 'EQUAL':
                    return val === filterValue;
                case 'NOT_EQUAL':
                    return val !== filterValue;
                case 'NULL':
                    return value === null || value === undefined || value === '';
                case 'NOT_NULL':
                    return !(value === null || value === undefined || value === '');
                default:
                    return false;
            }
        }
    }]);
    return BooleanFilter;
}());

JQX.Utilities.Assign('NumericFilter', function () {
    function NumericFilter(filterValue, condition) {
        babelHelpers.classCallCheck(this, NumericFilter);

        var that = this;

        that.value = filterValue;
        that.condition = condition;
        that.type = 'numericFilter';
    }

    babelHelpers.createClass(NumericFilter, [{
        key: 'evaluate',
        value: function evaluate(value) {
            var that = this;
            var filterValue = that.value,
                condition = that.condition;

            if (value === null || value === undefined || value === '') {
                if (condition === 'NOT_NULL') return false;

                if (condition === 'NULL') return true;else {
                    switch (condition) {
                        case 'EQUAL':
                            return value === filterValue;
                        case 'NOT_EQUAL':
                            return value !== filterValue;
                    }
                    return false;
                }
            } else {
                if (condition === 'NULL') return false;

                if (condition === 'NOT_NULL') return true;
            }

            var val = value;

            try {
                val = parseFloat(val);
            } catch (error) {
                if (value.toString() !== '') return false;
            }

            var compare = function compare(val, filterValue) {
                if (typeof val === 'number' && typeof filterValue !== 'number') {
                    filterValue = parseFloat(filterValue);
                }

                switch (condition) {
                    case 'EQUAL':
                        return val === filterValue;
                    case 'NOT_EQUAL':
                        return val !== filterValue;
                    case 'GREATER_THAN':
                        return val > filterValue;
                    case 'GREATER_THAN_OR_EQUAL':
                        return val >= filterValue;
                    case 'LESS_THAN':
                        return val < filterValue;
                    case 'LESS_THAN_OR_EQUAL':
                        return val <= filterValue;
                    case 'STARTS_WITH':
                        filterValue = filterValue.toString().toLowerCase();
                        return val.toString().toLowerCase().substring(0, filterValue.length) === filterValue;
                    case 'ENDS_WITH':
                        val = val.toString().toLowerCase();
                        filterValue = filterValue.toString().toLowerCase();
                        return val.substring(val.length - filterValue.length, val.length) === filterValue;
                    case 'ENDS_WITH_CASE_SENSITIVE':
                        val = val.toString();
                        filterValue = filterValue.toString();
                        return val.substring(val.length - filterValue.length, val.length) === filterValue;
                    case 'STARTS_WITH_CASE_SENSITIVE':
                        filterValue = filterValue.toString();
                        return val.toString().substring(0, filterValue.length) === filterValue;
                    case 'CONTAINS':
                        return val.toString().toLowerCase().indexOf(filterValue.toString().toLowerCase()) !== -1;
                    case 'CONTAINS_CASE_SENSITIVE':
                        return val.toString().indexOf(filterValue.toString()) !== -1;
                    case 'DOES_NOT_CONTAIN':
                        return val.toString().toLowerCase().indexOf(filterValue.toString().toLowerCase()) === -1;
                    case 'DOES_NOT_CONTAIN_CASE_SENSITIVE':
                        return val.toString().indexOf(filterValue.toString()) === -1;
                    default:
                        return true;
                }
            };

            var filterValues = new Array();

            if (filterValue && filterValue.indexOf) if (filterValue.indexOf('|') >= 0 || filterValue.indexOf(' AND ') >= 0 || filterValue.indexOf(' OR ') >= 0 || filterValue.indexOf(' and ') >= 0 || filterValue.indexOf(' or ') >= 0) {
                var result = compare(val, filterValue);

                if (result) {
                    return result;
                }

                filterValue = filterValue.toString();
                var andLowerCaseFilters = filterValue.indexOf(' and ') >= 0 ? filterValue.split(' and ') : new Array(),
                    orLowerCaseFilters = filterValue.indexOf(' or ') >= 0 ? filterValue.split(' or ') : new Array(),
                    delimiterFilters = filterValue.indexOf('|') >= 0 ? filterValue.split('|') : new Array();
                var andFilters = filterValue.indexOf(' AND ') >= 0 ? filterValue.split(' AND ') : new Array(),
                    orFilters = filterValue.indexOf(' OR ') >= 0 ? filterValue.split(' OR ') : new Array();

                andFilters = andFilters.concat(andLowerCaseFilters);
                orFilters = orFilters.concat(orLowerCaseFilters);
                if (delimiterFilters.length > 0) {
                    for (var i = 0; i < delimiterFilters.length; i++) {
                        delimiterFilters[i] = delimiterFilters[i].trim;
                    }
                }
                orFilters = orFilters.concat(delimiterFilters);

                if (andFilters.length > 0) {
                    for (var _i4 = 0; _i4 < andFilters.length; _i4++) {
                        if (!andFilters[_i4].indexOf(' OR ') >= 0) {
                            filterValues.push(andFilters[_i4]);
                        }
                    }
                }
                if (orFilters.length > 0) {
                    for (var _i5 = 0; _i5 < orFilters.length; _i5++) {
                        if (!orFilters[_i5].indexOf(' AND ') >= 0) {
                            filterValues.push(orFilters[_i5]);
                        }
                    }
                }

                var filterresult = undefined;

                for (var j = 0; j < filterValues.length; j++) {
                    var _value2 = filterValues[j];

                    if (_value2 && _value2.indexOf && _value2.indexOf('..') >= 0) {
                        var values = _value2.toString().split('..');

                        if (values.length === 2) {
                            result = val >= values[0] && val <= values[1];
                        }
                    } else {
                        result = compare(val, _value2);
                    }

                    var filteroperator = j < andFilters.length ? 'and' : 'or';

                    if (filterresult === undefined) {
                        filterresult = result;
                    } else {
                        if (filteroperator === 'or') {
                            filterresult = filterresult || result;
                        } else {
                            filterresult = filterresult && result;
                        }
                    }
                }
                return filterresult;
            }
            if (filterValue && filterValue.indexOf && filterValue.indexOf('..') >= 0) {
                filterValues = filterValue.toString().split('..');
                if (filterValues.length === 2) {
                    return val >= filterValues[0] && val <= filterValues[1];
                }
            }
            return compare(val, filterValue);
        }
    }]);
    return NumericFilter;
}());

JQX.Utilities.Assign('DateFilter', function () {
    function DateFilter(filterValue, condition, formatString, locale, timeOnly) {
        babelHelpers.classCallCheck(this, DateFilter);

        var that = this,
            parseAttemptDateTime = new JQX.Utilities.DateTime();

        that.value = filterValue;
        that.type = 'dateFilter';

        if (formatString !== undefined) {
            var parsedDate = parseAttemptDateTime.parseDate(filterValue, formatString);

            if (parsedDate !== null) {
                that.filterdate = parsedDate;
            } else {
                var result = parseAttemptDateTime.tryparseDate(filterValue);

                if (result !== null) {
                    that.filterdate = result;
                }
            }
        } else {
            var tmpvalue = new Date(filterValue);

            if (tmpvalue.toString() === 'NaN' || tmpvalue.toString() === 'Invalid Date') {
                that.filterdate = parseAttemptDateTime.tryparseDate(filterValue);
            } else {
                that.filterdate = tmpvalue;
            }
        }
        if (!that.filterdate) {
            var _tmpvalue = new Date(filterValue);

            if (_tmpvalue.toString() === 'NaN' || _tmpvalue.toString() === 'Invalid Date') {
                that.filterdate = parseAttemptDateTime.tryparseDate(filterValue);
            } else {
                that.filterdate = _tmpvalue;
            }
        }

        that.condition = condition;
        that.formatString = formatString;
        that.timeOnly = timeOnly;
    }

    babelHelpers.createClass(DateFilter, [{
        key: 'evaluate',
        value: function evaluate(value) {
            var that = this,
                condition = that.condition,
                formatString = that.formatString;
            var filterValue = that.value;

            if (that.timeOnly) {
                return that.evaluateTimeOnly(value);
            }

            if (value === null || value === undefined || value === '') {
                if (condition === 'NOT_NULL') {
                    return false;
                }

                if (condition === 'NULL') {
                    return true;
                } else {
                    switch (condition) {
                        case 'EQUAL':
                            return value === filterValue;
                        case 'NOT_EQUAL':
                            return value !== filterValue;
                    }
                    return false;
                }
            } else {
                if (condition === 'NULL') return false;

                if (condition === 'NOT_NULL') return true;
            }

            var val = new Date(),
                compareTimePart = void 0;

            val.setFullYear(1900, 0, 1);
            val.setHours(12, 0, 0, 0);

            try {
                var parseAttemptDateTime = new JQX.Utilities.DateTime(),
                    tmpvalue = new Date(value);

                if (tmpvalue.toString() === 'NaN' || tmpvalue.toString() === 'Invalid Date') {
                    value = parseAttemptDateTime.tryparseDate(value);
                } else {
                    value = tmpvalue;
                }

                val = value;
                compareTimePart = false;

                if (formatString !== undefined) {
                    if (formatString.indexOf('t') >= 0 || formatString.indexOf('T') >= 0 || formatString.indexOf(':') >= 0 || formatString.indexOf('f') >= 0) {
                        compareTimePart = true;
                        if (filterValue && filterValue.toString().indexOf(':') === -1) {
                            var result = parseAttemptDateTime.tryparseDate(filterValue.toString() + ':00');

                            if (result !== null) {
                                that.filterdate = result;
                            }
                        }
                    }
                }
                if (!compareTimePart) {
                    val.setHours(0);
                    val.setMinutes(0);
                    val.setSeconds(0);
                }
            } catch (error) {
                if (value.toString() !== '') return false;
            }

            if (that.filterdate !== null) {
                filterValue = that.filterdate;
            } else if (filterValue && filterValue.indexOf && (filterValue.indexOf(':') !== -1 || !isNaN(parseInt(filterValue)))) {

                var tmpFilter = new Date(val);

                tmpFilter.setHours(12, 0, 0, 0);

                var timeStrings = filterValue.split(':');

                for (var i = 0; i < timeStrings.length; i++) {
                    if (i === 0) {
                        tmpFilter.setHours(timeStrings[i]);
                    }
                    if (i === 1) {
                        tmpFilter.setMinutes(timeStrings[i]);
                    }
                    if (i === 2) {
                        tmpFilter.setSeconds(timeStrings[i]);
                    }
                }

                filterValue = tmpFilter;
            }

            if (compareTimePart) {
                if (filterValue && filterValue.setFullYear) {
                    if (val && val.getFullYear) {
                        if (formatString.indexOf('d') === -1 && formatString.indexOf('M') === -1 && formatString.indexOf('y') === -1) {
                            filterValue.setFullYear(val.getFullYear(), val.getMonth(), val.getDate());
                        }
                    }
                }
            }

            var compare = function compare(val, filterValue) {
                if (val === null) val = '';
                switch (condition) {
                    case 'EQUAL':
                        return val.toString() === filterValue.toString();
                    case 'NOT_EQUAL':
                        return val.toString() !== filterValue.toString();
                    case 'GREATER_THAN':
                        return val > filterValue;
                    case 'GREATER_THAN_OR_EQUAL':
                        return val >= filterValue;
                    case 'LESS_THAN':
                        return val < filterValue;
                    case 'LESS_THAN_OR_EQUAL':
                        return val <= filterValue;
                    case 'STARTS_WITH':
                        filterValue = filterValue.toString().toLowerCase();
                        return val.toString().toLowerCase().substring(0, filterValue.length) === filterValue;
                    case 'ENDS_WITH':
                        val = val.toString().toLowerCase();
                        filterValue = filterValue.toString().toLowerCase();
                        return val.substring(val.length - filterValue.length, val.length) === filterValue;
                    case 'ENDS_WITH_CASE_SENSITIVE':
                        val = val.toString();
                        filterValue = filterValue.toString();
                        return val.substring(val.length - filterValue.length, val.length) === filterValue;
                    case 'STARTS_WITH_CASE_SENSITIVE':
                        filterValue = filterValue.toString();
                        return val.toString().substring(0, filterValue.length) === filterValue;
                    case 'CONTAINS':
                        return val.toString().toLowerCase().indexOf(filterValue.toString().toLowerCase()) !== -1;
                    case 'CONTAINS_CASE_SENSITIVE':
                        return val.toString().indexOf(filterValue.toString()) !== -1;
                    case 'DOES_NOT_CONTAIN':
                        return val.toString().toLowerCase().indexOf(filterValue.toString().toLowerCase()) === -1;
                    case 'DOES_NOT_CONTAIN_CASE_SENSITIVE':
                        return val.toString().indexOf(filterValue.toString()) === -1;
                    default:
                        return true;
                }
            };

            var filterValues = new Array();

            if (filterValue && filterValue.indexOf) if (filterValue.indexOf('|') >= 0 || filterValue.indexOf(' AND ') >= 0 || filterValue.indexOf(' OR ') >= 0 || filterValue.indexOf(' and ') >= 0 || filterValue.indexOf(' or ') >= 0) {
                var _result2 = compare(val, filterValue);

                if (_result2) {
                    return _result2;
                }

                var andLowerCaseFilters = filterValue.indexOf(' and ') >= 0 ? filterValue.split(' and ') : new Array(),
                    orLowerCaseFilters = filterValue.indexOf(' or ') >= 0 ? filterValue.split(' or ') : new Array(),
                    delimiterFilters = filterValue.indexOf('|') >= 0 ? filterValue.split('|') : new Array();
                var andFilters = filterValue.indexOf(' AND ') >= 0 ? filterValue.split(' AND ') : new Array(),
                    orFilters = filterValue.indexOf(' OR ') >= 0 ? filterValue.split(' OR ') : new Array();

                andFilters = andFilters.concat(andLowerCaseFilters);
                orFilters = orFilters.concat(orLowerCaseFilters);
                if (delimiterFilters.length > 0) {
                    for (var _i6 = 0; _i6 < delimiterFilters.length; _i6++) {
                        delimiterFilters[_i6] = delimiterFilters[_i6].trim;
                    }
                }
                orFilters = orFilters.concat(delimiterFilters);

                if (andFilters.length > 0) {
                    for (var _i7 = 0; _i7 < andFilters.length; _i7++) {
                        if (!andFilters[_i7].indexOf(' OR ') >= 0) {
                            filterValues.push(andFilters[_i7]);
                        }
                    }
                }
                if (orFilters.length > 0) {
                    for (var _i8 = 0; _i8 < orFilters.length; _i8++) {
                        if (!orFilters[_i8].indexOf(' AND ') >= 0) {
                            filterValues.push(orFilters[_i8]);
                        }
                    }
                }

                var filterresult = undefined;

                for (var j = 0; j < filterValues.length; j++) {
                    var _value3 = filterValues[j];
                    if (_value3 && _value3.indexOf && _value3.indexOf('..') >= 0) {
                        var values = _value3.toString().split('..');
                        if (values.length === 2) {
                            _result2 = val >= values[0] && val <= values[1];
                        }
                    } else {
                        _result2 = compare(val, _value3);
                    }

                    var filteroperator = j < andFilters.length ? 'and' : 'or';

                    if (filterresult === undefined) {
                        filterresult = _result2;
                    } else {
                        if (filteroperator === 'or') {
                            filterresult = filterresult || _result2;
                        } else {
                            filterresult = filterresult && _result2;
                        }
                    }
                }

                return filterresult;
            }
            if (filterValue && filterValue.indexOf && filterValue.indexOf('..') >= 0) {
                filterValues = filterValue.toString().split('..');
                if (filterValues.length === 2) {
                    return val >= filterValues[0] && val <= filterValues[1];
                }
            }
            return compare(val, filterValue);
        }
    }, {
        key: 'evaluateTimeOnly',
        value: function evaluateTimeOnly(value) {
            var that = this,
                filterValue = that.value;

            if (!filterValue) {
                if (!value) {
                    return true;
                }

                return false;
            } else if (!value || !(value instanceof Date)) {
                return false;
            }

            var valueHours = value.getHours(),
                filterValueHours = filterValue.getHours();

            if (valueHours !== filterValueHours) {
                return false;
            }

            var valueMinutes = value.getMinutes(),
                filterValueMinutes = filterValue.getMinutes();

            if (valueMinutes !== filterValueMinutes) {
                return false;
            }

            var valueSeconds = value.getSeconds(),
                filterValueSeconds = filterValue.getSeconds();

            if (valueSeconds !== filterValueSeconds) {
                return false;
            }

            return true;
        }
    }]);
    return DateFilter;
}());

JQX.Utilities.Assign('CustomFilter', function () {
    function CustomFilter(filterValue, condition, customfilter) {
        babelHelpers.classCallCheck(this, CustomFilter);

        var that = this;

        that.value = filterValue;
        that.condition = condition;
        that.customfilter = customfilter;
    }

    babelHelpers.createClass(CustomFilter, [{
        key: 'evaluate',
        value: function evaluate(value) {
            var that = this;

            return that.customfilter(that.value, value, that.condition);
        }
    }]);
    return CustomFilter;
}());

JQX.FilterGroup = JQX.Utilities.FilterGroup;
JQX.StringFilter = JQX.Utilities.StringFilter;
JQX.NumericFilter = JQX.Utilities.NumericFilter;
JQX.DateFilter = JQX.Utilities.DateFilter;
JQX.CustomFilter = JQX.Utilities.CustomFilter;