'use strict';

JQX('jqx-splitter-item', function (_JQX$ContentElement) {
    babelHelpers.inherits(SplitterItem, _JQX$ContentElement);

    function SplitterItem() {
        babelHelpers.classCallCheck(this, SplitterItem);
        return babelHelpers.possibleConstructorReturn(this, (SplitterItem.__proto__ || Object.getPrototypeOf(SplitterItem)).apply(this, arguments));
    }

    babelHelpers.createClass(SplitterItem, [{
        key: 'template',


        /**
        * Element's template
        */
        value: function template() {
            return '<div id="container">\n                    <div class="jqx-header" id="header"></div>\n                    <div class="jqx-content" id="content" inner-H-T-M-L="[[innerHTML]]">\n                        <content></content>\n                    </div>\n                </div>';
        }

        /**
        * Element's event binding
        */

    }, {
        key: 'propertyChangedHandler',


        /**
        * Updates the SplitterItem when a property is  changed.
        * @param {string} propertyName The name of the property.
        * @param {number/string} oldValue The previously entered value.
        * @param {number/string} newValue The new entered value.
        */
        value: function propertyChangedHandler(propertyName, oldValue, newValue) {
            var that = this;

            switch (propertyName) {
                case 'collapsed':
                    that._ignorePropertyValue = true;
                    newValue ? that.collapse() : that.expand();
                    break;
                case 'collapsible':
                    that._updateNearSplitterBars();
                    break;
                case 'size':
                case 'min':
                case 'max':
                    that._setSize(propertyName, newValue);
                    break;
                default:
                    babelHelpers.get(SplitterItem.prototype.__proto__ || Object.getPrototypeOf(SplitterItem.prototype), 'propertyChangedHandler', this).call(this, propertyName, oldValue, newValue);
                    break;
            }
        }

        /**
         * Called when the element is attached to the DOM
         */

    }, {
        key: 'attached',
        value: function attached() {
            babelHelpers.get(SplitterItem.prototype.__proto__ || Object.getPrototypeOf(SplitterItem.prototype), 'attached', this).call(this);

            var that = this;

            if (!that._sizeLimits) {
                that._sizeLimits = {};
            }

            var computedStyle = getComputedStyle(that);

            if (!that.min) {
                that._sizeLimits.minWidth = parseFloat(computedStyle.getPropertyValue('min-width')) || 0;
                that._sizeLimits.minHeight = parseFloat(computedStyle.getPropertyValue('min-height')) || 0;
            }

            if (!that.max) {
                that._sizeLimits.maxWidth = parseFloat(computedStyle.getPropertyValue('max-width')) || 0;
                that._sizeLimits.maxHeight = parseFloat(computedStyle.getPropertyValue('max-height')) || 0;
            }
        }

        /**
         * Called when the element is detached from the DOM
         */

    }, {
        key: 'detached',
        value: function detached() {
            babelHelpers.get(SplitterItem.prototype.__proto__ || Object.getPrototypeOf(SplitterItem.prototype), 'detached', this).call(this);

            var that = this;

            that.$.removeClass('animate');
        }

        /**
        * Appends a node to the splitter item.
        */

    }, {
        key: 'appendChild',
        value: function appendChild(node) {
            var that = this;

            if (!node) {
                that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'appendChild', node: 'node' }));
                return;
            }

            if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
                var args = Array.prototype.slice.call(arguments, 2);
                return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
            }

            that.$.content.appendChild(node);
        }

        /**
         * Collapses the item
         */

    }, {
        key: 'collapse',
        value: function collapse(far) {
            var that = this;

            if (!that.collapsible) {
                that.collapsed = false;
                return;
            }

            if (that._ignorePropertyValue || !that.collapsed) {
                var ownerElement = (that.getRootNode() ? that.getRootNode().host : null) || that.closest('jqx-splitter');

                if (!ownerElement) {
                    return;
                }

                var itemIndex = ownerElement._items.indexOf(that);

                if (itemIndex === ownerElement._items.length - 1) {
                    far = true;
                } else if (itemIndex === 0) {
                    far = false;
                }

                var direction = far ? -1 : 1;
                var neighbourItemIndex = itemIndex + direction,
                    neighbourItem = ownerElement._items[neighbourItemIndex];

                while (neighbourItem) {
                    if (!neighbourItem.collapsed) {
                        break;
                    }

                    neighbourItemIndex += direction;
                    neighbourItem = ownerElement._items[neighbourItemIndex];
                }

                if (!neighbourItem) {
                    that.collapsed = false;
                    return;
                }

                delete that._ignorePropertyValue;

                //Store the size before collapsing
                if (!that._sizeBeforeCollapse) {
                    that._sizeBeforeCollapse = that[ownerElement._measurements.size];
                }

                if (!neighbourItem._sizeBeforeCollapse) {
                    neighbourItem._sizeBeforeCollapse = neighbourItem[ownerElement._measurements.size];
                }

                var splitterBar = void 0;

                if (that.previousElementSibling instanceof JQX.SplitterBar) {
                    splitterBar = that.previousElementSibling;
                } else if (that.nextElementSibling instanceof JQX.SplitterBar) {
                    splitterBar = that.nextElementSibling;
                }

                var totalSpace = neighbourItem[ownerElement._measurements.size] + that[ownerElement._measurements.size],
                    minSize = splitterBar ? splitterBar[ownerElement._measurements.size] : that._sizeLimits[ownerElement._measurements.minDimension],
                    spaceAvailable = totalSpace - minSize;

                if (totalSpace && spaceAvailable < minSize) {
                    that.collapsed = false;
                    return;
                }

                //Add animation class
                if (that.hasAnimation && !ownerElement._isInitializing) {
                    that.$.addClass('animate');
                    neighbourItem.$.addClass('animate');

                    that.addEventListener('transitionend', that._transitionEndHandler, { once: true });
                    that.addEventListener('transitioncancel', that._transitionEndHandler, { once: true });
                    neighbourItem.addEventListener('transitionend', that._transitionEndHandler, { once: true });
                    neighbourItem.addEventListener('transitioncancel', that._transitionEndHandler, { once: true });
                }

                if (!that._paddings) {
                    var computedStyle = getComputedStyle(that);

                    that._paddings = (parseFloat(computedStyle.getPropertyValue('padding-' + ownerElement._measurements.position)) || 0) + (parseFloat(computedStyle.getPropertyValue('padding-' + ownerElement._measurements.position2)) || 0);
                }

                if (neighbourItem._sizeBeforeCollapse) {
                    neighbourItem._sizeBeforeCollapse = neighbourItem._sizeBeforeCollapse + that._sizeBeforeCollapse;
                }

                if (neighbourItem._sizeLimits && neighbourItem._sizeLimits[ownerElement._measurements.maxDimension] && totalSpace > neighbourItem._sizeLimits[ownerElement._measurements.maxDimension]) {
                    neighbourItem._sizeLimits.ignoreUpdate = true;

                    if (neighbourItem._sizeBeforeCollapse) {
                        neighbourItem.style[ownerElement._measurements.maxDimension] = neighbourItem._sizeBeforeCollapse + 'px';
                    } else {
                        neighbourItem.style[ownerElement._measurements.maxDimension] = '';
                    }
                }

                if (neighbourItem._sizeBeforeCollapse) {
                    neighbourItem.style[ownerElement._measurements.dimension] = neighbourItem._sizeBeforeCollapse + 'px';
                }

                that.style[ownerElement._measurements.dimension] = that.style[ownerElement._measurements.minDimension] = '0';
                that.style.padding = '0'; //Make sure no paddings interferes with the size of the collapsed item
                that._neighbourItem = neighbourItem;

                that.collapsed = true;
                ownerElement.$.fireEvent('collapse', { itemIndex: ownerElement._items.indexOf(that) });

                if (far) {
                    that.previousElementSibling.itemCollapsed = true;
                    that.previousElementSibling.showFarButton = !(that.previousElementSibling.showNearButton = false);
                } else {
                    that.nextElementSibling.itemCollapsed = true;
                    that.nextElementSibling.showNearButton = !(that.nextElementSibling.showFarButton = false);
                }
            }
        }

        /**
        * Expands a splitter item
        */

    }, {
        key: 'expand',
        value: function expand() {
            var that = this;

            if (that._ignorePropertyValue || that.collapsed) {
                var ownerElement = (that.getRootNode() ? that.getRootNode().host : null) || that.closest('jqx-splitter');

                if (!ownerElement) {
                    that.collapsed = true;
                    return;
                }

                if (!that._neighbourItem) {
                    that.collapsed = true;
                    return;
                }

                delete that._ignorePropertyValue;

                if (!that._neighbourItem._ignorePropertyValue && that._neighbourItem.collapsed) {
                    var neighbourItemIndex = ownerElement._items.indexOf(that._neighbourItem);
                    var direction = ownerElement._items.indexOf(that) > ownerElement._items.indexOf(that._neighbourItem) ? -1 : 1;

                    that._neighbourItem = ownerElement._items[neighbourItemIndex];

                    while (that._neighbourItem) {
                        if (!that._neighbourItem.collapsed) {
                            break;
                        }

                        neighbourItemIndex += direction;
                        that._neighbourItem = ownerElement._items[neighbourItemIndex];
                    }
                }

                if (!that._neighbourItem) {
                    that.collapsed = true;
                    return;
                }

                if (that.min) {
                    that._setSize('min', that.min, true);
                }

                var totalSpace = that._neighbourItem._sizeBeforeCollapse,
                    minSize = that._sizeLimits[ownerElement._measurements.minDimension],
                    neighbourItemMin = that._neighbourItem._sizeLimits[ownerElement._measurements.minDimension],
                    spaceAvailable = totalSpace - minSize;

                if (totalSpace && spaceAvailable < neighbourItemMin) {
                    that.collapsed = true;
                    return;
                }

                if (!that._neighbourItem._paddings) {
                    var computedStyle = getComputedStyle(that._neighbourItem);

                    that._neighbourItem._paddings = (parseFloat(computedStyle.getPropertyValue('padding-' + ownerElement._measurements.position)) || 0) + (parseFloat(computedStyle.getPropertyValue('padding-' + ownerElement._measurements.position2)) || 0);
                }

                if (!that._paddings) {
                    var _computedStyle = getComputedStyle(that);

                    that._paddings = (parseFloat(_computedStyle.getPropertyValue('padding-' + ownerElement._measurements.position)) || 0) + (parseFloat(_computedStyle.getPropertyValue('padding-' + ownerElement._measurements.position2)) || 0);
                }

                if ((that.size + '').indexOf('%') > -1 && (!that._sizeBeforeCollapse || that._sizeBeforeCollapse === 0) && that._neighbourItem._sizeBeforeCollapse) {
                    var totalItemSize = 0;

                    ownerElement._items.map(function (item) {
                        return totalItemSize += !item.collapsed ? item.style[ownerElement._measurements.dimension] && item.style[ownerElement._measurements.dimension].indexOf('%') < -1 && item._sizeBeforeCollapse ? item._sizeBeforeCollapse : item.getBoundingClientRect()[ownerElement._measurements.dimension] : 0;
                    });
                    that._sizeBeforeCollapse = totalItemSize * parseFloat(that.size) / 100;
                }

                var previousSize = Math.min(Math.max(minSize, that._sizeBeforeCollapse), totalSpace - that._neighbourItem._paddings - that._paddings - neighbourItemMin);

                if (previousSize < 0) {
                    that.collapsed = true;
                    return;
                }

                //Add animation class
                if (that.hasAnimation && !ownerElement._isInitializing) {
                    that.$.addClass('animate');
                    that._neighbourItem.$.addClass('animate');

                    that.addEventListener('transitionend', that._transitionEndHandler, { once: true });
                    that.addEventListener('transitioncancel', that._transitionEndHandler, { once: true });
                    that._neighbourItem.addEventListener('transitionend', that._transitionEndHandler, { once: true });
                    that._neighbourItem.addEventListener('transitioncancel', that._transitionEndHandler, { once: true });
                }

                //Restore the size before collapsing
                that.style.padding = '';
                that.style[ownerElement._measurements.minDimension] = that.min ? that._sizeLimits[ownerElement._measurements.minDimension] + 'px' : '';
                that.style[ownerElement._measurements.dimension] = (that._sizeBeforeCollapse = previousSize) + 'px';

                that._neighbourItem.style[ownerElement._measurements.dimension] = (that._neighbourItem._sizeBeforeCollapse = Math.max(that._neighbourItem._sizeLimits[ownerElement._measurements.minDimension], totalSpace - previousSize)) + 'px';

                if (that._neighbourItem._sizeLimits[ownerElement._measurements.maxDimension]) {
                    that._neighbourItem.style[ownerElement._measurements.maxDimension] = that._neighbourItem._sizeLimits[ownerElement._measurements.maxDimension] + 'px';
                }

                that.collapsed = false;
                ownerElement.$.fireEvent('expand', { itemIndex: ownerElement._items.indexOf(that) });

                if (ownerElement._items.indexOf(that) > ownerElement._items.indexOf(that._neighbourItem)) {
                    that.previousElementSibling.itemCollapsed = false;
                    that.previousElementSibling.showNearButton = that._neighbourItem.collapsible;
                } else {
                    that.nextElementSibling.itemCollapsed = false;
                    that.nextElementSibling.showFarButton = that._neighbourItem.collapsible;
                }

                var previousElement = ownerElement._items[ownerElement._items.indexOf(that) - 1],
                    nextElement = ownerElement._items[ownerElement._items.indexOf(that) + 1];

                if (previousElement) {
                    var previousSplitterBar = previousElement.nextElementSibling;

                    if (previousSplitterBar && previousSplitterBar instanceof JQX.SplitterBar) {
                        if (!previousElement.collapsed) {
                            previousSplitterBar.itemCollapsed = false;
                            previousSplitterBar.showNearButton = previousElement.collapsible;
                            previousSplitterBar.showFarButton = that.collapsible;
                        } else {
                            previousSplitterBar.showNearButton = that.collapsible;
                        }
                    }
                }

                if (nextElement) {
                    var nextSplitterBar = nextElement.previousElementSibling;

                    if (nextSplitterBar && nextSplitterBar instanceof JQX.SplitterBar) {
                        if (!nextElement.collapsed) {
                            nextSplitterBar.itemCollapsed = false;
                            nextSplitterBar.showNearButton = that.collapsible;
                            nextSplitterBar.showFarButton = nextElement.collapsible;
                        } else {
                            nextSplitterBar.showFarButton = nextElement.collapsed;
                        }
                    }
                }

                delete that._neighbourItem;
            }
        }

        /**
        * Inserts a node before another node inside the splitter item.
        */

    }, {
        key: 'insertBefore',
        value: function insertBefore(node, referenceNode) {
            var that = this;

            if (!node) {
                that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'insertBefore', node: 'node' }));
                return;
            }

            if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
                var args = Array.prototype.slice.call(arguments, 2);
                return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments)));
            }

            that.$.content.insertBefore(node, referenceNode || null);
        }

        /**
        * Locks a splitter item so it's size can't change.
        */

    }, {
        key: 'lock',
        value: function lock() {
            var that = this;

            that.locked = true;
        }

        /**
        * Unlocks a splitter item
        */

    }, {
        key: 'unlock',
        value: function unlock() {
            var that = this;

            that.locked = false;
        }

        /**
        * Invoked when an instance of custom element is attached to the DOM for the first time.
        */

    }, {
        key: 'ready',
        value: function ready() {
            babelHelpers.get(SplitterItem.prototype.__proto__ || Object.getPrototypeOf(SplitterItem.prototype), 'ready', this).call(this);

            var that = this,
                ownerElement = that.closest('jqx-splitter'),
                isOwnerReady = ownerElement && ownerElement.isCompleted;

            that._sizeLimits = {};

            var isPercentage = typeof that.min === 'string' && that.min.indexOf('%') > -1;
            var min = isNaN(parseFloat(that.min)) ? 0 : parseFloat(that.min),
                max = isNaN(parseFloat(that.max)) ? 0 : parseFloat(that.max);

            that._sizeLimits.minWidth = that._sizeLimits.minHeight = isPercentage && isOwnerReady ? min * ownerElement[ownerElement._measurements.size] / 100 : min;

            isPercentage = typeof that.max === 'string' && that.max.indexOf('%') > -1;

            that._sizeLimits.maxWidth = that._sizeLimits.maxHeight = isPercentage && isOwnerReady ? max * ownerElement[ownerElement._measurements.size] / 100 : max;

            if (that.size) {
                isPercentage = typeof that.size === 'string' && that.size.indexOf('%') > -1;

                var size = that.size === 'auto' ? that.size : isNaN(parseFloat(that.size)) ? 0 : parseFloat(that.size) + (isPercentage ? '%' : 'px');

                isOwnerReady ? that.style[ownerElement._measurements.dimension] = size : that.style.width = that.style.height = size;
            }

            that._updateNearSplitterBars();
        }

        /**
        * Removes a child from the Splitter item.
        */

    }, {
        key: 'removeChild',
        value: function removeChild(node) {
            var that = this;

            if (!node) {
                that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'removeChild', node: 'node' }));
                return;
            }

            if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
                var args = Array.prototype.slice.call(arguments, 2);
                return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
            }

            that.$.content.removeChild(node);
        }

        /**
         * Expands regardless of the neighbour item. Force expand
         */

    }, {
        key: '_expand',
        value: function _expand() {
            var that = this;

            if (that._neighbourItem && that._neighbourItem.parentElement) {
                that.expand();
                return;
            }

            var ownerElement = that.closest('jqx-splitter');

            if (!ownerElement) {
                return;
            }

            delete that._neighbourItem;

            that.collapsed = false;
            ownerElement.$.fireEvent('expand', { itemIndex: ownerElement._items.indexOf(that) });

            that.style[ownerElement._measurements.minDimension] = that.min ? that._sizeLimits[ownerElement._measurements.minDimension] + 'px' : '';
            that.style[ownerElement._measurements.dimension] = that._sizeBeforeCollapse + 'px';

            if (ownerElement._items.length < 2) {
                return;
            }

            if (that.previousElementSibling instanceof JQX.SplitterBar) {
                that.previousElementSibling.itemCollapsed = false;
                that.previousElementSibling.showNearButton = ownerElement._items[ownerElement._items.indexOf(that) - 1].collapsible;
            }
        }

        /**
         * Mouse Enter/Leave event handler
         * @param {any} event
         */

    }, {
        key: '_mouseEventsHandler',
        value: function _mouseEventsHandler(event) {
            var that = this,
                ownerElement = (that.getRootNode() ? that.getRootNode().host : null) || that.closest('jqx-splitter');

            if (ownerElement && !ownerElement.disabled || JQX.Utilities.Core.isMobile) {
                event.type === 'mouseenter' ? this.setAttribute('hover', '') : this.removeAttribute('hover');
            }
        }

        /**
         * Validates the value of the property
         * @param {any} oldValue - the old value
         * @param {any} value - the new value
         */

    }, {
        key: '_propertyValidator',
        value: function _propertyValidator(oldValue, newValue) {
            if (typeof newValue !== 'number' && typeof newValue !== 'string') {
                return oldValue;
            }

            return newValue;
        }

        /**
         * Set the width/height/min/max of the element
         */

    }, {
        key: '_setSize',
        value: function _setSize(propertyName, newValue, noSizeValidation) {
            var that = this;

            if (that.locked) {
                return;
            }

            var ownerElement = that.closest('jqx-splitter');

            if (!ownerElement) {
                return;
            }

            if (!ownerElement.isCompleted) {
                ownerElement.whenReady(function () {
                    return that._setSize(propertyName, newValue);
                });
                return;
            }

            var isPercentage = typeof newValue === 'string' && newValue.indexOf('%') > -1,
                ownerSize = function () {
                var bars = ownerElement.bars;
                var splitterBarsSize = 0;

                for (var b = 0; b < bars.length; b++) {
                    splitterBarsSize += bars[b][ownerElement._measurements.size];
                }

                return ownerElement.$.container[ownerElement._measurements.size] - splitterBarsSize;
            }();

            newValue = isNaN(parseFloat(newValue)) ? '' : parseFloat(newValue);

            switch (propertyName) {
                case 'size':
                    {
                        var oldSize = that[ownerElement._measurements.size];

                        if (arguments[1] === 'auto' || !arguments[1]) {
                            that.style[ownerElement._measurements.dimension] = arguments[1];
                            that._sizeBeforeCollapse = that[ownerElement._measurements.size];
                        } else {
                            if (isPercentage) {
                                that.style[ownerElement._measurements.dimension] = newValue + '%';
                                that._sizeBeforeCollapse = newValue * ownerSize / 100;
                            } else {
                                that.style[ownerElement._measurements.dimension] = (that._sizeBeforeCollapse = newValue || 0) + 'px';
                            }
                        }

                        var sizeDifference = oldSize - that._sizeBeforeCollapse;

                        if (that._originalSize) {
                            that._originalSize = that._sizeBeforeCollapse;
                        }

                        var lastSplitterItem = ownerElement._items[ownerElement._items.length - 1];

                        if (that === lastSplitterItem) {
                            //Get the best fit item
                            var newLastItem = ownerElement._items.find(function (item) {
                                return item !== that && !item.collapsed && !item.locked && !item.size;
                            });

                            //Get the first possible item
                            if (!newLastItem) {
                                for (var i = Math.max(0, ownerElement._items.length - 2); i >= 0; i--) {
                                    if (!ownerElement._items[i].collapsed && !ownerElement._items[i].locked && ownerElement._items[i] !== that) {
                                        newLastItem = ownerElement._items[i];
                                        break;
                                    }
                                }
                            }

                            if (newLastItem) {
                                newLastItem.style[ownerElement._measurements.dimension] = (newLastItem._sizeBeforeCollapse = Math.max(0, newLastItem[ownerElement._measurements.size] + sizeDifference)) + 'px';
                            }
                        }

                        break;
                    }
                case 'min':
                    that._sizeLimits['minWidth'] = that._sizeLimits['minHeight'] = isPercentage ? newValue * ownerSize / 100 : newValue;
                    that.style[ownerElement._measurements.minDimension] = that.collapsed || !newValue ? '' : newValue + (isPercentage ? '%' : 'px');
                    that.style['min' + ownerElement._measurements.restricredDimension] = '';

                    if (!newValue && !ownerElement._noNeighbourValidation) {
                        ownerElement._validateNeighbourSizeLimits(that);
                    }

                    break;
                case 'max':
                    that._sizeLimits['maxWidth'] = that._sizeLimits['maxHeight'] = isPercentage ? newValue * ownerSize / 100 : newValue;
                    that.style[ownerElement._measurements.maxDimension] = newValue ? newValue + (isPercentage ? '%' : 'px') : '';
                    that.style['max' + ownerElement._measurements.restricredDimension] = '';

                    if (!newValue && !ownerElement._noNeighbourValidation) {
                        ownerElement._validateNeighbourSizeLimits(that);
                    }

                    break;
            }

            if (!noSizeValidation) {
                ownerElement._validateItemSize(true);
            }
        }

        /**
         * StyleChanged event handler
         */

    }, {
        key: '_styleChangedEventHandler',
        value: function _styleChangedEventHandler(event) {
            var that = this;

            if (that.locked) {
                return;
            }

            if (that._sizeLimits.ignoreUpdate) {
                delete that._sizeLimits.ignoreUpdate;
                return;
            }

            if (that.collapsed) {
                return;
            }

            var ownerElement = that.closest('jqx-splitter');
            var value = void 0;

            if (event.detail.styleProperties['min-width']) {
                value = event.detail.styleProperties['min-width'][ownerElement && ownerElement.orientation === 'horizontal' ? 'oldValue' : 'value'];
                that._sizeLimits['minWidth'] = (parseFloat(value) || 0) * (value && value.indexOf('%') > -1 ? ownerElement[ownerElement._measurements.size] / 100 : 1);
            } else if (event.detail.styleProperties['max-width']) {
                value = event.detail.styleProperties['max-width'][ownerElement && ownerElement.orientation === 'horizontal' ? 'oldValue' : 'value'];
                that._sizeLimits['maxWidth'] = (parseFloat(value) || 0) * (value && value.indexOf('%') > -1 ? ownerElement[ownerElement._measurements.size] / 100 : 1);
            } else if (event.detail.styleProperties['min-height']) {
                value = event.detail.styleProperties['min-height'][ownerElement && ownerElement.orientation === 'horizontal' ? 'value' : 'oldValue'];
                that._sizeLimits['minHeight'] = (parseFloat(value) || 0) * (value && value.indexOf('%') > -1 ? ownerElement[ownerElement._measurements.size] / 100 : 1);
            } else if (event.detail.styleProperties['max-height']) {
                value = event.detail.styleProperties['max-height'][ownerElement && ownerElement.orientation === 'horizontal' ? 'value' : 'oldValue'];
                that._sizeLimits['maxHeight'] = (parseFloat(value) || 0) * (value && value.indexOf('%') > -1 ? ownerElement[ownerElement._measurements.size] / 100 : 1);
            }
        }

        /**
         * Transitionend Event Handler
         */

    }, {
        key: '_transitionEndHandler',
        value: function _transitionEndHandler() {
            var that = this;

            if (!that.isCompleted && that.$.hasClass('animate')) {
                return;
            }

            that.$.removeClass('animate');

            if (that._neighbourItem && that._neighbourItem.$.hasClass('animate')) {
                that._neighbourItem.$.removeClass('animate');
            }

            if ((that.size + '').indexOf('%') > -1 || that._neighbourItem && (that._neighbourItem.size + '').indexOf('%') > -1) {
                var ownerElement = (that.getRootNode() ? that.getRootNode().host : null) || that.closest('jqx-splitter');

                ownerElement._validateItemSize();
            }
        }

        /**
         * Show/Hide the arrows of the neighbour splitter bars
         */

    }, {
        key: '_updateNearSplitterBars',
        value: function _updateNearSplitterBars() {
            var that = this;

            if (that.previousElementSibling instanceof JQX.SplitterBar) {
                that.previousElementSibling.showFarButton = that.collapsible;
            }

            if (that.nextElementSibling instanceof JQX.SplitterBar) {
                that.nextElementSibling.showNearButton = that.collapsible;
            }
        }
    }, {
        key: 'enableShadowDOM',


        /**
        * Disables ShadowDOM for the splitter items
        */
        get: function get() {
            return false;
        }
    }], [{
        key: 'properties',


        /**
        * Element's properties
        */
        get: function get() {
            return {
                'collapsed': {
                    value: false,
                    type: 'boolean'
                },
                'collapsible': {
                    value: false,
                    type: 'boolean'
                },
                'locked': {
                    value: false,
                    type: 'boolean'
                },
                'max': {
                    value: '',
                    type: 'any',
                    validator: '_propertyValidator'
                },
                'min': {
                    value: '',
                    type: 'any',
                    validator: '_propertyValidator'
                },
                'size': {
                    value: '',
                    type: 'any',
                    validator: '_propertyValidator'
                }
            };
        }
    }, {
        key: 'listeners',
        get: function get() {
            return {
                'mouseenter': '_mouseEventsHandler',
                'mouseleave': '_mouseEventsHandler',
                'styleChanged': '_styleChangedEventHandler'
            };
        }
    }]);
    return SplitterItem;
}(JQX.ContentElement));

JQX('jqx-splitter-bar', function (_JQX$BaseElement) {
    babelHelpers.inherits(SplitterBar, _JQX$BaseElement);

    function SplitterBar() {
        babelHelpers.classCallCheck(this, SplitterBar);
        return babelHelpers.possibleConstructorReturn(this, (SplitterBar.__proto__ || Object.getPrototypeOf(SplitterBar)).apply(this, arguments));
    }

    babelHelpers.createClass(SplitterBar, [{
        key: 'template',


        /**
        * Element's template
        */
        value: function template() {
            return '<div id="container" >\n                    <div class="jqx-splitter-far-collapse-button" id="farCollapseButton">\n                        <span id="arrowNear" class="jqx-arrow"></span>\n                    </div>\n                    <div class="jqx-splitter-resize-button" id="resizeButton">\n                        <span></span>\n                    </div>\n                    <div class="jqx-splitter-near-collapse-button" id="nearCollapseButton">\n                        <span id="arrowFar" class="jqx-arrow"></span>\n                    </div>\n                </div>';
        }

        /**
        * Element's event binding
        */

    }, {
        key: 'propertyChangedHandler',


        /**
        * Updates the SplitterBar when a property is  changed.
        * @param {string} propertyName The name of the property.
        * @param {number/string} oldValue The previously entered value.
        * @param {number/string} newValue The new entered value.
        */
        value: function propertyChangedHandler(propertyName, oldValue, newValue) {
            var that = this;

            switch (propertyName) {
                case 'unfocusable':
                    that._setFocusable();
                    break;
                default:
                    babelHelpers.get(SplitterBar.prototype.__proto__ || Object.getPrototypeOf(SplitterBar.prototype), 'propertyChangedHandler', this).call(this, propertyName, oldValue, newValue);
                    break;
            }
        }

        /**
        * Invoked when an instance of custom element is attached to the DOM for the first time.
        */

    }, {
        key: 'ready',
        value: function ready() {
            babelHelpers.get(SplitterBar.prototype.__proto__ || Object.getPrototypeOf(SplitterBar.prototype), 'ready', this).call(this);

            var that = this;

            that._setFocusable();
        }

        /**
         * Hides the Splitter Bar
         */

    }, {
        key: 'hide',
        value: function hide() {
            var that = this,
                ownerElement = that.closest('jqx-splitter');

            that.$.addClass('jqx-hidden');

            if (ownerElement) {
                var ownerItems = ownerElement.items;

                if (ownerElement.hasAnimation) {
                    var animatedItem = void 0;

                    for (var i = 0; i < ownerItems.length; i++) {
                        if (ownerItems[i].$.hasClass('animate')) {
                            animatedItem = true;
                            ownerItems[i].addEventListener('transitionend', function () {
                                that.closest('jqx-splitter')._autoFitItems();
                            }, { once: true });
                        }
                    }

                    if (animatedItem) {
                        return;
                    }
                }

                ownerElement._autoFitItems();
            }
        }

        /**
         * Shows the Splitter Bar
         */

    }, {
        key: 'show',
        value: function show() {
            var that = this,
                ownerElement = that.closest('jqx-splitter');

            that.$.removeClass('jqx-hidden');

            if (ownerElement) {
                var ownerItems = ownerElement.items;

                if (ownerElement.hasAnimation) {
                    var animatedItem = void 0;

                    for (var i = 0; i < ownerItems.length; i++) {
                        if (ownerItems[i].$.hasClass('animate')) {
                            animatedItem = true;
                            ownerItems[i].addEventListener('transitionend', function () {
                                that.closest('jqx-splitter')._autoFitItems();
                            }, { once: true });
                        }
                    }

                    if (animatedItem) {
                        return;
                    }
                }

                ownerElement._autoFitItems();
            }
        }

        /**
        * Locks a splitter bar so it can't be dragged
        */

    }, {
        key: 'lock',
        value: function lock() {
            var that = this;

            that.locked = that.unfocusable = true;

            if (that.showNearButton || that.showFarButton) {
                return;
            }

            that._setFocusable();
        }

        /**
        * Unlocks a splitter bar
        */

    }, {
        key: 'unlock',
        value: function unlock() {
            var that = this;

            that.locked = that.unfocusable = false;
            that._setFocusable();
        }

        /**
         * Focus/Blur event handler
         * @param {any} event
         */

    }, {
        key: '_focusEventHandler',
        value: function _focusEventHandler(event) {
            var that = this,
                ownerElement = (that.getRootNode() ? that.getRootNode().host : null) || that.closest('jqx-splitter');

            if (ownerElement && !ownerElement.disabled) {
                event.type === 'focus' ? this.setAttribute('focus', '') : this.removeAttribute('focus');
            }
        }

        /**
        * Sets tab index
        */

    }, {
        key: '_setFocusable',
        value: function _setFocusable() {
            var that = this;

            if (that.disabled || that.unfocusable) {
                that.removeAttribute('tabindex');
                return;
            }

            that.tabIndex = that.tabIndex > 0 ? that.tabIndex : 0;
        }

        /**
         * MouseEnter and MouseLeave event handler for the hover state of the Splitter Bar
         */

    }, {
        key: '_handleHoveredState',
        value: function _handleHoveredState(ownerElement, type) {
            var that = this;

            switch (type) {
                case 'mouseenter':
                    if (!ownerElement._getTargetItem(that, 'previousElementSibling') || !(ownerElement.resizeMode === 'adjacent' ? ownerElement._getTargetItem(that, 'nextElementSibling') : ownerElement._getTargetItem(that, 'previousElementSibling', true))) {
                        return;
                    }

                    that.setAttribute('hover', '');
                    break;
                case 'mouseleave':
                    {
                        that.removeAttribute('hover');
                        break;
                    }
            }
        }

        /**
        * Mouse Over/Out event handler
        * @param {any} event
        */

    }, {
        key: '_mouseEventsHandler',
        value: function _mouseEventsHandler(event) {
            var that = this,
                ownerElement = (that.getRootNode() ? that.getRootNode().host : null) || that.closest('jqx-splitter');

            if (ownerElement && ownerElement.disabled || JQX.Utilities.Core.isMobile) {
                return;
            }

            if (event.type === 'mouseenter' || event.type === 'mouseleave') {
                that._handleHoveredState(ownerElement, event.type);
                return;
            }

            if (event.target.closest('.jqx-splitter-far-collapse-button') === that.$.farCollapseButton) {
                event.type === 'mouseover' ? that.$.farCollapseButton.setAttribute('hover', '') : that.$.farCollapseButton.removeAttribute('hover');
                return;
            }

            if (event.target.closest('.jqx-splitter-near-collapse-button') === that.$.nearCollapseButton) {
                event.type === 'mouseover' ? that.$.nearCollapseButton.setAttribute('hover', '') : that.$.nearCollapseButton.removeAttribute('hover');
                return;
            }

            if (event.target.closest('.jqx-splitter-resize-button') === that.$.resizeButton) {
                event.type === 'mouseover' ? that.$.resizeButton.setAttribute('hover', '') : that.$.resizeButton.removeAttribute('hover');
            }
        }
    }, {
        key: 'enableShadowDOM',


        /**
        * Disables ShadowDOM for the splitter bars
        */
        get: function get() {
            return false;
        }
    }], [{
        key: 'properties',


        /**
        * Element's properties
        */
        get: function get() {
            return {
                'showNearButton': {
                    value: false,
                    type: 'boolean'
                },
                'showFarButton': {
                    value: false,
                    type: 'boolean'
                },
                'itemCollapsed': {
                    value: false,
                    type: 'boolean'
                },
                'locked': {
                    value: false,
                    type: 'boolean'
                }
            };
        }
    }, {
        key: 'listeners',
        get: function get() {
            return {
                'mouseenter': '_mouseEventsHandler',
                'mouseleave': '_mouseEventsHandler',
                'mouseover': '_mouseEventsHandler',
                'mouseout': '_mouseEventsHandler',
                'focus': '_focusEventHandler',
                'blur': '_focusEventHandler'
            };
        }
    }]);
    return SplitterBar;
}(JQX.BaseElement));

JQX('jqx-splitter', function (_JQX$ContentElement2) {
    babelHelpers.inherits(Splitter, _JQX$ContentElement2);

    function Splitter() {
        babelHelpers.classCallCheck(this, Splitter);
        return babelHelpers.possibleConstructorReturn(this, (Splitter.__proto__ || Object.getPrototypeOf(Splitter)).apply(this, arguments));
    }

    babelHelpers.createClass(Splitter, [{
        key: 'template',


        /** 
        * Splitter's HTML template.
        */
        value: function template() {
            return '<div id="container">\n                    <content></content>\n                </div>';
        }

        /**
        * Updates the Splitter when a property is  changed.
        * @param {string} propertyName The name of the property.
        * @param {number/string} oldValue The previously entered value.
        * @param {number/string} newValue The new entered value.
        */

    }, {
        key: 'propertyChangedHandler',
        value: function propertyChangedHandler(propertyName, oldValue, newValue) {
            var that = this;

            switch (propertyName) {
                case 'dataSource':
                    that._createLayout();
                    break;
                case 'resizeMode':
                    delete that._dragDetails;
                    break;
                case 'orientation':
                    {
                        that._setMeasurements();

                        //Used to avoid the animation if enabled
                        that.setAttribute('orientation-change', '');

                        for (var i = 0; i < that._items.length; i++) {
                            that._items[i].style[that._measurements.dimension] = that._items[i]['offset' + that._measurements.restricredDimension] + 'px';
                            that._items[i].style[that._measurements.restricredDimension.toLowerCase()] = '100%';

                            //Remove previous min/max
                            that._items[i].style['max' + that._measurements.restricredDimension] = 'none';
                            that._items[i].style['min' + that._measurements.restricredDimension] = 'none';

                            //Apply new max
                            that._items[i].style[that._measurements.maxDimension] = that._items[i].max ? that._items[i]._sizeLimits[that._measurements.maxDimension] + 'px' : '';

                            if (that._items[i].collapsed) {
                                that._items[i].style.minWidth = that._items[i].style.minHeight = '';
                                that._items[i].style[that._measurements.minDimension] = '0';
                            } else {
                                that._items[i].style[that._measurements.minDimension] = that._items[i].min ? that._items[i]._sizeLimits[that._measurements.minDimension] + 'px' : '';
                            }
                        }

                        that._validateItemSize();

                        //Used to avoid  the animation if enabled
                        that.removeAttribute('orientation-change');
                        break;
                    }
                case 'unfocusable':
                    that._setFocusable();
                    break;
                default:
                    babelHelpers.get(Splitter.prototype.__proto__ || Object.getPrototypeOf(Splitter.prototype), 'propertyChangedHandler', this).call(this, propertyName, oldValue, newValue);
                    break;
            }
        }

        /**
        * Appends a node to the splitter.
        */

    }, {
        key: 'appendChild',
        value: function appendChild(node) {
            var that = this;

            if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
                var args = Array.prototype.slice.call(arguments, 2);

                return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
            }

            if (!node || !(node instanceof JQX.SplitterItem)) {
                that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'appendChild', node: 'node' }));
                return;
            }

            that.insertBefore(node, null);
        }

        /**
        * Called when the element is attached to the DOM
        */

    }, {
        key: 'attached',
        value: function attached() {
            babelHelpers.get(Splitter.prototype.__proto__ || Object.getPrototypeOf(Splitter.prototype), 'attached', this).call(this);

            var that = this;

            //Make sure items are calculated properly on attached
            if (that.isCompleted) {
                that._validateItemSize();
            }
        }

        /**
        * Collapses a splitter item
        * item - Number indicating the index of the item / An isntance of JQX.SplitterItem
        * far - indicates whether the item should collapse to it's far or near side
        */

    }, {
        key: 'collapse',
        value: function collapse(item, far) {
            var that = this;

            if (typeof item === 'number') {
                item = that._items[item];
            }

            if (!item) {
                return;
            }

            var closestSplitter = (that.enableShadowDOM ? item.getRootNode().host : item).closest('jqx-splitter');

            if (item instanceof JQX.SplitterItem && closestSplitter === that) {
                item.collapse(far);
                return;
            }

            if (typeof item !== 'number' || !that._items[item]) {
                that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'collapse' }));
                return;
            }

            item.collapse(far);
        }

        /**
        * Expands a splitter item
        */

    }, {
        key: 'expand',
        value: function expand(item) {
            var that = this;

            if (typeof item === 'number') {
                item = that._items[item];
            }

            if (!item) {
                return;
            }

            var closestSplitter = (that.enableShadowDOM ? item.getRootNode().host : item).closest('jqx-splitter');

            if (item instanceof JQX.SplitterItem && closestSplitter === that) {
                item.expand();
                return;
            }

            if (typeof item !== 'number' || !that._items[item]) {
                that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'expand' }));
                return;
            }

            item.expand();
        }

        /**
         * Hides a splitter bar
         * index - the valid index of a jqxSplitterBar or its instance
         */

    }, {
        key: 'hideBar',
        value: function hideBar(item) {
            var that = this;

            if (typeof item === 'number') {
                item = that.bars[item];
            }

            if (!(item instanceof JQX.SplitterBar)) {
                that.error(that.localize('indexOutOfBound', { elementType: that.nodeName.toLowerCase(), method: 'hideBar' }));
                return;
            }

            if (item instanceof JQX.SplitterBar && (that.enableShadowDOM ? item.getRootNode().host : item.closest('jqx-splitter')) === that) {
                item.hide();
            }
        }

        /**
        * Returns an array of Splitter items that are inside the element
        */

    }, {
        key: 'insert',


        /**
         * Insert a new Splitter item at a given position
         * index - indicates the index at which a new item will be inserted
         */
        value: function insert(index, details) {
            var that = this;

            if (typeof details === 'string') {
                details = { content: details };
            }

            if (!details || (typeof details === 'undefined' ? 'undefined' : babelHelpers.typeof(details)) !== 'object') {
                that.error(that.localize('invalidSettings', { elementType: that.nodeName.toLowerCase(), method: 'insert' }));
                return;
            }

            if (typeof index !== 'number') {
                that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'insert' }));
                return;
            }

            var item = details instanceof JQX.SplitterItem ? details : that._createItem(details);

            if (index >= that._items.length || that._items.length === 0) {
                that.appendChild(item);
            } else {
                that.insertBefore(item, that._items[index]);
            }
        }

        /**
        * Inserts a new node after another node in the splitter.
        */

    }, {
        key: 'insertBefore',
        value: function insertBefore(node, referenceNode) {
            var that = this;

            function validateNodeSize() {
                var previousItem = function () {
                    var item = node.previousElementSibling;

                    while (item) {
                        if (item instanceof JQX.SplitterItem) {
                            return item;
                        }

                        item = item.previousElementSibling;
                    }
                }();
                var isPreviousItemLocked = previousItem ? previousItem.locked : undefined;

                if (previousItem) {
                    previousItem.locked = false;
                }

                that._resizeHostItemOnInsert(previousItem, node, splitterBar);

                if (that._items) {
                    that._items.splice(referenceNode ? that._items.indexOf(referenceNode) : that._items.length, 0, node);
                }

                if (previousItem) {
                    if (previousItem.max) {
                        previousItem._setSize('max', previousItem.max, true);
                    }

                    if (previousItem.min) {
                        previousItem._setSize('min', previousItem.min, true);
                    }

                    if (isPreviousItemLocked) {
                        previousItem.locked = true;
                    }
                }

                that._validateItemSize();
            }

            if (!that.isCompleted) {
                var args = Array.prototype.slice.call(arguments, 2);
                return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments)));
            }

            if (!node || !(node instanceof JQX.SplitterItem)) {
                that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'insertBefore', node: 'newNode/referenceNode' }));
                return;
            }

            if (referenceNode && !(referenceNode instanceof JQX.SplitterItem)) {
                that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'insertBefore', node: 'newNode/referenceNode' }));
                return;
            }

            //Set the restricted to fill the Splitter
            node.style[that._measurements.restricredDimension.toLowerCase()] = '100%';

            if (node.size) {
                var unit = typeof node.size === 'string' && node.size.indexOf('%') > -1 ? '%' : 'px';

                node.style[that._measurements.dimension] = node.size === 'auto' ? node.size : isNaN(parseFloat(node.size)) ? '' : parseFloat(node.size) + unit;

                if (that._items.length === 1) {
                    that._items[0].size = '';
                }
            } else {
                node.style[that._measurements.dimension] = '';
            }

            if (node._sizeBeforeCollapse) {
                if (node.size) {
                    var _unit = typeof node.size === 'string' && node.size.indexOf('%') > -1 ? '%' : 'px';

                    node.style[that._measurements.dimension] = node.size === 'auto' ? node.size : isNaN(parseFloat(node.size)) ? 0 : parseFloat(node.size) + _unit;
                    node._sizeBeforeCollapse = node[that._measurements.size];
                } else {
                    delete node._sizeBeforeCollapse;
                }
            }

            node.style['max' + that._measurements.restricredDimension] = 'none';

            node.style[that._measurements.maxDimension] = node._sizeLimits && node.max ? node._sizeLimits[that._measurements.maxDimension] + 'px' : '';

            if (node.collapsed) {
                node.style.minWidth = node.style.minHeight = '';
                node.style[that._measurements.minDimension] = node.style[that._measurements.dimension] = '0';
            } else {
                node.style[that._measurements.minDimension] = node._sizeLimits && node.min ? node._sizeLimits[that._measurements.minDimension] + 'px' : '';
            }

            for (var i = 0; i < that._items.length; i++) {
                if (!that._items[i]._sizeBeforeCollapse) {
                    that._items[i]._sizeBeforeCollapse = that._items[i][that._measurements.size];
                }
            }

            that.$.container.insertBefore(node, referenceNode || null);

            var splitterBar = void 0;
            var currentSplitterBars = that.bars;

            if (node.previousElementSibling instanceof JQX.SplitterItem) {
                splitterBar = that._createBar(node, node.previousElementSibling);
                that.$.container.insertBefore(splitterBar, node);
            } else if (node.nextElementSibling instanceof JQX.SplitterItem) {
                splitterBar = that._createBar(node, node.nextElementSibling);
                that.$.container.insertBefore(splitterBar, node.nextElementSibling);
            }

            if (splitterBar && currentSplitterBars.length > 0) {
                splitterBar.style[that._measurements.restricredDimension.toLowerCase()] = currentSplitterBars[0].style[that._measurements.restricredDimension.toLowerCase()];
            }

            //MS EDGE specific code. In EDGE browser _validateItemSize() is called before the attached method is called
            if (!node.isCompleted) {
                node.__onCompleted = node._onCompleted;

                node._onCompleted = function () {
                    if (node.__onCompleted) {
                        node.__onCompleted();
                        delete node.__onCompleted;
                    }

                    validateNodeSize();
                };
            } else {
                validateNodeSize();
            }
        }

        /**
         * Locks a splitter item so it's size can't change.
         * @param {any} item - the index of a Splitter Item or it's instance
         */

    }, {
        key: 'lockItem',
        value: function lockItem(item) {
            var that = this;

            if (item instanceof JQX.SplitterItem) {
                item.lock();
                return;
            }

            if (typeof item !== 'number' || !that._items[item]) {
                that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'lockItem' }));
                return;
            }

            item = that._items[item];

            if (item) {
                item.lock();
            }
        }

        /**
        * Locks a splitter bar so it can't be dragged.
        * @param {any} item - the index of a Splitter Bar or it's instance
        */

    }, {
        key: 'lockBar',
        value: function lockBar(item) {
            var that = this;

            if (item instanceof JQX.SplitterBar) {
                item.lock();
                return;
            }

            if (typeof item !== 'number') {
                that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'lockBar' }));
                return;
            }

            item = that.bars[item];

            if (item) {
                item.lock();
            }
        }

        /**
        * Set the styleObserver to listen only for resizing
        */

    }, {
        key: 'ready',


        /**
        * Called when the element is ready
        */
        value: function ready() {
            babelHelpers.get(Splitter.prototype.__proto__ || Object.getPrototypeOf(Splitter.prototype), 'ready', this).call(this);

            var that = this;

            //a flag used to avoid animations on startup
            that._isInitializing = true;

            that._createLayout();
            that._setFocusable();

            delete that._isInitializing;
        }

        /**
         * Refreshes the layout of the element
         */

    }, {
        key: 'refresh',
        value: function refresh() {
            this._resizeEventHandler();
        }

        /**
         * Removes a Splitter item at a given position
         * index - indicates the index at which a new item will be inserted
         */

    }, {
        key: 'remove',
        value: function remove(index) {
            var that = this;

            if (index instanceof JQX.SplitterItem && index.closest('jqx-splitter') === that) {
                that.removeChild(index);
                return;
            }

            if (typeof index !== 'number') {
                that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'remove' }));
                return;
            }

            if (index > that._items.length || index < 0) {
                that.error(that.localize('indexOutOfBound', { elementType: that.nodeName.toLowerCase(), method: 'remove' }));
                return;
            }

            that.removeChild(that._items[index]);
        }

        /**
         * Remove all items
         */

    }, {
        key: 'removeAll',
        value: function removeAll() {
            var that = this;

            that._items = [];
            that.$.container.innerHTML = '';
        }

        /**
        * Removes a node from the splitter.
        */

    }, {
        key: 'removeChild',
        value: function removeChild(node) {
            var that = this;

            function getNewNeighbourItem(deletedItemIndex, item, direction) {
                var index = deletedItemIndex,
                    newNeighbourItem = that._items[index];

                while (newNeighbourItem) {
                    if (!newNeighbourItem.collapsed) {
                        break;
                    }

                    newNeighbourItem = that._items[index += direction];
                }

                return newNeighbourItem;
            }

            if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
                var args = Array.prototype.slice.call(arguments, 2);
                return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
            }

            if (!node || !(node instanceof JQX.SplitterItem)) {
                that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'removeChild', node: 'node' }));
                return;
            }

            if (!that._items) {
                return;
            }

            var itemIndex = that._items.indexOf(node);

            if (node.collapsed) {
                that.$.container.removeChild(that._items.indexOf(node._neighbourItem) > itemIndex ? node.nextElementSibling : node.previousElementSibling);
            } else {
                if (node.previousElementSibling instanceof JQX.SplitterBar) {
                    that.$.container.removeChild(node.previousElementSibling);
                } else if (node.nextElementSibling instanceof JQX.SplitterBar) {
                    that.$.container.removeChild(node.nextElementSibling);
                }
            }

            that._items.splice(itemIndex, 1);
            itemIndex = Math.max(0, itemIndex - 1);

            var totalItemSize = 0;
            var uncollapsedItems = that._items.filter(function (item) {
                return !item.collapsed && !item.locked;
            }),
                nodeSize = node._sizeBeforeCollapse || node[that._measurements.size];

            uncollapsedItems.map(function (item) {
                return totalItemSize += (item.style[that._measurements.dimension] ? item._sizeBeforeCollapse : 0) || item[that._measurements.size];
            });

            that.$.content.removeChild(node);

            //If all left items are collapsed, force uncollapsing of the last item
            if (that._items.length === 1 && that._items[0].collapsed || that._items.length > 0 && that._items.map(function (item) {
                return item.collapsed;
            }).indexOf(false) < 0) {
                var lastItem = that._items[that._items.length - 1];
                var context = lastItem.context;

                lastItem.context = lastItem;
                lastItem._expand();
                lastItem.context = context;
            }

            for (var i = 0; i < that._items.length; i++) {
                if (that._items[i].collapsed && that._items[i]._neighbourItem === node) {
                    var _splitterBar = void 0,
                        splitterBarContext = void 0;

                    that._items[i]._neighbourItem = getNewNeighbourItem(itemIndex, that._items[i], 1);

                    if (!that._items[i]._neighbourItem) {
                        that._items[i]._neighbourItem = getNewNeighbourItem(itemIndex, that._items[i], -1);
                        _splitterBar = that._items[i].previousElementSibling;

                        if (_splitterBar) {
                            splitterBarContext = _splitterBar.context;
                            _splitterBar.context = _splitterBar;
                            _splitterBar.itemCollapsed = true;
                            _splitterBar.showFarButton = !(_splitterBar.showNearButton = false);
                            _splitterBar.context = splitterBarContext;
                        }
                    } else {
                        _splitterBar = that._items[i].nextElementSibling;

                        if (_splitterBar) {
                            splitterBarContext = _splitterBar.context;
                            _splitterBar.context = _splitterBar;
                            _splitterBar.itemCollapsed = true;
                            _splitterBar.showNearButton = !(_splitterBar.showFarButton = false);
                            _splitterBar.context = splitterBarContext;
                        }
                    }
                }
            }

            if (that.autoFitMode === 'proportional') {
                var currentItemSize = void 0,
                    newSize = void 0,
                    itemMinSize = void 0;

                for (var _i = 0; _i < uncollapsedItems.length; _i++) {
                    currentItemSize = uncollapsedItems[_i]._sizeBeforeCollapse || uncollapsedItems[_i][that._measurements.size];
                    newSize = currentItemSize + nodeSize * (currentItemSize / totalItemSize);

                    //Check for item min size
                    itemMinSize = uncollapsedItems[_i]._sizeLimits[that._measurements.minDimension] || 0;
                    uncollapsedItems[_i].style[that._measurements.dimension] = (uncollapsedItems[_i]._sizeBeforeCollapse = Math.max(0, newSize)) + 'px';

                    if (itemMinSize > currentItemSize) {
                        uncollapsedItems[_i][that._measurements.minDimension] = newSize + 'px';
                    }
                }
            }

            that._autoFitItems();
        }

        /**
         * Unhides a Splitter Bar
         * item - the index of the splitter bar or it's instance
         */

    }, {
        key: 'showBar',
        value: function showBar(item) {
            var that = this;

            if (item instanceof JQX.SplitterBar) {
                item.show();
                return;
            }

            if (typeof item !== 'number') {
                that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'showBar' }));
                return;
            }

            item = that.bars[item];

            if (!(item instanceof JQX.SplitterBar)) {
                that.error(that.localize('indexOutOfBound', { elementType: that.nodeName.toLowerCase(), method: 'showBar' }));
                return;
            }

            item.show();
        }

        /**
        * Returns an array of Splitter items that are inside the element
        */

    }, {
        key: 'unlockItem',


        /**
        * Unlocks a previously locked splitter item
        * @param {any} item - the index of a Splitter Item or it's instance
        */
        value: function unlockItem(item) {
            var that = this;

            if (item instanceof JQX.SplitterItem) {
                item.unlock();
                return;
            }

            if (typeof item !== 'number' || !that._items[item]) {
                that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'unlockItem' }));
                return;
            }

            item = that._items[item];

            if (item) {
                item.unlock();
            }
        }

        /**
        * Unlocks a previously locked splitter bar
        * @param {any} item - the index of a Splitter Bar or it's instance
        */

    }, {
        key: 'unlockBar',
        value: function unlockBar(item) {
            var that = this;

            if (item instanceof JQX.SplitterBar) {
                item.unlock();
                return;
            }

            if (typeof item !== 'number') {
                that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'unlockBar' }));
                return;
            }

            item = that.bars[item];

            if (item) {
                item.unlock();
            }
        }

        /**
         * Updates the Splitter item's properties
         * @param {any} index - index of the splitter item
         * @param {any} settings - object of properties and value
         */

    }, {
        key: 'update',
        value: function update(item, settings) {
            var that = this;

            if (typeof item === 'number') {
                item = that._items[item];

                if (!item) {
                    that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'update' }));
                    return;
                }
            }

            if (!(item instanceof JQX.SplitterItem) || !settings || (that.enableShadowDOM ? item.getRootNode().host : that.closest('jqx-splitter')) !== that) {
                return;
            }

            for (var key in settings) {
                if (item[key] !== undefined) {
                    item[key] = settings[key];
                }
            }
        }

        /**
        * Fits the last item according to the free space left in the Splitter.
        */

    }, {
        key: '_autoFitItems',
        value: function _autoFitItems() {
            var that = this,
                itemsCount = that._items.length;

            if (itemsCount === 0 || that.autoFitMode === 'overflow') {
                return;
            }

            var lastItem = void 0,
                lockedItems = [],
                collapsedItems = [],
                itemsWithoutSize = [];

            for (var i = itemsCount - 1; i >= 0; i--) {
                if (that._items[i].collapsed) {
                    collapsedItems.push(that._items[i]);
                } else if (that._items[i].locked) {
                    lockedItems.push(that._items[i]);
                } else if (!lastItem) {
                    lastItem = that._items[i];
                } else if (!that._items[i].size) {
                    itemsWithoutSize.push(that._items[i]);
                }
            }

            if (lastItem && lastItem.size && itemsWithoutSize.length > 0) {
                lastItem = itemsWithoutSize.filter(function (item) {
                    return !item.max && !item._sizeLimits[that._measurements.maxDimension];
                })[0] || lastItem;
            }

            if (collapsedItems.length === itemsCount) {
                lastItem = collapsedItems[0];
                lastItem.expand();
                lastItem.unlock();
            }

            that._autoFitLastItem(lastItem, collapsedItems, lockedItems);
        }

        /**
         * AutoFits the items by shrinking the last item.
         */

    }, {
        key: '_autoFitLastItem',
        value: function _autoFitLastItem(lastItem, collapsedItems, lockedItems) {
            var that = this,
                itemsCount = that._items.length;
            var lastLockedItem = void 0;

            if (itemsCount === 1 && that._items[0].locked) {
                lastLockedItem = that._items[0];
                lastLockedItem.locked = false;
            }

            if (lockedItems.length === itemsCount) {
                lockedItems[0].unlock();
            }

            if (!lastItem) {
                lastItem = lockedItems[0];
                lastItem.unlock();
            }

            var totalItemSize = 0,
                totalBarsSize = 0;

            that._items.map(function (item) {
                return totalItemSize += !item.collapsed ? item.style[that._measurements.dimension] && item.style[that._measurements.dimension].indexOf('%') < -1 && item._sizeBeforeCollapse ? item._sizeBeforeCollapse : item.getBoundingClientRect()[that._measurements.dimension] : 0;
            });

            that.bars.map(function (bar) {
                return totalBarsSize += bar[that._measurements.size];
            });

            var currentSplitterSize = totalItemSize + totalBarsSize,
                containerSize = that.$.container.getBoundingClientRect()[that._measurements.dimension];

            if (currentSplitterSize !== containerSize) {
                var lastItemSize = void 0;

                if (lastItem.style[that._measurements.dimension].indexOf('%') < -1) {
                    lastItemSize = lastItem._sizeBeforeCollapse ? lastItem._sizeBeforeCollapse : lastItem.getBoundingClientRect()[that._measurements.dimension];
                } else {
                    lastItemSize = lastItem.getBoundingClientRect()[that._measurements.dimension];
                }

                var sizeDifference = Math.abs(containerSize - currentSplitterSize),
                    sign = currentSplitterSize < containerSize ? 1 : -1;

                lastItem.style[that._measurements.dimension] = (lastItem._sizeBeforeCollapse = Math.max(0, lastItemSize + sign * sizeDifference)) + 'px';

                if (lastItem._sizeLimits[that._measurements.maxDimension] && lastItem._sizeBeforeCollapse > lastItem._sizeLimits[that._measurements.maxDimension]) {
                    lastItem.style[that._measurements.maxDimension] = (lastItem._sizeLimits[that._measurements.maxDimension] = lastItem._sizeBeforeCollapse) + 'px';
                }
            }

            if (lastLockedItem) {
                lastLockedItem.locked = true;
            }
        }

        /**
         * AutoFits the items by proportionally reducing the size of all items
         */

    }, {
        key: '_autoFitItemsProportionally',
        value: function _autoFitItemsProportionally(newItem, splitterBar) {
            var that = this,
                uncollapsedItems = that._items.filter(function (item) {
                return !item.collapsed;
            });
            var newItemSize = newItem[that._measurements.size],
                totalItemSize = 0;

            uncollapsedItems.map(function (item) {
                return totalItemSize += item._sizeBeforeCollapse || item[that._measurements.size];
            });

            if (splitterBar) {
                totalItemSize -= splitterBar[that._measurements.size];
            }

            if (newItem.size && !newItem.isCompleted) {
                newItem._setSize('size', newItemSize);
                newItemSize = newItem._sizeBeforeCollapse;
            }

            newItemSize = Math.min(that.$.container[that._measurements.size] / 2, newItem[that._measurements.size]);
            newItem.style[that._measurements.dimension] = newItemSize + 'px';

            var currentItemSize = void 0,
                newSize = void 0,
                itemMinSize = void 0;

            for (var i = 0; i < uncollapsedItems.length; i++) {
                currentItemSize = uncollapsedItems[i]._sizeBeforeCollapse || uncollapsedItems[i][that._measurements.size];
                newSize = (totalItemSize - newItemSize) * (currentItemSize / totalItemSize);

                //Check for item min size
                itemMinSize = uncollapsedItems[i]._sizeLimits[that._measurements.minDimension] || 0;
                uncollapsedItems[i].style[that._measurements.dimension] = (uncollapsedItems[i]._sizeBeforeCollapse = Math.max(itemMinSize, newSize)) + 'px';
            }
        }

        /**
         * Reads the dataSource and populates the Splitter with items.
         */

    }, {
        key: '_createLayout',
        value: function _createLayout() {
            var that = this;

            that._items = [];

            if (typeof that.dataSource === 'string') {
                that.dataSource = JSON.parse(that.dataSource);
            }

            if (that.dataSource !== null && Array.isArray(that.dataSource)) {
                that.$.container.innerHTML = '';

                var fragment = document.createDocumentFragment(),
                    item = void 0;

                for (var i = 0; i < that.dataSource.length; i++) {
                    item = that._createItem(that.dataSource[i]);
                    fragment.appendChild(item);
                }

                that._handleSplitterBars(fragment);
                return;
            }

            that._handleSplitterBars(that.$.container);
        }

        /**
         * Creates a splitter bar
         * @param {any} item - the item that precedes a splitter item
         */

    }, {
        key: '_createBar',
        value: function _createBar(item, neighbourItem) {
            var that = this,
                splitBar = document.createElement('jqx-splitter-bar');

            if (item.collapsed) {
                splitBar.itemCollapsed = true;

                if (that._items.indexOf(item) === that._items.length - 1) {
                    splitBar.showNearButton = true;
                } else {
                    splitBar.showFarButton = true;
                }
            } else {
                if (item.collapsible) {
                    splitBar.showNearButton = true;
                }

                if (neighbourItem && neighbourItem instanceof JQX.SplitterItem && neighbourItem.collapsible) {
                    neighbourItem === item.nextElementSibling ? splitBar.showFarButton = true : splitBar.showNearButton = true;
                }
            }

            return splitBar;
        }

        /**
         * Creates a splitter item
         */

    }, {
        key: '_createItem',
        value: function _createItem(data) {
            var item = document.createElement('jqx-splitter-item');

            if (data.id) {
                item.id = data.id;
            }

            item.innerHTML = data.content || '';
            item.collapsible = data.collapsible || false;
            item.collapsed = data.collapsed || false;
            item.locked = data.locked || false;

            if (data.max) {
                item.max = data.max;
            }

            if (data.min) {
                item.min = data.min;
            }

            if (data.size) {
                item.size = data.size;
            }

            return item;
        }

        /**
        * Finishes the resizing operation
        */

    }, {
        key: '_completeResizing',
        value: function _completeResizing(canceled) {
            var that = this;

            if (that._dragDetails) {
                if (that._splitBarDummy && that._splitBarDummy.parentElement) {
                    if (!canceled) {
                        that._dragDetails.firstItem.style[that._measurements.dimension] = (that._dragDetails.firstItem._sizeBeforeCollapse = that._dragDetails.firstItem.currentSize + that._dragDetails.firstItem._paddings) + 'px';
                        delete that._dragDetails.firstItem._originalSize;

                        if (that.resizeMode !== 'proportional') {
                            that._dragDetails.secondItem.style[that._measurements.dimension] = (that._dragDetails.secondItem._sizeBeforeCollapse = that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize + that._dragDetails.secondItem._paddings) + 'px';
                            delete that._dragDetails.secondItem._originalSize;
                        } else {
                            var itemCount = that._dragDetails.itemProportions.length;

                            if (itemCount > 1) {
                                for (var p = 0; p < itemCount; p++) {
                                    that._dragDetails.itemProportions[p].item.style[that._measurements.dimension] = (that._dragDetails.itemProportions[p].item._sizeBeforeCollapse = that._dragDetails.itemProportions[p].currentSize + that._dragDetails.itemProportions[p].item._paddings) + 'px';
                                    delete that._dragDetails.itemProportions[p]._originalSize;
                                }
                            } else {
                                that._dragDetails.secondItem[0].style[that._measurements.dimension] = (that._dragDetails.secondItem[0]._sizeBeforeCollapse = Math.floor(that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize + that._dragDetails.firstItem._paddings)) + 'px';
                                delete that._dragDetails.secondItem[0]._originalSize;
                            }
                        }
                    }

                    that.$.fireEvent('resizeEnd', {
                        firstItem: {
                            index: that._items.indexOf(that._dragDetails.firstItem),
                            oldSize: that._dragDetails.firstItem.originalSize,
                            newSize: that._dragDetails.firstItem[that._measurements.size]
                        },
                        secondItem: Array.isArray(that._dragDetails.secondItem) ? {
                            index: that._dragDetails.secondItem.map(function (item) {
                                return that._items.indexOf(item);
                            }),
                            oldSize: that._dragDetails.secondItem.map(function (item) {
                                return item.originalSize;
                            }),
                            newSize: that._dragDetails.secondItem.map(function (item) {
                                return item[that._measurements.size];
                            })
                        } : {
                            index: that._items.indexOf(that._dragDetails.secondItem),
                            oldSize: that._dragDetails.secondItem.originalSize,
                            newSize: that._dragDetails.secondItem[that._measurements.size]
                        }
                    });

                    that._splitBarDummy.classList.remove('limit-reached');
                    that._splitBarDummy.parentElement.removeChild(that._splitBarDummy);
                }

                that.removeAttribute('dragged');

                delete that._dragDetails;
                delete that._keyboardResizing;
            }
        }

        /**
         * Document DragStart event handler
         * @param {any} event
         */

    }, {
        key: '_dragStartHandler',
        value: function _dragStartHandler(event) {
            var that = this;

            if (that._dragDetails) {
                event.preventDefault();
            }
        }

        /**
         * Splitter mouse down event handler
         */

    }, {
        key: '_downHandler',
        value: function _downHandler(event) {
            var that = this;

            event.stopPropagation();

            if (that.disabled) {
                return;
            }

            if (that._keyboardResizing) {
                that._completeResizing();
                return;
            }

            var target = void 0,
                closestSplitter = void 0;

            if (that.enableShadowDOM) {
                target = event.originalEvent.composedPath()[0];
                closestSplitter = target.getRootNode().host;
            } else {
                target = event.originalEvent.target;
                closestSplitter = target.closest('jqx-splitter');
            }

            var closestSplitterBar = target && target.closest ? target.closest('jqx-splitter-bar') : null;

            if (closestSplitterBar && closestSplitter === that) {
                //Collapse Near item
                if (target.closest('.jqx-splitter-near-collapse-button') === closestSplitterBar.$.nearCollapseButton) {
                    that._collapseButtonPressed = {
                        splitBar: closestSplitterBar,
                        item: closestSplitterBar.previousElementSibling,
                        target: closestSplitterBar.$.nearCollapseButton,
                        farCollapse: false
                    };
                    return;
                }

                //Collapse far item
                if (target.closest('.jqx-splitter-far-collapse-button') === closestSplitterBar.$.farCollapseButton) {
                    that._collapseButtonPressed = {
                        splitBar: closestSplitterBar,
                        item: closestSplitterBar.nextElementSibling,
                        target: closestSplitterBar.$.farCollapseButton,
                        farCollapse: true
                    };
                    return;
                }

                if (!closestSplitterBar.itemCollapsed && !closestSplitterBar.locked && that.resizeMode !== 'none') {
                    that._setDragDetails(closestSplitterBar, event);
                }
            }
        }

        /**
         * iOS Safari bug fix. (iOS Safari doesn't support 'touch-action: none')
         */

    }, {
        key: '_moveHandler',
        value: function _moveHandler() {
            if (this.hasAttribute('dragged') && JQX.Utilities.Core.isMobile) {
                event.originalEvent.preventDefault();
            }
        }

        /**
         * Document move event handler
         */

    }, {
        key: '_documentMoveHandler',
        value: function _documentMoveHandler(event) {
            var that = this;

            if (that._keyboardResizing) {
                return;
            }

            that._resize(event);
        }

        /**
         * Document move event handler
         */

    }, {
        key: '_documentUpHandler',
        value: function _documentUpHandler(event) {
            var that = this;

            that.removeAttribute('dragging-not-allowed');
            that.removeAttribute('show-locked-items');

            if (that.disabled) {
                delete that._dragDetails;
                delete that._collapseButtonPressed;
                return;
            }

            var target = that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target;

            that._completeResizing();

            if (that._collapseButtonPressed && target.closest('.' + that._collapseButtonPressed.target.classList[0]) === that._collapseButtonPressed.target) {
                if (that._collapseButtonPressed.item.collapsed) {
                    that.expand(that._collapseButtonPressed.item);
                } else {
                    that.collapse(that._collapseButtonPressed.item, that._collapseButtonPressed.farCollapse);
                }

                delete that._collapseButtonPressed;
                return;
            }
        }

        /**
         * Ensures that all items are attached and ready.
         * @param {any} nodes - nodes that are not ready
         * @param {any} callback - a function to be called when all items are ready
         */

    }, {
        key: '_ensureItemsReady',
        value: function _ensureItemsReady(nodes, callback) {
            var that = this;

            var contextCallback = function contextCallback() {
                var setContext = function setContext(context) {
                    for (var i = 0; i < nodes.length; i++) {
                        nodes[i].context = context === 'node' ? nodes[i] : document;
                    }
                };

                setContext('node');
                callback();
                setContext();
            };

            if (nodes.length === 0) {
                contextCallback();
            } else {
                that._nodesReadyListeners = 0;

                for (var i = 0; i < nodes.length; i++) {
                    var node = nodes[i];

                    var readyEventHandler = function () {
                        that._nodesReadyListeners--;
                        if (that._nodesReadyListeners === 0) {
                            contextCallback();

                            delete that._nodesReadyListeners;
                        }
                    }.bind(that);

                    if (!node.isCompleted) {
                        that._nodesReadyListeners++;
                        node._onCompleted = readyEventHandler;
                    }
                }

                if (that._nodesReadyListeners === 0) {
                    contextCallback();
                }
            }
        }

        /**
         * Element's focus handler
         */

    }, {
        key: '_focusHandler',
        value: function _focusHandler(event) {
            var that = this;

            event.type === 'focus' ? that.setAttribute('focus', '') : that.removeAttribute('focus');
        }

        /**
         * Used in _setDragDetails() method to get the desired item ( first and second )
         * @param {any} sibling - next item
         * @param {any} reverse - reverse order flag
         */

    }, {
        key: '_getTargetItem',
        value: function _getTargetItem(splitter, sibling, reverse) {
            var that = this;
            var previousItem = reverse ? that._items[that._items.length - 1] : splitter[sibling];

            while (previousItem) {

                if (previousItem instanceof JQX.SplitterItem && !previousItem.collapsed) {
                    if (!previousItem.locked) {
                        return previousItem;
                    }

                    if (that._dragDetails && !that._dragDetails.firstItem) {
                        that._dragDetails.lockedItemsSize += previousItem[that._measurements.size] + (previousItem.previousElementSibling instanceof JQX.SplitterBar ? previousItem.previousElementSibling[that._measurements.size] : 0);
                    }
                }

                previousItem = previousItem[sibling];
            }
        }

        /**
         * Adds/Removes split bars
         */

    }, {
        key: '_handleSplitterBars',
        value: function _handleSplitterBars(itemContainer) {
            var that = this;

            if (that._items.length < 1) {
                //IE11 has no support for DocumentFragment.children. Use childNodes instead if no polyfill is provided
                that._items = itemContainer.parentElement ? that.items : Array.from(itemContainer.children);
            }

            if (!that._measurements) {
                that._setMeasurements();
            }

            if (that._items.length < 2) {
                var splitBars = that.bars;

                for (var i = 0; i < splitBars.length; i++) {
                    itemContainer.removeChild(splitBars[i]);
                }
            }

            if (!itemContainer.parentElement && itemContainer !== that.$.container) {
                that.$.container.appendChild(itemContainer);
            }

            for (var _i2 = 0; _i2 < that._items.length; _i2++) {
                that._items[_i2].style[that._measurements.restricredDimension.toLowerCase()] = '100%';
                that._items[_i2].style['max' + that._measurements.restricredDimension] = 'none';

                if (!that._items[_i2].size) {
                    that._items[_i2].style[that._measurements.dimension] = that._items[_i2]._sizeBeforeCollapse ? that._items[_i2]._sizeBeforeCollapse + 'px' : '';
                }

                var min = that._items[_i2].min,
                    max = that._items[_i2].max;

                if (typeof min === 'string' && min.indexOf('%') > -1) {
                    that._items[_i2]._setSize('min', min);
                }

                if (typeof max === 'string' && max.indexOf('%') > -1) {
                    that._items[_i2]._setSize('max', max);
                }

                that._items[_i2].style[that._measurements.maxDimension] = that._items[_i2].max ? that._items[_i2]._sizeLimits[that._measurements.maxDimension] + 'px' : '';

                if (that._items[_i2].nextElementSibling) {
                    var nextElementSibling = that._items[_i2].nextElementSibling;

                    if (nextElementSibling instanceof JQX.SplitterItem || nextElementSibling.tagName.toLowerCase() === 'jqx-splitter-item') {
                        that._items[_i2].parentNode.insertBefore(that._createBar(that._items[_i2], that._items[_i2].nextElementSibling), that._items[_i2].nextElementSibling);
                    } else {
                        that._items[_i2].parentNode.removeChild(that._items[_i2].nextElementSibling);
                    }
                }

                if (that._items[_i2].collapsed) {
                    var collapsible = that._items[_i2].collapsible;

                    that._items[_i2].style.minWidth = that._items[_i2].style.minHeight = '';
                    that._items[_i2].style[that._measurements.minDimension] = '0';
                    that._items[_i2]._ignorePropertyValue = true;

                    //Force collapse it
                    that._items[_i2].collapsible = true;
                    that._items[_i2].collapse();

                    //Return original proeprty value
                    that._items[_i2].collapsible = collapsible;
                } else {
                    that._items[_i2].style[that._measurements.minDimension] = that._items[_i2]._sizeLimits && that._items[_i2].min ? that._items[_i2]._sizeLimits[that._measurements.minDimension] + 'px' : '';
                }
            }

            //if (!itemContainer.parentElement && itemContainer !== that.$.container) {
            //    that.$.container.appendChild(itemContainer);
            //}

            //MS EDGE fix when items are supposed to be ready but they are not yet
            that._ensureItemsReady(that._items, that._validateItemSize.bind(that));
        }

        /**
         * Key down event handler
         * @param {any} event
         */

    }, {
        key: '_keyDownHandler',
        value: function _keyDownHandler(event) {
            var that = this;

            if (that.disabled) {
                return;
            }

            var splitterBar = that.enableShadowDOM ? that.shadowRoot.activeElement : document.activeElement;

            if (event.key === 'w' && event.altKey) {
                //Prevents container scrolling
                event.preventDefault();

                var firstItem = that.enableShadowDOM ? that.shadowRoot.querySelector('jqx-splitter-bar') : that.querySelector('jqx-splitter-bar');

                if (splitterBar !== firstItem) {
                    that._completeResizing(true);
                }

                firstItem.focus();
                return;
            }

            if (!event.ctrlKey && that._splitBarDummy && that._splitBarDummy.parentElement) {
                splitterBar = that._splitBarDummy;
            } else if (!(splitterBar instanceof JQX.SplitterBar)) {
                return;
            }

            if ((that.enableShadowDOM ? splitterBar.getRootNode().host : splitterBar.closest('jqx-splitter')) !== that) {
                return;
            }

            switch (event.key) {
                case 'ArrowLeft':
                case 'ArrowRight':
                case 'ArrowUp':
                case 'ArrowDown':
                    {
                        if ((event.key === 'ArrowUp' || event.key === 'ArrowDown') && that.orientation === 'vertical') {
                            return;
                        }

                        if ((event.key === 'ArrowLeft' || event.key === 'ArrowRight') && that.orientation === 'horizontal') {
                            return;
                        }

                        //Prevents container scrolling
                        event.preventDefault();

                        var direction = event.key === 'ArrowLeft' || event.key === 'ArrowUp' ? -1 : 1;

                        if (event.ctrlKey) {

                            //Cancel resizing if it's in motion
                            that._completeResizing(true);

                            var neighbourItem = void 0,
                                targetItem = void 0;

                            if (direction < 0) {
                                targetItem = splitterBar.previousElementSibling;
                                neighbourItem = splitterBar.nextElementSibling;
                            } else {
                                neighbourItem = splitterBar.previousElementSibling;
                                targetItem = splitterBar.nextElementSibling;
                            }

                            neighbourItem.collapsed ? neighbourItem.expand() : targetItem.collapse(direction > 0);
                            return;
                        }

                        if (splitterBar.locked) {
                            return;
                        }

                        if (that.resizeMode === 'none') {
                            return;
                        }

                        that._keyboardResizing = true;

                        var currentPosition = void 0;

                        if (!that._dragDetails) {
                            that._setDragDetails(splitterBar);
                            currentPosition = splitterBar[that._measurements.offset] + direction * that.resizeStep;
                        } else {
                            currentPosition = that._dragDetails.position + direction * that.resizeStep;
                        }

                        //Requires event parameter so we imitate it with an object
                        that._resize({ pageX: currentPosition, pageY: currentPosition });
                        break;
                    }
                case 'Enter':
                    that._completeResizing();
                    break;
                case 'Escape':
                case 'Tab':
                    that._completeResizing(true);
                    break;
            }
        }

        /**
         * Mouse Enter/Leave event handler
         * @param {any} event
         */

    }, {
        key: '_mouseEventsHandler',
        value: function _mouseEventsHandler(event) {
            event.type === 'mouseenter' && !JQX.Utilities.Core.isMobile ? this.setAttribute('hover', '') : this.removeAttribute('hover');
        }

        /**
        * Used to recalculate the Proportions during resizing when resizeMode is 'proportional'
        * @param {any} amount - amount of size that has changed since the start of the operation till now
        * @param {any} totalItemsCount - total number of all items that are being resized
        * @param {any} resizableItemsCount - the number of items that can be resized.
        */

    }, {
        key: '_recalcItemSize',
        value: function _recalcItemSize(amount, totalItemsCount, resizableItemsCount) {
            var that = this;
            var usedSize = void 0,
                minSize = void 0;

            if (!resizableItemsCount) {
                resizableItemsCount = totalItemsCount;
            }

            if (amount > 0) {
                for (var p = 0; p < totalItemsCount; p++) {
                    minSize = that._dragDetails.itemProportions[p].item._sizeLimits[that._measurements.minDimension];

                    if (that._dragDetails.itemProportions[p].currentSize > minSize) {
                        if (that._dragDetails.itemProportions[p].currentSize - minSize < amount / resizableItemsCount) {
                            usedSize = that._dragDetails.itemProportions[p].currentSize - minSize;
                        } else {
                            usedSize = amount / resizableItemsCount;
                        }

                        amount -= usedSize;
                        that._dragDetails.itemProportions[p].currentSize = Math.max(minSize, that._dragDetails.itemProportions[p].currentSize - usedSize);
                        delete that._dragDetails.itemProportions[p]._originalSize;
                    }

                    resizableItemsCount = Math.max(1, resizableItemsCount - 1);
                }
            } else {
                var maxSize = that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize - (totalItemsCount > 1 ? that._dragDetails.secondItemTotalMinSize - that._dragDetails.itemProportions[0].item._sizeLimits[that._measurements.minDimension] : 0);
                var itemMaxSize = void 0;

                for (var _p = 0; _p < totalItemsCount; _p++) {
                    if (that._dragDetails.itemProportions[_p].item._sizeLimits[that._measurements.maxDimension]) {
                        itemMaxSize = Math.min(that._dragDetails.itemProportions[_p].item._sizeLimits[that._measurements.maxDimension], maxSize);
                    } else {
                        itemMaxSize = maxSize;
                    }

                    if (that._dragDetails.itemProportions[_p].currentSize < itemMaxSize) {
                        if (that._dragDetails.itemProportions[_p].currentSize - amount / resizableItemsCount > itemMaxSize) {
                            usedSize = -1 * (itemMaxSize - that._dragDetails.itemProportions[_p].currentSize);
                        } else {
                            usedSize = amount / resizableItemsCount;
                        }

                        amount -= usedSize;
                        that._dragDetails.itemProportions[_p].currentSize = Math.min(itemMaxSize, that._dragDetails.itemProportions[_p].currentSize - usedSize);
                        delete that._dragDetails.itemProportions[_p]._originalSize;
                    }

                    resizableItemsCount = Math.max(1, resizableItemsCount - 1);
                }
            }

            //size less than 0.1 is too small to care. JS can't compute properly with too small values
            if (Math.abs(amount) > 0.1) {
                that._recalcItemSize(amount, totalItemsCount, resizableItemsCount);
            }
        }

        /**
        * Resizes the splitter items
        */

    }, {
        key: '_resize',
        value: function _resize(event) {
            var that = this;

            if (!that._dragDetails) {
                return;
            }

            var distance = event[that._measurements.pagePosition] - that._dragDetails.position,
                isLimitReached = void 0;

            var direction = Math.sign(distance),
                firstItemMinSize = that._dragDetails.firstItem._sizeLimits[that._measurements.minDimension],
                firstItemMaxSize = that._dragDetails.firstItem._sizeLimits[that._measurements.maxDimension];

            var sizeAvailable = void 0,
                isPossibleToResize = void 0;

            if (!that.hasAttribute('dragged')) {
                that.$.fireEvent('resizeStart', {
                    firstItem: {
                        index: that._items.indexOf(that._dragDetails.firstItem),
                        size: that._dragDetails.firstItem[that._measurements.size]
                    },
                    secondItem: Array.isArray(that._dragDetails.secondItem) ? {
                        index: that._dragDetails.secondItem.map(function (item) {
                            return that._items.indexOf(item);
                        }),
                        size: that._dragDetails.secondItem.map(function (item) {
                            return item[that._measurements.size];
                        })
                    } : {
                        index: that._items.indexOf(that._dragDetails.secondItem),
                        size: that._dragDetails.secondItem[that._measurements.size]
                    }
                });
            }

            that.setAttribute('dragged', '');

            if (Math.abs(distance) < that.resizeStep) {
                return;
            }

            var coercedDistance = Math.max(that.resizeStep, Math.floor(Math.abs(distance) / that.resizeStep) * that.resizeStep);
            var offset = distance - direction * coercedDistance;

            switch (that.resizeMode) {
                case 'adjacent':
                case 'end':
                    if (direction > 0) {
                        sizeAvailable = that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize;
                        isPossibleToResize = function isPossibleToResize() {
                            return sizeAvailable - that._dragDetails.secondItemTotalMinSize >= coercedDistance || firstItemMaxSize && that._dragDetails.firstItem.currentSize + that.resizeStep <= firstItemMaxSize;
                        };
                        isLimitReached = function isLimitReached() {
                            return firstItemMaxSize && that._dragDetails.firstItem.currentSize === firstItemMaxSize || sizeAvailable - that.resizeStep <= that._dragDetails.secondItemTotalMinSize;
                        };
                    } else {
                        sizeAvailable = that._dragDetails.firstItem.currentSize;
                        isPossibleToResize = function isPossibleToResize() {
                            return sizeAvailable - firstItemMinSize >= coercedDistance || that._dragDetails.secondItemTotalMaxSize && that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize + that.resizeStep <= that._dragDetails.secondItemTotalMaxSize;
                        };
                        isLimitReached = function isLimitReached() {
                            return that._dragDetails.secondItemTotalMaxSize && that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize === that._dragDetails.secondItemTotalMaxSize || sizeAvailable - that.resizeStep <= firstItemMinSize;
                        };
                    }

                    distance = 0;

                    while (coercedDistance > 0) {
                        if (isPossibleToResize()) {
                            distance += direction * that.resizeStep;
                        }

                        coercedDistance -= that.resizeStep;
                    }

                    that._resizeItem(event, distance, offset);
                    break;
                case 'proportional':
                    {
                        var initialRemainingSpace = that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize;

                        if (direction > 0) {
                            sizeAvailable = Math.abs(initialRemainingSpace - that._dragDetails.secondItemTotalMinSize);
                            isPossibleToResize = function isPossibleToResize() {
                                return sizeAvailable >= coercedDistance || firstItemMaxSize && that._dragDetails.firstItem.currentSize + that.resizeStep <= firstItemMaxSize;
                            };
                            isLimitReached = function isLimitReached() {
                                return firstItemMaxSize && that._dragDetails.firstItem.currentSize === firstItemMaxSize || that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize - that.resizeStep < that._dragDetails.secondItemTotalMinSize;
                            };
                        } else {
                            sizeAvailable = that._dragDetails.firstItem.currentSize;
                            //TODO: ResizeStep is not taken into account properly
                            isPossibleToResize = function isPossibleToResize() {
                                return sizeAvailable - firstItemMinSize >= coercedDistance && (that._dragDetails.secondItemTotalMaxSize ? that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize + that.resizeStep <= that._dragDetails.secondItemTotalMaxSize : true);
                            };
                            isLimitReached = function isLimitReached() {
                                return that._dragDetails.secondItemTotalMaxSize && that._dragDetails.splitAreaSize + that.resizeStep - that._dragDetails.firstItem.currentSize >= that._dragDetails.secondItemTotalMaxSize || that._dragDetails.firstItem.currentSize - that.resizeStep < firstItemMinSize;
                            };
                        }

                        var newSize = void 0,
                            isResized = void 0;

                        while (coercedDistance > 0) {
                            if (isPossibleToResize()) {
                                isResized = true;
                                newSize = Math.min(firstItemMaxSize ? Math.min(firstItemMaxSize, that._dragDetails.splitAreaSize - that._dragDetails.secondItemTotalMinSize) : that._dragDetails.splitAreaSize - that._dragDetails.secondItemTotalMinSize, Math.max(firstItemMinSize, that._dragDetails.firstItem.currentSize + direction * that.resizeStep));

                                that._dragDetails.firstItem.currentSize = that._dragDetails.firstItem._sizeBeforeCollapse = Math.floor(newSize);
                            }

                            coercedDistance -= that.resizeStep;
                        }

                        if (!isResized) {
                            break;
                        }

                        var remaningSpaceAfterResize = that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize,
                            itemCount = that._dragDetails.itemProportions.length;

                        //Recalculate the proportions
                        that._recalcItemSize(initialRemainingSpace - remaningSpaceAfterResize, itemCount);

                        if (that.liveResize) {
                            that._dragDetails.firstItem.style[that._measurements.dimension] = that._dragDetails.firstItem.currentSize + that._dragDetails.firstItem._paddings + 'px';

                            if (itemCount > 1) {
                                for (var p = 0; p < itemCount; p++) {
                                    that._dragDetails.itemProportions[p].item.style[that._measurements.dimension] = that._dragDetails.itemProportions[p].item._sizeBeforeCollapse = that._dragDetails.itemProportions[p].currentSize + that._dragDetails.itemProportions[p].item._paddings + 'px';
                                }
                            } else {
                                that._dragDetails.secondItem[0].style[that._measurements.dimension] = (that._dragDetails.secondItem[0]._sizeBeforeCollapse = Math.floor(remaningSpaceAfterResize + that._dragDetails.itemProportions[0].item._paddings)) + 'px';
                            }
                        } else {
                            that._splitBarDummy.style[that._measurements.position] = that._dragDetails.firstItem[that._measurements.offset] + that._dragDetails.firstItem.currentSize + that._dragDetails.lockedItemsSize + that._dragDetails.firstItem._paddings + 'px';
                        }

                        var edge = that._dragDetails.firstItem.getBoundingClientRect()[that.orientation === 'vertical' ? 'left' : 'top'] + that._dragDetails.splitBarOffset;

                        var maxPosition = firstItemMaxSize && that._dragDetails.splitAreaSize - firstItemMaxSize > that._dragDetails.secondItemTotalMinSize ? firstItemMaxSize : that._dragDetails.splitAreaSize - that._dragDetails.secondItemTotalMinSize;

                        that._dragDetails.position = Math.max(edge + (that._dragDetails.secondItemTotalMaxSize ? Math.max(that._dragDetails.splitAreaSize - that._dragDetails.secondItemTotalMaxSize, firstItemMinSize) : firstItemMinSize) + that._dragDetails.lockedItemsSize + that._dragDetails.firstItem._paddings, Math.min(edge + maxPosition + that._dragDetails.lockedItemsSize + that._dragDetails.firstItem._paddings, event[that._measurements.pagePosition] - offset));
                        break;
                    }
            }

            if (!that.liveResize) {
                isLimitReached() ? that._splitBarDummy.classList.add('limit-reached') : that._splitBarDummy.classList.remove('limit-reached');
            }

            //Should be called only when Splitter's width is auto
            that._validateBarsSize();
        }

        /**
         * Style Changed Event Handler - Refits the items if necessary
         */

    }, {
        key: '_resizeEventHandler',
        value: function _resizeEventHandler() {
            var that = this;

            that._resizeEventFired = true;
            that._validateItemSize();
            that._resizeEventFired = false;
        }

        /**
         * Resize the host item when inserting a new one inside it
         * @param {any} hostItem
         */

    }, {
        key: '_resizeHostItemOnInsert',
        value: function _resizeHostItemOnInsert(hostItem, newItem, splitterBar) {
            var that = this;

            if (that.autoFitMode === 'proportional') {
                that._autoFitItemsProportionally(newItem, splitterBar);
                return;
            }

            if (!hostItem || hostItem.locked) {
                return;
            }

            if (newItem.size) {
                var itemWithoutSize = function () {
                    var item = newItem.previousElementSibling;

                    while (item) {
                        if (item instanceof JQX.SplitterItem && !item.size) {
                            return item;
                        }

                        item = item.previousElementSibling;
                    }
                }();

                hostItem = itemWithoutSize || hostItem;
            }

            var hostItemNewSize = hostItem[that._measurements.size] - newItem[that._measurements.size] - splitterBar[that._measurements.size],
                hostItemSize = Math.max(hostItem._sizeLimits[that._measurements.minDimension], hostItemNewSize);

            hostItem.style[that._measurements.maxDimension] = hostItem.max ? isNaN(parseFloat(hostItem.max)) ? '' : parseFloat(hostItem.max) + babelHelpers.typeof(hostItem.max) === 'string' && hostItem.max.indexOf('%') > -1 ? '%' : 'px' : '';

            //StyleChanged not fired yet
            var hostItemMax = hostItem.style[that._measurements.maxDimension] ? parseFloat(hostItem.style[that._measurements.maxDimension]) : 0;

            if (newItem.size) {
                hostItem.style[that._measurements.dimension] = (hostItem._sizeBeforeCollapse = hostItemMax ? Math.min(hostItemMax, hostItemSize) : hostItemSize) + 'px';
            } else {
                hostItem.style[that._measurements.dimension] = hostItem.size ? hostItem.size === 'auto' ? hostItem.size : isNaN(parseFloat(hostItem.size)) ? 0 : parseFloat(hostItem.size) + (typeof hostItem.size === 'string' && hostItem.size.indexOf('%') > -1 ? '%' : 'px') : '';
                hostItem._sizeBeforeCollapse = hostItem[that._measurements.size];
            }
        }

        /**
         * Resize a single item
         * @param {any} event
         * @param {any} distance
         * @param {any} offset
         */

    }, {
        key: '_resizeItem',
        value: function _resizeItem(event, distance, offset) {
            var that = this;

            //Validate min accoridng to first Item
            var newSize = Math.max(that._dragDetails.firstItem._sizeLimits[that._measurements.minDimension], Math.min(that._dragDetails.splitAreaSize - that._dragDetails.secondItem._sizeLimits[that._measurements.minDimension], that._dragDetails.firstItem._sizeLimits[that._measurements.maxDimension] ? Math.min(that._dragDetails.firstItem._sizeLimits[that._measurements.maxDimension], that._dragDetails.firstItem.currentSize + distance) : that._dragDetails.firstItem.currentSize + distance));
            var minSize = that._dragDetails.firstItem._sizeLimits[that._measurements.minDimension];

            if (that._dragDetails.secondItem._sizeLimits[that._measurements.maxDimension] && that._dragDetails.splitAreaSize - newSize > that._dragDetails.secondItem._sizeLimits[that._measurements.maxDimension]) {
                minSize = newSize = that._dragDetails.splitAreaSize - that._dragDetails.secondItem._sizeLimits[that._measurements.maxDimension];
            }

            that._dragDetails.firstItem.currentSize = newSize;

            if (that.liveResize) {
                that._dragDetails.firstItem.style[that._measurements.dimension] = (that._dragDetails.firstItem._sizeBeforeCollapse = newSize + that._dragDetails.firstItem._paddings) + 'px';
                that._dragDetails.secondItem.style[that._measurements.dimension] = (that._dragDetails.secondItem._sizeBeforeCollapse = that._dragDetails.splitAreaSize - newSize + that._dragDetails.firstItem._paddings) + 'px';

                //Reset the original size
                delete that._dragDetails.firstItem._originalSize;
                delete that._dragDetails._originalSize;
            } else {
                //TODO: Doesn't include collpased items offset
                that._splitBarDummy.style[that._measurements.position] = that._dragDetails.firstItem[that._measurements.offset] + newSize + that._dragDetails.lockedItemsSize + that._dragDetails.firstItem._paddings + 'px';
            }

            var edge = that._dragDetails.firstItem.getBoundingClientRect()[that.orientation === 'vertical' ? 'left' : 'top'] + that._dragDetails.splitBarOffset;

            that._dragDetails.position = Math.max(edge + minSize + that._dragDetails.firstItem._paddings, Math.min(edge + that._dragDetails.splitAreaSize - that._dragDetails.secondItem._sizeLimits[that._measurements.minDimension] + that._dragDetails.lockedItemsSize + that._dragDetails.firstItem._paddings, event[that._measurements.pagePosition] - offset));

            if (that._dragDetails.firstItem._sizeLimits[that._measurements.maxDimension]) {
                that._dragDetails.position = Math.min(edge + that._dragDetails.firstItem._sizeLimits[that._measurements.maxDimension], that._dragDetails.position);
            }
        }

        /**
        * Sets tab index
        */

    }, {
        key: '_setFocusable',
        value: function _setFocusable() {
            var that = this;

            if (that.disabled || that.unfocusable) {
                that.removeAttribute('tabindex');
                return;
            }

            that.tabIndex = that.tabIndex > 0 ? that.tabIndex : 0;
        }

        /**
         * Set drag details for a splitter item
         * @param {any} event
         */

    }, {
        key: '_setDragDetails',
        value: function _setDragDetails(target, event) {
            var that = this;

            that._dragDetails = {};

            if (!that._measurements) {
                that._setMeasurements();
            }

            that._dragDetails.scrollAmount = target.parentElement[that._measurements.scroll];
            that._dragDetails.lockedItemsSize = 0;

            that.setAttribute('show-locked-items', '');

            if (!(that._dragDetails.firstItem = that._getTargetItem(target, 'previousElementSibling'))) {
                delete that._dragDetails;
                that.setAttribute('dragging-not-allowed', '');
                return;
            }

            that._dragDetails.firstItem.set('size', '');

            that._dragDetails.firstItem.currentSize = that._dragDetails.firstItem[that._measurements.size];
            that._dragDetails.firstItem.originalSize = that._dragDetails.firstItem.currentSize;

            var computedStyle = getComputedStyle(that._dragDetails.firstItem);

            that._dragDetails.firstItem._paddings = (parseFloat(computedStyle.getPropertyValue('padding-' + that._measurements.position)) || 0) + (parseFloat(computedStyle.getPropertyValue('padding-' + that._measurements.position2)) || 0);

            if (that._dragDetails.firstItem.currentSize < that._dragDetails.firstItem._sizeLimits[that._measurements.minDimension]) {
                delete that._dragDetails;
                return;
            }

            that._dragDetails.firstItem.currentSize -= that._dragDetails.firstItem._paddings;

            that._dragDetails.splitAreaSize = 0;
            that._dragDetails.secondItemTotalMaxSize = 0;
            that._dragDetails.secondItemTotalMinSize = 0;

            if (that.resizeMode === 'proportional') {
                if (that._setProportionalDetails()) {
                    return;
                }
            } else {
                if (that._setAdjacentOrEndDetails(target)) {
                    return;
                }
            }

            var splitterBarPagePosition = void 0;

            if (!event || (typeof event === 'undefined' ? 'undefined' : babelHelpers.typeof(event)) !== 'object') {
                event = { pageX: target[that._measurements.offset], pageY: target[that._measurements.offset] };
                splitterBarPagePosition = target[that._measurements.offset];
            } else {
                splitterBarPagePosition = target.getBoundingClientRect()[that._measurements.position];
            }

            that._dragDetails.position = event[that._measurements.pagePosition];
            that._dragDetails.splitBarOffset = that._dragDetails.position - splitterBarPagePosition;

            if (that.liveResize) {
                return;
            }

            if (!that._splitBarDummy) {
                that._splitBarDummy = document.createElement('div');
                that._splitBarDummy.classList.add('jqx-splitter-bar-feedback');
            }

            that._splitBarDummy.style.width = target.offsetWidth + 'px';
            that._splitBarDummy.style.height = target.offsetHeight + 'px';
            that._splitBarDummy.style.top = target.offsetTop + 'px';
            that._splitBarDummy.style.left = target.offsetLeft + 'px';
            target.parentElement.appendChild(that._splitBarDummy);
        }

        /**
         * Sets the drag details when resizeMode === 'adjacent' or 'end'
         */

    }, {
        key: '_setAdjacentOrEndDetails',
        value: function _setAdjacentOrEndDetails(target) {
            var that = this;

            if (!(that._dragDetails.secondItem = that.resizeMode === 'adjacent' ? that._getTargetItem(target, 'nextElementSibling') : that._getTargetItem(target, 'previousElementSibling', true))) {
                delete that._dragDetails;
                that.setAttribute('dragging-not-allowed', '');
                return true;
            }

            that._dragDetails.secondItem.set('size', '');

            that._dragDetails.secondItem.currentSize = that._dragDetails.secondItem[that._measurements.size];
            that._dragDetails.secondItem.originalSize = that._dragDetails.secondItem.currentSize;

            var computedStyle = getComputedStyle(that._dragDetails.secondItem);

            that._dragDetails.secondItem._paddings = (parseFloat(computedStyle.getPropertyValue('padding-' + that._measurements.position)) || 0) + (parseFloat(computedStyle.getPropertyValue('padding-' + that._measurements.position2)) || 0);

            that._dragDetails.secondItem.currentSize -= that._dragDetails.secondItem._paddings;

            that._dragDetails.splitAreaSize = that._dragDetails.firstItem.currentSize + that._dragDetails.secondItem.currentSize;
            that._dragDetails.secondItemTotalMaxSize = that._dragDetails.secondItem._sizeLimits[that._measurements.maxDimension];
            that._dragDetails.secondItemTotalMinSize = that._dragDetails.secondItem._sizeLimits[that._measurements.minDimension];
        }

        /**
         * Sets the measurement object that will be used during resizing
         */

    }, {
        key: '_setMeasurements',
        value: function _setMeasurements() {
            var that = this;

            that._measurements = {};

            if (that.orientation === 'horizontal') {
                that._measurements.dimension = 'height';
                that._measurements.minDimension = 'minHeight';
                that._measurements.maxDimension = 'maxHeight';
                that._measurements.restricredDimension = 'Width';
                that._measurements.size = 'offsetHeight';
                that._measurements.offset = 'offsetTop';
                that._measurements.position = 'top';
                that._measurements.position2 = 'bottom';
                that._measurements.pagePosition = 'pageY';
                that._measurements.scroll = 'scrollTop';
            } else {
                that._measurements.dimension = 'width';
                that._measurements.minDimension = 'minWidth';
                that._measurements.maxDimension = 'maxWidth';
                that._measurements.restricredDimension = 'Height';
                that._measurements.size = 'offsetWidth';
                that._measurements.offset = 'offsetLeft';
                that._measurements.position = 'left';
                that._measurements.position2 = 'right';
                that._measurements.pagePosition = 'pageX';
                that._measurements.scroll = 'scrollLeft';
            }

            that._measurements.overflow = getComputedStyle(that).getPropertyValue('overflow');
        }

        /**
         * Sets the dragging details when resizeMode = 'proportional'
         */

    }, {
        key: '_setProportionalDetails',
        value: function _setProportionalDetails() {
            var that = this;

            that._dragDetails.secondItem = that._items.slice(that._items.indexOf(that._dragDetails.firstItem) + 1).filter(function (item) {
                return !item.collapsed && !item.locked;
            });

            if (that._dragDetails.secondItem.length === 0) {
                delete that._dragDetails;
                return true;
            }

            that._dragDetails.splitAreaSize += that._dragDetails.firstItem.currentSize;
            that._dragDetails.itemProportions = [];

            var noMaxLimit = void 0;

            for (var i = 0; i < that._dragDetails.secondItem.length; i++) {
                that._dragDetails.secondItem[i].set('size', '');
                that._dragDetails.secondItem[i].currentSize = that._dragDetails.secondItem[i][that._measurements.size];
                that._dragDetails.secondItem[i].originalSize = that._dragDetails.secondItem[i].currentSize;

                var computedStyle = getComputedStyle(that._dragDetails.secondItem[i]);

                that._dragDetails.secondItem[i]._paddings = (parseFloat(computedStyle.getPropertyValue('padding-' + that._measurements.position)) || 0) + (parseFloat(computedStyle.getPropertyValue('padding-' + that._measurements.position2)) || 0);

                that._dragDetails.secondItem[i].currentSize -= that._dragDetails.secondItem[i]._paddings;

                that._dragDetails.splitAreaSize += that._dragDetails.secondItem[i].currentSize;
                that._dragDetails.itemProportions.push({
                    item: that._dragDetails.secondItem[i],
                    currentSize: that._dragDetails.secondItem[i].currentSize
                });

                if (!that._dragDetails.secondItem[i]._sizeLimits[that._measurements.maxDimension]) {
                    noMaxLimit = true;
                }

                that._dragDetails.secondItemTotalMinSize += that._dragDetails.secondItem[i]._sizeLimits[that._measurements.minDimension];
                that._dragDetails.secondItemTotalMaxSize += that._dragDetails.secondItem[i]._sizeLimits[that._measurements.maxDimension];
            }

            if (noMaxLimit) {
                that._dragDetails.secondItemTotalMaxSize = 0;
            }
        }

        /**
         * Validates the size of the Splitter Bars inside the Splitter
         */

    }, {
        key: '_validateBarsSize',
        value: function _validateBarsSize() {
            var that = this;

            //Check if size of the SplitterBar is explicitly set
            if ((getComputedStyle(that).getPropertyValue('--jqx-splitter-bar-fit-size') + '').trim() !== '100%') {
                return;
            }

            var biggestItem = that._items[0];
            var size = 'offset' + that._measurements.restricredDimension,
                bars = that.bars;

            if (bars.length === 0) {
                return;
            }

            for (var i = 0; i < that._items.length; i++) {
                if (that._items[i][size] > biggestItem[size]) {
                    biggestItem = that._items[i];
                }
            }

            if (!biggestItem) {
                return;
            }

            if (biggestItem[size] !== bars[0][size]) {
                bars.map(function (bar) {
                    return bar.style[that._measurements.restricredDimension.toLowerCase()] = biggestItem[size] + 'px';
                });
            }
        }

        /**
        * Validates the sizes of the Splitter items and resizes them to fit if the overflow is set to 'none' or 'visible'
        */

    }, {
        key: '_validateItemSize',
        value: function _validateItemSize(noStyleChangedIgnoring) {
            var that = this;

            if (that.autoFitMode === 'overflow') {
                return;
            }

            if (that.keepProportionsOnResize && that._resizeEventFired) {
                that._keepItemProportionsOnResize();
            } else {
                var totalItemSize = 0,
                    totalBarsSize = 0;

                that._items.map(function (item) {
                    return totalItemSize += !item.collapsed ? item.style[that._measurements.dimension] && item.style[that._measurements.dimension].indexOf('%') < -1 && item._sizeBeforeCollapse ? item._sizeBeforeCollapse : item.getBoundingClientRect()[that._measurements.dimension] : 0;
                });

                that.bars.map(function (bar) {
                    return totalBarsSize += bar[that._measurements.size];
                });

                var sizeDifference = totalItemSize + totalBarsSize - that.$.container.getBoundingClientRect()[that._measurements.dimension];

                if (sizeDifference > 0) {
                    that._validateItemsSizeOverflowing(sizeDifference, noStyleChangedIgnoring);
                } else {
                    that._validateItemsSizeUnderflowing(sizeDifference, noStyleChangedIgnoring);
                }
            }

            that._autoFitItems();

            //Should be called only when Splitter's width is 'auto'
            that._validateBarsSize();

            //Keeping the last valid splitter size
            that._splitterSize = that[that._measurements.size];

            //NOTE: Elements in ShadowDOM get initialized in reverse order ( from outher to inner elements). That's why this is necessary.
            if (that.enableShadowDOM) {
                var host = that.getRootNode().host;

                if (host && host.enableShadowDOM && host.isCompleted && host._validateItemSize) {
                    host._validateItemSize();
                }
            }
        }

        /**
         * Validates the min/max properties of the neighbour items
         * @param {any} item
         */

    }, {
        key: '_validateNeighbourSizeLimits',
        value: function _validateNeighbourSizeLimits(item) {
            var that = this;

            function checkLimits(neighbourItem) {
                if (!neighbourItem) {
                    return;
                }

                if (neighbourItem.min) {
                    neighbourItem._setSize('min', neighbourItem.min, true);
                }

                if (neighbourItem.max) {
                    neighbourItem._setSize('max', neighbourItem.max, true);
                }
            }

            if (!that._items || !that._items.length) {
                return;
            }

            that._noNeighbourValidation = true;

            var itemIndex = that._items.indexOf(item);

            //Previous item
            checkLimits(that._items[itemIndex - 1]);

            //Next item
            checkLimits(that._items[itemIndex + 1]);

            delete that._noNeighbourValidation;
        }

        /**
         * Keeps the same proportion of the items during resizing. Handles the keepProportionsOnResize proeprty
         */

    }, {
        key: '_keepItemProportionsOnResize',
        value: function _keepItemProportionsOnResize() {
            var that = this;
            var splitterBarsSize = 0,
                currentItemsSize = 0,
                resizableItems = [];

            that.bars.map(function (bar) {
                return splitterBarsSize += bar[that._measurements.size];
            });

            for (var i = 0; i < that._items.length; i++) {
                if (that._items[i].collapsed) {
                    continue;
                }

                resizableItems.push(that._items[i]);
                currentItemsSize += that._items[i]._sizeBeforeCollapse || that._items[i][that._measurements.size];
            }

            if (that._splitterSize) {
                currentItemsSize = that._splitterSize;
            }

            var splitterSizeAfterResize = that[that._measurements.size];

            for (var _i3 = 0; _i3 < resizableItems.length; _i3++) {
                if (resizableItems[_i3].style[that._measurements.dimension].indexOf('%') > -1) {
                    continue;
                }

                resizableItems[_i3].style[that._measurements.dimension] = (resizableItems[_i3]._sizeBeforeCollapse = (resizableItems[_i3]._sizeBeforeCollapse || resizableItems[_i3][that._measurements.size]) / currentItemsSize * splitterSizeAfterResize) + 'px';
            }
        }

        /**
         * Validates and recalculates the sizes of the items if they overflow the container
         */

    }, {
        key: '_validateItemsSizeOverflowing',
        value: function _validateItemsSizeOverflowing(sizeDifference, noStyleChangedIgnoring) {
            var that = this,
                itemsCount = that._items.length;
            var newSize = 0,
                initialSize = void 0,
                itemsLocked = [],
                currentSize = void 0,
                currentlySetSize = void 0,
                lastLockedItem = void 0,
                containerRect = that.$.container.getBoundingClientRect();

            for (var i = 0; i < that._items.length; i++) {
                //Note: If the size is set in percentages via CSS, it's not possible check if it's really percentages or not 
                //because even getComputedStyle returns the computed size not the original.
                //The only way to work is by setting the size property to a percentage value !
                currentlySetSize = that._items[i].style[that._measurements.dimension];
                currentSize = currentlySetSize.indexOf('%') > -1 ? currentlySetSize : that._items[i][that._measurements.size];

                if (!currentlySetSize && !that._items[i].size && that._items[i].size !== 0) {
                    delete that._items[i]._originalSize;
                }

                that._items[i]._originalSize = that._items[i]._originalSize ? that._items[i]._originalSize : currentSize;
                itemsLocked.push(that._items[i].locked);
            }

            if (itemsLocked.indexOf(false) < 0) {
                lastLockedItem = that._items[that._items.length - 1];
                lastLockedItem.locked = false;
            }

            //Check how many items should be resized to fit
            for (var _i4 = itemsCount - 1; _i4 >= 0; _i4--) {
                if (that._items[_i4].collapsed || that._items[_i4].locked) {
                    continue;
                }

                if ((that._items[_i4]._originalSize + '').indexOf('%') > -1) {
                    that._items[_i4].style[that._measurements.dimension] = that._items[_i4]._originalSize;
                    that._items[_i4]._sizeBeforeCollapse = containerRect[that._measurements.dimension] * parseFloat(that._items[_i4]._originalSize) / 100;
                    continue;
                }

                if (sizeDifference === 0) {
                    continue;
                }

                //Doesn't include the item paddings
                initialSize = that._items[_i4].getBoundingClientRect()[that._measurements.dimension];

                newSize = initialSize - sizeDifference;

                //May trigger the styleChanged event
                that._items[_i4].style[that._measurements.dimension] = (that._items[_i4]._sizeBeforeCollapse = Math.max(that._items[_i4]._sizeLimits ? that._items[_i4]._sizeLimits[that._measurements.minDimension] : 0, newSize)) + 'px';

                sizeDifference -= initialSize - that._items[_i4]._sizeBeforeCollapse;
            }

            //Reduce the min-sizes if necessary
            if (sizeDifference > 0) {
                for (var _i5 = itemsCount - 1; _i5 >= 0; _i5--) {
                    if (that._items[_i5].collapsed) {
                        continue;
                    }

                    initialSize = that._items[_i5].getBoundingClientRect()[that._measurements.dimension];
                    newSize = initialSize - sizeDifference;

                    var itemMin = that._items[_i5]._sizeLimits[that._measurements.minDimension] || that._items[_i5].min;

                    if (itemMin) {
                        if ((itemMin + '').indexOf('%') > -1) {
                            itemMin = parseFloat(itemMin) / 100 * that._items[_i5].parentElement[that._measurements.size];
                        } else {
                            itemMin = parseFloat(itemMin);
                        }

                        if (itemMin > newSize) {
                            //Ignore the StyleChanged event
                            that._items[_i5]._sizeLimits.ignoreUpdate = noStyleChangedIgnoring ? false : true;
                            that._items[_i5].style[that._measurements.minDimension] = Math.max(0, newSize) + 'px';
                        }
                    }

                    if (that._items[_i5]._originalSize && (that._items[_i5]._originalSize + '').indexOf('%') > -1) {
                        continue;
                    }

                    that._items[_i5]._sizeLimits.ignoreUpdate = noStyleChangedIgnoring ? false : true;
                    that._items[_i5].style[that._measurements.dimension] = (that._items[_i5]._sizeBeforeCollapse = Math.max(0, newSize)) + 'px';

                    sizeDifference -= initialSize - that._items[_i5]._sizeBeforeCollapse;
                }
            }

            if (lastLockedItem) {
                lastLockedItem.locked = true;
            }
        }

        /**
         * Validates the sizes of the items if the're underflowing the container ( should fit )
         */

    }, {
        key: '_validateItemsSizeUnderflowing',
        value: function _validateItemsSizeUnderflowing(sizeDifference, noStyleChangedIgnoring) {
            var that = this,
                itemsCount = that._items.length;
            var newSize = 0,
                initialSize = void 0,
                lastLockedItem = void 0;

            sizeDifference = Math.abs(sizeDifference);

            if (that._items.length > 0 && that._items.map(function (item) {
                return item.locked;
            }).indexOf(false) < 0) {
                lastLockedItem = that._items[that._items.length - 1];
                lastLockedItem.locked = false;
            }

            //Increase the min-size of the items if it has been changed
            for (var i = 0; i < itemsCount; i++) {
                if (that._items[i].collapsed || that._items[i][that._measurements.size] >= (that._items[i]._sizeLimits ? that._items[i]._sizeLimits[that._measurements.minDimension] : 0)) {
                    continue;
                }

                initialSize = that._items[i][that._measurements.size];
                newSize = that._items[i][that._measurements.size] + sizeDifference;

                if (that._items[i][that._measurements.size] < that._items[i]._sizeLimits[that._measurements.minDimension]) {
                    //Ignore the StyleChanged event
                    that._items[i]._sizeLimits.ignoreUpdate = noStyleChangedIgnoring ? false : true;
                    that._items[i].style[that._measurements.minDimension] = (that._items[i]._sizeBeforeCollapse = Math.max(0, Math.min(that._items[i]._sizeLimits[that._measurements.minDimension], newSize))) + 'px';
                }

                sizeDifference -= (that._items[i]._sizeBeforeCollapse || that._items[i][that._measurements.size]) - initialSize;

                if (sizeDifference <= 0) {
                    break;
                }
            }

            var containerSize = that.$.container.getBoundingClientRect()[that._measurements.dimension];

            if (sizeDifference > 0) {
                for (var _i6 = 0; _i6 < itemsCount; _i6++) {
                    if (that._items[_i6].collapsed || that._items[_i6].locked) {
                        continue;
                    }

                    if (that._items[_i6]._originalSize !== undefined) {
                        if ((that._items[_i6]._originalSize + '').indexOf('%') > -1) {
                            that._items[_i6].style[that._measurements.dimension] = that._items[_i6]._originalSize;
                            that._items[_i6]._sizeBeforeCollapse = parseFloat(that._items[_i6]._originalSize) * containerSize / 100;
                            //delete that._items[i]._originalSize;
                        } else if (that._items[_i6][that._measurements.size] >= that._items[_i6]._originalSize) {
                            sizeDifference += that._items[_i6][that._measurements.size] - that._items[_i6]._originalSize;
                            that._items[_i6].style[that._measurements.dimension] = (that._items[_i6]._sizeBeforeCollapse = that._items[_i6]._originalSize) + 'px';
                        } else {
                            newSize = Math.min(that._items[_i6]._originalSize, that._items[_i6][that._measurements.size] + sizeDifference);

                            var usedSize = newSize - that._items[_i6][that._measurements.size];

                            if (that._items[_i6][that._measurements.minDimension] < that._items[_i6]._sizeLimits[that._measurements.minDimension]) {
                                that._items[_i6].style[that._measurements.minDimension] = Math.min(that._items[_i6]._sizeLimits[that._measurements.minDimension], newSize) + 'px';
                            }

                            that._items[_i6].style[that._measurements.dimension] = (that._items[_i6]._sizeBeforeCollapse = Math.max(0, Math.min(newSize, that._items[_i6]._originalSize))) + 'px';
                            sizeDifference -= usedSize;
                        }

                        if (sizeDifference <= 0) {
                            break;
                        }
                    }
                }
            }

            if (lastLockedItem) {
                lastLockedItem.locked = true;
            }
        }
    }, {
        key: 'items',
        get: function get() {
            var that = this;

            if (!that.isReady) {
                return;
            }

            var children = that.$.container.children;

            var items = [];

            for (var i = 0; i < children.length; i++) {
                if (children[i] instanceof JQX.SplitterItem || children[i].tagName === 'JQX-SPLITTER-ITEM') {
                    items.push(children[i]);
                }
            }

            return items;
        }
    }, {
        key: 'hasStyleObserver',
        get: function get() {
            return 'resize';
        }
    }, {
        key: 'bars',
        get: function get() {
            var that = this;

            if (!that.isReady) {
                return;
            }

            var children = that.$.container.children;

            var items = [];

            for (var i = 0; i < children.length; i++) {
                if (children[i] instanceof JQX.SplitterBar || children[i].tagName === 'JQX-SPLITTER-BAR') {
                    items.push(children[i]);
                }
            }

            return items;
        }
    }], [{
        key: 'properties',


        /**
        * Splitter's properties
        */
        get: function get() {
            return {
                'autoFitMode': {
                    allowedValues: ['end', 'proportional', 'overflow'],
                    value: 'proportional',
                    type: 'string'
                },
                'dataSource': {
                    value: null,
                    type: 'object?',
                    reflectToAttribute: false
                },
                'orientation': {
                    allowedValues: ['horizontal', 'vertical'],
                    value: 'vertical',
                    type: 'string'
                },
                'keepProportionsOnResize': {
                    value: false,
                    type: 'boolean'
                },
                'resizeMode': {
                    allowedValues: ['none', 'adjacent', 'end', 'proportional'],
                    value: 'adjacent',
                    type: 'string'
                },
                'resizeStep': {
                    value: 5,
                    type: 'number'
                },
                'liveResize': {
                    value: false,
                    type: 'boolean'
                },
                'messages': {
                    extend: true,
                    value: {
                        'en': {
                            'invalidIndex': '{{elementType}}: "{{method}}" method accepts an index of type number.',
                            'indexOutOfBound': '{{elementType}}: Out of bound index/indexes in "{{method}}" method.',
                            'invalidNode': '{{elementType}}: "{{method}}" method accepts an object or an array of objects as it\'s second parameter.',
                            'invalidSettings': '{{elementType}}: "{{method}}" method accepts a string or an object as it\'s second parameter.',
                            'invalidType': '{{elementType}}: "{{propertyName}}" must be of type string or number.'
                        }
                    },
                    type: 'object'
                }
            };
        }

        /**
        * Splitter's event listeners
        */

    }, {
        key: 'listeners',
        get: function get() {
            return {
                'focus': '_focusHandler',
                'blur': '_focusHandler',
                'down': '_downHandler',
                'move': '_moveHandler',
                'document.dragstart': '_dragStartHandler',
                'document.move': '_documentMoveHandler',
                'document.up': '_documentUpHandler',
                'keydown': '_keyDownHandler',
                'resize': '_resizeEventHandler'
            };
        }

        /**
         * CSS files needed for the element (ShadowDOM)
         */

    }, {
        key: 'styleUrls',
        get: function get() {
            return ['jqx.button.css', 'jqx.splitter.css'];
        }
    }]);
    return Splitter;
}(JQX.ContentElement));