'use strict';

/**
* jqxCarousel custom element.
*/
JQX('jqx-carousel', function (_JQX$ContentElement) {
    babelHelpers.inherits(Carousel, _JQX$ContentElement);

    function Carousel() {
        babelHelpers.classCallCheck(this, Carousel);
        return babelHelpers.possibleConstructorReturn(this, (Carousel.__proto__ || Object.getPrototypeOf(Carousel)).apply(this, arguments));
    }

    babelHelpers.createClass(Carousel, [{
        key: 'template',


        /**
        * Element's HTML template.
        */
        value: function template() {
            return '<div id="container">\n                    <div id="itemsContainer" inner-h-t-m-l="[[innerHTML]]" class="jqx-items-container"><content></content></div>\n                    <jqx-repeat-button initial-delay="0" delay="[[delay]]" id="arrowLeft" animation="[[animation]]" unfocusable class="jqx-arrow jqx-arrow-left"></jqx-repeat-button>\n                    <jqx-repeat-button initial-delay="0" delay="[[delay]]" id="arrowRight" animation="[[animation]]" unfocusable class="jqx-arrow jqx-arrow-right"></jqx-repeat-button>\n                    <div id="indicatorsContainer" class="jqx-indicators-container"></div>\n                </div>';
        }

        /**
        * Updates the element when a property is changed.
        * @param {string} propertyName The name of the property.
        * @param {number/string} oldValue The previously entered value.
        * @param {number/string} newValue The new entered value.
        */

    }, {
        key: 'propertyChangedHandler',
        value: function propertyChangedHandler(propertyName, oldValue, newValue) {
            var that = this;

            babelHelpers.get(Carousel.prototype.__proto__ || Object.getPrototypeOf(Carousel.prototype), 'propertyChangedHandler', this).call(this, propertyName, oldValue, newValue);

            switch (propertyName) {
                case 'disabled':
                    that._setFocusable();
                    break;
                case 'dataSource':
                    that._generateIndicators();
                    that._generateItems();
                    that._handleIndicatorsState(0, 0);
                    that._handleItemsState(0, 0);
                    that._handle3dMode(0);

                    if (that.autoPlay !== false) {
                        var interval = parseInt(that.autoPlay);
                        if (interval) {
                            setTimeout(function () {
                                that.play();
                            }, interval);
                        } else {
                            that.play();
                        }
                    }

                    that._animationTrigger(that._currentIndex);
                    break;
                case 'itemTemplate':
                    that._generateItems();
                    that._handleItemsState(that._currentIndex, that._currentIndex + 1);
                    break;
                case 'indicatorTemplate':
                    that._generateIndicators();
                    that._handleIndicatorsState(that._currentIndex, that._currentIndex + 1);
                    break;
                case 'interval':
                    that.pause();
                    that.play();
                    break;
                case 'loop':
                    that._handleArrowsActiveState(that._currentIndex, that._currentIndex);
                    break;
                case 'hideArrows':
                    if (!newValue) {
                        that._handleArrowsActiveState(that._currentIndex, that._currentIndex);
                    }
                    break;
                case 'displayMode':
                    if (oldValue === 'multiple') {
                        that.$.itemsContainer.removeAttribute('style');
                    }
                    break;
            }
        }

        /**
        * Element's ready method.
        */

    }, {
        key: 'ready',
        value: function ready() {
            babelHelpers.get(Carousel.prototype.__proto__ || Object.getPrototypeOf(Carousel.prototype), 'ready', this).call(this);
            var that = this;

            that._setInitialState();
            that._generateIndicators();
            that._generateItems();
            that._handleIndicatorsState(0, 0);
            that._handleItemsState(0, 0);
            that._handle3dMode(0);

            if (that.autoPlay !== false) {
                var interval = parseInt(that.autoPlay);
                interval ? setTimeout(function () {
                    that.play();
                }, interval) : that.play();
            }

            that._setFocusable();
            that._animationTrigger(that._currentIndex);
        }

        /**
        * Moves to the slide with the next index. 
        * In loop mode if current is last index, carousel moves to the first slide.
        */

    }, {
        key: 'next',
        value: function next() {
            var that = this,
                availableItems = that.dataSource.length;

            if (that.disabled || availableItems === 0) {
                return;
            }

            var nextItem = that._currentIndex;

            if (that.loop) {
                nextItem = nextItem >= availableItems - 1 ? 0 : nextItem + 1;
            } else {
                nextItem = nextItem >= availableItems - 1 ? nextItem : nextItem + 1;
            }

            that._goToItem(nextItem);
        }

        /**
        * Pauses slideShow.
        */

    }, {
        key: 'pause',
        value: function pause() {
            var that = this;

            that._handleRotation();
            that._rotate = false;
        }

        /**
        * Slides to the element with the given index.
        */

    }, {
        key: 'slideTo',
        value: function slideTo(index) {
            var that = this;

            index = index ? parseInt(index) : 0;

            if (that.disabled || index < 0 || index > that._items.length) {
                return;
            }

            that._goToItem(index);
        }

        /**
        * Moves to the slide with the previous index. 
        * In loop mode if current is first index, carousel moves to the last slide.
        */

    }, {
        key: 'prev',
        value: function prev() {
            var that = this,
                availableItems = that.dataSource.length;

            if (that.disabled || availableItems === 0) {
                return;
            }

            var previousItem = that._currentIndex;

            if (that.loop) {
                previousItem = previousItem <= 0 ? availableItems - 1 : previousItem - 1;
            } else {
                previousItem = previousItem <= 0 ? 0 : previousItem - 1;
            }

            that._goToItem(previousItem);
        }

        /**
        * Starts slideShow.
        */

    }, {
        key: 'play',
        value: function play() {
            var that = this;

            if (that.disabled || !that.slideShow) {
                return;
            }

            if (that._rotationInterval) {
                clearInterval(that._rotationInterval);
            }

            that._handleRotation(true);
            that._rotate = true;
        }

        /**
        * Prevents animation on the selected animation slide immediately after items initialization
        */

    }, {
        key: '_animationTrigger',
        value: function _animationTrigger(skip) {
            var that = this;

            for (var i = 0; i < that._items.length; i++) {
                if (i === skip) {
                    continue;
                }
                that._items[i].classList.add('jqx-animate-trigger');
            }
        }

        /**
        * In "3d" mode sets positions of carousel items in relation to the active slide.
        */

    }, {
        key: '_handle3dMode',
        value: function _handle3dMode(newIndex) {
            var that = this,
                itemsCount = that.dataSource.length;

            if (that.disabled || !itemsCount || that.displayMode !== '3d') {
                return;
            }

            newIndex = newIndex || 0;

            for (var i = 0; i < itemsCount; i++) {
                var currentPosition = i - newIndex;

                currentPosition ? that._items[i].setAttribute('position', currentPosition) : that._items[i].removeAttribute('position');
            }
        }

        /**
        * Enables/disables arrows
        */

    }, {
        key: '_handleArrowsActiveState',
        value: function _handleArrowsActiveState(newIndex, oldIndex) {
            var that = this,
                itemsCount = that.dataSource.length;

            if (!that.loop) {
                oldIndex === 0 && (that.$.arrowLeft.disabled = false);
                oldIndex === itemsCount - 1 && (that.$.arrowRight.disabled = false);
                newIndex === 0 && (that.$.arrowLeft.disabled = true);
                newIndex === itemsCount - 1 && (that.$.arrowRight.disabled = true);
            } else {
                that.$.arrowLeft.disabled = that.$.arrowRight.disabled = false;
            }
        }

        /**
        * Handles click on carousel's arrows.
        */

    }, {
        key: '_handleArrowClick',
        value: function _handleArrowClick(event) {
            var that = this,
                previousIndex = that._currentIndex;

            if (that.disabled) {
                return;
            }

            that.$.arrowLeft.contains(event.target) ? that.prev() : that.next();
            that._changeEvent(previousIndex, that._currentIndex);
        }

        /**
        * Handles slides, set via inner HTML as LI elements.
        */

    }, {
        key: '_handleDefaultInnerHTML',
        value: function _handleDefaultInnerHTML() {
            var that = this;

            if (that.dataSource && that.dataSource.length > 0) {
                return;
            }

            if (that.$.itemsContainer.innerHTML.indexOf('<ul') >= 0) {
                var firstUl = that.$.itemsContainer.getElementsByTagName('ul')[0],
                    items = firstUl.getElementsByTagName('li');

                for (var i = 0; i < items.length; i++) {
                    var slide = { HTMLcontent: items[i].innerHTML };

                    that.dataSource.push(slide);
                }
            }
        }

        /**
        * Handles indicator's state.
        */

    }, {
        key: '_handleIndicatorsState',
        value: function _handleIndicatorsState(from, to) {
            var that = this;

            if (that.disabled || that._indicators.length === 0 || !from && from !== 0 || !to && to !== 0) {
                return;
            }

            if (from !== to) {
                that._indicators[from].classList.remove('jqx-active');
            }

            that._indicators[to].classList.add('jqx-active');
        }

        /**
        * On '3d' mode makes clicked item active
        */

    }, {
        key: '_handleItemClick',
        value: function _handleItemClick(event) {
            var that = this,
                clickedItem = event.target.closest('.jqx-carousel-item');

            if (that.disabled || !clickedItem || that.displayMode !== '3d' || that.disableItemClick) {
                return;
            }

            var itemId = parseInt(clickedItem.getAttribute('item-id')),
                itemPosition = parseInt(clickedItem.getAttribute('position'));

            if (Math.abs(itemPosition) > 3) {
                return;
            }

            that._goToItem(itemId);
        }

        /**
        * Handles items's state.
        */

    }, {
        key: '_handleItemsState',
        value: function _handleItemsState(from, to) {
            var that = this;

            if (that.disabled || that._items.length === 0 || !from && from !== 0 || !to && to !== 0) {
                return;
            }

            if (from !== to) {
                that._items[from].classList.remove('jqx-active');
                that._items[from].classList.add('jqx-out');
            }

            that._items[to].classList.add('jqx-active');
        }

        /**
        * Handles click on indicators.
        */

    }, {
        key: '_handleIndicatorsContainerClick',
        value: function _handleIndicatorsContainerClick(event) {
            var that = this,
                clickedItem = event.target.closest('.jqx-indicator'),
                previousIndex = that._currentIndex;

            if (that.disabled || !clickedItem) {
                return;
            }

            var itemId = parseInt(clickedItem.getAttribute('indicator-id'));

            if (previousIndex === itemId) {
                return;
            }

            that._goToItem(itemId);
            that._changeEvent(previousIndex, that._currentIndex);
        }

        /**
        * In "multiple" mode sets positions of carousel items in relation to the active slide.
        */

    }, {
        key: '_handleMultipleMode',
        value: function _handleMultipleMode(newIndex) {
            var that = this;

            if (that.displayMode !== 'multiple') {
                return;
            }

            var item = that._items[newIndex],
                itemWidth = item.offsetWidth,
                containerWidth = that.$.container.offsetWidth,
                itemsContainerWidth = that.$.itemsContainer.offsetWidth;
            var itemOffset = 0;

            if (newIndex === 0) {
                that.$.itemsContainer.style.marginLeft = '0px';
                return;
            } else if (newIndex === that._items.length - 1) {
                that.$.itemsContainer.style.marginLeft = '-' + (itemsContainerWidth - containerWidth) + 'px';
                return;
            }

            for (var i = 0; i < newIndex; i++) {
                itemOffset = itemOffset + that._items[newIndex].offsetWidth;
            }

            if (itemOffset + itemWidth / 2 >= containerWidth / 2 && itemOffset + itemWidth < itemsContainerWidth) {
                that.$.itemsContainer.style.marginLeft = '-' + (itemOffset + itemWidth / 2 - containerWidth / 2) + 'px';
            }
        }

        /**
        * Fires change/changing events.
        */

    }, {
        key: '_changeEvent',
        value: function _changeEvent(from, to) {
            if (from === to) {
                return;
            }

            var that = this;

            that.$.fireEvent('changing', {
                'index': to,
                'previousIndex': from
            });

            if (!that.hasAnimation) {
                that.$.fireEvent('change', {
                    'index': to,
                    'previousIndex': from
                });
            }
        }

        /**
        * Handles keyboard navigation.
        */

    }, {
        key: '_handleKeyDown',
        value: function _handleKeyDown(event) {
            var that = this,
                key = event.key,
                previousIndex = that._currentIndex,
                allowedKeys = ['ArrowLeft', 'ArrowDown', 'ArrowRight', 'ArrowUp', 'Home', 'End', ' ', 'Enter'];

            if (that.disabled || !that.keyboard || allowedKeys.indexOf(key) === -1) {
                return;
            }

            switch (key) {
                case 'ArrowLeft':
                case 'ArrowDown':
                    that.prev();
                    break;
                case 'ArrowUp':
                case 'ArrowRight':
                    that.next();
                    break;
                case 'Home':
                    that._goToItem(0);
                    break;
                case 'End':
                    that._goToItem(that.dataSource.length - 1);
                    break;
                case ' ':
                    that._rotate ? that.pause() : that.play();
                    break;
                case 'Enter':
                    that.play();
                    break;
            }

            that._changeEvent(previousIndex, that._currentIndex);
        }

        /**
        * Allows navigation between slides via mouse wheel.
        */

    }, {
        key: '_handleMouseWheel',
        value: function _handleMouseWheel(event) {
            var that = this,
                previousIndex = that._currentIndex;

            if (that.disabled || !that.wheel || document.activeElement !== that) {
                return;
            }

            event.stopPropagation();
            event.preventDefault();
            event.deltaY > 0 ? that.next() : that.prev();
            that._changeEvent(previousIndex, that._currentIndex);
        }

        /**
        * Start/stop slideShow.
        */

    }, {
        key: '_handleRotation',
        value: function _handleRotation(on) {
            var that = this;

            if (on) {
                that._rotationInterval = setInterval(function () {
                    if (!that.slideShow) {
                        return;
                    }

                    that.next();
                }, that.interval);
            } else {
                clearInterval(that._rotationInterval);
            }
        }

        /**
        * Slides to next/prev slide on swipeRight/swipeLeft.
        */

    }, {
        key: '_handleSwipe',
        value: function _handleSwipe(event) {
            var that = this;

            if (that.disabled || !that.swipe) {
                return;
            }

            event.stopPropagation();
            event.preventDefault();
            event.type === 'swipeleft' ? that.prev() : that.next();
        }

        /**
        * Generates single indicator item
        */

    }, {
        key: '_generateIndicator',
        value: function _generateIndicator(id) {
            var that = this,
                indicatorContainer = document.createElement('span'),
                indicatorId = id ? id : 0;

            if (that.indicatorTemplate) {
                var template = that._validateTemplate(that.indicatorTemplate);

                indicatorContainer.innerHTML = that._processItemTemplate(template.content, that.dataSource[indicatorId]);
            }

            indicatorContainer.classList.add('jqx-indicator');
            indicatorContainer.setAttribute('indicator-id', indicatorId);

            return indicatorContainer;
        }

        /**
        * Fills indicators container by generating multiple indicators.
        */

    }, {
        key: '_generateIndicators',
        value: function _generateIndicators() {
            var that = this,
                itemsCount = that.dataSource.length;
            var indicators = [],
                fragment = document.createDocumentFragment();

            for (var i = 0; i < itemsCount; i++) {
                var item = that._generateIndicator(i);

                indicators.push(item);
                fragment.appendChild(item);
            }

            that._indicators = indicators;

            var indicatorsContainer = that.$.indicatorsContainer;

            while (indicatorsContainer.firstChild) {
                indicatorsContainer.removeChild(indicatorsContainer.firstChild);
            }

            indicatorsContainer.appendChild(fragment);
        }

        /**
        * Generates single slide
        */

    }, {
        key: '_generateItem',
        value: function _generateItem(id) {
            var that = this,
                itemContainer = document.createElement('div'),
                itemId = id ? id : 0;

            if (that.itemTemplate) {
                var template = that._validateTemplate(that.itemTemplate);

                itemContainer.innerHTML = that._processItemTemplate(template.content, that.dataSource[itemId]);
            } else {
                var item = that.dataSource[itemId];

                if (typeof item === 'string') {
                    itemContainer.style.backgroundImage = 'url("' + item + '")';
                } else {
                    itemContainer.innerHTML = '<div class="jqx-carousel-item-container" style="background-image:url(\'' + (item.image || '') + '\')">\n                        <h2 class="jqx-carousel-item-label">' + (item.label || '') + '</h2>\n                        <p class="jqx-carousel-item-content">' + (item.content || '') + '</p>\n                    </div>\n                    <div class="jqx-carousel-html-content">' + (item.HTMLcontent || '') + '</div>\n                </div>';
                }
            }

            itemContainer.classList.add('jqx-carousel-item');
            itemContainer.setAttribute('item-id', itemId);

            return itemContainer;
        }

        /**
        * Binds template and data source item
        */

    }, {
        key: '_processItemTemplate',
        value: function _processItemTemplate(template, dataSource) {
            var regex = /{{\w+}}/g,
                bindings = template.match(regex);
            var processedTemplate = template;

            if (!bindings || bindings.length === 0) {
                return processedTemplate;
            }

            bindings.forEach(function (binding) {
                var propertyName = binding.replace('{{', '').replace('}}', '');

                processedTemplate = processedTemplate.replace(binding, dataSource[propertyName] || '');
            });

            return processedTemplate;
        }

        /**
        * Fills slides container by generating multiple items.
        */

    }, {
        key: '_generateItems',
        value: function _generateItems() {
            var that = this,
                itemsCount = that.dataSource.length;
            var items = [],
                fragment = document.createDocumentFragment();

            for (var i = 0; i < itemsCount; i++) {
                var item = that._generateItem(i);

                items.push(item);
                fragment.appendChild(item);
            }

            that._items = items;

            var itemsContainer = that.$.itemsContainer;

            while (itemsContainer.firstChild) {
                itemsContainer.removeChild(itemsContainer.firstChild);
            }

            itemsContainer.appendChild(fragment);
        }

        /**
        * Moves slides to an item with particular index.
        */

    }, {
        key: '_goToItem',
        value: function _goToItem(index, fireEvent) {
            var that = this,
                itemsCount = that.dataSource.length,
                oldIndex = that._currentIndex;
            var newIndex = index;

            if (index < 0) {
                newIndex = 0;
            } else if (index > itemsCount - 1) {
                newIndex = itemsCount - 1;
            }

            that._removeFadeOut();
            that._animationTrigger();
            that._handleIndicatorsState(oldIndex, newIndex);
            that._handleItemsState(oldIndex, newIndex);
            that._currentIndex = newIndex;
            fireEvent && that._changeEvent(oldIndex, newIndex);
            that._handle3dMode(newIndex);
            that._handleMultipleMode(newIndex);
            that._handleArrowsActiveState(newIndex, oldIndex);
        }

        /**
        * Sets tab index 
        */

    }, {
        key: '_setFocusable',
        value: function _setFocusable() {
            var that = this;

            if (that.disabled || that.unfocusable) {
                that.removeAttribute('tabindex');
                that.tabIndex = -1;
                return;
            }

            var index = that.tabIndex > 0 ? that.tabIndex : 0;

            that.setAttribute('tabindex', index);
            that.tabIndex = index;
        }

        /**
        * Sets initial values to inner variables, used in latest stage.
        */

    }, {
        key: '_setInitialState',
        value: function _setInitialState() {
            var that = this;

            that._currentIndex = 0;
            that._indicators = [];
            that._items = [];
            that._rotate = false;
            that._handleDefaultInnerHTML();
        }

        /**
        * Sets initial values to inner variables, used in latest stage.
        */

    }, {
        key: '_validateTemplate',
        value: function _validateTemplate(template) {
            var that = this;
            var templateContent = '',
                hasBindings = false,
                regex = /{{\w+}}/g;

            if (typeof template === 'function') {
                templateContent = template();
            }

            if (!('content' in document.createElement('template'))) {
                that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() }));
                that.itemTemplate = null;
                return;
            }

            if (template instanceof HTMLElement) {
                templateContent = template.innerHTML;
            } else {
                template = document.getElementById(template);
                templateContent = template ? template.innerHTML : '';
            }

            if (regex.exec(templateContent)) {
                hasBindings = true;
            }

            return { content: templateContent, hasBindings: hasBindings };
        }

        /**
        * Detect animation end and updates animated item's class list
        */

    }, {
        key: '_handleTransitionEnd',
        value: function _handleTransitionEnd(event) {
            if (!event.target.classList.contains('jqx-carousel-item') || event.target.getAttribute('position')) {
                return;
            }

            var that = this,
                currentTransitionEndId = event.target.getAttribute('item-id');

            if (that._lastTransitionEndId === currentTransitionEndId) {
                return;
            }

            that._removeFadeOut();
            this.$.fireEvent('change', {
                'index': currentTransitionEndId,
                'previousIndex': that._lastTransitionEndId
            });
            that._lastTransitionEndId = currentTransitionEndId;
        }

        /**
        * Removes the class related to items fade out effect 
        */

    }, {
        key: '_removeFadeOut',
        value: function _removeFadeOut() {
            var that = this,
                fadeOutItems = that.$.itemsContainer.getElementsByClassName('jqx-out');

            if (fadeOutItems.length) {
                for (var i = 0; i < fadeOutItems.length; i++) {
                    fadeOutItems[i].classList.remove('jqx-out');
                }
            }
        }
    }], [{
        key: 'properties',

        /**
        * Element's properties
        */
        get: function get() {
            return {
                'autoPlay': {
                    value: false,
                    type: 'any'
                },
                'dataSource': {
                    value: [],
                    type: 'array',
                    reflectToAttribute: false
                },
                'delay': {
                    value: 200,
                    type: 'number'
                },
                'displayMode': {
                    allowedValues: ['default', 'multiple', '3d'],
                    value: 'default',
                    type: 'string'
                },
                'disableItemClick': {
                    value: false,
                    type: 'boolean'
                },
                'hideArrows': {
                    value: false,
                    type: 'boolean'
                },
                'hideIndicators': {
                    value: false,
                    type: 'boolean'
                },
                'indicatorTemplate': {
                    value: null,
                    type: 'any'
                },
                'interval': {
                    value: 5000,
                    type: 'number'
                },
                'itemTemplate': {
                    value: null,
                    type: 'any'
                },
                'keyboard': {
                    value: false,
                    type: 'boolean'
                },
                'loop': {
                    value: false,
                    type: 'boolean'
                },
                'messages': {
                    value: {
                        'en': {
                            'htmlTemplateNotSuported': '{{elementType}}:  Browser doesn\'t support HTMLTemplate elements.'
                        }
                    },
                    type: 'object',
                    extend: true
                },
                'slideShow': {
                    value: false,
                    type: 'boolean'
                },
                'swipe': {
                    value: false,
                    type: 'boolean'
                },
                'wheel': {
                    value: false,
                    type: 'boolean'
                }
            };
        }

        /**
        * Element's event listeners.
        */

    }, {
        key: 'listeners',
        get: function get() {
            return {
                'arrowLeft.click': '_handleArrowClick',
                'arrowRight.click': '_handleArrowClick',
                'indicatorsContainer.click': '_handleIndicatorsContainerClick',
                'keydown': '_handleKeyDown',
                'swipeleft': '_handleSwipe',
                'swiperight': '_handleSwipe',
                'wheel': '_handleMouseWheel',
                'itemsContainer.click': '_handleItemClick',
                'itemsContainer.transitionend': '_handleTransitionEnd'
            };
        }

        /*
        * Checks for missing modules.
        */

    }, {
        key: 'requires',
        get: function get() {
            return {
                'JQX.RepeatButton': 'jqxbutton.js'
            };
        }
    }, {
        key: 'styleUrls',
        get: function get() {
            return ['jqx.button.css', 'jqx.carousel.css'];
        }
    }]);
    return Carousel;
}(JQX.ContentElement));