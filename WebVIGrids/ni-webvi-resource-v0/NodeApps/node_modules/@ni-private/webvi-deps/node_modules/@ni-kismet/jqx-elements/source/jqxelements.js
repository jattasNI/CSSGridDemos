/**
 * A class for instantiating a complex number object.
 */
JQX.Utilities.Assign('Complex', class JQXComplex {
    constructor(value, imag) {
        if (typeof value === 'string') {
            this.complexNumber = this.parseComplexNumber(value);
            this.realPart = this.complexNumber.realPart;
            this.imaginaryPart = this.complexNumber.imaginaryPart;
        }
        else if (typeof value === 'number') {
            this.realPart = value;
            if (typeof imag === 'number') {
                this.imaginaryPart = imag;
            }
            else if (typeof imag === 'undefined') {
                this.imaginaryPart = 0;
            }
            else {
                throw new Error('Can\'t create complex number: invalid imaginary part');
            }

            this.complexNumber = this.parseComplexNumber(this.realPart, this.imaginaryPart);
        }
        else {
            throw new Error('Can\'t create complex number');
        }
    }

    valueOf() {
        if (this.imaginaryPart === 0) {
            return this.realPart;
        }
        return null;
    }

    isNaN() {
        return isNaN(this.realPart) || isNaN(this.imaginaryPart);
    }


    isZero() {
        return (
                (this.realPart === 0 || this.realPart === -0) &&
                (this.imaginaryPart === 0 || this.imaginaryPart === -0)
                );
    }


    isFinite() {
        return isFinite(this.realPart) && isFinite(this.imaginaryPart);
    }

    isInfinite() {
        return !(this.isNaN() || this.isFinite());
    }

    parseComplexNumber(value, imaginaryPart) {
        const complexNumber = { realPart: 0, imaginaryPart: 0 };

        if (value === undefined || value === null) {
            complexNumber.realPart = complexNumber.imaginaryPart = 0;
        }
        else if (imaginaryPart !== undefined) {
            complexNumber.realPart = value;
            complexNumber.imaginaryPart = imaginaryPart;
        }
        else
            switch (typeof value) {
                case 'object':
                    if ('imaginaryPart' in value && 'realPart' in value) {
                        complexNumber.realPart = value.realPart;
                        complexNumber.imaginaryPart = value.imaginaryPart;
                    }
                    else if (value.length === 2) {
                        complexNumber.realPart = value[0];
                        complexNumber.imaginaryPart = value[1];
                    }
                    else {
                        throw SyntaxError('Invalid Complex Number Parameter');
                    }
                    break;

                case 'string': {
                    complexNumber.imaginaryPart = complexNumber.realPart = 0;

                    const tokens = value.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);

                    let plus = 1;
                    let minus = 0;

                    if (tokens === null) {
                        throw SyntaxError('Invalid Complex Number Parameter');
                    }

                    for (let i = 0; i < tokens.length; i++) {
                        const token = tokens[i];

                        if (token === ' ' || token === '\t' || token === '\n') {
                            /* void */
                        }
                        else if (token === '+') {
                            plus++;
                        }
                        else if (token === '-') {
                            minus++;
                        }
                        else if (token === 'i' || token === 'I') {

                            if (plus + minus === 0) {
                                throw SyntaxError('Invalid Complex Number Parameter');
                            }

                            if (tokens[i + 1] !== ' ' && !isNaN(tokens[i + 1])) {
                                complexNumber.imaginaryPart += parseFloat((minus % 2 ? '-' : '') + tokens[i + 1]);
                                i++;
                            }
                            else {
                                complexNumber.imaginaryPart += parseFloat((minus % 2 ? '-' : '') + '1');
                            }
                            plus = minus = 0;

                        }
                        else {
                            if (plus + minus === 0 || isNaN(token)) {
                                throw SyntaxError('Invalid Complex Number Parameter');
                            }

                            if (tokens[i + 1] === 'i' || tokens[i + 1] === 'I') {
                                complexNumber.imaginaryPart += parseFloat((minus % 2 ? '-' : '') + token);
                                i++;
                            }
                            else {
                                complexNumber.realPart += parseFloat((minus % 2 ? '-' : '') + token);
                            }
                            plus = minus = 0;
                        }
                    }

                    if (plus + minus > 0) {
                        throw SyntaxError('Invalid Complex Number Parameter');
                    }
                    break;
                }
                case 'number':
                    complexNumber.imaginaryPart = 0;
                    complexNumber.realPart = value;
                    break;

                default:
                    throw SyntaxError('Invalid Complex Number Parameter');
            }

        return complexNumber;
    }

    compare(value, imaginaryPart) {
        const complexNumber = this.parseComplexNumber(value, imaginaryPart);
        const epsilon = this.parseComplexNumber('1e-16');

        return Math.abs(complexNumber.realPart - this.realPart) <= epsilon &&
                    Math.abs(complexNumber.imaginaryPart - this.imaginaryPart) <= epsilon;
    }

    toString() {
        let realPart = this.realPart;
        let imaginaryPart = this.imaginaryPart;
        let complexNumberAsString = '';

        if (this.isNaN()) {
            return 'NaN';
        }

        if (this.isZero()) {
            return '0';
        }

        if (this.isInfinite()) {
            return 'Infinity';
        }

        if (realPart !== 0) {
            complexNumberAsString += realPart;
        }

        if (imaginaryPart !== 0) {
            if (realPart !== 0) {
                complexNumberAsString += imaginaryPart < 0 ? ' - ' : ' + ';
            }
            else if (imaginaryPart < 0) {
                complexNumberAsString += '-';
            }

            imaginaryPart = Math.abs(imaginaryPart);

            if (1 !== imaginaryPart) {
                complexNumberAsString += imaginaryPart;
            }

            complexNumberAsString += 'i';
        }

        if (!complexNumberAsString) {
            return '0';
        }

        return complexNumberAsString;
    }
});

class DataAdapter {
    constructor(config) {
        if (!config) {
            config = {};
        }

        const that = Object.assign(this, config);

        const generateKey = function () {
            const S4 = function () {
                return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
            };
            return S4();
        };

        that.key = generateKey();

        that.$document = JQX.Utilities.Extend(document);
        that.boundSource = false === that.observable ? [] : new JQX.ObservableArray();
        that.dataItemById = [];

        if (that.allowAdd === undefined) {
            that.allowAdd = true;
        }

        if (that.allowRemove === undefined) {
            that.allowRemove = true;
        }

        if (that.allowUpdate === undefined) {
            that.allowUpdate = true;
        }

        if (config.observable === undefined) {
            that.observable = true;
        }


        if (!config.dataSource) {
            that.dataSource = [];
        }

        if (!config.dataFields) {
            that.dataFields = [];
        }
        else {
            /* if (config.dataSource && config.dataSource.length > 0) {
                 const keys = Object.keys(config.dataSource[0]);
 
                 //     that.dataFields = [];
 
                 for (let i = 0; i < keys.length; i++) {
 
                 }
             }
             */
        }

        if (!config.dataSourceType) {
            that.dataSourceType = 'array';
        }

        if (!config.id) {
            that.id = null;
        }

        if (!config.autoFetch) {
            that.autoFetch = true;
        }

        if (config.dataFields) {
            that.dataFields = config.dataFields;
        }

        if (config && config.autoBind !== false) {
            that.dataBind();
        }

        that.isInitialized = true; 
    }

    get dataFields() {
        const that = this;

        return that._dataFields;
    }

    set dataFields(value) {
        const that = this;

        that._dataFields = that._getDataFieldObjects(value);

        return that._dataFields;
    }

    _getDataFieldObjects(dataFields) {
        //const that = this;

        let dataFieldObjects = [];

        if (typeof dataFields === 'number') {
            const charCode = 'A'.charCodeAt(0);
            let prefix = '';
            let index = 0;

            for (let i = 0; i < dataFields; i++) {
                const letter = String.fromCharCode(charCode + index);

                index++;

                const label = prefix + letter;

                dataFieldObjects.push({ name: label, dataType: 'string'})

                if (index >= 26) {
                    index = 0;
                    prefix += 'A';
                }
            }
        }
        else if (dataFields.length > 0) {
            for (let i = 0; i < dataFields.length; i++) {
                const dataField = dataFields[i];

                if (typeof dataField === 'string') {
                    const dataFieldParts = dataField.split(':');
                    const name = dataFieldParts[0].trim();
                    const dataType = dataFieldParts.length > 1 ? dataFieldParts[1].trim() : 'string';

                    dataFieldObjects.push({ name: name, dataType: dataType });
                }
                else {
                    dataFieldObjects.push(dataField);
                }
            }
        }

        return dataFieldObjects;
    }

    get dataSource() {
        const that = this;

        if (!that._dataSource) {
            that._dataSource = [];
        }

        return that._dataSource;
    }

    set dataSource(value) {
        const that = this;

        that._dataSource = value;

        if (that.isInitialized) {
            that.boundSource = false === that.observable ? [] : new JQX.ObservableArray();
            that.dataItemById = [];
            that.bindingCompleted = false;
            that.dataBind();
        }
    }

    get canNotify() {
        const that = this;

        if (that._canNotify === undefined) {
            that._canNotify = true;
        }

        return that._canNotify;
    }

    set canNotify(value) {
        const that = this;

        that._canNotify = value;
    }

    _notify(changeArgs) {
        const that = this;

        if (!that.canNotify) {
            return;
        }

        if (that.notifyFn) {
            that.notifyFn(changeArgs);
        }
    }

    notify(notifyFn) {
        const that = this;

        if (notifyFn) {
            that.notifyFn = notifyFn;
        }
    }

    toArray() {
        const that = this;

        return that.boundSource.toArray();
    }

    dataBind() {
        const that = this;

        that.clear();
    
        const completed = () => {
            if (that.observable) {
                that.boundSource.notify(function (event) {
                    if (event.action === 'update' && event.path && event.path.indexOf('.') >= 0
                        && event.path.indexOf('children') === -1
                        && event.path.indexOf('loaded') === -1
                        && event.path.indexOf('level') === -1
                        && event.path.indexOf('leaf') === -1
                        && event.path.indexOf('expanded') === -1) {
    
                        let canNotify = false;
    
                        for (let i = 0; i < that.dataFields.length; i++) {
                            const dataField = that.dataFields[i].name;
    
                            if (event.path.indexOf(dataField) >= 0) {
                                canNotify = true;
                            }
                        }
    
                        if (that._notify && canNotify) {
                            that._notify({ action: 'update', data: event.target, index: event.index });
                        }
                    }
                });
            }

            if (!that.groupBy) {
                that.groupBy = [];
            }
    
            that.groupBy = new JQX.ObservableArray(that.groupBy);
            that.groupBy.notify(function () {
                that.boundHierarchy = null;
                that.refreshHierarchy();
    
                if (that.onGroup) {
                    that.onGroup();
                }
            });
    
            that._onBindingComplete();
        }

        if (typeof that.dataSource === 'string' && (that.dataSource.indexOf('.json') >= 0)) {
            that.url = that.dataSource;
            that.dataSourceType = 'json';
             
            //const ajaxJSON = new Ajax(that, (data, status) => {
            //    that.dataSource = data;
           
            //    that._bindToJSON();
            //});
        }
        else if (typeof that.dataSource === 'string' && (that.dataSource.indexOf('.xlsx') >= 0)) {
            that.url = that.dataSource;
            that.dataSourceType = 'xlsx';

            //const ajaxJSON = new Ajax(that, (data, status) => {
            //    const keys = Object.keys(data[0]);
            //    const dataFieldMap = {};
            //    const dataRows = [];
                
            //    if (that.exportHeader !== false) {
            //        let index = 0;

            //        for(let key in keys) {
            //            const name = keys[key];

            //            dataFieldMap[name] = that.dataFields[index++].name;
            //        }

            //        for(let i = 1; i < data.length; i++) {
            //            const row = data[i];
            //            const dataRow = {};
                    
            //            for(let key in keys) {
            //                const name = keys[key];

            //                dataRow[dataFieldMap[name]] = row[name];
            //            }

            //            dataRows.push(dataRow);
            //        }

            //        that.dataSource = dataRows;
            //    }

            //    that._bindToArray();
            //    completed();        
            //});
        }
        else if (typeof that.dataSource === 'string' && (that.dataSource.indexOf('.csv') >= 0)) {
            that.dataSourceType = 'csv';
      
            //const ajaxJSON = new Ajax(that, (data, status) => {
            //    that._bindToArray();
            //});
        }
        else if (typeof that.dataSource === 'string' && (that.dataSource.indexOf('.tsv') >= 0)) {
            that.dataSourceType = 'tsv';
      
            //const ajaxJSON = new Ajax(that, (data, status) => {
            //});
        }
        else if (that.dataSourceType === 'array') {
            that._bindToArray();
            completed();
        }
        else if (that.dataSourceType === 'json') {
            that._bindToJSON();
            completed();
        }    
    }

    _onBindingComplete() {
        const that = this;

        that._buildHierarchy();

        if (that.onBindingComplete) {
            that.onBindingComplete({ data: that.boundSource });
        }

        if (that._notify) {
            that._notify({ action: 'bindingComplete', data: that.boundSource });
        }

        that.bindingCompleted = true;
    }

    refreshHierarchy() {
        const that = this;

        that._buildHierarchy();
    }

    find() {
        const that = this;

        return that.boundSource.find.apply(that.boundSource, arguments);
    }

    //toArray() {
    //    const that = this;

    //    return that.boundSource.toArray();
    //}

    onVirtualDataSourceRequested(requestCallback, details) {
        const that = this;

        let first = details ? details.first : Infinity;
        let last = details ? details.last : Infinity;
        let row = details ? details.row : null;

        if (undefined === first) {
            first = Infinity;
        }

        if (undefined === last) {
            last = Infinity;
        }

        that.virtualFirstIndex = first;
        that.virtualLastIndex = last;

        if (that.virtualDataSource) {
            const getDataSource = function (dataAdapterSettings) {
                if (dataAdapterSettings.virtualDataSourceLength) {
                    that.virtualDataSourceLength = dataAdapterSettings.virtualDataSourceLength;
                }

                new JQX.DataAdapter(
                    {
                        dataSource: dataAdapterSettings.dataSource,
                        dataFields: dataAdapterSettings.dataFields || that.dataFields,
                        data: details,
                        onBindingComplete(event) {

                            if (that.virtualDataSourceOnExpand && row) {
                                if (event.data && event.data.length > 0) {
                                    that.add(event.data, row.$.id);
                                }
                                else {
                                    row.leaf = true;
                                }

                                if (that.onFilter) {
                                    that.onFilter()
                                }

                                requestCallback();

                                return;
                            }

                            if (first === Infinity) {
                                that.add(event.data);
                            }
                            else {
                                let items = [];
                                let indexes = [];

                                for (let i = 0; i < event.data.length; i++) {
                                    const item = event.data[i];

                                    if (first + i <= last) {
                                        items.push(item);
                                        indexes.push(first + i);
                                    }
                                }

                                that.update(indexes, items);
                            }


                            if (that.onFilter) {
                                that.onFilter()
                            }

                            requestCallback();
                        }
                    });
            }

            let hasCache = false;

            const isEmpty = (obj) => Object.entries(obj).length === 0 && (obj.constructor === Object || obj.constructor === Array);
            const canCache = isEmpty(details.sorting) && isEmpty(details.filtering) && isEmpty(details.grouping) && !details.row && (details.action !== 'filter' && details.action !== 'sort' && details.action !== 'group');

            if (that.virtualDataSourceCache && first !== Infinity && canCache) {
                let cachedCount = 0;

                for (let i = first; i < last; i++) {
                    if (!that[i].isEmpty) {
                        cachedCount++;
                    }
                }

                if (cachedCount === last - first) {
                    hasCache = true;
                }
            }

            if (hasCache) {
                requestCallback();
            }
            else {
                if (details.action === 'expand') {
                    that.virtualDataSourceOnExpand(getDataSource, {
                        first: first,
                        last: last,
                        row: details.row,
                        sorting: details.sorting,
                        filtering: details.filtering,
                        grouping: details.grouping,
                        action: details.action
                    });
                }
                else {
                    that.virtualDataSource(getDataSource, {
                        first: first,
                        last: last,
                        sorting: details.sorting,
                        filtering: details.filtering,
                        grouping: details.grouping,
                        action: details.action
                    });
                }
            }
        }
        else {
            requestCallback();
        }
    }

    add(item, parentId) {
        const that = this;

        if (!item) {
            return;
        }

        let result = true;

        const addItem = function (item) {
            const itemObject = that._getDataItem(item, that.boundSource.length);

            that[that.boundSource.length] = itemObject;
            that.dataItemById[itemObject.$.id] = itemObject;

            const pushResult = that.boundSource.push(itemObject);

            if (parentId !== undefined) {
                itemObject.$.parentId = parentId;
            }

            if (!pushResult) {
                result = false;
            }

            return itemObject;
        }

        if (item.length) {
            let itemObjects = [];

            for (let i = 0; i < item.length; i++) {
                const itemObject = addItem(item[i]);

                itemObjects.push(itemObject);
            }

            that._notify({ action: 'add', data: itemObjects });
        }
        else {
            const itemObject = addItem(item);

            that._notify({ action: 'add', data: itemObject });
        }

        that.refreshHierarchy();

        return result;
    }

    refreshIndexes() {
        const that = this;

        for(let i = 0; i < that.boundSource.length; i++) {
            that[i] = that.boundSource[i];
        }
    }

    removeLast() {
        const that = this;

        delete that[that.boundSource.length-1];

        const result = that.boundSource.pop();

        that._notify({ action: 'removeLast', data: result });

        that.refreshHierarchy();

        return result;
    }

    remove(index) {
        const that = this;

        const item = that.boundSource[index];

        if (!item) {
            throw new Error('Invalid Item Index');
        }

        that.boundSource.splice(index, 1);
        that.refreshIndexes();

        that._notify({ action: 'remove', index: index, data: item });

        that.refreshHierarchy();
    }

    update(index, dataSourceItem) {
        const that = this;

        if (JQX.Utilities.Types.isArray(index) && JQX.Utilities.Types.isArray(dataSourceItem)) {
            if (index.length === 0 && dataSourceItem.length === 0) {
                return;
            }
        }

        if (dataSourceItem.length && index.length) {
            let itemObjects = [];

            for (let i = 0; i < index.length; i++) {
                const itemObject = that._getDataItem(dataSourceItem[i], index[i]);
                const currentIndex = index[i];

                itemObjects.push(itemObject);

                that.boundSource[currentIndex] = itemObject;
                that[currentIndex] = that.boundSource[currentIndex];
                that.dataItemById[itemObject.$.id] = that[currentIndex];
            }

            that._notify({ action: 'update', index: index, data: itemObjects });

            that.refreshHierarchy();

            return;
        }

        const itemObject = that._getDataItem(dataSourceItem, index);

        that.boundSource[index] = itemObject;
        that[index] = that.boundSource[index];
        that.dataItemById[itemObject.$.id] = that[index];

        that._notify({ action: 'update', index: index, data: itemObject });

        that.refreshHierarchy();

        return itemObject;
    }

    insert(index, item) {
        const that = this;

        item = that._getDataItem(item, index);

        const result = that.boundSource.splice(index, 0, item);

        that.refreshIndexes();
        
        that._notify({ action: 'insert', index: index, data: item });

        that.refreshHierarchy();

        return result;
    }

    move(from, to) {
        if (to > from && to - from === 1 || from === to) {
            return;
        }

        const that = this,
            recordToMove = that.boundSource.splice(from, 1)[0];

        if (to > from) {
            to--;
            that.boundSource.splice(to, 0, recordToMove);
        }
        else {
            that.boundSource.splice(to, 0, recordToMove);
        }

        that.refreshIndexes();

        that._notify({ action: 'move', index: to, data: that.boundSource[to] });

        that.refreshHierarchy();
    }

    indexOf(item) {
        const that = this;
        const index = that.boundSource.indexOf(item);

        return index;
    }

    get length() {
        const that = this;

        if (that.virtualDataSourceLength) {
            return that.virtualDataSourceLength;
        }
        
        if (that.dataSourceLength) {
            return that.dataSourceLength;
        }

        if (typeof (that.dataSource) === 'number') {
            return that.dataSource;
        }

        if (that.bindingCompleted) {
            return that.boundSource.length;
        }

        if (that.dataSource && typeof that.dataSource !== 'string' && that.dataSource.length) {
            return that.dataSource.length;
        }

        return that.boundSource.length;
    }

    clear() {
        const that = this;

        if (!that.isInitialized) {
            that._cachedValues = [];
            that.dataItemById = [];
            return;
        }

        for (let i = 0; i < that.boundSource.length; i++) {
            delete that[i];
        }

        that._cachedValues = [];
        that.boundSource = that.observable ? new JQX.ObservableArray() : [];
        that.dataItemById = [];
        that.refreshHierarchy();
    }

    _getId(id, item, index) {
        if (id !== null && id.name !== undefined) {
            if (id.name && item.getAttribute) {
                let result = item.getAttribute(id.name);
                if (result !== null && result.toString().length > 0) {
                    return result;
                }
                else if (id.map) {
                    try {
                        let result = item.getAttribute(id.map);
                        if (result !== null && result.toString().length > 0) {
                            return result;
                        }
                    }
                    catch (error) {
                        return index;
                    }
                }
                return;
            }
        }

        if (id) {
            if (id.toString().length > 0 && item.getAttribute) {
                let result = item.getAttribute(id);
                if (result !== null && result.toString().length > 0) {
                    return result.trim().split(' ').join('').replace(/([ #;?%&,.+*~\':'!^$[\]()=>|\/@])/g, '');
                }
                else {
                    let splitMap = id.split(this.mapChar);
                    if (splitMap.length > 1) {
                        let d = item;
                        for (let p = 0; p < splitMap.length; p++) {
                            if (d !== undefined) {
                                d = d[splitMap[p]];
                            }
                        }
                        if (d !== undefined) {
                            return d;
                        }
                    }
                    else {
                        if (item[id] !== undefined) {
                            return item[id];
                        }
                    }
                }
            }
        }

        return index;
    }

    _buildHierarchy() {
        const that = this;

        if (!that.reservedNames) {
            that.reservedNames = {
                leaf: 'leaf',
                parent: 'parent',
                expanded: 'expanded',
                checked: 'checked',
                selected: 'selected',
                level: 'level',
                icon: 'icon',
                data: 'data'
            }
        }
        else {
            const names = that.reservedNames;

            if (!names.leaf) {
                names.leaf = 'leaf';
            }
            if (!names.parent) {
                names.parent = 'parent';
            }
            if (!names.expanded) {
                names.expanded = 'expanded';
            }
            if (!names.checked) {
                names.checked = 'checked';
            }
            if (!names.selected) {
                names.selected = 'selected';
            }
            if (!names.level) {
                names.level = 'level';
            }
            if (!names.data) {
                names.data = 'data';
            }

        }

        const names = that.reservedNames;

        if (that.childrenDataField) {
            const hierarchy = [];

            for (let i = 0; i < that.boundSource.length; i++) {
                const item = Object.assign({}, that.boundSource[i]);

                if (!item) {
                    continue;
                }

                hierarchy.push(item);

                const addItems = function (item) {
                    const splitMap = that.childrenDataField.split(that.mapChar);
                    let children = null;

                    if (splitMap.length > 1) {
                        let data = item;

                        for (let p = 0; p < splitMap.length; p++) {
                            if (data !== undefined) {
                                data = data[splitMap[p]];
                            }
                        }

                        children = data;
                    }
                    else {
                        children = item['children'];
                    }

                    item['children'] = children;

                    if (item['children'] === null || item['children'] === undefined || (item['children'] && item['children'].length === 0)) {
                        item[names.leaf] = true;
                    }
                }

                addItems(item);
                item[names.level] = 0;

                if (!item.$) {
                    item.$ = {};
                }

                item[names.parent] = null;
                item[names.data] = item;

                if (item[names.expanded] === undefined) {
                    item[names.expanded] = false;
                }

                const drillThrough = function (parent, children) {
                    if (!children) {
                        parent['children'] = new Array();
                        return;
                    }

                    for (let i = 0; i < children.length; i++) {
                        let item = that._getDataItem(children[i], i);

                        if (!item) {
                            continue;
                        }

                        addItems(item);
                        item[names.level] = parent[names.level] + 1;
                        item[names.parent] = parent;
                        item[names.data] = item;

                        if (parent) {
                            parent['children'][i] = item;
                        }


                        if (item[names.expanded] === undefined) {
                            item[names.expanded] = false;
                        }

                        drillThrough(item, item['children']);
                    }
                }

                drillThrough(item, item['children']);
            }


            that.boundHierarchy = hierarchy;

            if (!that._boundSourceUpdate) {
                for (let i = 0; i < that.boundHierarchy.length; i++) {
                    const item = that.boundHierarchy[i];

                    if (item.children) {
                        const drillThrough = function (item) {
                            if (!that.dataItemById[item.$.id]) {
                                that.boundSource.canNotify = false;
                                that.dataItemById[item.$.id] = item;
                                that[that.boundSource.length] = item;
                                that.boundSource.push(item);
                                that.boundSource.canNotify = true;
                            }

                            if (item.children) {
                                for (let i = 0; i < item.children.length; i++) {
                                    const child = item.children[i];

                                    if (child.children) {
                                        drillThrough(child);
                                    }
                                }
                            }
                        }

                        drillThrough(item);
                    }
                }

                that._boundSourceUpdate = true;
            }
        }

        if (that.xmlRoot && that.dataSourceType === 'xml') {
            that.boundHierarchy = this._getHierarchy('uid', '_parentuid', 'children', null, that.boundSource);
        }

        if (that.keyDataField && that.parentDataField) {
            that.boundHierarchy = this._getHierarchy(that.keyDataField, that.parentDataField, 'children', null, that.boundSource);
        }

        if (that.groupBy && that.groupBy.length > 0) {
            that.boundHierarchy = this._getGroupHierarchy(that.groupBy, 'children', 'label', null, 'data', null, 'parent', that.boundSource);
        }

        if (that.virtualDataSourceOnExpand) {
            that.boundHierarchy = this._getHierarchy('id', 'parentId', 'children', null, that.boundSource);
        }
    }


    _getGroupHierarchy(groups, collectionName, groupName, mappingFields, itemName, valueName, parentName, data, startIndex) {
        let that = this;

        if (!startIndex) {
            startIndex = 0;
        }

        let names = that.reservedNames;

        const guid = function () {
            function s4() {
                return Math.floor((1 + Math.random()) * 0x10000)
                    .toString(16)
                    .substring(1);
            }

            return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
        }

        let groupHashCodes = new Array();
        for (let iGroupColumn = 0; iGroupColumn < groups.length; iGroupColumn++) {
            groupHashCodes[iGroupColumn] = guid();
        }

        if (!collectionName) {
            collectionName = 'children';
        }

        if (!groupName) {
            groupName = 'group';
        }

        if (!itemName) {
            itemName = 'item';
        }

        if (!parentName) {
            parentName = 'parent';
        }

        if (undefined === valueName) {
            valueName = 'value';
        }

        const groupboundSource = new Array();
        const hashItemGroups = new Array();

        let groupboundSourceIndex = 0;

        const getItem = function (item) {
            let itemObj = item;
            if (mappingFields) {
                for (let mappingField in mappingFields) {
                    const mappingObject = mappingFields[mappingField];

                    if (mappingObject.name && mappingObject.map) {
                        itemObj[mappingObject.map] = itemObj[mappingObject.name];
                    }
                }
            }

            return itemObj;
        }

        for (let obj = 0; obj < data.length; obj++) {
            let item = Object.assign({}, getItem(data[obj]));

            item[names.leaf] = false;

            let itemKeysHierarchy = new Array();
            let keys = 0;

            for (let iGroupColumn = 0; iGroupColumn < groups.length; iGroupColumn++) {
                const group = groups[iGroupColumn];
                const value = item[group];

                if (null === value) {
                    continue;
                }

                itemKeysHierarchy[keys++] = { value: value, group: group, hash: groupHashCodes[iGroupColumn] };
            }

            if (itemKeysHierarchy.length !== groups.length) {
                break;
            }

            let parentItem = null;
            let lookupKey = '';

            for (let q = 0; q < itemKeysHierarchy.length; q++) {
                const itemKey = itemKeysHierarchy[q].value;
                const groupDataField = itemKeysHierarchy[q].group;
                const columnHash = itemKeysHierarchy[q].hash;

                lookupKey = lookupKey + '_' + columnHash + '_' + itemKey;

                if (hashItemGroups[lookupKey] !== undefined && hashItemGroups[lookupKey] !== null) {
                    parentItem = hashItemGroups[lookupKey];
                    continue;
                }

                if (parentItem === null) {
                    parentItem = { $: {} };

                    parentItem[names.level] = 0;
                    parentItem[names.leaf] = false;
                    parentItem[parentName] = null;
                    parentItem[groupName] = itemKey;
                    parentItem[itemName] = item;
                    parentItem['groupDataField'] = groupDataField;

                    if (item[names.expanded] !== undefined) {
                        parentItem[names.expanded] = item[names.expanded];
                    }
                    else {
                        parentItem[names.expanded] = false;
                    }

                    if (valueName) {
                        parentItem[valueName] = item[valueName];
                    }

                    parentItem[collectionName] = new Array();

                    let uid = groupboundSource.length + startIndex;

                    if (!this.id || typeof item.$.id === 'number' || isFinite(item.$.id)) {
                        uid = 'Item' + uid;
                    }
                    if (parentItem.$.id === undefined) {
                        parentItem.$.id = uid;
                    }

                    groupboundSource[groupboundSourceIndex++] = parentItem;
                }
                else {
                    const subItem = { $: {} };

                    subItem[names.level] = parentItem[names.level] + 1;
                    subItem[parentName] = parentItem;
                    subItem[groupName] = itemKey;
                    subItem[collectionName] = new Array();
                    subItem[itemName] = item;
                    subItem['groupDataField'] = groupDataField;
                    subItem[names.leaf] = false;

                    if (item[names.expanded] !== undefined) {
                        subItem[names.expanded] = item[names.expanded];
                    }
                    else {
                        subItem[names.expanded] = false;
                    }

                    if (valueName) {
                        subItem[valueName] = item[valueName];
                    }

                    if (subItem.$.id === undefined) {
                        subItem.$.id = parentItem.$.id + '_' + parentItem[collectionName].length;
                    }

                    parentItem[collectionName][parentItem[collectionName].length] = subItem;
                    parentItem = subItem;
                }

                hashItemGroups[lookupKey] = parentItem;
            }

            if (item) {
                item[names.leaf] = true;
            }

            if (parentItem !== null) {
                if (this.id === null) {
                    if (undefined === item.$.id) {
                        item.$.id = parentItem.$.id + '_' + parentItem[collectionName].length;
                    }
                }
                else {
                    if (undefined === item.$.id) {
                        if (item.$.id.toString().indexOf(parentItem.$.id) === -1) {
                            item.$.id = parentItem.$.id + '_' + item.$.id;
                        }
                    }
                }

                item[parentName] = parentItem;
                item[names.level] = parentItem[names.level] + 1;
                parentItem[collectionName][parentItem[collectionName].length] = item;
            }
            else {
                if (undefined === item.$.id) {
                    item.$.id = guid();
                }
            }
        }

        return groupboundSource;
    }

    _getHierarchy(fieldName, parentFieldName, collectionName, mappingFields, boundSource) {
        const that = this;

        const databoundHierarchy = new Array();
        let flatData = this.boundSource;

        if (boundSource) {
            flatData = boundSource;
        }

        if (this.boundSource.length === 0)
            return null;

        const childrenName = collectionName !== null ? collectionName : 'children';
        let items = new Array();
        let data = flatData;
        let dataLength = data.length;
        let names = that.reservedNames;

        const getItem = function (item) {
            let itemObj = item;
            if (mappingFields) {
                for (let mappingField in mappingFields) {
                    const mappingObject = mappingFields[mappingField];

                    if (mappingObject.name && mappingObject.map) {
                        itemObj[mappingObject.map] = itemObj[mappingObject.name];
                    }
                }
            }

            return itemObj;
        }

        // build hierarchical source.
        for (let i = 0; i < dataLength; i++) {
            let item = data[i];
            let parentId = item[parentFieldName];
            let id = item[fieldName];

            if (parentFieldName === 'parentId') {
                parentId = item.$.parentId;
            }

            if (fieldName === 'id') {
                id = item.$.id;
            }

            item[childrenName] = new Array();

            items[id] = { parentId: parentId, item: item };
        }

        for (let i = 0; i < dataLength; i++) {
            const item = data[i];
            let parentId = item[parentFieldName];
            let id = item[fieldName];

            if (parentFieldName === 'parentId') {
                parentId = item.$.parentId;
            }

            if (fieldName === 'id') {
                id = item.$.id;
            }

            if (items[parentId] !== undefined) {
                let item = { parentId: parentId, item: items[id].item };
                let parentItem = items[parentId].item;
                if (!parentItem[childrenName]) {
                    parentItem[childrenName] = new Array();
                }
                let length = parentItem[childrenName].length;
                item = item.item;

                if (!names) {
                    if (item.parent === undefined) {
                        item.parent = parentItem;
                    }
                }
                else {
                    if (item[names.parent] === undefined) {
                        item[names.parent] = parentItem;
                    }
                }

                const itemObj = getItem(item);

                parentItem[childrenName][length] = itemObj;
                items[parentId].item = parentItem;
                items[id].item = item;

            }
            else {
                let item = items[id].item;
                if (!names) {
                    if (item.parent === undefined) {
                        item.parent = null;
                    }
                }
                else {
                    if (item[names.parent] === undefined) {
                        item[names.parent] = null;
                    }
                }

                const itemObj = getItem(item);

                if (!names) {
                    itemObj.level = 0;
                }
                else {
                    itemObj[names.level] = 0;
                }

                databoundHierarchy[databoundHierarchy.length] = itemObj;
            }
        }
        if (databoundHierarchy.length !== 0) {
            let updateLevels = function (level, children) {
                for (let i = 0; i < children.length; i++) {
                    const child = children[i];

                    if (!names) {
                        child.level = level;
                    }
                    else {
                        child[names.level] = level;
                    }

                    const childChildren = child[childrenName];

                    if (childChildren) {
                        if (childChildren.length > 0) {
                            updateLevels(level + 1, childChildren);
                        }
                        else {
                            if (that.virtualDataSourceOnExpand) {
                                if (child.leaf === undefined) {
                                    child.leaf = false;
                                }
                            }
                            else {
                                if (!names) {
                                    child.leaf = true;
                                }
                                else {
                                    child[names.leaf] = true;
                                }
                            }
                        }
                    }
                    else {
                        if (that.virtualDataSourceOnExpand) {
                            if (child.leaf === undefined) {
                                child.leaf = false;
                            }
                        }
                        else {
                            if (!names) {
                                child.leaf = true;
                            }
                            else {
                                child[names.leaf] = true;
                            }
                        }
                    }
                }
            };
            updateLevels(0, databoundHierarchy);
        }
        return databoundHierarchy;
    }

    summarize(summaryItems, boundSource) {
        const that = this;

        if (!Array.isArray(summaryItems)) {
            summaryItems = [summaryItems];
        }

        let tempSummaryItems = [];

        for (let i = 0; i < summaryItems.length; i++) {
            const summaryItem = summaryItems[i];

            for (let name in summaryItem) {
                const functions = summaryItem[name];

                tempSummaryItems.push({ dataField: name, functions: functions })
            }
        }

        summaryItems = tempSummaryItems;

        let data = {};
        let summaryByDataField = new Array();

        if (!boundSource) {
            boundSource = that.boundSource;
        }

        let length = boundSource.length;

        if (length === 0) {
            return;
        }

        if (length === undefined) {
            return;
        }

        for (let i = 0; i < length; i++) {
            let dataItem = boundSource[i];

            for (let j = 0; j < summaryItems.length; j++) {
                const summaryItem = summaryItems[j];
                let value = dataItem[summaryItem.dataField];

                if (summaryItem.functions) {
                    data[summaryItem.dataField] = data[summaryItem.dataField] || {};
                    summaryByDataField[summaryItem.dataField] = summaryByDataField[summaryItem.dataField] || 0;
                    summaryByDataField[summaryItem.dataField]++;

                    const _summaryItemFunction = function (summaryItemObject) {
                        for (let name in summaryItemObject) {
                            let oldValue = data[summaryItem.dataField][name];

                            if (oldValue === null || oldValue === undefined) {
                                data[summaryItem.dataField][name] = 0;
                                oldValue = 0;
                            }

                            if (typeof summaryItemObject[name] === 'function') {
                                oldValue = summaryItemObject[name](oldValue, value, summaryItem.dataField, dataItem);
                            }
                            data[summaryItem.dataField][name] = oldValue;
                        }
                    }

                    let canParse = parseFloat(value);

                    if (isNaN(canParse)) {
                        canParse = false;
                    }
                    else {
                        canParse = true;
                    }

                    if (canParse) {
                        value = parseFloat(value);
                    }

                    if (typeof value === 'number' && isFinite(value)) {
                        summaryItem.functions.forEach(function (summaryItemFunction) {
                            let oldValue = data[summaryItem.dataField][summaryItemFunction];

                            if (oldValue === null || oldValue === undefined) {
                                oldValue = 0;

                                if (this === 'min') {
                                    oldValue = 9999999999999;
                                }

                                if (this === 'max') {
                                    oldValue = -9999999999999;
                                }
                            }

                            if (summaryItemFunction === 'sum' || summaryItemFunction === 'avg' || summaryItemFunction === 'stdev'
                                || summaryItemFunction === 'stdevp' || summaryItemFunction === 'var' || summaryItemFunction === 'varp') {
                                oldValue += parseFloat(value);
                            }
                            else if (summaryItemFunction === 'product') {
                                if (i === 0)
                                    oldValue = parseFloat(value);
                                else
                                    oldValue *= parseFloat(value);
                            }
                            else if (summaryItemFunction === 'min') {
                                oldValue = Math.min(oldValue, parseFloat(value));
                            }
                            else if (summaryItemFunction === 'max') {
                                oldValue = Math.max(oldValue, parseFloat(value));
                            }
                            else if (summaryItemFunction === 'count') {
                                oldValue++;
                            }
                            else if (typeof (summaryItemFunction) === 'object') {
                                _summaryItemFunction(summaryItemFunction);
                                return;
                            }

                            data[summaryItem.dataField][summaryItemFunction] = oldValue;
                        });
                    }
                    else {
                        summaryItem.functions.forEach(function (summaryItemFunction) {
                            if (summaryItemFunction === 'min' || summaryItemFunction === 'max' || summaryItemFunction === 'count' || summaryItemFunction === 'product' || summaryItemFunction === 'sum'
                                || summaryItemFunction === 'avg' || summaryItemFunction === 'stdev'
                                || summaryItemFunction === 'stdevp' || summaryItemFunction === 'var' || summaryItemFunction === 'varp') {
                                if (value === null) {
                                    return true;
                                }

                                let oldValue = data[summaryItem.dataField][summaryItemFunction];

                                if (oldValue === null || oldValue === undefined) {
                                    oldValue = 0;
                                }

                                data[summaryItem.dataField][summaryItemFunction] = oldValue;

                                return true;
                            }

                            if (typeof (summaryItemFunction) === 'object') {
                                _summaryItemFunction(summaryItemFunction);
                            }
                        });
                    }
                }
            }
        }

        for (let j = 0; j < summaryItems.length; j++) {
            const summaryItem = summaryItems[j];

            if (!summaryItem.functions) {
                continue;
            }
            if (!data[summaryItem.dataField]) {
                data[summaryItem.dataField] = {};

                summaryItem.functions.forEach(function (summaryItemFunction) {
                    data[summaryItem.dataField][summaryItemFunction] = 0;
                });
            }

            if (data[summaryItem.dataField]['avg'] !== undefined) {
                const value = data[summaryItem.dataField]['avg'];
                const dataValues = summaryByDataField[summaryItem.dataField];

                if (dataValues === 0 || dataValues === undefined) {
                    data[summaryItem.dataField]['avg'] = 0;
                }
                else {
                    data[summaryItem.dataField]['avg'] = value / dataValues;
                }
            }
            else if (data[summaryItem.dataField]['count'] !== undefined) {
                data[summaryItem.dataField]['count'] = length;
            }

            // stdev, stdevp, var, varp.
            // stdev - Standard deviation on a sample.
            // varp - Variance on an entire population.
            // let - Variance on a sample.
            if (data[summaryItem.dataField]['stdev'] || data[summaryItem.dataField]['stdevp']
                || data[summaryItem.dataField]['var'] || data[summaryItem.dataField]['varp']) {
                summaryItem.functions.forEach(function (summaryItemFunction) {
                    if (summaryItemFunction === 'stdev' || summaryItemFunction === 'var' || summaryItemFunction === 'varp' || summaryItemFunction === 'stdevp') {
                        const value = data[summaryItem.dataField][summaryItemFunction];
                        const count = length;
                        const average = (value / length);
                        let sumSq = 0.0;

                        for (let i = 0; i < length; i++) {
                            let dataItem = boundSource[i];
                            let value = dataItem[summaryItem.dataField];

                            sumSq += (value - average) * (value - average);
                        }

                        let denominator = (summaryItemFunction === 'stdevp' || summaryItemFunction === 'varp') ? count : count - 1;

                        if (denominator === 0) {
                            denominator = 1;
                        }

                        if (summaryItemFunction === 'var' || summaryItemFunction === 'varp') {
                            data[summaryItem.dataField][summaryItemFunction] = sumSq / denominator;
                        }
                        else if (summaryItemFunction === 'stdevp' || summaryItemFunction === 'stdev') {
                            data[summaryItem.dataField][summaryItemFunction] = Math.sqrt(sumSq / denominator);
                        }
                    }
                });
            }
        }
        return data;
    }

    _getDataItem(dataSourceItem, index) {
        const that = this;
        const itemObject = {};
        const unboundMode = typeof (that.dataSource) === 'number' || that.dataSourceLength;

        if (!dataSourceItem) {
            return { $: { id: index }, isEmpty: true, index: index }
        }

        if (unboundMode) {
            for (let j = 0; j < that.dataFields.length; j++) {
                const dataField = that.dataFields ? that.dataFields[j] : {};

                itemObject[dataField.name] = '';
            }

            itemObject.$ = {};
            itemObject.$.id = index;
            itemObject.$.index = index;

            return itemObject;
        }

        const dataItem = dataSourceItem;

        if (dataItem.expanded !== undefined) {
            itemObject.expanded = dataItem.expanded;

            if (dataItem.expanded === 'true' || dataItem.expanded === true || dataItem.expanded === 1) {
                itemObject.expanded = true;
            }
            else {
                itemObject.expanded = false;
            }
        }

        if (that.childrenDataField) {
            if (dataItem[that.childrenDataField] !== undefined) {
                itemObject.children = dataItem[that.childrenDataField];
            }
        }
        else {
            if (dataItem.children !== undefined) {
                itemObject.children = dataItem.children;
            }
            else if (dataItem.items !== undefined) {
                itemObject.children = dataItem.items;
            }
        }
        if (dataItem.leaf !== undefined) {
            itemObject.leaf = dataItem.leaf;
        }

        if (dataItem.level !== undefined) {
            itemObject.level = dataItem.level;
        }

        if (that.keyDataField) {
            if (dataItem[that.keyDataField] !== undefined) {
                itemObject[that.keyDataField] = dataItem[that.keyDataField];
            }
        }

        if (that.parentDataField) {
            if (dataItem[that.parentDataField] !== undefined) {
                itemObject[that.parentDataField] = dataItem[that.parentDataField];
            }
        }

        if (that.dataFields.length === 0) {
            const names = Object.getOwnPropertyNames(dataSourceItem);

            for (let i = 0; i < names.length; i++) {
                that.dataFields.push({ name: names[i], dataType: 'string' });
            }
        }

        for (let j = 0; j < that.dataFields.length; j++) {
            const dataField = that.dataFields ? that.dataFields[j] : {};
            let value = '';

            if (undefined === dataField || dataField === null) {
                continue;
            }

            if (dataSourceItem.length) {
                value = dataSourceItem[j];
            }

            if (dataField.map) {
                let splitMap = dataField.map.split(that.mapChar);

                if (splitMap.length > 0) {
                    let dataMappedItem = dataItem;

                    for (let p = 0; p < splitMap.length; p++) {
                        if (!dataItem) {
                            continue;
                        }

                        dataMappedItem = dataMappedItem[splitMap[p]];
                    }

                    value = dataMappedItem;
                }
                else {
                    value = dataItem[dataField.map];
                }
            }

            if (value !== undefined && value !== null) {
                value = value.toString();
            }
            else {
                if (value === undefined && value !== null) {
                    value = '';
                }
            }


            let isEmptyString = false;
            // searches by both selectors when necessary.
            if (value === '') {
                isEmptyString = true;
                value = dataSourceItem[dataField.name];

                if (value !== undefined && value !== null) {
                    if (dataField.dataType !== 'array') {
                        if (dataField.dataType !== 'date') {
                            value = value.toString();
                        }
                    }
                }
                else {
                    value = '';
                }
            }

            if (value === '[object Object]' && dataField.map && isEmptyString) {
                value = '';
            }

            if (that._cachedValues['' + value + '_' + dataField.dataType]) {
                value = that._cachedValues['' + value + '_' + dataField.dataType];
            }
            else {
                if (dataField.dataType === 'bool' || dataField.dataType === 'boolean') {
                    if (value === 'true' || value === '1') {
                        value = true;
                    }
                    else if (value === 'false' || value === '0') {
                        value = false;
                    }
                }
                else {
                    value = that.$document.deserialize('' + value, dataField.dataType, true);
                }

                that._cachedValues[value + '_' + dataField.dataType] = value;
            }

            if (dataField.dataType !== 'string' && dataField.dataType !== 'boolean' && dataField.dataType !== 'bool') {
                if (isNaN(value) || value === -Infinity || value === Infinity) {
                    value = 0;
                }
            }

            itemObject[dataField.name] = value;
        }

        let itemObjectId = index;

        if (that.id) {
            itemObjectId = dataItem[that.id];
            if (typeof (itemObjectId) === 'object') {
                itemObjectId = index;
            }
        }
        else if (that.dataItemById && that.dataItemById[itemObjectId]) {
            itemObjectId = that.length;
        }

        if (!itemObject.$) {
            itemObject.$ = {};
        }

        itemObject.$.id = itemObjectId;
        itemObject.$.index = index;

        return new Object(itemObject);
    }

    _bindToArray() {
        const that = this;

        const unboundMode = typeof (that.dataSource) === 'number' || that.dataSourceLength;
        const dataArray = [];

        that.boundSource.canNotify = false;

        for (let i = 0; i < that.length; i++) {
            const dataSourceItem = unboundMode ? {} : that.dataSource[i];
            const itemObject = that._getDataItem(dataSourceItem, i);

            dataArray.push(itemObject);
        }

        if (unboundMode && that.dataSourceLength && that.dataSource.length > 0) {
            for(let i = 0; i < that.dataSource.length; i++) {
                const cell = that.dataSource[i].cell;
                const value = that.dataSource[i].value;

                const row = cell.replace(/[^0-9]/g, '');
                const dataField = cell.replace(/[0-9]/g, '');
            
                dataArray[row-1][dataField] = value;
            }
        }

        that.boundSource = false === that.observable ? dataArray : new JQX.ObservableArray(dataArray);

        for (let i = 0; i < that.length; i++) {
            that[i] = that.boundSource[i];
            that.dataItemById[that[i].$.id] = that[i];
        }

        that.boundSource.canNotify = true;
    }

    _bindToJSON() {
        const that = this;

        const dataArray = [];

        const dataEntries = Object.entries(that.dataSource);

        that.boundSource.canNotify = false;

        for (let i = 0; i < dataEntries.length; i++) {
            const dataSourceItem = dataEntries[i];
            const itemObject = that._getDataItem(dataSourceItem, i);

            dataArray.push(itemObject);
        }

        that.boundSource = false === that.observable ? dataArray : new JQX.ObservableArray(dataArray);

        for (let i = 0; i < that.length; i++) {
            that[i] = that.boundSource[i];
            that.dataItemById[that[i].$.id] = that[i];
        }

        that.boundSource.canNotify = true;
    }

    sortBy(dataField, dataType, orderBy) {
        const that = this;

        if (!dataType) {
            for (let i = 0; i < that.dataFields.length; i++) {
                const field = that.dataFields[i];

                if (field.name === dataField) {
                    dataType = field.dataType;
                    break;
                }
            }
        }

        if (that.boundHierarchy) {
            const sortBy = function (hierarchy) {
                that._sort(hierarchy, dataField, orderBy, dataType);

                for (let i = 0; i < hierarchy.length; i++) {
                    const item = hierarchy[i];

                    if (item['children']) {
                        sortBy(item['children'], dataField, orderBy, dataType);
                    }
                }
            }

            sortBy(that.boundHierarchy);
        }
        else {
            that._sort(that.boundSource, dataField, orderBy, dataType);
        }
    }

    _createFilter(dataType, filterExpressions) {
        const filterOperators = {
            '=': 'EQUAL',
            '<>': 'NOT_EQUAL',
            '<': 'LESS_THAN',
            '>': 'GREATER_THAN',
            '<=': 'LESS_THAN_OR_EQUAL',
            '>=': 'GREATER_THAN_OR_EQUAL',
            'equal': 'EQUAL',
            'not equal': 'NOT_EQUAL',
            'less than': 'LESS_THAN',
            'greater than': 'GREATER_THAN',
            'greater than or equal': 'GREATER_THAN_OR_EQUAL',
            'less than or equal': 'LESS_THAN_OR_EQUAL',
            'starts with': 'STARTS_WITH',
            'ends with': 'ENDS_WITH',
            'null': 'null',
            '': 'EMPTY',
            'isblank': 'EMPTY',
            'isnotblank': 'NOT_EMPTY',
            'contains': 'CONTAINS',
            'notcontains': 'DOES_NOT_CONTAIN',
            'startswith': 'STARTS_WITH',
            'endswith': 'ENDS_WITH',
            'NULL': 'NULL',
            'NOT_NULL': 'NOT_NULL'
        };

        let filterExpressionsArray = [];

        for (let i = 0; i < filterExpressions.length; i++) {
            const filterExpression = filterExpressions[i];

            const filterExpressionParts = filterExpression.indexOf('"') === -1 ? filterExpression.split(' ') : filterExpression.split('"');
            let filter = [];

            for (let j = 0; j < filterExpressionParts.length; j++) {
                const part = filterExpressionParts[j];

                if (part !== '') {
                    filter.push(part.trim());
                }
            }

            filterExpressionsArray.push(filter);
        }

        const filterGroup = new JQX.FilterGroup();
        const filterGroupOperators = [];
        const filterSubGroups = [];

        for (let i = 0; i < filterExpressionsArray.length; i++) {
            const filterExpression = filterExpressionsArray[i];


            if (filterExpression.length > 1) {
                const filterSubGroup = new JQX.FilterGroup();

                let operator = 'and';
                let filterExpressionPartsCounter = 0;

                for (let j = 0; j < filterExpression.length; j++) {
                    const value = filterExpression[j];

                    if (value === 'and' || value === 'or') {
                        operator = value;
                        continue;
                    }

                    filterExpressionPartsCounter++;

                    if (filterExpressionPartsCounter === 2) {
                        const filter = filterSubGroup.createFilter(dataType, value, filterOperators[filterExpression[j - 1]]);

                        filterExpressionPartsCounter = 0;

                        if (operator) {
                            filterSubGroup.addFilter(operator, filter);
                        }
                    }
                }

                filterSubGroups.push(filterSubGroup);
            }
            else {
                const filterGroupOperator = filterExpression[0];

                if (filterGroupOperator !== 'and' && filterGroupOperator !== 'or') {
                    throw new Error('Filter Exprresion expects "AND" or "OR", but the token is: ' + filterGroupOperator);
                }

                filterGroupOperators.push(filterGroupOperator);
            }
        }

        let operatorsCounter = 0;

        if (filterSubGroups.length === 1) {
            return filterSubGroups[0];
        }

        for (let i = 0; i < filterSubGroups.length; i++) {
            let operator = filterGroupOperators[operatorsCounter];

            if ((i + 1) % 2 === 0) {
                operatorsCounter++;
            }

            if (!operator) {
                operator = 'and';
            }

            filterGroup.addFilter(operator, filterSubGroups[i]);
        }

        return filterGroup;
    }

    filterBy(dataField, ...filterExpressions) {
        const that = this;


        const dataType = (() => {
            for (let i = 0; i < that.dataFields.length; i++) {
                const field = that.dataFields[i];

                if (field.name === dataField) {
                    return field.dataType;
                }
            }
        })();


        const filterGroup = that._createFilter(dataType, filterExpressions);

        let filteredData = that.boundSource.filter((value) => {
            const evaluation = filterGroup.evaluate(value[dataField]);

            return evaluation;
        });

        return filteredData;
    }

    _filter(filters, operator = 'and') {
        const that = this;
        const filterGroups = [];
        const dataFields = [];

        if (filters.length === 0) {
            that.clearFilter();
            return;
        }

        const dataType = (dataField) => {
            for (let i = 0; i < that.dataFields.length; i++) {
                const field = that.dataFields[i];

                if (field.name === dataField) {
                    return field.dataType;
                }
            }
        };
        let defaultResult, operatorSpecificEval;

        if (operator === 'and') {
            defaultResult = true;
            operatorSpecificEval = function (result, filterGroup, row) {
                return result && filterGroup.evaluate(row[filterGroup.dataField]);
            };
        }
        else {
            defaultResult = false;
            operatorSpecificEval = function (result, filterGroup, row) {
                return result || filterGroup.evaluate(row[filterGroup.dataField]);
            };
        }

        for (let i = 0; i < filters.length; i++) {
            const filter = filters[i];
            const dataField = filter[0];
            let filterGroup = null;

            if (filter[1] instanceof JQX.FilterGroup) {
                filterGroup = filter[1];
            }
            else {
                filterGroup = that._createFilter(dataType(dataField), filter.splice(1));
            }

            if (filterGroup) {
                dataFields.push(dataField);
                filterGroup.dataField = dataField;
                filterGroups.push(filterGroup);
            }
        }

        if (that.boundHierarchy) {
            const filter = function (row) {
                let result = defaultResult;

                for (let j = 0; j < filterGroups.length; j++) {
                    const filterGroup = filterGroups[j];

                    result = operatorSpecificEval(result, filterGroup, row);
                }

                row.$.filtered = result;

                return result;
            }

            const filterBy = function (hierarchy, parentItem, root) {
                let filteredCount = 0;

                for (let i = 0; i < hierarchy.length; i++) {
                    const item = hierarchy[i];

                    filter(item);

                    if (item.$.filtered) {
                        filteredCount++;
                    }

                    if (item['children']) {
                        filterBy(item['children'], item, parentItem);
                    }
                }

                if (filteredCount > 0 && that.groupBy.length > 0 && parentItem) {
                    parentItem.$.filtered = true;

                    if (root && !root.$.filtered) {
                        root.$.filtered = true;
                    }
                }
                else {
                    if (filteredCount > 0 && filteredCount !== hierarchy.length && parentItem) {
                        parentItem.$.filtered = null;

                        if (root && !root.$.filtered) {
                            root.$.filtered = null;
                        }
                    }
                }
            }

            filterBy(that.boundHierarchy, null, null);
        }
        else {
            for (let i = 0; i < that.boundSource.length; i++) {
                const row = that.boundSource[i];

                let result = defaultResult;

                for (let j = 0; j < filterGroups.length; j++) {
                    const filterGroup = filterGroups[j];

                    result = operatorSpecificEval(result, filterGroup, row);
                }

                row.$.filtered = result;
            }
        }

        if (that.onFilter) {
            that.onFilter()
        }
    }

        clearGroup() {
            const that = this;

            that.groupBy = [];
            that.boundHierarchy = null;
            that.refreshHierarchy();

            if (that.onGroup) {
                that.onGroup()
            }
        }

        clearFilter() {
            const that = this;

            for (let i = 0; i < that.boundSource.length; i++) {
                const row = that.boundSource[i];

                row.$.filtered = true;
            }

            if (that.boundHierarchy) {
                const filterBy = function (hierarchy, parentItem, root) {
                    //let filteredCount = 0;

                    for (let i = 0; i < hierarchy.length; i++) {
                        const item = hierarchy[i];

                        item.$.filtered = true;

                        //if (item.$.filtered) {
                        //    filteredCount++;
                        //}

                        if (item['children']) {
                            filterBy(item['children'], item, parentItem);
                        }
                    }

                    if (parentItem) {
                        parentItem.$.filtered = true;

                        if (root && !root.$.filtered) {
                            root.$.filtered = true;
                        }
                    }
                }

                filterBy(that.boundHierarchy, null, null);
            }

            if (that.onFilter) {
                that.onFilter()
            }
        }

        clearSort() {
            const that = this;

            that._sort(that.boundSource, [], [], []);
        }

        _sort(dataSource, sortColumns, directions, dataTypes, customSortingCallback) {
            const that = this;

            let isObservableArray = false;

            if (dataSource.length === 0) {
                return;
            }

            if (dataSource && dataSource.constructor && dataSource instanceof JQX.ObservableArray) {
                isObservableArray = true;
            }

            if (!dataSource || !(Array.isArray(dataSource)) || dataSource.length === 0 ||
                !sortColumns || Array.isArray(sortColumns) && sortColumns.length === 0) {
                if (!isObservableArray && !that.boundHierarchy) {
                    throw new Error('sort: Missing or Invalid arguments!');
                }
            }

            if (typeof sortColumns === 'string') {
                sortColumns = [sortColumns];
            }

            const directionCoefficients = [],
                compareFunctions = [];

            if (directions === undefined) {
                directions = [];
            }

            const getCompareFunction = function (a, knownDataType) {
                // gets data type of column (not necessary if the Grid provides this information)
                const dataType = knownDataType || typeof a;
                let compareFunction;

                switch (dataType) {
                    case 'string':
                        compareFunction = new Intl.Collator().compare;
                        break;
                    case 'number':
                        compareFunction = function (a, b) {
                            return a - b;
                        };
                        break;
                    case 'boolean':
                    case 'bool':
                        compareFunction = function (a, b) {
                            if (a === b) {
                                return 0;
                            }
                            else if (a === false) {
                                return -1;
                            }
                            else {
                                return 1;
                            }
                        };
                        break;
                    case 'date':
                    case 'time':
                    case 'dateTime':
                        if (a instanceof Date) {
                            compareFunction = function (a, b) {
                                return a.getTime() - b.getTime();
                            };
                        }
                        else if (a instanceof JQX.Utilities.DateTime ||
                            a instanceof JQX.Utilities.BigNumber) {
                            compareFunction = function (a, b) {
                                return a.compare(b);
                            };
                        }
                        break;
                    case 'object':
                        if (a instanceof Date) {
                            compareFunction = function (a, b) {
                                return a.getTime() - b.getTime();
                            };
                        }
                        else if (a instanceof JQX.Utilities.DateTime ||
                            a instanceof JQX.Utilities.BigNumber) {
                            compareFunction = function (a, b) {
                                return a.compare(b);
                            };
                        }
                        else if (a instanceof JQX.Utilities.Complex || (window.NIComplex && a instanceof window.NIComplex)) {
                            const complexNumericProcessor = new JQX.Utilities.ComplexNumericProcessor();

                            compareFunction = function (a, b) {
                                return complexNumericProcessor.compareComplexNumbers(a, b);
                            }
                        }

                        break;
                }

                return compareFunction;
            }

            for (let i = 0; i < sortColumns.length; i++) {
                if (directions[i] === undefined || directions[i] === 'asc' || directions[i] === 'ascending') {
                    directionCoefficients[i] = 1;
                }
                else {
                    directionCoefficients[i] = -1;
                }

                const value = dataSource[0][sortColumns[i]];

                compareFunctions[i] = getCompareFunction(value, dataTypes[i]);
            }

            if (customSortingCallback) {
                customSortingCallback(dataSource, sortColumns, directions, compareFunctions);
                return;
            }

            dataSource.sort(function (a, b) {
                for (let i = 0; i < sortColumns.length; i++) {
                    const result = compareFunctions[i](a[sortColumns[i]], b[sortColumns[i]]);

                    if (result === 0) {
                        if (sortColumns[i + 1]) {
                            continue;
                        }
                        else if (a._index !== undefined) {
                            // makes sorting stable
                            return (a._index - b._index) * directionCoefficients[i];
                        }

                        return 0;
                    }

                    return result * directionCoefficients[i];
                }

                if (sortColumns.length === 0) {
                    if (a.$.index < b.$.index) {
                        return -1;
                    }

                    if (a.$.index > b.$.index) {
                        return 1;
                    }

                    return 0;

                }
            });

            for (let i = 0; i < dataSource.length; i++) {
                that[i] = dataSource[i];
            }
        }

    static Filter(dataSource, filterColumns, filterGroups, customFilteringCallback) {
        const filteredData = dataSource.filter((dataItem) => {
            let result = true;

            for (let i = 0; i < filterGroups.length; i++) {
                const filterGroup = filterGroups[i];
                const filterColumn = filterColumns[i];

                if (customFilteringCallback) {
                    result = result && customFilteringCallback(dataItem, filterColumn, filterGroup);
                }
                else {
                    result = result && filterGroup.evaluate(dataItem[filterColumn]);
                }
            }

            return result;
        });

        return filteredData;
    }

        filter(filterColumns, filterGroups, customFilteringCallback) {
            JQX.DataAdapter.Filter(this.boundSource, filterColumns, filterGroups, customFilteringCallback);
        }

        sort(sortColumns, directions, customSortingCallback) {
            JQX.DataAdapter.Sort(this.boundSource, sortColumns, directions, customSortingCallback);
        }

    static Sort(dataSource, sortColumns, directions, customSortingCallback) {
        const getCompareFunction = function (a) {
            // gets data type of column (not necessary if the Grid provides this information)
            const dataType = typeof a;
            let compareFunction;

            switch (dataType) {
                case 'string':
                    compareFunction = new Intl.Collator().compare;
                    break;
                case 'number':
                    compareFunction = function (a, b) {
                        return a - b;
                    };
                    break;
                case 'boolean':
                    compareFunction = function (a, b) {
                        if (a === b) {
                            return 0;
                        }
                        else if (a === false) {
                            return -1;
                        }
                        else {
                            return 1;
                        }
                    };
                    break;
                case 'object':
                    if (a instanceof Date) {
                        compareFunction = function (a, b) {
                            return a.getTime() - b.getTime();
                        };
                    }
                    else if (a instanceof JQX.Utilities.DateTime ||
                        a instanceof BigNumberNG) {
                        compareFunction = function (a, b) {
                            return a.compare(b);
                        };
                    }
                    else if (a instanceof JQX.Utilities.Complex || (window.NIComplex && a instanceof window.NIComplex)) {
                        const complexNumericProcessor = new JQX.Utilities.ComplexNumericProcessor();

                        compareFunction = function (a, b) {
                            return complexNumericProcessor.compareComplexNumbers(a, b);
                        }
                    }

                    break;
            }

            return compareFunction;
        }

        if (!dataSource || !(Array.isArray(dataSource)) || dataSource.length === 0 ||
            !sortColumns || Array.isArray(sortColumns) && sortColumns.length === 0) {
            return;
        }

        if (typeof sortColumns === 'string') {
            sortColumns = [sortColumns];
        }

        const directionCoefficients = [],
            compareFunctions = [];

        if (directions === undefined) {
            directions = [];
        }

        for (let i = 0; i < sortColumns.length; i++) {
            if (directions[i] === undefined || directions[i] === 'asc' || directions[i] === 'ascending') {
                directionCoefficients[i] = 1;
            }
            else {
                directionCoefficients[i] = -1;
            }

            compareFunctions[i] = getCompareFunction(dataSource[0][sortColumns[i]]);
        }

        if (customSortingCallback) {
            customSortingCallback(dataSource, sortColumns, directions, compareFunctions);
            return;
        }

        const sortedData = dataSource.slice(0);

        sortedData.sort(function (a, b) {
            for (let i = 0; i < sortColumns.length; i++) {
                const result = compareFunctions[i](a[sortColumns[i]], b[sortColumns[i]]);

                if (result === 0) {
                    if (sortColumns[i + 1]) {
                        continue;
                    }
                    else if (a._index !== undefined) {
                        // makes sorting stable
                        return (a._index - b._index) * directionCoefficients[i];
                    }

                    return 0;
                }

                return result * directionCoefficients[i];
            }
        });

        return sortedData;
    }
    }

    JQX.DataAdapter = DataAdapter;

// eslint-disable-next-line
class Ajax {
    constructor(config, callback) {
        const that = this;

        that.config = config;
        that.callback = callback;

        if (config.autoFetch === false) {
            return;
        }

        that.call(config);
    }
    
    call(config) {
        const that = this;

        if (!config) {
            config = that.config;
        }

        let method = 'GET',
        url = config.url,
        body = null,
        async = true;

        if (config.type) {
            method = config.type;
        }

        if (config.data) {
            if (method === 'GET') {
                url += '?';

                for (let prop in config.data) {
                    if (config.data.hasOwnProperty(prop)) {
                        url += encodeURI(prop + '=' + config.data[prop] + '&');
                    }
                }

                if (url.charAt(url.length - 1) === '&') {
                    url = url.slice(0, url.length - 1);
                }
            }
            else if (method === 'POST') {
                body = JSON.stringify(config.data);
            }
        }

        if (config && config.async === false && config.dataSourceType !== 'xlsx') {
            async = false;
        }

        if (window.fetch !== undefined && async) {
            that.ajaxFetch(config, method, url, body);
        }
        else {
            that.ajaxXMLHttpRequest(config, method, url, body, async);
        }
    }

    ajaxFetch(config, method, url, body) {
        // prepare fetch config
        const that = this;
        const fetchInit = { method: method };
        let parseMethod;
    
        switch (config.dataSourceType) {
            case 'json':
                parseMethod = 'json';
                break;
            case 'xlsx':
                parseMethod = 'arrayBuffer';
                break;
            default:
                parseMethod = 'text';
        }
    
        if (config) {
            if (config.contentType) {
                fetchInit.headers = new Headers({
                    'Content-Type': config.contentType
                });
            }
        }
    
        if (body !== null) {
            fetchInit.body = body;
        }
    
        let status, fetchTimeout, timeouted;
    
        if (config.timeout) {
            fetchTimeout = setTimeout(function () {
                timeouted = true;
            }, config.timeout);
        }
    
        if (config.beforeSend) {
            const beforeSendResult = config.beforeSend(fetchInit, config);
    
            if (beforeSendResult === false) {
                return;
            }
        }
    
        // fetch resource
        fetch(url, fetchInit)
            .then(function (response) {
                if (timeouted) {
                    status = 408;
                    throw new Error('timeout');
                }
    
                if (fetchTimeout) {
                    clearTimeout(fetchTimeout);
                }
    
                status = response.status;
    
                if (!response.ok) {
                    throw new Error(response.statusText);
                }
    
                return response[parseMethod]();
            })
            .then(function (data) {
                if (parseMethod === 'arrayBuffer') {
                    return JSZip.loadAsync(data).then(function (zipData) {
                        // "data" represents the whole XLSX/ZIP file
                        return zipData.files['xl/worksheets/sheet1.xml'].async('text').then(function (sheet1) {
                            return zipData.files['xl/sharedStrings.xml'].async('text').then(function (sharedStrings) {
                                const parsedData = that.parseXLSXData(sheet1, sharedStrings);
    
                                that.ajaxComplete(config, parsedData, status);
                            });
                        });
                    });
                }
                else {
                    that.ajaxComplete(config, data, status);
                }
            })
            .catch(function (error) {
                if (error.message === 'JSZip is not defined') {
                    error.message = 'JSZip is not defined. Please include a reference to JSZip to be able to load data from XLSX files.';
                }
    
                if (config && config.loadError) {
                    config.loadError(status, error);
                }

                if (that.callback) {
                    that.callback(error, status);
                }
            });
    }
    
    ajaxXMLHttpRequest(config, method, url, body, async) {
        const request = new XMLHttpRequest();
        const that = this;

        request.open(method, url, async);
    
        request.ontimeout = function () {
            if (config && config.loadError) {
                config.loadError(408, 'timeout');
            }
        };
    
        request.onload = function () {
            if (request.readyState === 4) {
                const status = request.status;
                let data = request.response;
    
                if (status >= 200 && status <= 299) {
                    if (config.dataSourceType === 'json') {
                        data = JSON.parse(data);
                    }
    
                    that.ajaxComplete(config, data, status);
                }
                else if (config && config.loadError) {
                    config.loadError(status, data);
                }
            }
        };
    
        request.onerror = function () {
            if (config && config.loadError) {
                config.loadError(request.status, request.response);
            }
        };
    
        if (config && config.contentType) {
            request.setRequestHeader('Content-Type', config.contentType);
        }
    
        if (async && config.timeout) {
            request.timeout = config.timeout;
        }
    
        if (config.beforeSend) {
            const beforeSendResult = config.beforeSend(request, config);
    
            if (beforeSendResult === false) {
                return;
            }
        }
    
        request.send(body);
    }
    
    ajaxComplete(config, data, status) {
        if (!config) {
            return;
        }
    
        if (config.beforeLoadComplete) {
            const processedData = config.beforeLoadComplete(data);
    
            if (processedData) {
                data = processedData;
            }
        }
    
        if (config.loadComplete) {
            config.loadComplete(data, status);
        }

        if (this.callback) {
            this.callback(data, status);
        }
    }
    
    parseXLSXData(sheet1, sharedStrings) {
        const parser = new DOMParser(),
            sharedStringsDocument = parser.parseFromString(sharedStrings, 'text/xml'),
            sharedStringsContainers = Array.from(sharedStringsDocument.getElementsByTagName('si')),
            sharedStringsCollection = [],
            sheet1Document = parser.parseFromString(sheet1, 'text/xml'),
            rows = Array.from(sheet1Document.getElementsByTagName('row')),
            parsedData = [];
    
        sharedStringsContainers.forEach(function (si) {
            let texts = si.getElementsByTagName('t');
    
            if (texts.length === 1) {
                sharedStringsCollection.push(texts[0].innerHTML);
            }
            else {
                let text = '';
    
                texts = Array.from(texts);
                texts.forEach(function (t) {
                    text += t.innerHTML;
                });
                sharedStringsCollection.push(text);
            }
        });
    
        rows.forEach(function (row) {
            const rowObject = {},
                cells = Array.from(row.getElementsByTagName('c'));
    
            cells.forEach(function (cell/*, index*/) {
                const column = cell.getAttribute('r').match(/\D+/)[0],
                    type = cell.getAttribute('t'),
                    xmlValue = cell.getElementsByTagName('v')[0].innerHTML;
                let value;
    
                switch (type) {
                    case 's':
                        // string                    
                        value = sharedStringsCollection[parseFloat(xmlValue)];
                        break;
                    case 'b':
                        // boolean
                        value = parseFloat(xmlValue) === 1;
                        break;
                    default:
                        // number or date
                        value = parseFloat(xmlValue);
                }
    
                rowObject[column] = value;
            });
    
            parsedData.push(rowObject);
        });
    
        return parsedData;
    }    
}
const localTimezoneOffset = -1 * new Date().getTimezoneOffset();

const __timeZones = [
    { id: 'Local', offset: localTimezoneOffset, offsetHours: localTimezoneOffset / 60, displayName: '', supportsDaylightSavingTime: false },
    { id: 'Dateline Standard Time', offset: -720, offsetHours: -12, displayName: '(UTC-12:00) International Date Line West', supportsDaylightSavingTime: false },
    { id: 'UTC-11', offset: -660, offsetHours: -11, displayName: '(UTC-11:00) Coordinated Universal Time-11', supportsDaylightSavingTime: false },
    { id: 'Hawaiteratoran Standard Time', offset: -600, offsetHours: -10, displayName: '(UTC-10:00) Hawaiterator', supportsDaylightSavingTime: false },
    { id: 'Alaskan Standard Time', offset: -540, offsetHours: -9, displayName: '(UTC-09:00) Alaska', supportsDaylightSavingTime: true },
    { id: 'Pacific Standard Time (Mexico)', offset: -480, offsetHours: -8, displayName: '(UTC-08:00) Baja California', supportsDaylightSavingTime: true },
    { id: 'Pacific Standard Time', offset: -480, offsetHours: -8, displayName: '(UTC-08:00) Pacific Time (US & Canada)', supportsDaylightSavingTime: true },
    { id: 'US Mountain Standard Time', offset: -420, offsetHours: -7, displayName: '(UTC-07:00) Arizona', supportsDaylightSavingTime: false },
    { id: 'Mountain Standard Time (Mexico)', offset: -420, offsetHours: -7, displayName: '(UTC-07:00) Chihuahua, La Paz, Mazatlan', supportsDaylightSavingTime: true },
    { id: 'Mountain Standard Time', offset: -420, offsetHours: -7, displayName: '(UTC-07:00) Mountain Time (US & Canada)', supportsDaylightSavingTime: true },
    { id: 'Central Standard Time', offset: -360, offsetHours: -6, displayName: '(UTC-06:00) Central Time (US & Canada)', supportsDaylightSavingTime: true },
    { id: 'Central America Standard Time', offset: -360, offsetHours: -6, displayName: '(UTC-06:00) Central America', supportsDaylightSavingTime: false },
    { id: 'Canada Central Standard Time', offset: -360, offsetHours: -6, displayName: '(UTC-06:00) Saskatchewan', supportsDaylightSavingTime: false },
    { id: 'Central Standard Time (Mexico)', offset: -360, offsetHours: -6, displayName: '(UTC-06:00) Guadalajara, Mexico City, Monterrey', supportsDaylightSavingTime: true },
    { id: 'SA Pacific Standard Time', offset: -300, offsetHours: -5, displayName: '(UTC-05:00) Bogota, Lima, Quito, Rio Branco', supportsDaylightSavingTime: false },
    { id: 'Eastern Standard Time', offset: -300, offsetHours: -5, displayName: '(UTC-05:00) Eastern Time (US & Canada)', supportsDaylightSavingTime: true },
    { id: 'US Eastern Standard Time', offset: -300, offsetHours: -5, displayName: '(UTC-05:00) Indiana (East)', supportsDaylightSavingTime: true },
    { id: 'Venezuela Standard Time', offset: -270, offsetHours: -4.5, displayName: '(UTC-04:30) Caracas', supportsDaylightSavingTime: false },
    { id: 'Atlantic Standard Time', offset: -240, offsetHours: -4, displayName: '(UTC-04:00) Atlantic Time (Canada)', supportsDaylightSavingTime: true },
    { id: 'Paraguay Standard Time', offset: -240, offsetHours: -4, displayName: '(UTC-04:00) Asuncion', supportsDaylightSavingTime: true },
    { id: 'Central Brazilian Standard Time', offset: -240, offsetHours: -4, displayName: '(UTC-04:00) Cuiaba', supportsDaylightSavingTime: true },
    { id: 'Pacific SA Standard Time', offset: -240, offsetHours: -4, displayName: '(UTC-04:00) Santiago', supportsDaylightSavingTime: true },
    { id: 'SA Western Standard Time', offset: -240, offsetHours: -4, displayName: '(UTC-04:00) Georgetown, La Paz, Manaus, San Juan', supportsDaylightSavingTime: false },
    { id: 'Newfoundland Standard Time', offset: -210, offsetHours: -3.5, displayName: '(UTC-03:30) Newfoundland', supportsDaylightSavingTime: true },
    { id: 'SA Eastern Standard Time', offset: -180, offsetHours: -3, displayName: '(UTC-03:00) Cayenne, Fortaleza', supportsDaylightSavingTime: false },
    { id: 'Argentina Standard Time', offset: -180, offsetHours: -3, displayName: '(UTC-03:00) Buenos Aires', supportsDaylightSavingTime: true },
    { id: 'E. South America Standard Time', offset: -180, offsetHours: -3, displayName: '(UTC-03:00) Brasilia', supportsDaylightSavingTime: true },
    { id: 'Bahia Standard Time', offset: -180, offsetHours: -3, displayName: '(UTC-03:00) Salvador', supportsDaylightSavingTime: true },
    { id: 'Montevideo Standard Time', offset: -180, offsetHours: -3, displayName: '(UTC-03:00) Montevideo', supportsDaylightSavingTime: true },
    { id: 'Greenland Standard Time', offset: -180, offsetHours: -3, displayName: '(UTC-03:00) Greenland', supportsDaylightSavingTime: true },
    { id: 'UTC-02', offset: -120, offsetHours: -2, displayName: '(UTC-02:00) Coordinated Universal Time-02', supportsDaylightSavingTime: false },
    { id: 'Mid-Atlantic Standard Time', offset: -120, offsetHours: -2, displayName: '(UTC-02:00) Mid-Atlantic - Old', supportsDaylightSavingTime: true },
    { id: 'Azores Standard Time', offset: -60, offsetHours: -1, displayName: '(UTC-01:00) Azores', supportsDaylightSavingTime: true },
    { id: 'Cape Verde Standard Time', offset: -60, offsetHours: -1, displayName: '(UTC-01:00) Cape Verde Is.', supportsDaylightSavingTime: false },
    { id: 'Morocco Standard Time', offset: 0, offsetHours: 0, displayName: '(UTC) Casablanca', supportsDaylightSavingTime: true },
    { id: 'UTC', offset: 0, offsetHours: 0, displayName: '(UTC) Coordinated Universal Time', supportsDaylightSavingTime: false },
    { id: 'GMT Standard Time', offset: 0, offsetHours: 0, displayName: '(UTC) Dublin, Edinburgh, Lisbon, London', supportsDaylightSavingTime: true },
    { id: 'Greenwich Standard Time', offset: 0, offsetHours: 0, displayName: '(UTC) Monrovia, Reykjavik', supportsDaylightSavingTime: false },
    { id: 'Central European Standard Time', offset: 60, offsetHours: 1, displayName: '(UTC+01:00) Sarajevo, Skopje, Warsaw, Zagreb', supportsDaylightSavingTime: true },
    { id: 'Namibia Standard Time', offset: 60, offsetHours: 1, displayName: '(UTC+01:00) Windhoek', supportsDaylightSavingTime: true },
    { id: 'W. Central Africa Standard Time', offset: 60, offsetHours: 1, displayName: '(UTC+01:00) West Central Africa', supportsDaylightSavingTime: false },
    { id: 'W. Europe Standard Time', offset: 60, offsetHours: 1, displayName: '(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna', supportsDaylightSavingTime: true },
    { id: 'Central Europe Standard Time', offset: 60, offsetHours: 1, displayName: '(UTC+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague', supportsDaylightSavingTime: true },
    { id: 'Romance Standard Time', offset: 60, offsetHours: 1, displayName: '(UTC+01:00) Brussels, Copenhagen, Madrid, Paris', supportsDaylightSavingTime: true },
    { id: 'FLE Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius', supportsDaylightSavingTime: true },
    { id: 'South Africa Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) Harare, Pretoria', supportsDaylightSavingTime: false },
    { id: 'Turkey Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) Istanbul', supportsDaylightSavingTime: true },
    { id: 'GTB Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) Athens, Bucharest', supportsDaylightSavingTime: true },
    { id: 'Libya Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) Tripoli', supportsDaylightSavingTime: true },
    { id: 'E. Europe Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) E. Europe', supportsDaylightSavingTime: true },
    { id: 'Jordan Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) Amman', supportsDaylightSavingTime: true },
    { id: 'Middle East Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) Beirut', supportsDaylightSavingTime: true },
    { id: 'Egypt Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) Cairo', supportsDaylightSavingTime: true },
    { id: 'Syria Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) Damascus', supportsDaylightSavingTime: true },
    { id: 'Israel Standard Time', offset: 120, offsetHours: 2, displayName: '(UTC+02:00) Jerusalem', supportsDaylightSavingTime: true },
    { id: 'Arab Standard Time', offset: 180, offsetHours: 3, displayName: '(UTC+03:00) Kuwait, Riyadh', supportsDaylightSavingTime: false },
    { id: 'E. Africa Standard Time', offset: 180, offsetHours: 3, displayName: '(UTC+03:00) Nairobi', supportsDaylightSavingTime: false },
    { id: 'Arabic Standard Time', offset: 180, offsetHours: 3, displayName: '(UTC+03:00) Baghdad', supportsDaylightSavingTime: true },
    { id: 'Kaliningrad Standard Time', offset: 180, offsetHours: 3, displayName: '(UTC+03:00) Kaliningrad, Minsk', supportsDaylightSavingTime: true },
    { id: 'Iran Standard Time', offset: 210, offsetHours: 3.5, displayName: '(UTC+03:30) Tehran', supportsDaylightSavingTime: true },
    { id: 'Mauritius Standard Time', offset: 240, offsetHours: 4, displayName: '(UTC+04:00) Port Louis', supportsDaylightSavingTime: true },
    { id: 'Georgian Standard Time', offset: 240, offsetHours: 4, displayName: '(UTC+04:00) Tbilisi', supportsDaylightSavingTime: false },
    { id: 'Caucasus Standard Time', offset: 240, offsetHours: 4, displayName: '(UTC+04:00) Yerevan', supportsDaylightSavingTime: true },
    { id: 'Arabian Standard Time', offset: 240, offsetHours: 4, displayName: '(UTC+04:00) Abu Dhabi, Muscat', supportsDaylightSavingTime: false },
    { id: 'Azerbaijan Standard Time', offset: 240, offsetHours: 4, displayName: '(UTC+04:00) Baku', supportsDaylightSavingTime: true },
    { id: 'Russian Standard Time', offset: 240, offsetHours: 4, displayName: '(UTC+04:00) Moscow, St. Petersburg, Volgograd', supportsDaylightSavingTime: true },
    { id: 'Afghanistan Standard Time', offset: 270, offsetHours: 4.5, displayName: '(UTC+04:30) Kabul', supportsDaylightSavingTime: false },
    { id: 'Pakistan Standard Time', offset: 300, offsetHours: 5, displayName: '(UTC+05:00) Islamabad, Karachi', supportsDaylightSavingTime: true },
    { id: 'West Asia Standard Time', offset: 300, offsetHours: 5, displayName: '(UTC+05:00) Ashgabat, Tashkent', supportsDaylightSavingTime: false },
    { id: 'India Standard Time', offset: 330, offsetHours: 5.5, displayName: '(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi', supportsDaylightSavingTime: false },
    { id: 'Sri Lanka Standard Time', offset: 330, offsetHours: 5.5, displayName: '(UTC+05:30) Sri Jayawardenepura', supportsDaylightSavingTime: false },
    { id: 'Nepal Standard Time', offset: 345, offsetHours: 5.75, displayName: '(UTC+05:45) Kathmandu', supportsDaylightSavingTime: false },
    { id: 'Central Asia Standard Time', offset: 360, offsetHours: 6, displayName: '(UTC+06:00) Astana', supportsDaylightSavingTime: false },
    { id: 'Bangladesh Standard Time', offset: 360, offsetHours: 6, displayName: '(UTC+06:00) Dhaka', supportsDaylightSavingTime: true },
    { id: 'Ekaterinburg Standard Time', offset: 360, offsetHours: 6, displayName: '(UTC+06:00) Ekaterinburg', supportsDaylightSavingTime: true },
    { id: 'Myanmar Standard Time', offset: 390, offsetHours: 6.5, displayName: '(UTC+06:30) Yangon (Rangoon)', supportsDaylightSavingTime: false },
    { id: 'SE Asia Standard Time', offset: 420, offsetHours: 7, displayName: '(UTC+07:00) Bangkok, Hanoi, Jakarta', supportsDaylightSavingTime: false },
    { id: 'N. Central Asia Standard Time', offset: 420, offsetHours: 7, displayName: '(UTC+07:00) Novosibirsk', supportsDaylightSavingTime: true },
    { id: 'Ulaanbaatar Standard Time', offset: 480, offsetHours: 8, displayName: '(UTC+08:00) Ulaanbaatar', supportsDaylightSavingTime: false },
    { id: 'China Standard Time', offset: 480, offsetHours: 8, displayName: '(UTC+08:00) Beijing, Chongqing, Hong Kong, Urumqi', supportsDaylightSavingTime: false },
    { id: 'Singapore Standard Time', offset: 480, offsetHours: 8, displayName: '(UTC+08:00) Kuala Lumpur, Singapore', supportsDaylightSavingTime: false },
    { id: 'North Asia Standard Time', offset: 480, offsetHours: 8, displayName: '(UTC+08:00) Krasnoyarsk', supportsDaylightSavingTime: true },
    { id: 'Taipei Standard Time', offset: 480, offsetHours: 8, displayName: '(UTC+08:00) Taipei', supportsDaylightSavingTime: false },
    { id: 'W. Australia Standard Time', offset: 480, offsetHours: 8, displayName: '(UTC+08:00) Perth', supportsDaylightSavingTime: true },
    { id: 'Korea Standard Time', offset: 540, offsetHours: 9, displayName: '(UTC+09:00) Seoul', supportsDaylightSavingTime: false },
    { id: 'North Asia East Standard Time', offset: 540, offsetHours: 9, displayName: '(UTC+09:00) Irkutsk', supportsDaylightSavingTime: true },
    { id: 'Tokyo Standard Time', offset: 540, offsetHours: 9, displayName: '(UTC+09:00) Osaka, Sapporo, Tokyo', supportsDaylightSavingTime: false },
    { id: 'AUS Central Standard Time', offset: 570, offsetHours: 9.5, displayName: '(UTC+09:30) Darwin', supportsDaylightSavingTime: false },
    { id: 'Cen. Australia Standard Time', offset: 570, offsetHours: 9.5, displayName: '(UTC+09:30) Adelaide', supportsDaylightSavingTime: true },
    { id: 'West Pacific Standard Time', offset: 600, offsetHours: 10, displayName: '(UTC+10:00) Guam, Port Moresby', supportsDaylightSavingTime: false },
    { id: 'Tasmania Standard Time', offset: 600, offsetHours: 10, displayName: '(UTC+10:00) Hobart', supportsDaylightSavingTime: true },
    { id: 'E. Australia Standard Time', offset: 600, offsetHours: 10, displayName: '(UTC+10:00) Brisbane', supportsDaylightSavingTime: false },
    { id: 'AUS Eastern Standard Time', offset: 600, offsetHours: 10, displayName: '(UTC+10:00) Canberra, Melbourne, Sydney', supportsDaylightSavingTime: true },
    { id: 'Yakutsk Standard Time', offset: 600, offsetHours: 10, displayName: '(UTC+10:00) Yakutsk', supportsDaylightSavingTime: true },
    { id: 'Vladivostok Standard Time', offset: 660, offsetHours: 11, displayName: '(UTC+11:00) Vladivostok', supportsDaylightSavingTime: true },
    { id: 'Central Pacific Standard Time', offset: 660, offsetHours: 11, displayName: '(UTC+11:00) Solomon Is., New Caledonia', supportsDaylightSavingTime: false },
    { id: 'Magadan Standard Time', offset: 720, offsetHours: 12, displayName: '(UTC+12:00) Magadan', supportsDaylightSavingTime: true },
    { id: 'Kamchatka Standard Time', offset: 720, offsetHours: 12, displayName: '(UTC+12:00) Petropavlovsk-Kamchatsky - Old', supportsDaylightSavingTime: true },
    { id: 'Fiji Standard Time', offset: 720, offsetHours: 12, displayName: '(UTC+12:00) Fiji', supportsDaylightSavingTime: true },
    { id: 'New Zealand Standard Time', offset: 720, offsetHours: 12, displayName: '(UTC+12:00) Auckland, Wellington', supportsDaylightSavingTime: true },
    { id: 'UTC+12', offset: 720, offsetHours: 12, displayName: '(UTC+12:00) Coordinated Universal Time+12', supportsDaylightSavingTime: false },
    { id: 'Tonga Standard Time', offset: 780, offsetHours: 13, displayName: '(UTC+13:00) Nuku\'alofa', supportsDaylightSavingTime: false },
    { id: 'Samoa Standard Time', offset: 780, offsetHours: 13, displayName: '(UTC+13:00) Samoa', supportsDaylightSavingTime: true }
],
    __daysToMonth365 = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365],
    __daysToMonth366 = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366],
    __daysPer4Years = 365 * 4 + 1,
    __daysPer100Years = (365 * 4 + 1) * 25 - 1,
    __daysPer400Years = ((365 * 4 + 1) * 25 - 1) * 4 + 1,
    // Number of days from 1/1/0001 to 12/31/1600
    __daysTo1601 = (((365 * 4 + 1) * 25 - 1) * 4 + 1) * 4,
    // Number of days from 1/1/0001 to 12/30/1899
    __daysTo1899 = (((365 * 4 + 1) * 25 - 1) * 4 + 1) * 4 + ((365 * 4 + 1) * 25 - 1) * 3 - 367,
    // Number of days from 1/1/0001 to 12/31/9999
    __daysTo10000 = (((365 * 4 + 1) * 25 - 1) * 4 + 1) * 25 - 366,
    __minTicks = 0,
    __maxTicks = ((((365 * 4 + 1) * 25 - 1) * 4 + 1) * 25 - 366) * (1000 * 10000 * 3600 * 24) - 1,
    __maxMillis = ((((365 * 4 + 1) * 25 - 1) * 4 + 1) * 25 - 366) * (1000 * 60 * 60 * 24);

JQX.Utilities.Assign('TimeSpan', class TimeSpan {
    constructor() {
        const that = this;

        that.ticksPerMillisecond = 10000;
        that.millisecondsPerTick = 1 / 10000;
        that.ticksPerSecond = 1000 * 10000;
        that.secondsPerTick = 1 / (1000 * 10000);
        that.ticksPerMinute = 1000 * 10000 * 60;
        that.minutesPerTick = 1 / (1000 * 10000 * 60);
        that.ticksPerHour = 1000 * 10000 * 3600;
        that.hoursPerTick = 1 / (1000 * 10000 * 3600);
        that.ticksPerDay = 1000 * 10000 * 3600 * 24;
        that.daysPerTick = 1 / (1000 * 10000 * 3600 * 24);
        that.millisPerSecond = 1000;
        that.millisPerMinute = 1000 * 60;
        that.millisPerHour = 1000 * 60 * 60;
        that.millisPerDay = 1000 * 60 * 60 * 24;
        that._ticks = 0;

        if (arguments.length === 1) {
            if (isNaN(arguments[0])) {
                throw new Error('Argument must be a number.');
            }

            that._ticks = arguments[0];
        }
        else if (arguments.length === 3) {
            that._ticks = that.timeToMS(arguments[0], arguments[1], arguments[2], 0);
        }
        else if (arguments.length === 4) {
            const days = arguments[0],
                hours = arguments[1],
                minutes = arguments[2],
                seconds = arguments[3],
                milliseconds = 0,
                totalMilliSeconds = (days * 3600 * 24 + hours * 3600 + minutes * 60 + seconds) * 1000 + milliseconds;

            that._ticks = totalMilliSeconds * that.ticksPerMillisecond;
        }
        else if (arguments.length === 5) {
            const days = arguments[0],
                hours = arguments[1],
                minutes = arguments[2],
                seconds = arguments[3],
                milliseconds = arguments[4],
                totalMilliSeconds = (days * 3600 * 24 + hours * 3600 + minutes * 60 + seconds) * 1000 + milliseconds;

            that._ticks = totalMilliSeconds * that.ticksPerMillisecond;
        }
    }

    ticks() {
        return this._ticks;
    }

    days() {
        const that = this;

        return parseInt(that._ticks / that.ticksPerDay);
    }

    timeToMS(hour, minute, second, milliseconds) {
        const totalSeconds = hour * 3600 + minute * 60 + second + milliseconds / 1000;

        return parseInt(totalSeconds * this.ticksPerSecond);
    }

    hours() {
        const that = this;

        return parseInt(that._ticks / that.ticksPerHour) % 24;
    }

    milliseconds() {
        const that = this;

        return parseInt(that._ticks / that.ticksPerMillisecond) % 1000;
    }

    minutes() {
        const that = this;

        return parseInt(that._ticks / that.ticksPerMinute) % 60;
    }

    seconds() {
        const that = this;

        return parseInt(that._ticks / that.ticksPerSecond) % 60;
    }

    totalDays() {
        const that = this;

        return parseInt(that._ticks * that.daysPerTick);
    }

    totalHours() {
        const that = this;

        return parseInt(that._ticks * that.hoursPerTick);
    }

    totalMilliseconds() {
        const that = this,
            temp = that._ticks * that.millisecondsPerTick;

        return parseInt(temp);
    }

    totalMinutes() {
        const that = this;

        return parseInt(that._ticks * that.minutesPerTick);
    }

    totalSeconds() {
        const that = this;

        return parseInt(that._ticks * that.secondsPerTick);
    }

    add(ts) {
        const result = this._ticks + ts._ticks,
            timeSpan = new JQX.Utilities.TimeSpan(result);

        return timeSpan;
    }

    subtract(ts) {
        const result = this._ticks - ts._ticks;

        return new JQX.Utilities.TimeSpan(result);
    }

    duration() {
        const that = this;

        if (that._ticks >= 0) {
            return new JQX.Utilities.TimeSpan(that._ticks);
        }
        else {
            return new JQX.Utilities.TimeSpan(-that._ticks);
        }
    }

    equals(ts) {
        return this._ticks === ts._ticks;
    }

    valueOf() {
        return this._ticks
    }

    compare(t1, t2) {
        if (t1._ticks > t2._ticks) {
            return 1;
        }

        if (t1._ticks < t2._ticks) {
            return -1;
        }

        return 0;
    }

    interval(value, scale) {
        const tmp = value * scale,
            millis = tmp + (value >= 0 ? 0.5 : -0.5);

        return new JQX.Utilities.TimeSpan(millis * this.ticksPerMillisecond);
    }

    fromDays(value) {
        const that = this;

        return that.interval(value, that.millisPerDay);
    }

    fromHours(value) {
        const that = this;

        return that.interval(value, that.millisPerHour);
    }

    fromMilliseconds(value) {
        return this.interval(value, 1);
    }

    fromMinutes(value) {
        const that = this;

        return that.interval(value, that.millisPerMinute);
    }

    fromSeconds(value) {
        const that = this;

        return that.interval(value, that.millisPerSecond);
    }

    fromTicks(value) {
        return new JQX.Utilities.TimeSpan(value);
    }

    toString() {
        return this.totalMilliseconds().toString();
    }

    negate() {
        return new JQX.Utilities.TimeSpan(-this._ticks);
    }
});

JQX.Utilities.Assign('DateTime', class DateTime {
    constructor() {
        function getUTCDate(ISOString) {
            const parseResult = that.regexISOString.exec(ISOString);

            UTCDate = new JQX.Utilities.DateTime(
                parseFloat(parseResult[1]), parseFloat(parseResult[2]), parseFloat(parseResult[3]),
                parseFloat(parseResult[4]), parseFloat(parseResult[5]), parseFloat(parseResult[6]),
                parseFloat(parseResult[7]), 0, 0, 0, 0, 0, 0, 0, 'UTC'
            );
        }

        const that = this;
        let UTCDate;

        that.ticksPerMillisecond = 10000;
        that.millisecondsPerTick = 1 / 10000;
        that.ticksPerSecond = 1000 * 10000;
        that.secondsPerTick = 1 / (1000 * 10000);
        that.ticksPerMinute = 1000 * 10000 * 60;
        that.minutesPerTick = 1 / (1000 * 10000 * 60);
        that.ticksPerHour = 1000 * 10000 * 3600;
        that.hoursPerTick = 1 / (1000 * 10000 * 3600);
        that.ticksPerDay = 1000 * 10000 * 3600 * 24;
        that.daysPerTick = 1 / (1000 * 10000 * 3600 * 24);
        that.millisPerSecond = 1000;
        that.millisPerMinute = 1000 * 60;
        that.millisPerHour = 1000 * 60 * 60;
        that.millisPerDay = 1000 * 60 * 60 * 24;
        that.daysPerYear = 365;
        that.daysPer4Years = __daysPer4Years;
        that.daysPer100Years = __daysPer100Years;
        that.daysPer400Years = __daysPer400Years;
        // Number of days from 1/1/0001 to 12/31/1600
        that.daysTo1601 = __daysTo1601;
        // Number of days from 1/1/0001 to 12/30/1899
        that.daysTo1899 = __daysTo1899;
        // Number of days from 1/1/0001 to 12/31/9999
        that.daysTo10000 = __daysTo10000;
        that.minTicks = 0;
        that.maxTicks = __maxTicks;
        that.maxMillis = __maxMillis;
        that.datePartYear = 0;
        that.datePartDayOfYear = 1;
        that.datePartMonth = 2;
        that.datePartDay = 3;
        that.daysToMonth365 = __daysToMonth365;
        that.daysToMonth366 = __daysToMonth366;
        that.minValue = new Date(0);
        that.maxValue = new Date(((((365 * 4 + 1) * 25 - 1) * 4 + 1) * 25 - 366) * (1000 * 10000 * 3600 * 24) - 1);
        that.ticksMask = 0x3FFFFFFFFFFFFFFF;
        that.flagsMask = 0xC000000000000000;
        that.localMask = 0x8000000000000000;
        that.ticksCeiling = 0x4000000000000000;
        that.kindUnspecified = 0x0000000000000000;
        that.kindUtc = 0x4000000000000000;
        that.kindLocal = 0x8000000000000000;
        that.kindLocalAmbiguousDst = 0xC000000000000000;
        that.kindShift = 62;
        that.regexTrim = /^\s+|\s+$/g;
        that.regexInfinity = /^[+-]?infinity$/i;
        that.regexHex = /^0x[a-f0-9]+$/i;
        that.regexParseFloat = /^[+-]?\d*\.?\d*(e[+-]?\d+)?$/;
        that.regexISOString = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}).(\d{3})Z$/;
        that.calendar = {
            // separator of parts of a date (e.g. '/' in 11/05/1955)
            '/': '/',
            // separator of parts of a time (e.g. ':' in 05:44 PM)
            ':': ':',
            // the first day of the week (0 = Sunday, 1 = Monday, etc)
            firstDay: 0,
            days: {
                // full day names
                names: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                // abbreviated day names
                namesAbbr: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
                // shortest day names
                namesShort: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']
            },
            months: {
                // full month names (13 months for lunar calendards -- 13th month should be '' if not lunar)
                names: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December', ''],
                // abbreviated month names
                namesAbbr: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec', '']
            },
            // AM and PM designators in one of these forms:
            // The usual view, and the upper and lower case versions
            //      [standard,lowercase,uppercase]
            // The culture does not use AM or PM (likely all standard date formats use 24 hour time)
            //      null
            AM: ['AM', 'am', 'AM'],
            PM: ['PM', 'pm', 'PM'],
            eras: [
                // eras in reverse chronological order.
                // name: the name of the era in this culture (e.g. A.D., C.E.)
                // start: when the era starts in ticks (gregorian, gmt), null if it is the earliest supported era.
                // offset: offset in years from gregorian calendar
                { 'name': 'A.D.', 'start': null, 'offset': 0 }
            ],
            twoDigitYearMax: 2029,
            patterns: {
                // short date pattern
                d: 'M/d/yyyy',
                // long date pattern
                D: 'dddd, MMMM dd, yyyy',
                // short time pattern
                t: 'h:mm tt',
                // long time pattern
                T: 'h:mm:ss tt',
                // long date, short time pattern
                f: 'dddd, MMMM dd, yyyy h:mm tt',
                // long date, long time pattern
                F: 'dddd, MMMM dd, yyyy h:mm:ss tt',
                // month/day pattern
                M: 'MMMM dd',
                // month/year pattern
                Y: 'yyyy MMMM',
                // S is a sortable format that does not vary by culture
                S: 'yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss',
                // formatting of dates in MySQL DataBases
                ISO: 'yyyy-MM-dd hh:mm:ss',
                ISO2: 'yyyy-MM-dd HH:mm:ss',
                d1: 'dd.MM.yyyy',
                d2: 'dd-MM-yyyy',
                zone1: 'yyyy-MM-ddTHH:mm:ss-HH:mm',
                zone2: 'yyyy-MM-ddTHH:mm:ss+HH:mm',
                custom: 'yyyy-MM-ddTHH:mm:ss.fff',
                custom2: 'yyyy-MM-dd HH:mm:ss.fff',
                // full precision (from year to yoctoseconds)
                FP: 'yyyy-MM-dd HH:mm:ss:fff:uu:nn:pp:ee:aa:xx:oo',
                // alternative full precision (from year to yoctoseconds, no delimiters)
                FPA: 'yyyy/MM/dd HH:mm:ss:fffuunnppeeaaxxoo',
                // alternative full precision (from year to yoctoseconds, no delimiters)
                FPA2: 'yyyy-MM-dd HH:mm:ss:fffuunnppeeaaxxoo',
                // full precision time (from hours to yoctoseconds)
                FT: 'HH:mm:ss:fff:uu:nn:pp:ee:aa:xx:oo',
                // processor precision (from year to picoseconds)
                PP: 'yyyy-MM-dd HH:mm:ss:fff:uu:nn:pp',
                // processor precision time (from hours to picoseconds)
                PT: 'HH:mm:ss:fff:uu:nn:pp'
            },
            percentsymbol: '%',
            currencysymbol: '$',
            currencysymbolposition: 'before',
            decimalseparator: '.',
            thousandsseparator: ','
        };
        that.dateData = 0;
        that.timeZone = null;
        that.timeZones = __timeZones;

        that._codeToUnit = {
            'u': '_microsecond',
            'uu': '_microsecond',
            'n': '_nanosecond',
            'nn': '_nanosecond',
            'p': '_picosecond',
            'pp': '_picosecond',
            'e': '_femtosecond',
            'ee': '_femtosecond',
            'a': '_attosecond',
            'aa': '_attosecond',
            'x': '_zeptosecond',
            'xx': '_zeptosecond',
            'o': '_yoctosecond',
            'oo': '_yoctosecond'
        };

        that._smallUnits = ['_microsecond', '_nanosecond', '_picosecond', '_femtosecond', '_attosecond', '_zeptosecond', '_yoctosecond'];

        that._microsecond = 0;
        that._nanosecond = 0;
        that._picosecond = 0;
        that._femtosecond = 0;
        that._attosecond = 0;
        that._zeptosecond = 0;
        that._yoctosecond = 0;

        if (arguments.length === 0) {
            const date = new Date();
            that.dateData = that.dateToMS(date.getFullYear(), date.getMonth() + 1, date.getDate()) + that.timeToMS(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
        else if (arguments.length === 1) {
            if (arguments[0] === undefined)
                arguments[0] = 'todayDate';

            const isNumber = typeof arguments[0] === 'number' && isFinite(arguments[0]);

            if (!isNumber && typeof arguments[0] === 'string') {
                let date;

                if (arguments[0] === 'today') {
                    date = new Date();
                }
                else if (arguments[0] === 'todayDate') {
                    date = new Date();
                    date.setHours(0, 0, 0, 0);
                }
                else if (that.regexISOString.test(arguments[0])) {
                    getUTCDate(arguments[0]);
                }
                else {
                    date = that.tryparseDate(arguments[0]);
                }

                if (date) {
                    that.dateData = that.dateToMS(date.getFullYear(), date.getMonth() + 1, date.getDate()) + that.timeToMS(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
                }
            }
            else {
                if (typeof (arguments[0]) === 'number') {
                    that.dateData = arguments[0];
                }
                else {
                    if (arguments[0] instanceof Date) {
                        const date = arguments[0];
                        that.dateData = that.dateToMS(date.getFullYear(), date.getMonth() + 1, date.getDate()) + that.timeToMS(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
                    }
                    else {
                        that.dateData = arguments[0];
                    }
                }
            }
        }
        else if (arguments.length === 2) {
            if (arguments[0] === undefined)
                arguments[0] = 'todayDate';

            const isNumber = typeof arguments[0] === 'number' && isFinite(arguments[0]);

            if (!isNumber && typeof arguments[0] === 'string') {
                let date;

                if (arguments[0] === 'today') {
                    date = new Date();
                }
                else if (arguments[0] === 'todayDate') {
                    date = new Date();
                    date.setHours(0, 0, 0, 0);
                }
                else if (that.regexISOString.test(arguments[0])) {
                    getUTCDate(arguments[0]);
                }
                else {
                    date = that.tryparseDate(arguments[0]);
                }

                if (date) {
                    that.dateData = that.dateToMS(date.getFullYear(), date.getMonth() + 1, date.getDate()) + that.timeToMS(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
                }
            }
            else {
                if (typeof (arguments[0]) === 'number') {
                    that.dateData = arguments[0];
                }
                else {
                    if (arguments[0] instanceof Date) {
                        const date = arguments[0];
                        that.dateData = that.dateToMS(date.getFullYear(), date.getMonth() + 1, date.getDate()) + that.timeToMS(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
                    }
                    else {
                        that.dateData = arguments[0];
                    }
                }
            }

            that.validateTimeZone(arguments[1]);
        }
        else if (arguments.length > 2) {
            if (typeof arguments[0] === 'string') {
                const date = that.tryparseDate(arguments[0], arguments[2], arguments[1]);
                that.dateData = that.dateToMS(date.getFullYear(), date.getMonth() + 1, date.getDate()) + that.timeToMS(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
            }
            else {
                const year = arguments[0],
                    month = arguments[1] - 1,
                    day = arguments[2],
                    hour = arguments[3] || 0,
                    minute = arguments[4] || 0,
                    second = arguments[5] || 0,
                    millisecond = arguments[6] || 0,
                    microsecond = arguments[7] || 0,
                    nanosecond = arguments[8] || 0,
                    picosecond = arguments[9] || 0,
                    femtosecond = arguments[10] || 0,
                    attosecond = arguments[11] || 0,
                    zeptosecond = arguments[12] || 0,
                    yoctosecond = arguments[13] || 0,

                    date = new Date(year, month, day, hour, minute, second, millisecond);

                if (year < 1970) {
                    date.setFullYear(year);
                }

                that.dateData = that.dateToMS(date.getFullYear(), date.getMonth() + 1, date.getDate()) + that.timeToMS(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
                that._microsecond = microsecond;
                that._nanosecond = nanosecond;
                that._picosecond = picosecond;
                that._femtosecond = femtosecond;
                that._attosecond = attosecond;
                that._zeptosecond = zeptosecond;
                that._yoctosecond = yoctosecond;

                if (arguments[14]) {
                    that.validateTimeZone(arguments[14]);
                }
            }
        }

        if (!that.timeZone) {
            that.validateTimeZone('Local');
        }

        if (UTCDate) {
            const convertedUTCDate = UTCDate.toTimeZone(that.timeZone);

            that.dateData = convertedUTCDate.dateData;
        }
    }

    static validateDate(value, referenceValue, formatString) {
        if (value instanceof JQX.Utilities.DateTime) {
            return value;
        }

        if (value instanceof Date) {
            return new JQX.Utilities.DateTime(value);
        }

        try {
            if (new RegExp(/^\d{1,2}\/\d{1,2}\/\d{4}(, \d{1,2}:\d{2}:\d{1,2} [A|P]M)?$/).test(value)) {
                const constructedDate = new Date(value);

                if (!isNaN(constructedDate.getTime())) {
                    return new JQX.Utilities.DateTime(constructedDate);
                }
            }

            if (typeof value === 'string') {
                return this.parseDateString(value, referenceValue, formatString);
            }

            if (typeof value === 'number') {
                return new JQX.Utilities.DateTime(new Date(value));
            }
        }
        catch (error) {
            //
        }

        return referenceValue;
    }

    static parseDateString(value, referenceValue, formatString) {
        const parseAttemptDate = new Date(value);

        if (!isNaN(parseAttemptDate.getTime())) {
            return new JQX.Utilities.DateTime(parseAttemptDate);
        }

        const indexOfDate = value.indexOf('Date('),
            indexOfDateTime = value.indexOf('DateTime('),
            indexOfBracket = value.lastIndexOf(')');
        let validValue = value;

        if ((indexOfDate !== -1 || indexOfDateTime !== -1) && indexOfBracket !== -1) {
            if (indexOfDate !== -1) {
                validValue = value.slice(indexOfDate + 5, indexOfBracket);
            }
            else {
                validValue = value.slice(indexOfDateTime + 9, indexOfBracket);
            }

            validValue = validValue.replace(/'/g, '').replace(/"/g, '').replace(/^\s+|\s+$|\s+(?=\s)/g, '');

            if (validValue.trim() === '') {
                return new JQX.Utilities.DateTime();
            }

            if (new RegExp(/(^(\d+)(\s*,\s*\d+)+(\s*,\s*[a-zA-Z ]+)?$)/g).test(validValue)) {
                validValue = validValue.split(',');

                validValue.map(function (argument, index) {
                    if (!isNaN(validValue[index])) {
                        validValue[index] = parseInt(argument);
                    }
                    else {
                        validValue[index] = argument.trim();
                    }
                });

                if (indexOfDate !== -1) {
                    validValue[1]++;
                }

                validValue.unshift(null);
                validValue = new (Function.prototype.bind.apply(JQX.Utilities.DateTime, validValue));

                return validValue;
            }
        }
        else {
            const parseAttemptDateTime = new JQX.Utilities.DateTime(),
                parseAttempt = parseAttemptDateTime.parseDate(value, formatString);

            if (parseAttempt) {
                validValue = new JQX.Utilities.DateTime(parseAttempt);
                parseAttemptDateTime.copySmallTimePartValues(validValue);
                return validValue;
            }
        }

        if (validValue.trim() === '') {
            return referenceValue;
        }

        if (!isNaN(validValue)) {
            validValue = new Date(parseInt(validValue, 10));
            return new JQX.Utilities.DateTime(validValue);
        }

        try {
            const splitValue = validValue.split(',');

            if (splitValue.length === 2) {
                splitValue[1] = splitValue[1].trim();

                splitValue.unshift(null);
                validValue = new (Function.prototype.bind.apply(JQX.Utilities.DateTime, splitValue));
            }
            else {
                validValue = new JQX.Utilities.DateTime(validValue);
            }
        }
        catch (error) {
            validValue = referenceValue;
        }

        return validValue;
    }

    static fromFullTimeStamp(timeStamp) {
        timeStamp = timeStamp.toString();

        const dateTime = new JQX.Utilities.DateTime(parseFloat(timeStamp.slice(0, timeStamp.length - 21)));
        let smallTimeParts = timeStamp.slice(timeStamp.length - 21),
            unitIndex = 0;

        while (smallTimeParts.length > 0) {
            dateTime[dateTime._smallUnits[unitIndex]] = parseInt(smallTimeParts.slice(0, 3), 10);

            smallTimeParts = smallTimeParts.slice(3);
            unitIndex++;
        }

        return dateTime;
    }

    /**
     * Returns full DateTime constructor parameters.
     */
    static getConstructorParameters(oldValue) {
        return [
            oldValue.year(), oldValue.month(), oldValue.day(),
            oldValue.hour(), oldValue.minute(), oldValue.second(), oldValue.millisecond(),
            oldValue._microsecond, oldValue._nanosecond, oldValue._picosecond,
            oldValue._femtosecond, oldValue._attosecond, oldValue._zeptosecond, oldValue._yoctosecond,
            oldValue.timeZone
        ];
    }

    /**
     * Detects whether the formatString contains only date or time information, or both.
     */
    static detectDisplayMode(value, formatString, formatStringRegExp) {
        if (value.calendar.patterns[formatString]) {
            if (['d', 'D', 'M', 'Y', 'd1', 'd2'].indexOf(formatString) !== -1) {
                return 'calendar';
            }

            if (['t', 'T', 'FT', 'PT'].indexOf(formatString) !== -1) {
                return 'timePicker';
            }

            return 'default';
        }

        const dateParts = ['d', 'M', 'y'],
            timeParts = ['h', 'H', 'm', 's', 't', 'f', 'u', 'n', 'p', 'e', 'a', 'x', 'o'],
            groups = formatStringRegExp.groups;
        let calendar = false,
            timePicker = false;

        for (let i = 0; i < groups.length; i++) {
            const char = groups[i].charAt(0);

            if (dateParts.indexOf(char) !== -1) {
                calendar = true;
            }
            else if (timeParts.indexOf(char) !== -1) {
                timePicker = true;
            }

            if (calendar && timePicker) {
                break;
            }
        }

        if (calendar === timePicker) {
            return 'default';
        }

        if (calendar) {
            return 'calendar';
        }

        return 'timePicker';
    }

    /**
     * Gets and stores month and day names based on locale.
     */
    static getLocalizedNames(locale) {
        const days = { names: [], namesAbbr: [], namesShort: [] },
            months = { names: [], namesAbbr: [] };

        if (this[locale]) {
            return this[locale];
        }

        for (let i = 23; i < 30; i++) {
            const date = new Date(2017, 6, i),
                name = date.toLocaleString(locale, { 'weekday': 'long' });

            days.names.push(name);
            days.namesAbbr.push(date.toLocaleString(locale, { 'weekday': 'short' }));
            days.namesShort.push(name.substring(0, 2));
        }

        for (let i = 0; i < 12; i++) {
            const date = new Date(2017, i, 1),
                name = date.toLocaleString(locale, { 'month': 'long' });

            months.names.push(name);
            months.namesAbbr.push(name.substring(0, 3));
        }

        months.names.push('');
        months.namesAbbr.push('');

        this[locale] = { days: days, months: months };

        return this[locale];
    }

    internalMS() {
        return this.dateData;
    }
    // Returns a given date part of this DateTithat. This method is used
    // to compute the year, day-of-year, month, or day part.
    getDatePart(part) {
        const that = this,
            ms = that.internalMS();
        // n = number of days since 1/1/0001
        let n = parseInt(ms / that.millisPerDay);
        // y400 = number of whole 400-year periods since 1/1/0001
        const y400 = parseInt(n / that.daysPer400Years);
        // n = day number within 400-year period
        n -= y400 * that.daysPer400Years;
        // y100 = number of whole 100-year periods within 400-year period
        let y100 = parseInt(n / that.daysPer100Years);
        // Last 100-year period has an extra day, so decrement result if 4
        if (y100 === 4) y100 = 3;
        // n = day number within 100-year period
        n -= y100 * that.daysPer100Years;
        // y4 = number of whole 4-year periods within 100-year period
        const y4 = parseInt(n / that.daysPer4Years);
        // n = day number within 4-year period
        n -= y4 * that.daysPer4Years;
        // y1 = number of whole years within 4-year period
        let y1 = parseInt(n / that.daysPerYear);
        // Last year has an extra day, so decrement result if 4
        if (y1 === 4) y1 = 3;
        // If year was requested, compute and return it
        if (part === that.datePartYear) {
            return parseInt(y400 * 400 + y100 * 100 + y4 * 4 + y1 + 1);
        }
        // n = day number within year
        n -= y1 * that.daysPerYear;
        // If day-of-year was requested, return it
        if (part === that.datePartDayOfYear) return parseInt(n + 1);
        // Leap year calculation looks different from IsLeapYear since y1, y4,
        // and y100 are relative to year 1, not year 0
        const leapYear = y1 === 3 && (y4 !== 24 || y100 === 3),
            days = leapYear ? that.daysToMonth366 : that.daysToMonth365;
        // All months have less than 32 days, so n >> 5 is a good conservative
        // estimate for the month
        let m = n >> 5 + 1;
        // m = 1-based month number
        while (n >= days[m]) m++;
        // If month was requested, return it
        if (part === that.datePartMonth) return parseInt(m);
        // Return 1-based day-of-month
        return parseInt(n - days[m - 1] + 1);
    }

    dayOfWeek() {
        const that = this,
            ms = that.dateData,
            dayOfWeek = parseInt(ms / that.millisPerDay + 1) % 7;

        return dayOfWeek;
    }

    dayOfYear() {
        const that = this;

        return that.getDatePart(that.datePartDayOfYear);
    }

    weekOfYear(firstDay) {
        const that = this,
            dateObj = that.toDate(),
            dowOffset = firstDay || that.calendar.firstDay, //default dowOffset to zero
            newYear = new Date(dateObj.getFullYear(), 0, 1),
            daynum = Math.floor((dateObj.getTime() - newYear.getTime() - (dateObj.getTimezoneOffset() - newYear.getTimezoneOffset()) * 60000) / 86400000) + 1;
        let day = newYear.getDay() - dowOffset; //the day of week the year begins on
        day = (day >= 0 ? day : day + 7);
        let weeknum;
        //if the year starts before the middle of a week
        if (day < 4) {
            weeknum = Math.floor((daynum + day - 1) / 7) + 1;
            if (weeknum > 52) {
                const nYear = new Date(dateObj.getFullYear() + 1, 0, 1);
                let nday = nYear.getDay() - dowOffset;
                nday = nday >= 0 ? nday : nday + 7;
                /*if the next year starts before the middle of
                  the week, it is week #1 of that year*/
                weeknum = nday < 4 ? 1 : 53;
            }
        }
        else {
            weeknum = Math.floor((daynum + day - 1) / 7);
        }
        return weeknum;
    }

    subtract(date) {
        const that = this;

        return new JQX.Utilities.TimeSpan(that.dateData * that.ticksPerMillisecond - date.dateData * that.ticksPerMillisecond);
    }

    dateToMS(year, month, day) {
        const that = this;

        if (year >= 1 && year <= 9999 && month >= 1 && month <= 12) {
            year = parseInt(year);
            const days = that.isLeapYear(year) ? that.daysToMonth366 : that.daysToMonth365;
            if (day >= 1 && day <= days[month] - days[month - 1]) {
                const y = year - 1;
                const n = y * 365 + parseInt(y / 4) - parseInt(y / 100) + parseInt(y / 400) + days[month - 1] + day - 1;
                return n * that.millisPerDay;
            }
        }
    }

    isLeapYear(year) {
        if (year < 1 || year > 9999) {
            throw new Error('Year out of Range');
        }
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }

    timeToMS(hour, minute, second, ms) {
        const that = this;

        if (hour >= 0 && hour < 24 && minute >= 0 && minute < 60 && second >= 0 && second < 60) {
            const totalSeconds = parseInt(hour * 3600 + minute * 60 + second);
            if (ms > 0 && ms < 1000) {
                return (totalSeconds * that.millisPerSecond) + ms;
            }
            return totalSeconds * that.millisPerSecond;
        }
    }

    daysInMonth(year, month) {
        if (month < 1 || month > 12) {
            throw new Error('Month out of Range');
        }

        const that = this,
            days = that.isLeapYear(year) ? that.daysToMonth366 : that.daysToMonth365;

        return days[month] - days[month - 1];
    }

    arrayIndexOf(array, item) {
        return array.indexOf(item);
    }

    startsWith(value, pattern) {
        return value.indexOf(pattern) === 0;
    }

    endsWith(value, pattern) {
        return value.substr(value.length - pattern.length) === pattern;
    }

    trim(value) {
        return (value + '').replace(this.regexTrim, '');
    }

    expandFormat(calendar, format) {
        // expands unspecified or single character date formats into the full pattern.
        format = format || 'F';
        let pattern,
            patterns = calendar.patterns,
            len = format.length;

        if (patterns[format]) {
            return patterns[format];
        }

        if (len === 1) {
            pattern = patterns[format];
            if (!pattern) {
                throw 'Invalid date format string \'' + format + '\'.';
            }
            format = pattern;
        }
        else if (len === 2 && format.charAt(0) === '%') {
            // %X escape format -- intended as a custom format string that is only one character, not a built-in format.
            format = format.charAt(1);
        }
        return format;
    }

    getEra(date, eras) {
        if (!eras) return 0;
        if (typeof date === 'string') {
            return 0;
        }

        let start, ticks = date.getTime();
        for (let i = 0, l = eras.length; i < l; i++) {
            start = eras[i].start;
            if (start === null || ticks >= start) {
                return i;
            }
        }
        return 0;
    }

    toUpper(value) {
        // 'he-IL' has non-breaking space in weekday names.
        return value.split('\u00A0').join(' ').toUpperCase();
    }

    toUpperArray(arr) {
        const results = [];
        for (let i = 0, l = arr.length; i < l; i++) {
            results[i] = this.toUpper(arr[i]);
        }
        return results;
    }

    getEraYear(date, cal, era, sortable) {
        let year = date.getFullYear();
        if (!sortable && cal.eras) {
            // convert normal gregorian year to era-shifted gregorian
            // year by subtracting the era offset
            year -= cal.eras[era].offset;
        }
        return year;
    }

    getDayIndex(cal, value, abbr) {
        const that = this,
            days = cal.days;
        let ret,
            upperDays = cal._upperDays;

        if (!upperDays) {
            cal._upperDays = upperDays = [
                that.toUpperArray(days.names),
                that.toUpperArray(days.namesAbbr),
                that.toUpperArray(days.namesShort)
            ];
        }
        value = value.toUpperCase();
        if (abbr) {
            ret = that.arrayIndexOf(upperDays[1], value);
            if (ret === -1) {
                ret = that.arrayIndexOf(upperDays[2], value);
            }
        }
        else {
            ret = that.arrayIndexOf(upperDays[0], value);
        }
        return ret;
    }

    getMonthIndex(cal, value, abbr) {
        const that = this;

        let months = cal.months,
            monthsGen = cal.monthsGenitive || cal.months,
            upperMonths = cal._upperMonths,
            upperMonthsGen = cal._upperMonthsGen;
        if (!upperMonths) {
            cal._upperMonths = upperMonths = [
                that.toUpperArray(months.names),
                that.toUpperArray(months.namesAbbr)
            ];
            cal._upperMonthsGen = upperMonthsGen = [
                that.toUpperArray(monthsGen.names),
                that.toUpperArray(monthsGen.namesAbbr)
            ];
        }
        value = that.toUpper(value);
        let i = that.arrayIndexOf(abbr ? upperMonths[1] : upperMonths[0], value);
        if (i < 0) {
            i = that.arrayIndexOf(abbr ? upperMonthsGen[1] : upperMonthsGen[0], value);
        }
        return i;
    }

    appendPreOrPostMatch(preMatch, strings) {
        // appends pre- and post- token match strings while removing escaped characters.
        // Returns a single quote count which is used to determine if the token occurs
        // in a string literal.
        let quoteCount = 0,
            escaped = false;
        for (let i = 0, il = preMatch.length; i < il; i++) {
            const c = preMatch.charAt(i);
            switch (c) {
                case '\'':
                    if (escaped) {
                        strings.push('\'');
                    }
                    else {
                        quoteCount++;
                    }
                    escaped = false;
                    break;
                case '\\':
                    if (escaped) {
                        strings.push('\\');
                    }
                    escaped = !escaped;
                    break;
                default:
                    strings.push(c);
                    escaped = false;
                    break;
            }
        }
        return quoteCount;
    }

    getTokenRegExp() {
        // regular expression for matching date and time tokens in format strings.
        return /\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyyy|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|uu|u|nn|n|pp|p|ee|e|aa|a|xx|x|oo|o|i{1,24}|zzz|zz|z|gg|g/g;
    }

    tryparseDate(value, calendar, format) {
        const that = this;

        if (calendar === undefined || calendar === null) {
            calendar = that.calendar;
        }

        if (format !== undefined) {
            if (Array.isArray(format)) {
                for (let i = 0; i < format.length; i++) {
                    const tryParse = that.parseDate(value, format[i], calendar);

                    if (tryParse) {
                        return tryParse;
                    }
                }
            }
            const tryParse = that.parseDate(value, format, calendar);
            if (tryParse)
                return tryParse;
        }

        if (value === '')
            return null;

        if (value !== null && value !== undefined && !value.substring) {
            value = value.toString();
        }

        if (value !== null && value !== undefined && value.substring(0, 6) === '/Date(') {
            const jsonDateRE = /^\/Date\((-?\d+)(\+|-)?(\d+)?\)\/$/;

            let date = new Date(+value.replace(/\/Date\((\d+)\)\//, '$1'));
            if (date === 'Invalid Date') {
                const m = value.match(/^\/Date\((\d+)([-+]\d\d)(\d\d)\)\/$/);

                date = null;

                if (m) {
                    date = new Date(1 * m[1] + 3600000 * m[2] + 60000 * m[3]);
                }
            }
            if (date === null || date === undefined || date === 'Invalid Date' || isNaN(date)) {
                const arr = jsonDateRE.exec(value);
                if (arr) {
                    // 0 - complete results; 1 - ticks; 2 - sign; 3 - minutes
                    const result = new Date(parseInt(arr[1]));
                    if (arr[2]) {
                        let mins = parseInt(arr[3]);
                        if (arr[2] === '-') {
                            mins = -mins;
                        }
                        const current = result.getUTCMinutes();
                        result.setUTCMinutes(current - mins);
                    }
                    if (!isNaN(result.valueOf())) {
                        return result;
                    }
                }
            }

            return date;
        }

        const defaultPatterns = {
            jqxdate: 'yyyy-MM-dd HH:mm:ss',
            // short date pattern
            d: 'M/d/yyyy',
            // long date pattern
            D: 'dddd, MMMM dd, yyyy',
            // short time pattern
            t: 'h:mm tt',
            // long time pattern
            T: 'h:mm:ss tt',
            // long date, short time pattern
            f: 'dddd, MMMM dd, yyyy h:mm tt',
            // long date, long time pattern
            F: 'dddd, MMMM dd, yyyy h:mm:ss tt',
            // month/day pattern
            M: 'MMMM dd',
            // month/year pattern
            Y: 'yyyy MMMM',
            // S is a sortable format that does not vary by culture
            S: 'yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss',
            // formatting of dates in MySQL DataBases
            ISO: 'yyyy-MM-dd hh:mm:ss',
            ISO2: 'yyyy-MM-dd HH:mm:ss',
            ISO8601: 'yyyy-MM-ddTHH:mm:ss.sssZ',
            d1: 'dd.MM.yyyy',
            d2: 'dd-MM-yyyy',
            d3: 'MM-dd-yyyy',
            d4: 'MM.dd.yyyy',
            zone1: 'yyyy-MM-ddTHH:mm:ss-HH:mm',
            zone2: 'yyyy-MM-ddTHH:mm:ss+HH:mm',
            custom: 'yyyy-MM-ddTHH:mm:ss.fff',
            custom2: 'yyyy-MM-dd HH:mm:ss.fff',
            iso: 'yyyy-MM-ddTHH:mm:ssZ',
            iso_date1: 'yyyy-MM-dd',
            iso_date2: 'yyyy-MM-dd',
            iso_date3: 'yyyy-ddd',
            iso_date4: 'yyyy-MM-dd HH:mm',
            iso_date5: 'yyyy-MM-dd HH:mm Z',
            iso_date6: 'yyyy-MMM-dd',
            iso_date7: 'yyyy-MM',
            iso_date8: 'yyyy-MMM',
            iso_date9: 'yyyy-MMMM',
            iso_date10: 'yyyy-MMMM-dd',
            iso_time1: 'HH:mm:ss.tttt',
            iso_time2: 'HH:mm:ss',
            iso_time3: 'HH:mm',
            iso_time4: 'HH',
            iso_time5: 'yyyyyy-MM-dd',
            iso_time6: 'yyyyyy-MM-dd'
        };

        for (let prop in defaultPatterns) {
            const date = that.parseDate(value, defaultPatterns[prop], calendar);

            if (date) {
                return date;
            }
        }

        const patterns = calendar.patterns;
        for (let prop in patterns) {
            const date = that.parseDate(value, patterns[prop], calendar);

            if (date) {
                if (prop === 'ISO') {
                    const tmpDate = that.parseDate(value, patterns['ISO2'], calendar);
                    if (tmpDate) return tmpDate;
                }
                return date;
            }
        }

        let dateParts;

        if (typeof value === 'string') {
            value = that.trim(value);
            const splitParts = [':', '/', '-', ' ', ','];
            const replaceAll = function (find, replace, str) {
                return str.replace(new RegExp(find, 'g'), replace);
            }
            value = replaceAll(', ', ',', value);
            let timePart = '';
            let datePart = value;
            if (value.indexOf(':') >= 0) {
                timePart = value.substring(value.indexOf(':') - 2);
                timePart = that.trim(timePart);
                datePart = value.substring(0, value.indexOf(':') - 2);
            }
            else if (value.toUpperCase().indexOf('AM') >= 0) {
                timePart = value.substring(value.toUpperCase().indexOf('AM') - 2);
                timePart = that.trim(timePart);
                datePart = value.substring(0, value.toUpperCase().indexOf('AM') - 2);
            }
            else if (value.toUpperCase().indexOf('PM') >= 0) {
                timePart = value.substring(value.toUpperCase().indexOf('PM') - 2);
                timePart = that.trim(timePart);
                datePart = value.substring(0, value.toUpperCase().indexOf('PM') - 2);
            }
            let parseDate = new Date();
            let parsed = false;
            if (datePart) {
                for (let i = 0; i < splitParts.length; i++) {
                    if (datePart.indexOf(splitParts[i]) >= 0) {
                        dateParts = datePart.split(splitParts[i]);
                        break;
                    }
                }

                let days = new Array();
                let months = new Array();
                let years = new Array();
                let dayPart = null;
                let monthPart = null;
                for (let i = 0; i < dateParts.length; i++) {
                    const part = dateParts[i];
                    const isDay = that.parseDate(part, 'd', calendar) || that.parseDate(part, 'dd', calendar) || that.parseDate(part, 'ddd', calendar) || that.parseDate(part, 'dddd', calendar);
                    if (isDay) {
                        days.push(isDay.getDate());
                        if (part.length > 2) {
                            dayPart = i;
                            break;
                        }
                    }
                }
                for (let i = 0; i < dateParts.length; i++) {
                    const part = dateParts[i],
                        isMonth = that.parseDate(part, 'M', calendar) || that.parseDate(part, 'MM', calendar) || that.parseDate(part, 'MMM', calendar) || that.parseDate(part, 'MMMM', calendar);
                    if (isMonth) {
                        if (dayPart !== null && dayPart !== undefined && dayPart === i)
                            continue;

                        months.push(isMonth.getMonth());

                        if (part.length > 2) {
                            monthPart = i;
                            break;
                        }
                    }
                }
                for (let i = 0; i < dateParts.length; i++) {
                    const part = dateParts[i];
                    const isYear = that.parseDate(part, 'yyyy', calendar);
                    if (isYear) {
                        if (dayPart !== null && dayPart !== undefined && dayPart === i)
                            continue;

                        if (monthPart !== null && monthPart !== undefined && monthPart === i)
                            continue;

                        years.push(isYear.getFullYear());
                    }
                }
                const dates = new Array();
                for (let d = days.length - 1; d >= 0; d--) {
                    for (let m = 0; m < months.length; m++) {
                        for (let y = 0; y < years.length; y++) {
                            const result = new Date(years[y], months[m], days[d]);
                            if (years[y] < 1970)
                                result.setFullYear(years[y]);
                            if (!isNaN(result.getTime())) {
                                dates.push(result);
                            }
                        }
                    }
                }
                if (dates.length > 0) {
                    parseDate = dates[0];
                    parsed = true;
                }
            }
            if (timePart) {
                const timeParts = timePart.indexOf(':') >= 0 ? timePart.split(':') : timePart;
                const parsedTime = that.parseDate(timePart, 'h:mm tt', calendar) || that.parseDate(timePart, 'HH:mm:ss.fff', calendar) || that.parseDate(timePart, 'HH:mm:ss.ff', calendar) || that.parseDate(timePart, 'h:mm:ss tt', calendar) || that.parseDate(timePart, 'HH:mm:ss.tttt', calendar) || that.parseDate(timePart, 'HH:mm:ss', calendar) || that.parseDate(timePart, 'HH:mm', calendar) || that.parseDate(timePart, 'HH', calendar);

                let hour = 0, minute = 0, second = 0, milisecond = 0;
                if (parsedTime && !isNaN(parsedTime.getTime())) {
                    hour = parsedTime.getHours();
                    minute = parsedTime.getMinutes();
                    second = parsedTime.getSeconds();
                    milisecond = parsedTime.getMilliseconds();
                }
                else {
                    if (timeParts.length === 1) {
                        hour = parseInt(timeParts[0]);
                    }
                    if (timeParts.length === 2) {
                        hour = parseInt(timeParts[0]);
                        minute = parseInt(timeParts[1]);
                    }
                    if (timeParts.length === 3) {
                        hour = parseInt(timeParts[0]);
                        minute = parseInt(timeParts[1]);
                        if (timeParts[2].indexOf('.') >= 0) {
                            second = parseInt(timeParts[2].toString().split('.')[0]);
                            milisecond = parseInt(timeParts[2].toString().split('.')[1]);
                        }
                        else {
                            second = parseInt(timeParts[2]);
                        }
                    }
                    if (timeParts.length === 4) {
                        hour = parseInt(timeParts[0]);
                        minute = parseInt(timeParts[1]);
                        second = parseInt(timeParts[2]);
                        milisecond = parseInt(timeParts[3]);
                    }
                }
                if (parseDate && !isNaN(hour) && !isNaN(minute) && !isNaN(second) && !isNaN(milisecond)) {
                    parseDate.setHours(hour, minute, second, milisecond);
                    parsed = true;
                }
            }
            if (parsed) {
                return parseDate;
            }
        }
        if (value !== null && value !== undefined) {
            dateParts = [':', '/', '-'];
            let canParse = true;
            for (let part = 0; part < dateParts.length; part++) {
                if (value.indexOf(dateParts[part]) !== -1) {
                    canParse = false;
                }
            }

            if (canParse) {
                const number = new Number(value);
                if (!isNaN(number)) {
                    return new Date(number);
                }
            }
        }

        return null;
    }

    getParseRegExp(cal, format) {
        const that = this;

        // converts a format string into a regular expression with groups that
        // can be used to extract date fields from a date string.
        // check for a cached parse regex.
        let re = cal._parseRegExp;
        if (!re) {
            cal._parseRegExp = re = {};
        }
        else {
            const reFormat = re[format];
            if (reFormat) {
                return reFormat;
            }
        }

        // expand single digit formats, then escape regular expression characters.
        let expFormat = that.expandFormat(cal, format).replace(/([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, '\\\\$1'),
            regexp = ['^'],
            groups = [],
            index = 0,
            quoteCount = 0,
            tokenRegExp = that.getTokenRegExp(),
            match;

        // iterate through each date token found.
        while ((match = tokenRegExp.exec(expFormat)) !== null) {
            const preMatch = expFormat.slice(index, match.index);
            index = tokenRegExp.lastIndex;

            // don't replace any matches that occur inside a string literal.
            quoteCount += that.appendPreOrPostMatch(preMatch, regexp);
            if (quoteCount % 2) {
                regexp.push(match[0]);
                continue;
            }

            // add a regex group for the token.
            let m = match[0],
                len = m.length,
                add;

            switch (m) {
                case 'dddd': case 'ddd':
                case 'MMMM': case 'MMM':
                case 'gg': case 'g':
                    add = '(\\D+)';
                    break;
                case 'tt': case 't':
                    add = '(\\D*)';
                    break;
                case 'yyyyy':
                    add = '(\\d{1,4})';
                    break;
                case 'yyyy':
                    add = '(\\d{' + len + '})';
                    break;
                case 'fff':
                case 'ff':
                case 'f':
                    add = '(\\d{1,' + len + '})';
                    break;
                case 'dd': case 'd':
                case 'MM': case 'M':
                case 'yy': case 'y':
                case 'HH': case 'H':
                case 'hh': case 'h':
                case 'mm': case 'm':
                case 'ss': case 's':
                    add = '(\\d\\d?)';
                    break;
                case 'uu':
                case 'nn':
                case 'pp':
                case 'ee':
                case 'aa':
                case 'xx':
                case 'oo':
                    add = '(\\d{1,3})';
                    break;
                case 'zzz':
                    add = '([+-]?\\d\\d?:\\d{2})';
                    break;
                case 'zz': case 'z':
                    add = '([+-]?\\d\\d?)';
                    break;
                case '/':
                    add = '/'; // To include slash in a capturing group  add = '(\\' + cal['/'] + ')';
                    break;
                default:
                    if ((/i{1,24}/).test(m)) {
                        add = '(\\d{' + m.length + '})';
                    }
                    else {
                        throw 'Invalid date format pattern \'' + m + '\'.';
                    }
            }
            if (add) {
                regexp.push(add);
            }

            if (m === '/') {
                continue;
            }

            groups.push(match[0]);
        }
        that.appendPreOrPostMatch(expFormat.slice(index), regexp);
        regexp.push('$');

        // allow whitespace to differ when matching formats.
        const regexpStr = regexp.join('').replace(/\s+/g, '\\s+'),
            parseRegExp = { 'regExp': regexpStr, 'groups': groups };

        // cache the regex for this format.
        return re[format] = parseRegExp;
    }

    outOfRange(value, low, high) {
        return value < low || value > high;
    }

    expandYear(cal, year) {
        const that = this;

        // expands 2-digit year into 4 digits.
        const now = new Date(),
            era = that.getEra(now);
        if (year < 100) {
            let twoDigitYearMax = cal.twoDigitYearMax;
            twoDigitYearMax = typeof twoDigitYearMax === 'string' ? new Date().getFullYear() % 100 + parseInt(twoDigitYearMax, 10) : twoDigitYearMax;
            const curr = that.getEraYear(now, cal, era);
            year += curr - (curr % 100);
            if (year > twoDigitYearMax) {
                year -= 100;
            }
        }
        return year;
    }

    padZeros(num, c) {
        let r, s = num + '',
            zeros = ['0', '00', '000'];
        if (c > 1 && s.length < c) {
            r = (zeros[c - 2] + s);
            return r.substr(r.length - c, c);
        }
        else {
            r = s;
        }
        return r;
    }

    parseDate(value, format, calendar) {
        const that = this;

        if (calendar === undefined || calendar === null) {
            calendar = that.calendar;
        }
        // try to parse the date string by matching against the format string
        // while using the specified culture for date field names.
        value = that.trim(value);
        const cal = calendar,
            // convert date formats into regular expressions with groupings.
            // use the regexp to determine the input format and extract the date fields.
            parseInfo = that.getParseRegExp(cal, format),
            match = new RegExp(parseInfo.regExp).exec(value);
        if (match === null) {
            return null;
        }
        // found a date format that matches the input.
        let groups = parseInfo.groups,
            era = null, year = null, month = null, date = null, weekDay = null,
            hour = 0, hourOffset, min = 0, sec = 0, msec = 0, tzMinOffset = null,
            pmHour = false;
        // iterate the format groups to extract and set the date fields.
        for (let j = 0, jl = groups.length; j < jl; j++) {
            const matchGroup = match[j + 1];
            if (matchGroup) {
                const current = groups[j],
                    clength = current.length,
                    matchInt = parseInt(matchGroup, 10);

                switch (current) {
                    case 'dd': case 'd':
                        // Day of month.
                        date = matchInt;
                        // check that date is generally in valid range, also checking overflow below.
                        if (that.outOfRange(date, 1, 31)) return null;
                        break;
                    case 'MMM':
                    case 'MMMM':
                    case 'MMMMM':
                    case 'MMMMMM':
                    case 'MMMMMMM':
                    case 'MMMMMMMM':
                        month = that.getMonthIndex(cal, matchGroup, clength === 3);
                        if (that.outOfRange(month, 0, 11)) return null;
                        break;
                    case 'M': case 'MM':
                        // Month.
                        month = matchInt - 1;
                        if (that.outOfRange(month, 0, 11)) return null;
                        break;
                    case 'y': case 'yy':
                    case 'yyyy':
                        year = clength < 4 ? that.expandYear(cal, matchInt) : matchInt;
                        if (that.outOfRange(year, 0, 9999)) return null;
                        break;
                    case 'h': case 'hh':
                        // Hours (12-hour clock).
                        hour = matchInt;
                        if (hour === 12) hour = 0;
                        if (that.outOfRange(hour, 0, 11)) return null;
                        break;
                    case 'H': case 'HH':
                        // Hours (24-hour clock).
                        hour = matchInt;
                        if (that.outOfRange(hour, 0, 23)) return null;
                        break;
                    case 'm': case 'mm':
                        // Minutes.
                        min = matchInt;
                        if (that.outOfRange(min, 0, 59)) return null;
                        break;
                    case 's': case 'ss':
                        // Seconds.
                        sec = matchInt;
                        if (that.outOfRange(sec, 0, 59)) return null;
                        break;
                    case 'tt': case 't':
                        // AM/PM designator.
                        // see if it is standard, upper, or lower case PM. If not, ensure it is at least one of
                        // the AM tokens. If not, fail the parse for this format.
                        pmHour = cal.PM && (matchGroup === cal.PM[0] || matchGroup === cal.PM[1] || matchGroup === cal.PM[2]);
                        if (!pmHour && (!cal.AM || (matchGroup !== cal.AM[0] && matchGroup !== cal.AM[1] && matchGroup !== cal.AM[2]))) return null;
                        break;
                    case 'f': // Deciseconds.
                    case 'ff': // Centiseconds.
                    case 'fff': // Milliseconds.
                        msec = matchInt * Math.pow(10, 3 - clength);
                        if (that.outOfRange(msec, 0, 999)) return null;
                        break;
                    case 'uu':
                    case 'nn':
                    case 'pp':
                    case 'ee':
                    case 'aa':
                    case 'xx':
                    case 'oo':
                        if (that.outOfRange(matchInt, 0, 1000)) {
                            return null;
                        }

                        that[that._codeToUnit[current]] = matchInt;
                        break;
                    case 'ddd': // Day of week.
                    case 'dddd': // Day of week.
                        weekDay = that.getDayIndex(cal, matchGroup, clength === 3);
                        if (that.outOfRange(weekDay, 0, 6)) return null;
                        break;
                    case 'zzz': {
                        // Time zone offset in +/- hours:min.
                        const offsets = matchGroup.split(/:/);
                        if (offsets.length !== 2) return null;
                        hourOffset = parseInt(offsets[0], 10);
                        if (that.outOfRange(hourOffset, -12, 13)) return null;
                        const minOffset = parseInt(offsets[1], 10);
                        if (that.outOfRange(minOffset, 0, 59)) return null;
                        tzMinOffset = (hourOffset * 60) + (that.startsWith(matchGroup, '-') ? -minOffset : minOffset);
                        break;
                    }
                    case 'z': case 'zz':
                        // Time zone offset in +/- hours.
                        hourOffset = matchInt;
                        if (that.outOfRange(hourOffset, -12, 13)) return null;
                        tzMinOffset = hourOffset * 60;
                        break;
                    case 'g': case 'gg': {
                        let eraName = matchGroup;
                        if (!eraName || !cal.eras) return null;
                        eraName = this.trim(eraName.toLowerCase());
                        for (let i = 0, l = cal.eras.length; i < l; i++) {
                            if (eraName === cal.eras[i].nathat.toLowerCase()) {
                                era = i;
                                break;
                            }
                        }
                        // could not find an era with that name
                        if (era === null) return null;
                        break;
                    }
                    default: {
                        let precisionDigits = matchGroup;

                        if (precisionDigits.length % 3 === 1) {
                            precisionDigits += '00';
                        }
                        else if (precisionDigits.length % 3 === 2) {
                            precisionDigits += '0';
                        }

                        msec = parseInt(precisionDigits.slice(0, 3), 10);
                        precisionDigits = precisionDigits.slice(3);

                        let unitIndex = 0;

                        while (precisionDigits.length > 0) {
                            that[that._smallUnits[unitIndex]] = parseInt(precisionDigits.slice(0, 3), 10);

                            precisionDigits = precisionDigits.slice(3);
                            unitIndex++;
                        }
                    }
                }
            }
        }
        let result = new Date(), defaultYear, convert = cal.convert;
        defaultYear = result.getFullYear();
        if (year === null) {
            year = defaultYear;
        }
        else if (cal.eras) {
            // year must be shifted to normal gregorian year
            // but not if year was not specified, its already normal gregorian
            // per the main if clause above.
            year += cal.eras[(era || 0)].offset;
        }
        // set default day and month to 1 and January, so if unspecified, these are the defaults
        // instead of the current day/month.
        if (month === null) {
            month = 0;
        }
        if (date === null) {
            date = 1;
        }
        // now have year, month, and date, but in the culture's calendar.
        // convert to gregorian if necessary
        if (convert) {
            result = convert.toGregorian(year, month, date);
            // conversion failed, must be an invalid match
            if (result === null) return null;
        }
        else {
            // have to set year, month and date together to avoid overflow based on current date.
            result.setFullYear(year, month, date);
            // check to see if date overflowed for specified month (only checked 1-31 above).
            if (result.getDate() !== date) return null;
            // invalid day of week.
            if (weekDay !== null && result.getDay() !== weekDay) {
                return null;
            }
        }
        // if pm designator token was found make sure the hours fit the 24-hour clock.
        if (pmHour && hour < 12) {
            hour += 12;
        }
        result.setHours(hour, min, sec, msec);

        if (tzMinOffset !== null) {
            // adjust timezone to utc before applying local offset.
            const adjustedMin = result.getMinutes() - (tzMinOffset + result.getTimezoneOffset());
            // Safari limits hours and minutes to the range of -127 to 127.  We need to use setHours
            // to ensure both these fields will not exceed this range.  adjustedMin will range
            // somewhere between -1440 and 1500, so we only need to split this into hours.
            result.setHours(result.getHours() + parseInt(adjustedMin / 60, 10), adjustedMin % 60);
        }
        return result;
    }

    toString(format, calendar) {
        const that = this;

        if (format === undefined) {
            format = 'yyyy-MM-dd HH:mm:ss';
        }

        const formatStamp = that.dateData.toString() + that.getFractionsOfSecondStamp() + format + (that.timeZone || '');

        if (JQX.Utilities.DateTime.cache && JQX.Utilities.DateTime.cache[formatStamp]) {
            return JQX.Utilities.DateTime.cache[formatStamp];
        }
        const value = that.toDate();

        if (calendar === undefined || calendar === null) {
            calendar = that.calendar;
        }

        if (typeof value === 'string') {
            return value;
        }

        if (!format || !format.length || format === 'i') {
            let ret;
            ret = that.formatDate(value, calendar.patterns.F, calendar);
            return ret;
        }

        const eras = calendar.eras,
            sortable = format === 's';
        format = that.expandFormat(calendar, format);

        // Start with an empty string
        const ret = [];
        let hour,
            quoteCount = 0,
            tokenRegExp = that.getTokenRegExp(),
            converted;

        function getPart(date, part) {
            if (converted) {
                return converted[part];
            }
            if (date.getMonth !== undefined) {
                switch (part) {
                    case 0: return date.getFullYear();
                    case 1: return date.getMonth();
                    case 2: return date.getDate();
                }
            }
        }

        for (; ;) {
            // Save the current index
            const index = tokenRegExp.lastIndex,
                // Look for the next pattern
                ar = tokenRegExp.exec(format);

            // Append the text before the pattern (or the end of the string if not found)
            const preMatch = format.slice(index, ar ? ar.index : format.length);
            quoteCount += that.appendPreOrPostMatch(preMatch, ret);

            if (!ar) {
                break;
            }

            // do not replace any matches that occur inside a string literal.
            if (quoteCount % 2) {
                ret.push(ar[0]);
                continue;
            }

            const current = ar[0],
                clength = current.length;
            let part;

            if ((/i{1,24}/).test(current)) {
                ret.push(that.getFirstNDigitsOfPrecision(current.length));
                continue;
            }

            switch (current) {
                case 'ddd': //Day of the week, as a three-letter abbreviation
                case 'dddd': {
                    // Day of the week, using the full name
                    const names = (clength === 3) ? calendar.days.namesAbbr : calendar.days.names;
                    ret.push(names[value.getDay()]);
                    break;
                }
                case 'd': // Day of month, without leading zero for single-digit days
                case 'dd': // Day of month, with leading zero for single-digit days
                    ret.push(that.padZeros(getPart(value, 2), clength));
                    break;
                case 'MMM': // Month, as a three-letter abbreviation
                case 'MMMM': // Month, using the full name
                    part = getPart(value, 1);
                    ret.push(calendar.months[clength === 3 ? 'namesAbbr' : 'names'][part]);
                    break;
                case 'M': // Month, as digits, with no leading zero for single-digit months
                case 'MM': // Month, as digits, with leading zero for single-digit months
                    ret.push(that.padZeros(getPart(value, 1) + 1, clength));
                    break;
                case 'y': // Year, as two digits, but with no leading zero for years less than 10
                case 'yy': // Year, as two digits, with leading zero for years less than 10
                case 'yyyy': // Year represented by four full digits
                    part = that.getEraYear(value, calendar, that.getEra(value, eras), sortable);
                    if (clength < 4) {
                        part = part % 100;
                    }
                    ret.push(that.padZeros(part, clength));
                    break;
                case 'h': // Hours with no leading zero for single-digit hours, using 12-hour clock
                case 'hh': // Hours with leading zero for single-digit hours, using 12-hour clock
                    hour = value.getHours() % 12;
                    if (hour === 0) hour = 12;
                    ret.push(that.padZeros(hour, clength));
                    break;
                case 'H': // Hours with no leading zero for single-digit hours, using 24-hour clock
                case 'HH': // Hours with leading zero for single-digit hours, using 24-hour clock
                    ret.push(that.padZeros(value.getHours(), clength));
                    break;
                case 'm': // Minutes with no leading zero  for single-digit minutes
                case 'mm': // Minutes with leading zero  for single-digit minutes
                    ret.push(that.padZeros(value.getMinutes(), clength));
                    break;
                case 's': // Seconds with no leading zero for single-digit seconds
                case 'ss': // Seconds with leading zero for single-digit seconds
                    ret.push(that.padZeros(value.getSeconds(), clength));
                    break;
                case 't': // One character am/pm indicator ('a' or 'p')
                case 'tt': // Multicharacter am/pm indicator
                    part = value.getHours() < 12 ? (calendar.AM ? calendar.AM[0] : ' ') : (calendar.PM ? calendar.PM[0] : ' ');
                    ret.push(clength === 1 ? part.charAt(0) : part);
                    break;
                case 'f': // Deciseconds
                case 'ff': // Centiseconds
                case 'fff': // Milliseconds
                    ret.push(that.padZeros(value.getMilliseconds(), 3).substr(0, clength));
                    break;
                case 'u':
                case 'n':
                case 'p':
                case 'e':
                case 'a':
                case 'x':
                case 'o':
                    ret.push(that[that._codeToUnit[current]]);
                    break;
                case 'uu':
                case 'nn':
                case 'pp':
                case 'ee':
                case 'aa':
                case 'xx':
                case 'oo':
                    ret.push(that.padZeros(that[that._codeToUnit[current]], 3));
                    break;
                case 'z': // Time zone offset, no leading zero                
                case 'zz': // Time zone offset with leading zero
                    //hour = value.getTimezoneOffset() / 60;
                    //ret.push((hour <= 0 ? '+' : '-') + that.padZeros(Math.floor(Math.abs(hour)), clength));

                    ret.push((that.timeZoneOffsetHours >= 0 ? '+' : '-') +
                        that.padZeros(Math.floor(Math.abs(that.timeZoneOffsetHours)), clength));
                    break;
                case 'zzz':
                    //    // Time zone offset with leading zero
                    //    hour = value.getTimezoneOffset() / 60;
                    //    ret.push((hour <= 0 ? '+' : '-') + that.padZeros(Math.floor(Math.abs(hour)), 2) +
                    //    // Hard coded ':' separator, rather than using calendar.TimeSeparator
                    //    // Repeated here for consistency, plus ':' was already assumed in date parsing.
                    //':' + that.padZeros(Math.abs(value.getTimezoneOffset() % 60), 2));

                    ret.push((that.timeZoneOffsetHours >= 0 ? '+' : '-') +
                        that.padZeros(Math.floor(Math.abs(that.timeZoneOffsetHours)), 2) + ':' +
                        that.padZeros(Math.abs(that.timeZoneOffsetHours % 1) * 60, 2));
                    break;
                case 'g':
                case 'gg':
                    if (calendar.eras) {
                        ret.push(calendar.eras[that.getEra(value, eras)].name);
                    }
                    break;
                case '/':
                    ret.push(calendar['/']);
                    break;
                default:
                    throw 'Invalid date format pattern \'' + current + '\'.';
            }
        }

        const result = ret.join('');
        if (!JQX.Utilities.DateTime.cache) {
            JQX.Utilities.DateTime.cache = new Array();
        }
        JQX.Utilities.DateTime.cache[formatStamp] = result;
        return result;
    }

    /**
     * Returns a time stamp from the microseconds, nanoseconds, picoseconds, femtoseconds, attoseconds, zeptoseconds and yoctoseconds.
     */
    getFractionsOfSecondStamp() {
        const that = this;

        return that._microsecond.toString() + that._nanosecond + that._picosecond + that._femtosecond + that._attosecond + that._zeptosecond + that._yoctosecond;
    }

    getFirstNDigitsOfPrecision(precision, noMilliseconds) {
        const that = this,
            result = '' + (noMilliseconds !== true ? that.padZeros(that.millisecond(), 3) : '') +
                that.padZeros(that._microsecond, 3) +
                that.padZeros(that._nanosecond, 3) +
                that.padZeros(that._picosecond, 3) +
                that.padZeros(that._femtosecond, 3) +
                that.padZeros(that._attosecond, 3) +
                that.padZeros(that._zeptosecond, 3) +
                that.padZeros(that._yoctosecond, 3);

        return result.slice(0, precision);
    }

    copySmallTimePartValues(newDate) {
        const that = this;

        newDate._microsecond = that._microsecond;
        newDate._nanosecond = that._nanosecond;
        newDate._picosecond = that._picosecond;
        newDate._femtosecond = that._femtosecond;
        newDate._attosecond = that._attosecond;
        newDate._zeptosecond = that._zeptosecond;
        newDate._yoctosecond = that._yoctosecond;
    }

    add(value, scale, createNew) {
        const that = this;

        const ms = that.internalMS();
        if (scale === undefined) {
            if (createNew === false) {
                that.dateData = (ms + parseInt(value._ticks / that.ticksPerMillisecond));
                return that;
            }

            const newDate = new JQX.Utilities.DateTime((ms + parseInt(value._ticks / that.ticksPerMillisecond)));
            that.copyTimeZone(newDate);
            that.copySmallTimePartValues(newDate);
            return newDate;
        }
        const millis = (value * scale);
        if (millis <= -that.maxMillis || millis >= that.maxMillis)
            throw new Error('Out of Range');

        if (createNew === false) {
            that.dateData = (ms + millis);
            return that;
        }

        const newDate = new JQX.Utilities.DateTime(ms + millis);
        that.copyTimeZone(newDate);
        that.copySmallTimePartValues(newDate);
        return newDate;
    }

    addDays(value, createNew) {
        const that = this;

        return that.add(value, that.millisPerDay, createNew);
    }

    /**
     * Clones a DateTime object.
     */
    clone() {
        const that = this,
            date = new JQX.Utilities.DateTime(that.dateData);

        that.copyTimeZone(date);
        that.copySmallTimePartValues(date);

        return date;
    }

    clearTime() {
        const that = this,
            month = that.month(),
            year = that.year(),
            day = that.day(),
            newDate = new JQX.Utilities.DateTime(year, month, day, 0, 0, 0, 0);

        that.copyTimeZone(newDate);

        return newDate;
    }

    addHours(value, createNew) {
        const that = this;

        return that.add(value, that.millisPerHour, createNew);
    }

    addDeciseconds(value, createNew) {
        return this.add(value * 100, 1, createNew);
    }

    addCentiseconds(value, createNew) {
        return this.add(value * 10, 1, createNew);
    }

    addMilliseconds(value, createNew) {
        return this.add(value, 1, createNew);
    }

    addMinutes(value, createNew) {
        const that = this;

        return that.add(value, that.millisPerMinute, createNew);
    }

    addMonths(months, createNew) {
        const that = this;

        if (months < -120000 || months > 120000) throw new Error('Invalid Months Value');
        let y = parseInt(that.getDatePart(that.datePartYear)),
            m = parseInt(that.getDatePart(that.datePartMonth)),
            d = parseInt(that.getDatePart(that.datePartDay));

        if (months % 12 === 0) {
            y = y + months / 12;
        }
        else {
            const i = m - 1 + months;
            if (i >= 0) {
                m = i % 12 + 1;
                y = y + i / 12;
            }
            else {
                m = 12 + (i + 1) % 12;
                y = y + (i - 11) / 12;
            }
            y = parseInt(y);
        }
        if (y < 1 || y > 9999) {
            throw new Error('Year out of range');
        }
        const days = that.daysInMonth(y, m);
        if (d > days) d = days;

        if (createNew === false) {
            that.dateData = (that.dateToMS(y, m, d) + that.internalMS() % that.millisPerDay);
            return that;
        }

        const newDate = new JQX.Utilities.DateTime((that.dateToMS(y, m, d) + that.internalMS() % that.millisPerDay));
        that.copyTimeZone(newDate);
        that.copySmallTimePartValues(newDate);
        return newDate;
    }

    addSeconds(value, createNew) {
        const that = this;

        return that.add(value, that.millisPerSecond, createNew);
    }

    addYears(value, createNew) {
        return this.addMonths(value * 12, createNew);
    }

    /**
     * Adds or removes microseconds.
     */
    addMicroseconds(value, createNew) {
        if (value === 0) {
            return;
        }

        const that = this;
        let millisecondsToAdd, microseconds;

        if (value < 0 &&
            that.hour() === 0 &&
            that.minute() === 0 &&
            that.second() === 0 &&
            that.millisecond() === 0 &&
            that._microsecond === 0) {

            millisecondsToAdd = parseInt(value / 1000, 10) - 1;
            microseconds = 1000 + (value % 1000);
        }

        const totalMilliseconds = that.timeToMS(that.hour(), that.minute(), that.second(), that.millisecond()) * 1000 + that._microsecond,
            updatedTotalMilliseconds = totalMilliseconds + value;

        if (millisecondsToAdd === undefined) {
            millisecondsToAdd = parseInt(updatedTotalMilliseconds / 1000, 10) - parseInt(totalMilliseconds / 1000, 10);
        }

        if (microseconds === undefined) {
            microseconds = parseInt(updatedTotalMilliseconds % 1000, 10);
        }

        let newDateTimeObject;

        if (millisecondsToAdd !== 0) {
            newDateTimeObject = that.addMilliseconds(millisecondsToAdd, createNew);
        }

        if (createNew === false) {
            that._microsecond = microseconds;
        }
        else {
            if (!newDateTimeObject) {
                newDateTimeObject = that.clone();
            }

            newDateTimeObject._microsecond = microseconds;

            return newDateTimeObject;
        }
    }

    /**
     * Adds or removes parts of a second.
     */
    addFractionsOfSecond(value, createNew, unit, biggerUnit, biggerUnitMethod) {
        if (value === 0) {
            return;
        }

        const that = this,
            total = that[biggerUnit] * 1000 + that[unit],
            updatedTotal = value + total;
        let biggerUnitToAdd = parseInt(updatedTotal / 1000, 10) - parseInt(total / 1000, 10),
            units = parseInt(updatedTotal % 1000, 10),
            newDateTimeObject;

        if (value < 0 && updatedTotal < 0 && units < 0) {
            biggerUnitToAdd--;
            units = 1000 + units;
        }

        if (biggerUnitToAdd !== 0) {
            newDateTimeObject = that[biggerUnitMethod](biggerUnitToAdd, createNew);
        }

        if (createNew === false) {
            that[unit] = units;
        }
        else {
            if (!newDateTimeObject) {
                newDateTimeObject = that.clone();
            }

            newDateTimeObject[unit] = units;

            return newDateTimeObject;
        }
    }

    /**
     * Adds or removes nanoseconds.
     */
    addNanoseconds(value, createNew) {
        return this.addFractionsOfSecond(value, createNew, '_nanosecond', '_microsecond', 'addMicroseconds');
    }

    /**
     * Adds or removes picoseconds.
     */
    addPicoseconds(value, createNew) {
        return this.addFractionsOfSecond(value, createNew, '_picosecond', '_nanosecond', 'addNanoseconds');
    }

    /**
     * Adds or removes femtoseconds.
     */
    addFemtoseconds(value, createNew) {
        return this.addFractionsOfSecond(value, createNew, '_femtosecond', '_picosecond', 'addPicoseconds');
    }

    /**
     * Adds or removes attoseconds.
     */
    addAttoseconds(value, createNew) {
        return this.addFractionsOfSecond(value, createNew, '_attosecond', '_femtosecond', 'addFemtoseconds');
    }

    /**
     * Adds or removes zeptoseconds.
     */
    addZeptoseconds(value, createNew) {
        return this.addFractionsOfSecond(value, createNew, '_zeptosecond', '_attosecond', 'addAttoseconds');
    }

    /**
     * Adds or removes yoctoseconds.
     */
    addYoctoseconds(value, createNew) {
        return this.addFractionsOfSecond(value, createNew, '_yoctosecond', '_zeptosecond', 'addZeptoseconds');
    }

    getTimeZoneOffset() {
        const today = new Date(),
            jan = new Date(today.getFullYear(), 0, 1),
            jul = new Date(today.getFullYear(), 6, 1),
            dst = today.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());

        return {
            offset: -(today.getTimezoneOffset() / 60),
            dst: +dst
        };
    }

    isInDaylightSavingTime() {
        const today = new Date(),
            winter = new Date(today.getFullYear(), 0, 1),
            summer = new Date(today.getFullYear(), 6, 1);

        return this.date().getTimezoneOffset() < Math.max(winter.getTimezoneOffset(), summer.getTimezoneOffset());
    }

    supportsDaylightSavingTime() {
        const today = new Date(),
            winter = new Date(today.getFullYear(), 0, 1),
            summer = new Date(today.getFullYear(), 6, 1);
        return winter.getTimezoneOffset() !== summer.getTimezoneOffset();
    }

    date() {
        const that = this,
            month = that.month(),
            year = that.year(),
            day = that.day(),
            newDate = new JQX.Utilities.DateTime(year, month, day);

        that.copyTimeZone(newDate);
        return newDate;
    }

    isWeekend() {
        const that = this;

        return that.dayOfWeek() === 0 || that.dayOfWeek() === 6;
    }

    toDate(timeZone) {
        const that = this,
            month = that.month(),
            year = that.year(),
            day = that.day(),
            hour = that.hour(),
            minute = that.minute(),
            second = that.second(),
            millisecond = that.millisecond();
        let result = new Date(year, month - 1, day);

        if (year < 1970) {
            result.setFullYear(year);
        }
        result.setHours(hour, minute, second, millisecond);
        if (timeZone) {
            const matches = that.timeZones.filter(function (zone) {
                return zone.id === timeZone;
            });
            if (matches.length) {
                let tzMinOffset = matches[0].offset;
                const localTime = result.getTime();
                let localOffset = result.getTimezoneOffset() * 60 * 1000;
                if (that.timeZone) {
                    const timeZoneMatches = that.timeZones.filter(function (zone) {
                        return zone.id === that.timeZone;
                    });
                    if (timeZoneMatches.length) {
                        localOffset = -timeZoneMatches[0].offset * 60 * 1000;
                    }
                }
                // obtain UTC time in msec
                const utc = localTime + localOffset;

                // create new Date object for different city
                // using supplied offset
                result = new Date(utc + (60 * 1000 * tzMinOffset));
            }
        }
        return result;
    }

    toTimeZone(timeZone) {
        const that = this;
        let tz = timeZone;

        if (tz === null || tz === undefined) {
            tz = 'Local';
        }

        if (that.timeZone === tz) {
            return that.clone();
        }

        const matches = that.timeZones.filter(function (zone) {
            return zone.id === tz;
        });

        if (matches.length === 0) {
            return that.clone();
        }

        const date = this.toDate(tz),
            jqxDate = new JQX.Utilities.DateTime(date);

        jqxDate.timeZone = tz;
        jqxDate.timeZoneOffset = matches[0].offset;
        jqxDate.timeZoneOffsetHours = matches[0].offsetHours;

        that.copySmallTimePartValues(jqxDate);

        return jqxDate;
    }

    day() {
        const that = this;

        return that.getDatePart(that.datePartDay);
    }

    month() {
        const that = this;

        return that.getDatePart(that.datePartMonth);
    }

    year() {
        const that = this;

        return that.getDatePart(that.datePartYear);
    }

    millisecond() {
        return parseInt((this.internalMS()) % 1000);
    }

    hour() {
        const that = this;

        return parseInt(Math.floor(that.internalMS() / that.millisPerHour) % 24);
    }

    minute() {
        const that = this;

        return parseInt((that.internalMS() / that.millisPerMinute) % 60);
    }

    second() {
        const that = this;

        return parseInt((that.internalMS() / that.millisPerSecond) % 60);
    }

    microsecond() {
        return this._microsecond;
    }

    nanosecond() {
        return this._nanosecond;
    }

    picosecond() {
        return this._picosecond;
    }

    femtosecond() {
        return this._femtosecond;
    }

    attosecond() {
        return this._attosecond;
    }

    zeptosecond() {
        return this._zeptosecond;
    }

    yoctosecond() {
        return this._yoctosecond;
    }

    valueOf() {
        return this.dateData;
    }

    equals(date) {
        const that = this;

        return that.dateData === date.dateData && that._microsecond === date._microsecond && that._nanosecond === date._nanosecond && that._picosecond === date._picosecond &&
            that._femtosecond === date._femtosecond && that._attosecond === date._attosecond && that._zeptosecond === date._zeptosecond && that._yoctosecond === date._yoctosecond;
    }

    equalDateParts(date) {
        const that = this;

        if (that.year() === date.year() &&
            that.month() === date.month() &&
            that.day() === date.day()) {
            return true;
        }

        return false;
    }

    /**
     * Compares two dates.
     */
    compare(date) {
        const that = this;

        if (that.equals(date)) {
            return 0;
        }

        const timeParts = ['dateData', '_microsecond', '_nanosecond', '_picosecond', '_femtosecond', '_attosecond', '_zeptosecond', '_yoctosecond'];

        for (let i = 0; i < timeParts.length; i++) {
            const timePart = timeParts[i];

            if (that[timePart] > date[timePart]) {
                return 1;
            }
            else if (that[timePart] < date[timePart]) {
                return -1;
            }
        }

        return 0;
    }

    toDateString() {
        return this.toDate().toDateString();
    }

    toLocaleDateString() {
        const that = this;

        return that.toDate().toLocaleDateString(that.calendar.locale);
    }

    toLocaleString() {
        const that = this;

        return that.toDate().toLocaleString(that.calendar.locale);
    }

    toLocaleTimeString() {
        const that = this;

        return that.toDate().toLocaleTimeString(that.calendar.locale);
    }

    validateTimeZone(timeZone) {
        const that = this;

        if (typeof timeZone !== 'string') {
            return;
        }

        const matches = that.timeZones.filter(function (zone) {
            return zone.id === timeZone;
        });

        if (matches.length === 0) {
            return;
        }

        that.timeZone = timeZone;
        that.timeZoneOffset = matches[0].offset;
        that.timeZoneOffsetHours = matches[0].offsetHours;
    }

    copyTimeZone(newDateTime) {
        const that = this;

        newDateTime.timeZone = that.timeZone;
        newDateTime.timeZoneOffset = that.timeZoneOffset;
        newDateTime.timeZoneOffsetHours = that.timeZoneOffsetHours;
    }

    getTimeStamp() {
        const that = this,
            timeStamp = new JQX.Utilities.BigNumber(that.dateData.toString() + that.getFirstNDigitsOfPrecision(undefined, true));

        return timeStamp;
    }
});

// Draw class
JQX.Utilities.Assign('Draw', class Draw {
    constructor(host, renderEngine) {
        const that = this;

        that.host = host;
        that.renderEngine = renderEngine || '';

        that.refresh();

        const functions = [
            'clear',
            'removeElement',
            'attr',
            'getAttr',
            'line',
            'circle',
            'rect',
            'path',
            'pieslice',
            'pieSlicePath',
            'text',
            'measureText'
        ];

        for (let i in functions) {
            that._addFn(JQX.Utilities.Draw.prototype, functions[i]);
        }
    }

    _addFn(target, name) {
        if (target[name])
            return;

        target[name] = function () {
            return this.renderer[name].apply(this.renderer, arguments);
        };
    }

    _initRenderer(host) {
        return this.createRenderer(this, host);
    }

    _internalRefresh() {
        const self = this;

        if (!self.renderer) {
            self.host.innerHTML = '';
            self._initRenderer(self.host);
        }

        // validate visiblity
        if (window.getComputedStyle(self.host).display === 'none') {
            return;
        }

        const renderer = self.renderer;
        if (!renderer)
            return;

        const rect = renderer.getRect();

        self._render({ x: 1, y: 1, width: rect.width, height: rect.height });
    }

    _render(rect) {
        this._plotRect = rect;
    }

    // Public API
    refresh() {
        this._internalRefresh();
    }

    getSize() {
        const rect = this._plotRect;
        return { width: rect.width, height: rect.height };
    }

    toGreyScale(color) {
        if (color.indexOf('#') === -1)
            return color;

        const rgb = this.cssToRgb(color);
        rgb[0] = rgb[1] = rgb[2] = Math.round(0.3 * rgb[0] + 0.59 * rgb[1] + 0.11 * rgb[2]);
        const hex = this.rgbToHex(rgb[0], rgb[1], rgb[2]);
        return '#' + hex[0] + hex[1] + hex[2];
    }

    decToHex(dec) {
        return dec.toString(16);
    }

    hexToDec(hex) {
        return parseInt(hex, 16);
    }

    rgbToHex(r, g, b) {
        return [this.decToHex(r), this.decToHex(g), this.decToHex(b)];
    }

    hexToRgb(h, e, x) {
        return [this.hexToDec(h), this.hexToDec(e), this.hexToDec(x)];
    }

    cssToRgb(color) {
        if (color.indexOf('rgb') <= -1) {
            return this.hexToRgb(color.substring(1, 3), color.substring(3, 5), color.substring(5, 7));
        }
        return color.substring(4, color.length - 1).split(',');
    }

    hslToRgb(hsl) {
        let r, g, b;
        const h = parseFloat(hsl[0]);
        const s = parseFloat(hsl[1]);
        const l = parseFloat(hsl[2]);

        if (s === 0) {
            r = g = b = l;
        }
        else {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = this.hueToRgb(p, q, h + 1 / 3);
            g = this.hueToRgb(p, q, h);
            b = this.hueToRgb(p, q, h - 1 / 3);
        }
        return [r * 255, g * 255, b * 255];
    }

    hueToRgb(p, q, t) {
        if (t < 0)
            t += 1;
        if (t > 1)
            t -= 1;

        if (t < 1 / 6)
            return p + (q - p) * 6 * t;
        else if (t < 1 / 2)
            return q;
        else if (t < 2 / 3)
            return p + (q - p) * (2 / 3 - t) * 6;

        return p;

    }

    rgbToHsl(rgb) {
        const r = parseFloat(rgb[0]) / 255;
        const g = parseFloat(rgb[1]) / 255;
        const b = parseFloat(rgb[2]) / 255;

        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0;
        }
        else {
            const diff = max - min;
            s = l > 0.5 ? diff / (2 - max - min) : diff / (max + min);
            switch (max) {
                case r: h = (g - b) / diff + (g < b ? 6 : 0); break;
                case g: h = (b - r) / diff + 2; break;
                case b: h = (r - g) / diff + 4; break;
            }
            h /= 6;
        }

        return [h, s, l];
    }

    swap(x, y) {
        const tmp = x;
        x = y;
        y = tmp;
    }

    getNum(arr) {
        if (arr.constructor !== Array) {
            if (isNaN(arr))
                return 0;
        }
        else {
            for (let i = 0; i < arr.length; i++)
                if (!isNaN(arr[i]))
                    return arr[i];
        }

        return 0;
    }

    _ptRotate(x, y, cx, cy, angle) {
        const radius = Math.sqrt(Math.pow(Math.abs(x - cx), 2) + Math.pow(Math.abs(y - cy), 2));
        const currAngle = Math.asin((x - cx) / radius);
        const newAngle = currAngle + angle;

        x = cx + Math.cos(newAngle) * radius;
        y = cy + Math.sin(newAngle) * radius;

        return { x: x, y: y };
    }

    log(val, base) {
        return Math.log(val) / (base ? Math.log(base) : 1);
    }

    _mod(a, b) {
        const min = Math.abs(a > b ? b : a);
        let scale = 1;
        if (min !== 0) {
            while (min * scale < 100)
                scale *= 10;
        }

        a = a * scale;
        b = b * scale;

        return (a % b) / scale;
    }

    createRenderer(widgetInstance, host) {
        const self = widgetInstance;
        let renderer = self.renderer = null;

        if (document.createElementNS && self.renderEngine !== 'HTML5') {
            renderer = new JQX.Utilities.SvgRenderer(this);
        }

        if (renderer === null && (self.renderEngine === 'HTML5' || self.renderEngine === undefined)) {
            renderer = new JQX.Utilities.HTML5Renderer(this);
        }

        renderer.init(host);
        self.renderer = renderer;

        return renderer;
    }

    getByPriority(arr) {
        let value = undefined;
        for (let i = 0; i < arr.length; i++) {
            const current = arr[i];

            if (current !== undefined && current !== null && current !== '') {
                value = current;
                break;
            }
        }

        return value;
    }

    get(array, index, key) {
        return key !== undefined ? array[index][key] : array[index];
    }

    min(array, key) {
        let min = NaN;
        for (let i = 0; i < array.length; i++) {
            const val = this.get(array, i, key);

            if (isNaN(min) || val < min)
                min = val;
        }

        return min;
    }

    max(array, key) {
        let max = NaN;
        for (let i = 0; i < array.length; i++) {
            const val = this.get(array, i, key);

            if (isNaN(max) || val > max)
                max = val;
        }

        return max;
    }

    sum(array, key) {
        let sum = 0;
        for (let i = 0; i < array.length; i++) {
            const val = this.get(array, i, key);
            if (!isNaN(val))
                sum += val;
        }

        return sum;
    }

    count(array, key) {
        let count = 0;
        for (let i = 0; i < array.length; i++) {
            const val = this.get(array, i, key);
            if (!isNaN(val))
                count++;
        }

        return count;
    }

    avg(array, key) {
        return this.sum(array, key) / Math.max(1, this.count(array, key));
    }

    filter(array, fn) {
        if (!fn)
            return array;

        const out = [];
        for (let i = 0; i < array.length; i++)
            if (fn(array[i]))
                out.push(array[i]);

        return out;
    }

    scale(val, range, scale_range, params) {
        if (isNaN(val))
            return NaN;

        if (val < Math.min(range.min, range.max) || val > Math.max(range.min, range.max)) {
            if (!params || params['ignore_range'] !== true)
                return NaN;
        }

        let outVal = NaN;

        let percent = 1;
        if (range.type === undefined || range.type !== 'logarithmic') {
            let denom = Math.abs(range.max - range.min);
            if (!denom)
                denom = 1;
            percent = Math.abs(val - Math.min(range.min, range.max)) / denom;
        }
        else if (range.type === 'logarithmic') {
            let logBase = range.base;
            if (isNaN(logBase))
                logBase = 10;

            let min = Math.min(range.min, range.max);
            if (min <= 0)
                min = 1;

            let max = Math.max(range.min, range.max);
            if (max <= 0)
                max = 1;

            const maxPow = this.log(max, logBase);
            max = Math.pow(logBase, maxPow);

            const minPow = this.log(min, logBase);
            min = Math.pow(logBase, minPow);

            const valPow = this.log(val, logBase);

            percent = Math.abs(valPow - minPow) / (maxPow - minPow);
        }

        if (scale_range.type === 'logarithmic') {
            let logBase = scale_range.base;
            if (isNaN(logBase))
                logBase = 10;

            const maxPow = this.log(scale_range.max, logBase),
                minPow = this.log(scale_range.min, logBase);

            if (scale_range.flip)
                percent = 1 - percent;

            const valPow = Math.min(minPow, maxPow) + percent * Math.abs(maxPow - minPow);
            outVal = Math.pow(logBase, valPow);
        }
        else {
            outVal = Math.min(scale_range.min, scale_range.max) + percent * Math.abs(scale_range.max - scale_range.min);

            if (scale_range.flip)
                outVal = Math.max(scale_range.min, scale_range.max) - outVal + scale_range.min;
        }

        return outVal;
    }

    axis(min, max, preferedCount) {
        if (preferedCount <= 1)
            return [max, min];

        if (isNaN(preferedCount) || preferedCount < 2)
            preferedCount = 2;

        let decimalPlaces = 0;
        while (Math.round(min) !== min && Math.round(max) !== max && decimalPlaces < 10) {
            min *= 10;
            max *= 10;
            decimalPlaces++;
        }

        let preferedIntSize = (max - min) / preferedCount;
        while (decimalPlaces < 10 && Math.round(preferedIntSize) !== preferedIntSize) {
            min *= 10;
            max *= 10;
            preferedIntSize *= 10;
            decimalPlaces++;
        }

        const scale = [1, 2, 5];

        let i = 0,
            intSizeNext;

        // eslint-disable-next-line
        while (true) {
            let idx = i % scale.length;
            let pow = Math.floor(i / scale.length);
            let intSizeCurr = Math.pow(10, pow) * scale[idx];

            idx = (i + 1) % scale.length;
            pow = Math.floor((i + 1) / scale.length);
            intSizeNext = Math.pow(10, pow) * scale[idx];

            if (preferedIntSize >= intSizeCurr && preferedIntSize < intSizeNext)
                break;

            i++;
        }

        const intSizeSelected = intSizeNext;

        const out = [];
        let curr = this.renderer._rnd(min, intSizeSelected, false);
        const denominator = decimalPlaces <= 0 ? 1 : Math.pow(10, decimalPlaces);
        while (curr < max + intSizeSelected) {
            out.push(curr / denominator);
            curr += intSizeSelected;
        }

        return out;
    }

    _widgetToImage(widgetInstance, type, fileName, fnCallback, pageOrientation) {
        let self = widgetInstance;

        if (!self)
            return false;

        if (fileName === undefined || fileName === '')
            fileName = 'image.' + type;

        let renderEngineSaved = self.renderEngine;
        let enableAnimationsSaved = self.animation;

        self.animation = 'none';

        // try switching to HTML5
        self.renderEngine = 'HTML5';

        if (self.renderEngine !== renderEngineSaved) {
            try {
                self.refresh();
            }
            catch (e) {
                self.renderEngine = renderEngineSaved;
                self.refresh();
                self.animation = enableAnimationsSaved;

                return false;
            }
        }

        let canvas = self.renderer.getContainer().firstElementChild;

        let continueExport = true;
        if (typeof fnCallback === 'function') {
            continueExport = fnCallback(widgetInstance, canvas);
        }

        let result = true;
        if (continueExport)
            result = this.exportImage(widgetInstance, canvas, type, fileName, pageOrientation);

        // switch back to existing engine
        if (self.renderEngine !== renderEngineSaved) {
            self.renderEngine = renderEngineSaved;
            self.refresh();
            self.animation = enableAnimationsSaved;
        }

        return result;
    }

    _saveAsImage(type, fileName) {
        return this._widgetToImage(this, type, fileName);
    }

    saveAsPNG(filename) {
        return this._saveAsImage('png', filename);
    }

    saveAsJPEG(filename) {
        return this._saveAsImage('jpeg', filename);
    }

    exportImage(widgetInstance, canvas, type, fileName, pageOrientation) {
        if (!canvas)
            return false;

        let isPDF = type.toLowerCase() === 'pdf';
        if (isPDF) type = 'jpeg';
        if (fileName === undefined || fileName === '')
            fileName = 'image.' + type;

        let result = true;

        if (type === 'print') {
            const newWindow = window.open('', '', 'width=800,height=500'),
                printDocument = newWindow.document.open(),
                pageContent =
                    '<!DOCTYPE html>' +
                    '<html>' +
                    '<head>' +
                    '<meta charset="utf-8" />' +
                    '<title>jQWidgets Chart</title>' +
                    '</head>' +
                    '<body><img src="' + canvas.toDataURL() + '" /></html>';

            try {
                printDocument.write(pageContent);
                printDocument.close();

                setTimeout(function () {
                    newWindow.print();
                    newWindow.close();
                }, 100);
            }
            catch (error) {
                //
            }

            return;
        }

        try {
            if (canvas) {
                if (isPDF) {
                    pageOrientation = pageOrientation || 'portrait';

                    const data = canvas.toDataURL('image/' + type),
                        docDefinition = {
                            content: {
                                image: data,
                                width: Math.min(canvas.width / 1.35, (pageOrientation === 'portrait' ? 515 : 762))
                            },
                            pageOrientation: pageOrientation
                        };

                    try {
                        pdfMake.createPdf(docDefinition).download(fileName);
                    }
                    catch (error) {
                        widgetInstance.error(widgetInstance.localize('missingReference', { files: 'pdfmake.min.js' }));
                    }
                }
                else {
                    if (!JQX.Utilities.DataExporter) {
                        widgetInstance.error(widgetInstance.localize('missingReference', { files: 'jqxexport.js' }));
                    }

                    const dataExporter = new JQX.Utilities.DataExporter();

                    canvas.toBlob(function (blob) {
                        dataExporter.downloadFile(blob, type, fileName);
                    });
                }
            }
        }
        catch (e) {
            result = false;
        }

        return result;
    }
});

// SvgRenderer class
JQX.Utilities.Assign('Renderer', class Renderer {
    constructor(draw) {
        const that = this;

        that.draw = draw;
        that._gradients = {};
        that._toRadiansCoefficient = Math.PI * 2 / 360;
    }

    pieSlicePath(x, y, innerRadius, outerRadius, angleFrom, angleTo, centerOffset) {
        if (!outerRadius)
            outerRadius = 1;

        const diff = Math.abs(angleFrom - angleTo);
        const lFlag = diff > 180 ? 1 : 0;
        if (diff >= 360) {
            angleTo = angleFrom + 359.99;
        }
        const radFrom = angleFrom * this._toRadiansCoefficient;
        const radTo = angleTo * this._toRadiansCoefficient;

        let x1 = x, x2 = x, y1 = y, y2 = y;

        const isDonut = !isNaN(innerRadius) && innerRadius > 0;

        if (isDonut)
            centerOffset = 0;

        const radFromCos = Math.cos(radFrom),
            radFromSin = Math.sin(radFrom),
            radToCos = Math.cos(radTo),
            radToSin = Math.sin(radTo);

        if (centerOffset + innerRadius > 0) {
            if (centerOffset > 0) {
                const midAngle = diff / 2 + angleFrom;
                const radMid = midAngle * this._toRadiansCoefficient;

                x += centerOffset * Math.cos(radMid);
                y -= centerOffset * Math.sin(radMid);
            }

            if (isDonut) {
                x1 = x + innerRadius * radFromCos;
                y1 = y - innerRadius * radFromSin;
                x2 = x + innerRadius * radToCos;
                y2 = y - innerRadius * radToSin;
            }
        }

        const x3 = x + outerRadius * radFromCos;
        const x4 = x + outerRadius * radToCos;
        const y3 = y - outerRadius * radFromSin;
        const y4 = y - outerRadius * radToSin;

        let path = '';

        const isPartialCircle = (Math.abs(Math.abs(angleTo - angleFrom) - 360) > 0.02);

        if (isDonut) {
            path = 'M ' + x2 + ',' + y2;
            path += ' a' + innerRadius + ',' + innerRadius;
            path += ' 0 ' + lFlag + ',1 ' + (x1 - x2) + ',' + (y1 - y2);
            if (isPartialCircle)
                path += ' L' + x3 + ',' + y3;
            else
                path += ' M' + x3 + ',' + y3;

            path += ' a' + outerRadius + ',' + outerRadius;
            path += ' 0 ' + lFlag + ',0 ' + (x4 - x3) + ',' + (y4 - y3);

            if (isPartialCircle)
                path += ' Z';
        }
        else {
            path = 'M ' + x4 + ',' + y4;
            path += ' a' + outerRadius + ',' + outerRadius;
            path += ' 0 ' + lFlag + ',1 ' + (x3 - x4) + ',' + (y3 - y4);

            if (isPartialCircle) {
                path += ' L' + x + ',' + y;
                path += ' Z';
            }
        }

        return path;
    }

    measureText(text, angle, params, includeTextPartsInfo) {
        const textPartsInfo = this._getTextParts(text, angle, params);
        const tw = textPartsInfo.width;
        let th = textPartsInfo.height;

        if (false === includeTextPartsInfo)
            th /= 0.6;

        let retVal = {};

        if (isNaN(angle))
            angle = 0;

        if (angle === 0) {
            retVal = { width: this._rup(tw), height: this._rup(th) };
        }
        else {
            const rads = angle * Math.PI * 2 / 360;
            const sn = Math.abs(Math.sin(rads));
            const cs = Math.abs(Math.cos(rads));
            const bh = Math.abs(tw * sn + th * cs);
            const bw = Math.abs(tw * cs + th * sn);

            retVal = { width: this._rup(bw), height: this._rup(bh) };
        }

        if (includeTextPartsInfo)
            retVal.textPartsInfo = textPartsInfo;

        //retVal.height += 5;
        return retVal;
    }

    alignTextInRect(x, y, width, height, textWidth, textHeight, halign, valign, angle, rotateAround) {
        const rads = angle * Math.PI * 2 / 360;
        const sn = Math.sin(rads);
        const cs = Math.cos(rads);

        const h2 = textWidth * sn;
        const w2 = textWidth * cs;

        if (halign === 'center' || halign === '' || halign === 'undefined')
            x = x + width / 2;
        else if (halign === 'right')
            x = x + width;

        if (valign === 'center' || valign === 'middle' || valign === '' || valign === 'undefined')
            y = y + height / 2;
        else if (valign === 'bottom')
            y += height - textHeight / 2;
        else if (valign === 'top')
            y += textHeight / 2;

        rotateAround = rotateAround || '';

        let adjustY = 'middle';
        if (rotateAround.indexOf('top') !== -1)
            adjustY = 'top';
        else if (rotateAround.indexOf('bottom') !== -1)
            adjustY = 'bottom';

        let adjustX = 'center';
        if (rotateAround.indexOf('left') !== -1)
            adjustX = 'left';
        else if (rotateAround.indexOf('right') !== -1)
            adjustX = 'right';

        if (adjustX === 'center') {
            x -= w2 / 2;
            y -= h2 / 2;
        }
        else if (adjustX === 'right') {
            x -= w2;
            y -= h2;
        }

        if (adjustY === 'top') {
            x -= textHeight * sn;
            y += textHeight * cs;
        }
        else if (adjustY === 'middle') {
            x -= textHeight * sn / 2;
            y += textHeight * cs / 2;
        }

        x = this._rup(x);
        y = this._rup(y);

        return { x: x, y: y };
    }

    adjustColor(color, adj) {
        if (typeof (color) !== 'string')
            return '#000000';

        if (color.indexOf('#') === -1)
            return color;

        const draw = this.draw;
        let rgb = draw.cssToRgb(color);
        const hsl = draw.rgbToHsl(rgb);
        hsl[2] = Math.min(1, hsl[2] * adj);
        hsl[1] = Math.min(1, hsl[1] * adj * 1.1);
        rgb = draw.hslToRgb(hsl);

        color = '#';
        for (let i = 0; i < 3; i++) {
            let c = Math.round(rgb[i]);
            c = draw.decToHex(c);
            if (c.toString().length === 1)
                color += '0';

            color += c;
        }

        return color.toUpperCase();
    }

    _rup(n) {
        let nr = Math.round(n);
        if (n > nr)
            nr++;

        return nr;
    }

    _ptdist(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }

    _rnd(num, unit, toGreater, fast) {
        if (isNaN(num))
            return num;

        if (undefined === fast)
            fast = true;

        let a = num - ((fast === true) ? num % unit : this._mod(num, unit));
        if (num === a)
            return a;

        if (toGreater) {
            if (num > a)
                a += unit;
        }
        else {
            if (a > num)
                a -= unit;
        }

        return (unit === 1) ? Math.round(a) : a;
    }

    _ptrnd(val) {
        if (!document.createElementNS) {
            if (Math.round(val) === val)
                return val;
            return this._rnd(val, 1, false, true);
        }

        const rnd = this._rnd(val, 0.5, false, true);
        if (Math.abs(rnd - Math.round(rnd)) !== 0.5) {
            return rnd > val ? rnd - 0.5 : rnd + 0.5;
        }
        return rnd;
    }

    _getContrastColor(color) {
        if (color === undefined) {
            return undefined;
        }

        let rgb = this.draw.hexToRgb(color.slice(1, 3), color.slice(3, 5), color.slice(5, 7)),
            luminance = (0.299 * rgb[0] + 0.587 * rgb[1] + 0.114 * rgb[2]) / 255;

        if (luminance > 0.6) {
            return '#000000';
        }
        else {
            return '#FFFFFF';
        }
    }
});

// SvgRenderer class
JQX.Utilities.Assign('SvgRenderer', class SvgRenderer extends JQX.Utilities.Renderer {
    constructor(draw) {
        super(draw);

        const that = this;

        that._svgns = 'http://www.w3.org/2000/svg';
        that._openGroups = [];
        that._clipId = 0;
    }

    init(host) {
        const container = document.createElement('div');

        container.className = 'drawContainer';
        container.onselectstart = function () {
            return false;
        }

        host.appendChild(container);

        this.host = host;
        this.container = container;

        try {
            const svg = document.createElementNS(this._svgns, 'svg');
            svg.setAttribute('version', '1.1');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('overflow', 'hidden');
            container.appendChild(svg);
            this.canvas = svg;
        }
        catch (e) {
            return false;
        }

        this._id = new Date().getTime();
        this.clear();

        return true;
    }

    getType() {
        return 'SVG';
    }

    refresh() {
    }

    getRect() {
        return { x: 0, y: 0, width: Math.max(this._rup(this.host.offsetWidth) - 1, 0), height: Math.max(this._rup(this.host.offsetHeight) - 1, 0) };
    }

    getContainer() {
        return this.container;
    }

    clear() {
        while (this.canvas.childNodes.length > 0) {
            this.removeElement(this.canvas.firstElementChild);
        }

        this._defaultParent = undefined;
        this._defs = document.createElementNS(this._svgns, 'defs');
        this._gradients = {};
        this.canvas.appendChild(this._defs);
    }

    removeElement(element) {
        if (undefined === element)
            return;

        try {
            while (element.firstChild) {
                this.removeElement(element.firstChild);
            }

            if (element.parentNode)
                element.parentNode.removeChild(element);
            else
                this.canvas.removeChild(element);
        }
        catch (error) {
            //
        }
    }

    beginGroup() {
        const parent = this._activeParent();
        const g = document.createElementNS(this._svgns, 'g');
        parent.appendChild(g);
        this._openGroups.push(g);

        return g;
    }

    endGroup() {
        if (this._openGroups.length === 0)
            return;

        this._openGroups.pop();
    }

    _activeParent() {
        return this._openGroups.length === 0 ? this.canvas : this._openGroups[this._openGroups.length - 1];
    }

    createClipRect(rect) {
        const c = document.createElementNS(this._svgns, 'clipPath');
        const r = document.createElementNS(this._svgns, 'rect');
        this.attr(r, { x: rect.x, y: rect.y, width: rect.width, height: rect.height, fill: 'none' });

        this._clipId = this._clipId || 0;
        c.id = 'cl' + this._id + '_' + (++this._clipId).toString();
        c.appendChild(r);

        this._defs.appendChild(c);

        return c;
    }

    getWindowHref() {
        // Get modified href. This is needed to handle cases where the page uses <base> tags.

        let href = window.location.href;
        if (!href)
            return href;

        href = href.replace(/([\('\)])/g, '\\$1'); // escape brackets & quotes (Chrome)
        href = href.replace(/#.*$/, ''); // remove bookmark links

        return href;
    }

    setClip(elem, clip) {
        const url = 'url(' + this.getWindowHref() + '#' + clip.id + ')';
        return this.attr(elem, { 'clip-path': url });
    }

    addHandler(element, event, fn) {
        element.addEventListener(event, fn);
    }

    removeHandler(/*element, event, fn*/) {
        //if ($(element).off)
        //    $(element).off(event, fn);
        //else
        //    $(element).unbind(event, fn);
    }

    on(element, event, fn) {
        this.addHandler(element, event, fn);
    }

    off(element, event, fn) {
        this.removeHandler(element, event, fn);
    }

    shape(name, params) {
        const s = document.createElementNS(this._svgns, name);
        if (!s)
            return undefined;

        for (let param in params)
            s.setAttribute(param, params[param]);

        this._activeParent().appendChild(s);

        return s;
    }

    _getTextParts(text, angle, params) {
        const textPartsInfo = { width: 0, height: 0, parts: [] };
        if (undefined === text)
            return textPartsInfo;

        const coeff = 0.6;
        const textParts = text.toString().split('<br>');

        const parent = this._activeParent();
        const txt = document.createElementNS(this._svgns, 'text');
        this.attr(txt, params);

        for (let i = 0; i < textParts.length; i++) {
            const textPart = textParts[i];

            const txtNode = txt.ownerDocument.createTextNode(textPart);
            txt.appendChild(txtNode);

            parent.appendChild(txt);
            let bbox;
            try {
                bbox = txt.getBBox();
            }
            catch (e) {
                //
            }

            const tw = this._rup(bbox.width);
            const th = this._rup(bbox.height * coeff);

            txt.removeChild(txtNode);

            textPartsInfo.width = Math.max(textPartsInfo.width, tw);
            textPartsInfo.height += th + (i > 0 ? 4 : 0);
            textPartsInfo.parts.push({ width: tw, height: th, text: textPart });
        }
        parent.removeChild(txt);

        return textPartsInfo;
    }

    _measureText(text, angle, params, includeTextPartsInfo) {
        return super.measureText(text, angle, params, includeTextPartsInfo);
    }

    measureText(text, angle, params) {
        return this._measureText(text, angle, params, false);
    }

    text(text, x, y, width, height, angle, params, clip, halign, valign, rotateAround) {
        const sz = this._measureText(text, angle, params, true, this);
        const textPartsInfo = sz.textPartsInfo;
        const textParts = textPartsInfo.parts;
        const color = this._getContrastColor(arguments[11]);

        let gClip;
        if (!halign)
            halign = 'center';
        if (!valign)
            valign = 'center';

        if (textParts.length > 1 || clip)
            gClip = this.beginGroup();

        if (clip) {
            const crect = this.createClipRect({ x: this._rup(x) - 1, y: this._rup(y) - 1, width: this._rup(width) + 2, height: this._rup(height) + 2 });
            this.setClip(gClip, crect);
        }

        //this.rect(x, y, width, height, {fill: 'yellow', stroke: 'red'});

        let parent = this._activeParent();

        let tw = 0, th = 0;

        tw = textPartsInfo.width;
        th = textPartsInfo.height;

        if (isNaN(width) || width <= 0)
            width = tw;
        if (isNaN(height) || height <= 0)
            height = th;

        const w = width || 0;
        const h = height || 0;

        let yOffset = 0;

        if (!angle || angle === 0) {
            y += th;

            if (valign === 'center' || valign === 'middle')
                y += (h - th) / 2;
            else if (valign === 'bottom')
                y += h - th;

            if (!width)
                width = tw;

            if (!height)
                height = th;

            parent = this._activeParent();
            let txt;
            for (let i = textParts.length - 1; i >= 0; i--) {
                txt = document.createElementNS(this._svgns, 'text');
                this.attr(txt, params);
                this.attr(txt, { cursor: 'default' });

                const txtNode = txt.ownerDocument.createTextNode(textParts[i].text);
                txt.appendChild(txtNode);

                let xOffset = x;
                const wPart = textParts[i].width;
                const hPart = textParts[i].height;

                if (halign === 'center')
                    xOffset += (w - wPart) / 2;
                else if (halign === 'right')
                    xOffset += (w - wPart);

                this.attr(txt, { x: this._rup(xOffset), y: this._rup(y + yOffset), width: this._rup(wPart), height: this._rup(hPart) });

                if (color !== undefined) {
                    txt.style.fill = color;
                }

                parent.appendChild(txt);

                yOffset -= textParts[i].height + 4;
            }

            if (gClip) {
                this.endGroup();
                return gClip;
            }

            return txt;
        }

        const point = this.alignTextInRect(x, y, width, height, tw, th, halign, valign, angle, rotateAround);
        x = point.x;
        y = point.y;

        const gTranslate = this.shape('g', { transform: 'translate(' + x + ',' + y + ')' });
        const gRotate = this.shape('g', { transform: 'rotate(' + angle + ')' });

        gTranslate.appendChild(gRotate);

        // add the text blocks
        yOffset = 0;

        for (let i = textParts.length - 1; i >= 0; i--) {
            const tx = document.createElementNS(this._svgns, 'text');
            this.attr(tx, params);
            this.attr(tx, { cursor: 'default' });

            const txtNode = tx.ownerDocument.createTextNode(textParts[i].text);
            tx.appendChild(txtNode);

            let xOffset = 0;
            const wPart = textParts[i].width;
            const hPart = textParts[i].height;

            if (halign === 'center')
                xOffset += (textPartsInfo.width - wPart) / 2;
            else if (halign === 'right')
                xOffset += (textPartsInfo.width - wPart);

            this.attr(tx, { x: this._rup(xOffset), y: this._rup(yOffset), width: this._rup(wPart), height: this._rup(hPart) });
            gRotate.appendChild(tx);

            yOffset -= hPart + 4;
        }

        parent.appendChild(gTranslate);

        if (gClip)
            this.endGroup();

        return gTranslate;
    }

    line(x1, y1, x2, y2, params) {
        const line = this.shape('line', { x1: x1, y1: y1, x2: x2, y2: y2 });
        this.attr(line, params);
        return line;
    }

    path(points, params) {
        const s = this.shape('path');
        s.setAttribute('d', points);
        if (params) {
            this.attr(s, params);
        }
        return s;
    }

    rect(x, y, w, h, params) {
        x = this._ptrnd(x);
        y = this._ptrnd(y);
        w = Math.max(1, this._rnd(w, 1, false));
        h = Math.max(1, this._rnd(h, 1, false));
        const s = this.shape('rect', { x: x, y: y, width: w, height: h });
        if (params)
            this.attr(s, params);
        return s;
    }

    circle(x, y, r, params) {
        const s = this.shape('circle', { cx: x, cy: y, r: r });
        if (params)
            this.attr(s, params);
        return s;
    }

    pieslice(x, y, innerRadius, outerRadius, angleFrom, angleTo, centerOffset, params) {
        const pathCmd = this.pieSlicePath(x, y, innerRadius, outerRadius, angleFrom, angleTo, centerOffset);

        const s = this.shape('path');
        s.setAttribute('d', pathCmd);

        if (params)
            this.attr(s, params);

        return s;
    }

    attr(element, params) {
        if (!element || !params)
            return;

        for (let param in params) {
            if (param === 'textContent')
                element.textContent = params[param];
            else {
                element.setAttribute(param, params[param]);
            }
        }
    }

    removeAttr(element, params) {
        if (!element || !params)
            return;

        for (let param in params) {
            if (param === 'textContent')
                element.textContent = '';
            else {
                element.removeAttribute(params[param]);
            }
        }
    }

    getAttr(element, key) {
        return element['getAttribute'](key);
    }

    _toLinearGradient(color, isVertical, stops) {
        const id = 'grd' + this._id + color.replace('#', '') + (isVertical ? 'v' : 'h');
        const url = 'url(' + this.getWindowHref() + '#' + id + ')';
        if (this._gradients[url])
            return url;

        const gr = document.createElementNS(this._svgns, 'linearGradient');
        this.attr(gr, { x1: '0%', y1: '0%', x2: isVertical ? '0%' : '100%', y2: isVertical ? '100%' : '0%', id: id });

        for (let i = 0; i < stops.length; i++) {
            const stop = stops[i];
            const s = document.createElementNS(this._svgns, 'stop');
            const st = 'stop-color:' + this.adjustColor(color, stop[1]);
            this.attr(s, { offset: stop[0] + '%', style: st });
            gr.appendChild(s);
        }

        this._defs.appendChild(gr);
        this._gradients[url] = true;

        return url;
    }

    _toRadialGradient(color, stops, coords) {
        const id = 'grd' + this._id + color.replace('#', '') + 'r' + (coords !== undefined ? coords.key : '');

        const url = 'url(' + this.getWindowHref() + '#' + id + ')';
        if (this._gradients[url])
            return url;

        const gr = document.createElementNS(this._svgns, 'radialGradient');
        if (coords === undefined)
            this.attr(gr, { cx: '50%', cy: '50%', r: '100%', fx: '50%', fy: '50%', id: id });
        else
            this.attr(gr, { cx: coords.x, cy: coords.y, r: coords.outerRadius, id: id, gradientUnits: 'userSpaceOnUse' });

        for (let i = 0; i < stops.length; i++) {
            const stop = stops[i];
            const s = document.createElementNS(this._svgns, 'stop');
            const st = 'stop-color:' + this.adjustColor(color, stop[1]);
            this.attr(s, { offset: stop[0] + '%', style: st });
            gr.appendChild(s);
        }

        this._defs.appendChild(gr);
        this._gradients[url] = true;

        return url;
    }
});

// HTML5Renderer class
JQX.Utilities.Assign('HTML5Renderer', class HTML5Renderer extends JQX.Utilities.Renderer {
    constructor(draw) {
        super(draw);

        const that = this;

        that._renderers = new JQX.Utilities.HTML5RenderHelpers(that);
    }

    init(host) {
        try {
            this.host = host;

            const chartContainer = document.createElement('div'),
                canvas = document.createElement('canvas');

            chartContainer.className = 'chartContainer';
            chartContainer.style.position = 'relative';
            chartContainer.onselectstart = function () {
                return false;
            }

            canvas.id = '__jqxCanvasWrap';
            canvas.style.width = '100%';
            canvas.style.height = '100%';

            chartContainer.appendChild(canvas);
            host.appendChild(chartContainer);

            this.canvas = canvas;
            canvas.width = host.offsetWidth;
            canvas.height = host.offsetHeight;
            this.ctx = canvas.getContext('2d');

            this._elements = {};
            this._maxId = 0;
            this._gradientId = 0;
            this._gradients = {};
            this._currentPoint = { x: 0, y: 0 };
            this._lastCmd = '';
            this._pos = 0;
        }
        catch (e) {
            return false;
        }

        return true;
    }

    getType() {
        return 'HTML5';
    }

    getContainer() {
        let container = this.host.getElementsByClassName('chartContainer')[0];
        return container;
    }

    getRect() {
        return { x: 0, y: 0, width: this.canvas.width - 1, height: this.canvas.height - 1 };
    }

    beginGroup() {
    }

    endGroup() {
    }

    setClip() {
    }

    createClipRect() {
    }

    addHandler() {
        // unsupported
    }

    removeHandler() {
        // unsupported
    }

    on(element, event, fn) {
        this.addHandler(element, event, fn);
    }

    off(element, event, fn) {
        this.removeHandler(element, event, fn);
    }

    clear() {
        this._elements = {};
        this._maxId = 0;
        this._renderers._gradients = {};
        this._gradientId = 0;
    }

    removeElement(element) {
        if (undefined === element)
            return;
        if (this._elements[element.id])
            delete this._elements[element.id];
    }

    shape(name, params) {
        let s = { type: name, id: this._maxId++ };

        for (let param in params)
            s[param] = params[param];

        this._elements[s.id] = s;

        return s;
    }

    attr(element, params) {
        for (let param in params)
            element[param] = params[param];
    }

    removeAttr(element, params) {
        for (let param in params) {
            delete element[params[param]];
        }
    }

    rect(x, y, w, h, params) {
        if (isNaN(x))
            throw 'Invalid value for "x"';
        if (isNaN(y))
            throw 'Invalid value for "y"';
        if (isNaN(w))
            throw 'Invalid value for "width"';
        if (isNaN(h))
            throw 'Invalid value for "height"';

        let s = this.shape('rect', { x: x, y: y, width: w, height: h });
        if (params)
            this.attr(s, params);
        return s;
    }

    path(pathCmd, params) {
        let s = this.shape('path', params);
        this.attr(s, { d: pathCmd });
        return s;
    }

    line(x1, y1, x2, y2, params) {
        return this.path('M ' + x1 + ',' + y1 + ' L ' + x2 + ',' + y2, params);
    }

    circle(x, y, r, params) {
        let s = this.shape('circle', { x: x, y: y, r: r });
        if (params)
            this.attr(s, params);
        return s;
    }

    pieslice(x, y, innerRadius, outerRadius, angleFrom, angleTo, centerOffset, params) {
        let element = this.path(this.pieSlicePath(x, y, innerRadius, outerRadius, angleFrom, angleTo, centerOffset), params);
        this.attr(element, { x: x, y: y, innerRadius: innerRadius, outerRadius: outerRadius, angleFrom: angleFrom, angleTo: angleTo });
        return element;
    }

    _getCSSStyle(name) {
        const measureElement = document.createElement('div');

        measureElement.className = name;
        measureElement.style.position = 'absolute';
        measureElement.style.visibility = 'hidden';

        this.host.appendChild(measureElement);

        let style = window.getComputedStyle(measureElement);

        style = {
            color: style.color,
            fontFamily: style.fontFamily,
            fontSize: style.fontSize,
            fontWeight: style.fontWeight
        };

        this.host.removeChild(measureElement);

        return style;
    }

    _getTextParts(text, angle, params) {
        let fontFamily = 'Arial';
        let fontSize = '10pt';
        let fontWeight = '';
        if (params && params['class']) {
            let style = this._getCSSStyle(params['class']);

            if (style['fontSize'])
                fontSize = style['fontSize'];
            if (style['fontFamily'])
                fontFamily = style['fontFamily'];
            if (style['fontWeight'])
                fontWeight = style['fontWeight'];
        }

        this.ctx.font = fontWeight + ' ' + fontSize + ' ' + fontFamily;

        let textPartsInfo = { width: 0, height: 0, parts: [] };

        let coeff = 0.6;
        let textParts = text.toString().split('<br>');
        for (let i = 0; i < textParts.length; i++) {
            let textPart = textParts[i];

            let tw = this.ctx.measureText(textPart).width;
            let span = document.createElement('span');
            span.className = 'jqxchart';
            span.font = this.ctx.font;
            span.textContent = textPart;
            this.host.appendChild(span);
            let th = span.offsetHeight * coeff;
            this.host.removeChild(span);

            textPartsInfo.width = Math.max(textPartsInfo.width, this._rup(tw));
            textPartsInfo.height += th + (i > 0 ? 4 : 0);
            textPartsInfo.parts.push({ width: tw, height: th, text: textPart });
        }

        return textPartsInfo;
    }

    _measureText(text, angle, params, includeTextPartsInfo) {
        return super.measureText(text, angle, params, includeTextPartsInfo);
    }

    measureText(text, angle, params) {
        return this._measureText(text, angle, params, false);
    }

    text(text, x, y, width, height, angle, params, clip, halign, valign, rotateAround) {
        let t = this.shape('text', { text: text, x: x, y: y, width: width, height: height, angle: angle, clip: clip, halign: halign, valign: valign, rotateAround: rotateAround });
        if (params)
            this.attr(t, params);

        t.fontFamily = 'Arial';
        t.fontSize = '10pt';
        t.fontWeight = '';
        t.color = this._getContrastColor(arguments[11]);

        if (params && params['class']) {
            let style = this._getCSSStyle(params['class']);
            t.fontFamily = style.fontFamily || t.fontFamily;
            t.fontSize = style.fontSize || t.fontSize;
            t.fontWeight = style['fontWeight'] || t.fontWeight;
            t.color = t.color || style.color;
        }

        t.color = t.color || '#000000';

        let sz = this._measureText(text, 0, params, true);
        this.attr(t, { textPartsInfo: sz.textPartsInfo, textWidth: sz.width, textHeight: sz.height });

        if (width <= 0 || isNaN(width))
            this.attr(t, { width: sz.width });

        if (height <= 0 || isNaN(height))
            this.attr(t, { height: sz.height });

        return t;
    }

    _toLinearGradient(color, isVertical, stops) {
        if (this._renderers._gradients[color])
            return color;

        let colorStops = [];
        for (let i = 0; i < stops.length; i++)
            colorStops.push({ percent: stops[i][0] / 100, color: this.adjustColor(color, stops[i][1]) });

        let name = 'gr' + this._gradientId++;
        this.createGradient(name, isVertical ? 'vertical' : 'horizontal', colorStops);
        return name;
    }

    _toRadialGradient(color, stops) {
        if (this._renderers._gradients[color])
            return color;

        let colorStops = [];
        for (let i = 0; i < stops.length; i++)
            colorStops.push({ percent: stops[i][0] / 100, color: this.adjustColor(color, stops[i][1]) });

        let name = 'gr' + this._gradientId++;
        this.createGradient(name, 'radial', colorStops);
        return name;
    }

    createGradient(name, orientation, colorStops) {
        this._renderers.createGradient(this, name, orientation, colorStops);
    }

    refresh() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        for (let element in this._elements) {
            let params = this._elements[element];

            this._renderers.setFillStyle(this, params);
            this._renderers.setStroke(this, params);

            this._renderers[this._elements[element].type](this.ctx, params);
        }
    }
});

// HTML5RenderHelpers class
JQX.Utilities.Assign('HTML5RenderHelpers', class HTML5RenderHelpers {
    constructor(HTML5Renderer) {
        this.HTML5Renderer = HTML5Renderer;
        this._cmds = 'mlcazq';
    }

    ptrnd(val) {
        if (Math.abs(Math.round(val) - val) === 0.5)
            return val;

        let rnd = Math.round(val);
        if (rnd < val)
            rnd = rnd - 1;

        return rnd + 0.5;
    }

    createGradient(context, name, orientation, colorStops) {
        context._gradients[name] = { orientation: orientation, colorStops: colorStops };
    }

    setStroke(context, params) {
        let ctx = context.ctx,
            strokeWidth = params['stroke-width'];

        ctx.strokeStyle = params['stroke'] || 'transparent';

        if (strokeWidth === 0) {
            ctx.lineWidth = 0.01;
        }
        else if (strokeWidth !== undefined) {
            ctx.lineWidth = strokeWidth;
        }
        else {
            ctx.lineWidth = 1;
        }

        if (params['fill-opacity'] !== undefined) {
            ctx.globalAlpha = params['fill-opacity'];
        }
        else if (params['opacity'] !== undefined) {
            ctx.globalAlpha = params['opacity'];
        }
        else {
            ctx.globalAlpha = 1;
        }

        if (ctx.setLineDash) {
            if (params['stroke-dasharray'])
                ctx.setLineDash(params['stroke-dasharray'].split(','));
            else
                ctx.setLineDash([]);
        }
    }

    setFillStyle(context, params) {
        let ctx = context.ctx;

        ctx.fillStyle = 'transparent';

        if (params['fill-opacity'] !== undefined) {
            ctx.globalAlpha = params['fill-opacity'];
        }
        else if (params['opacity'] !== undefined) {
            ctx.globalAlpha = params['opacity'];
        }
        else {
            ctx.globalAlpha = 1;
        }

        if (params.fill && params.fill.indexOf('#') === -1 && context._gradients[params.fill]) {
            let isVertical = context._gradients[params.fill].orientation !== 'horizontal';
            let isRadial = context._gradients[params.fill].orientation === 'radial';
            let x1 = this.ptrnd(params.x);
            let y1 = this.ptrnd(params.y);
            let x2 = this.ptrnd(params.x + (isVertical ? 0 : params.width));
            let y2 = this.ptrnd(params.y + (isVertical ? params.height : 0));

            let gradient;

            if ((params.type === 'circle' || params.type === 'path' || params.type === 'rect') && isRadial) {
                let x = this.ptrnd(params.x),
                    y = this.ptrnd(params.y);
                const r1 = params.innerRadius || 0,
                    r2 = params.outerRadius || params.r || 0;

                if (params.type === 'rect') {
                    x += params.width / 2;
                    y += params.height / 2;
                }

                gradient = ctx.createRadialGradient(x, y, r1, x, y, r2);
            }

            if (!isRadial) {
                if (isNaN(x1) || isNaN(x2) || isNaN(y1) || isNaN(y2)) {
                    x1 = 0;
                    y1 = 0;
                    x2 = isVertical ? 0 : ctx.canvas.width;
                    y2 = isVertical ? ctx.canvas.height : 0;
                }

                gradient = ctx.createLinearGradient(x1, y1, x2, y2);
            }

            let colorStops = context._gradients[params.fill].colorStops;
            for (let i = 0; i < colorStops.length; i++)
                gradient.addColorStop(colorStops[i].percent, colorStops[i].color);

            ctx.fillStyle = gradient;
        }
        else if (params.fill) {
            ctx.fillStyle = params.fill;
        }
    }

    rect(ctx, params) {
        if (params.width === 0 || params.height === 0)
            return;
        ctx.fillRect(this.ptrnd(params.x), this.ptrnd(params.y), params.width, params.height);
        ctx.strokeRect(this.ptrnd(params.x), this.ptrnd(params.y), params.width, params.height);
    }

    circle(ctx, params) {
        if (params.r === 0)
            return;
        ctx.beginPath();
        ctx.arc(this.ptrnd(params.x), this.ptrnd(params.y), params.r, 0, Math.PI * 2, false);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }

    _parsePoint(str) {
        let x = this._parseNumber(str);
        let y = this._parseNumber(str);
        return ({ x: x, y: y });
    }

    _parseNumber(str) {
        let numStarted = false, i;
        for (i = this._pos; i < str.length; i++) {
            if ((str[i] >= '0' && str[i] <= '9') || str[i] === '.' || str[i] === 'e' || (str[i] === '-' && !numStarted) || (str[i] === '-' && i >= 1 && str[i - 1] === 'e')) {
                numStarted = true;
                continue;
            }
            if (!numStarted && (str[i] === ' ' || str[i] === ',')) {
                this._pos++;
                continue;
            }

            break;
        }

        let val = parseFloat(str.substring(this._pos, i));
        if (isNaN(val))
            return undefined;

        this._pos = i;
        return val;
    }

    _isRelativeCmd(cmd) {
        return this._cmds.indexOf(cmd) !== -1;
    }

    _parseCmd(string) {
        for (let i = this._pos; i < string.length; i++) {
            if (this._cmds.toLowerCase().indexOf(string[i].toLowerCase()) !== -1) {
                this._pos = i + 1;
                this._lastCmd = string[i];
                return this._lastCmd;
            }
            if (string[i] === ' ') {
                this._pos++;
                continue;
            }
            if (string[i] >= '0' && string[i] <= '9') {
                this._pos = i;
                if (this._lastCmd === '')
                    break;
                else
                    return this._lastCmd;
            }
        }

        return undefined;
    }

    _toAbsolutePoint(point) {
        return { x: this._currentPoint.x + point.x, y: this._currentPoint.y + point.y };
    }

    path(ctx, params) {
        let path = params.d;

        this._pos = 0;
        this._lastCmd = '';

        let firstPoint = undefined;
        this._currentPoint = { x: 0, y: 0 };

        ctx.beginPath();

        while (this._pos < path.length) {
            let cmd = this._parseCmd(path);
            if (cmd === undefined)
                break;

            if (cmd === 'M' || cmd === 'm') {
                let point = this._parsePoint(path);
                if (point === undefined)
                    break;
                ctx.moveTo(point.x, point.y);
                this._currentPoint = point;
                if (firstPoint === undefined)
                    firstPoint = point;

                continue;
            }

            if (cmd === 'L' || cmd === 'l') {
                let point = this._parsePoint(path);
                if (point === undefined)
                    break;

                ctx.lineTo(point.x, point.y);
                this._currentPoint = point;
                continue;
            }

            if (cmd === 'A' || cmd === 'a') {
                let rx = this._parseNumber(path);
                let ry = this._parseNumber(path);
                let angle = this._parseNumber(path) * (Math.PI / 180.0);
                let largeFlag = this._parseNumber(path);
                let sweepFlag = this._parseNumber(path);
                let endPoint = this._parsePoint(path);

                if (this._isRelativeCmd(cmd)) {
                    endPoint = this._toAbsolutePoint(endPoint);
                }

                if (rx === 0 || ry === 0)
                    continue;

                let cp = this._currentPoint;

                /// START
                // x1', y1'
                let cp2 = {
                    x: Math.cos(angle) * (cp.x - endPoint.x) / 2.0 + Math.sin(angle) * (cp.y - endPoint.y) / 2.0,
                    y: -Math.sin(angle) * (cp.x - endPoint.x) / 2.0 + Math.cos(angle) * (cp.y - endPoint.y) / 2.0
                };

                // adjust radii
                let adj = Math.pow(cp2.x, 2) / Math.pow(rx, 2) + Math.pow(cp2.y, 2) / Math.pow(ry, 2);
                if (adj > 1) {
                    rx *= Math.sqrt(adj);
                    ry *= Math.sqrt(adj);
                }

                // cx', cy'
                let s = (largeFlag === sweepFlag ? -1 : 1) * Math.sqrt(
                    ((Math.pow(rx, 2) * Math.pow(ry, 2)) - (Math.pow(rx, 2) * Math.pow(cp2.y, 2)) - (Math.pow(ry, 2) * Math.pow(cp2.x, 2))) /
                    (Math.pow(rx, 2) * Math.pow(cp2.y, 2) + Math.pow(ry, 2) * Math.pow(cp2.x, 2))
                );

                if (isNaN(s))
                    s = 0;

                let cp3 = { x: s * rx * cp2.y / ry, y: s * -ry * cp2.x / rx };

                // cx, cy
                let centerPoint = {
                    x: (cp.x + endPoint.x) / 2.0 + Math.cos(angle) * cp3.x - Math.sin(angle) * cp3.y,
                    y: (cp.y + endPoint.y) / 2.0 + Math.sin(angle) * cp3.x + Math.cos(angle) * cp3.y
                };

                // vector magnitude
                let m = function (v) {
                    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));
                }

                // ratio between two vectors
                let r = function (u, v) {
                    return (u[0] * v[0] + u[1] * v[1]) / (m(u) * m(v));
                }

                // angle between two vectors
                let a = function (u, v) {
                    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(r(u, v));
                }

                // initial angle
                let startAngle = a([1, 0], [(cp2.x - cp3.x) / rx, (cp2.y - cp3.y) / ry]);

                // angle delta
                let u = [(cp2.x - cp3.x) / rx, (cp2.y - cp3.y) / ry];
                let v = [(-cp2.x - cp3.x) / rx, (-cp2.y - cp3.y) / ry];
                let deltaAngle = a(u, v);
                if (r(u, v) <= -1)
                    deltaAngle = Math.PI;

                if (r(u, v) >= 1)
                    deltaAngle = 0;

                if (sweepFlag === 0 && deltaAngle > 0)
                    deltaAngle = deltaAngle - 2 * Math.PI;

                if (sweepFlag === 1 && deltaAngle < 0)
                    deltaAngle = deltaAngle + 2 * Math.PI;

                let r1 = (rx > ry) ? rx : ry;
                let sx = (rx > ry) ? 1 : rx / ry;
                let sy = (rx > ry) ? ry / rx : 1;

                ctx.translate(centerPoint.x, centerPoint.y);
                ctx.rotate(angle);
                ctx.scale(sx, sy);
                ctx.arc(0, 0, r1, startAngle, startAngle + deltaAngle, 1 - sweepFlag);
                ctx.scale(1 / sx, 1 / sy);
                ctx.rotate(-angle);

                ctx.translate(-centerPoint.x, -centerPoint.y);

                continue;
            }

            if ((cmd === 'Z' || cmd === 'z') && firstPoint !== undefined) {
                ctx.lineTo(firstPoint.x, firstPoint.y);
                this._currentPoint = firstPoint;
                continue;
            }

            if (cmd === 'C' || cmd === 'c') {
                let p1 = this._parsePoint(path);
                let p2 = this._parsePoint(path);
                let p3 = this._parsePoint(path);

                ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
                this._currentPoint = p3;
                continue;
            }

            if (cmd === 'Q' || cmd === 'q') {
                let p1 = this._parsePoint(path);
                let p2 = this._parsePoint(path);

                ctx.quadraticCurveTo(p1.x, p1.y, p2.x, p2.y);
                this._currentPoint = p2;
                continue;
            }

        }

        ctx.fill();
        ctx.stroke();
        ctx.closePath();
    }

    text(ctx, params) {
        let x = this.ptrnd(params.x);
        let y = this.ptrnd(params.y);
        let width = this.ptrnd(params.width);
        let height = this.ptrnd(params.height);
        let halign = params.halign;
        let valign = params.valign;
        let angle = params.angle;
        let rotateAround = params.rotateAround;
        let textPartsInfo = params.textPartsInfo;
        let textParts = textPartsInfo.parts;

        let clip = params.clip;
        if (clip === undefined)
            clip = true;

        ctx.save();

        if (!halign)
            halign = 'center';
        if (!valign)
            valign = 'center';

        if (clip) {
            ctx.rect(x, y, width, height);
            ctx.clip();
        }

        let tw = params.textWidth;
        let th = params.textHeight;

        let w = width || 0;
        let h = height || 0;

        ctx.fillStyle = params.color;
        ctx.font = params.fontWeight + ' ' + params.fontSize + ' ' + params.fontFamily;

        if (!angle || angle === 0) {
            y += th;

            if (valign === 'center' || valign === 'middle')
                y += (h - th) / 2;
            else if (valign === 'bottom')
                y += h - th;

            if (!width)
                width = tw;

            if (!height)
                height = th;

            let yOffset = 0;

            for (let i = textParts.length - 1; i >= 0; i--) {
                let textPart = textParts[i];
                let xOffset = x;
                let wPart = textParts[i].width;

                if (halign === 'center')
                    xOffset += (w - wPart) / 2;
                else if (halign === 'right')
                    xOffset += (w - wPart);

                ctx.fillText(textPart.text, xOffset, y + yOffset);
                yOffset -= textPart.height + (i > 0 ? 4 : 0);
            }
            ctx.restore();
            return;
        }

        let point = this.HTML5Renderer.alignTextInRect(x, y, width, height, tw, th, halign, valign, angle, rotateAround);
        x = point.x;
        y = point.y;

        let rads = angle * Math.PI * 2 / 360;
        ctx.translate(x, y);
        ctx.rotate(rads);

        let yOffset = 0;
        let maxW = textPartsInfo.width;

        for (let i = textParts.length - 1; i >= 0; i--) {
            let xOffset = 0;

            if (halign === 'center')
                xOffset += (maxW - textParts[i].width) / 2;
            else if (halign === 'right')
                xOffset += (maxW - textParts[i].width);

            ctx.fillText(textParts[i].text, xOffset, yOffset);

            yOffset -= textParts[i].height + 4;
        }

        ctx.restore();
    }
});

// Plot class
JQX.Utilities.Assign('Plot', class Plot {
    constructor(renderer) {
        this.renderer = renderer;
    }

    get(array, index, key) {
        return key !== undefined ? array[index][key] : array[index];
    }

    min(array, key) {
        let min = NaN;
        for (let i = 0; i < array.length; i++) {
            let val = this.get(array, i, key);

            if (isNaN(min) || val < min)
                min = val;
        }

        return min;
    }

    max(array, key) {
        let max = NaN;
        for (let i = 0; i < array.length; i++) {
            let val = this.get(array, i, key);

            if (isNaN(max) || val > max)
                max = val;
        }

        return max;
    }

    sum(array, key) {
        let sum = 0;
        for (let i = 0; i < array.length; i++) {
            let val = this.get(array, i, key);
            if (!isNaN(val))
                sum += val;
        }

        return sum;
    }

    count(array, key) {
        let count = 0;
        for (let i = 0; i < array.length; i++) {
            let val = this.get(array, i, key);
            if (!isNaN(val))
                count++;
        }

        return count;
    }

    avg(array, key) {
        return this.sum(array, key) / Math.max(1, this.count(array, key));
    }

    filter(array, fn) {
        if (!fn)
            return array;

        let out = [];
        for (let i = 0; i < array.length; i++)
            if (fn(array[i]))
                out.push(array[i]);

        return out;
    }

    scale(val, range, scale_range, params) {
        if (isNaN(val))
            return NaN;

        if (val < Math.min(range.min, range.max) || val > Math.max(range.min, range.max)) {
            if (!params || params['ignore_range'] !== true)
                return NaN;
        }

        let outVal = NaN;

        let percent = 1;
        if (range.type === undefined || range.type !== 'logarithmic') {
            let denom = Math.abs(range.max - range.min);
            if (!denom)
                denom = 1;
            percent = Math.abs(val - Math.min(range.min, range.max)) / denom;
        }
        else if (range.type === 'logarithmic') {
            let logBase = range.base;
            if (isNaN(logBase))
                logBase = 10;

            let min = Math.min(range.min, range.max);
            if (min <= 0)
                min = 1;

            let max = Math.max(range.min, range.max);
            if (max <= 0)
                max = 1;

            let maxPow = Math.log(max) / Math.log(logBase);
            max = Math.pow(logBase, maxPow);

            let minPow = Math.log(min) / Math.log(logBase);
            min = Math.pow(logBase, minPow);

            let valPow = Math.log(val) / Math.log(logBase);

            percent = Math.abs(valPow - minPow) / (maxPow - minPow);
        }

        if (scale_range.type === 'logarithmic') {
            let logBase = scale_range.base;
            if (isNaN(logBase))
                logBase = 10;

            let maxPow = Math.log(scale_range.max) / Math.log(logBase);
            let minPow = Math.log(scale_range.min) / Math.log(logBase);

            if (scale_range.flip)
                percent = 1 - percent;

            let valPow = Math.min(minPow, maxPow) + percent * Math.abs(maxPow - minPow);
            outVal = Math.pow(logBase, valPow);
        }
        else {
            outVal = Math.min(scale_range.min, scale_range.max) + percent * Math.abs(scale_range.max - scale_range.min);

            if (scale_range.flip)
                outVal = Math.max(scale_range.min, scale_range.max) - outVal + scale_range.min;
        }

        return outVal;
    }

    axis(min, max, preferedCount) {
        if (preferedCount <= 1)
            return [max, min];

        //let minSave = min;
        //let maxSave = max;

        if (isNaN(preferedCount) || preferedCount < 2)
            preferedCount = 2;

        let decimalPlaces = 0;
        while (Math.round(min) !== min && Math.round(max) !== max && decimalPlaces < 10) {
            min *= 10;
            max *= 10;
            decimalPlaces++;
        }

        let preferedIntSize = (max - min) / preferedCount;
        while (decimalPlaces < 10 && Math.round(preferedIntSize) !== preferedIntSize) {
            min *= 10;
            max *= 10;
            preferedIntSize *= 10;
            decimalPlaces++;
        }

        let scale = [1, 2, 5];

        //let itemsCount = 0;
        let i = 0;
        let intSizeNext;

        // eslint-disable-next-line
        while (true) {
            let idx = i % scale.length;
            let pow = Math.floor(i / scale.length);
            let intSizeCurr = Math.pow(10, pow) * scale[idx];

            idx = (i + 1) % scale.length;
            pow = Math.floor((i + 1) / scale.length);
            intSizeNext = Math.pow(10, pow) * scale[idx];

            if (preferedIntSize >= intSizeCurr && preferedIntSize < intSizeNext)
                break;

            i++;
        }

        let intSizeSelected = intSizeNext;

        let out = [];
        let curr = this.renderer._rnd(min, intSizeSelected, false);
        let denominator = decimalPlaces <= 0 ? 1 : Math.pow(10, decimalPlaces);
        while (curr < max + intSizeSelected) {
            out.push(curr / denominator);
            curr += intSizeSelected;
        }

        return out;
    }
});

JQX.Utilities.Assign('FilterGroup', class FilterGroup {
    constructor() {
        const that = this;

        that.stringConditions = ['EMPTY', 'NOT_EMPTY', 'CONTAINS', 'CONTAINS_CASE_SENSITIVE',
            'DOES_NOT_CONTAIN', 'DOES_NOT_CONTAIN_CASE_SENSITIVE', 'STARTS_WITH', 'STARTS_WITH_CASE_SENSITIVE',
            'ENDS_WITH', 'ENDS_WITH_CASE_SENSITIVE', 'EQUAL', 'EQUAL_CASE_SENSITIVE', 'NULL', 'NOT_NULL'];
        that.numericConditions = ['EQUAL', 'NOT_EQUAL', 'LESS_THAN', 'LESS_THAN_OR_EQUAL', 'GREATER_THAN', 'GREATER_THAN_OR_EQUAL', 'NULL', 'NOT_NULL'];
        that.dateConditions = ['EQUAL', 'NOT_EQUAL', 'LESS_THAN', 'LESS_THAN_OR_EQUAL', 'GREATER_THAN', 'GREATER_THAN_OR_EQUAL', 'NULL', 'NOT_NULL'];
        that.booleanConditions = ['EQUAL', 'NOT_EQUAL', 'NULL', 'NOT_NULL'];

        that.filters = new Array();
        that.logicalOperators = new Array();
    }
 
    evaluate(value) {
        const that = this;
        let result = true;

        for (let i = 0; i < that.filters.length; i++) {
            let currentResult = that.filters[i].evaluate(value);

            if (i === 0) {
                result = currentResult;
            }
            else {
                if (that.logicalOperators[i] === 1 || that.logicalOperators[i] === 'or') {
                    result = result || currentResult;
                }
                else {
                    result = result && currentResult;
                }
            }
        }

        return result;
    }

    getFiltersCount() {
        return this.filters.length;
    }

    setConditions(filterType, conditions) {
        const that = this;

        switch (filterType) {
            case 'numeric':
                that.numericConditions = conditions;
                break;
            case 'string':
                that.stringConditions = conditions;
                break;
            case 'date':
            case 'time':
                that.dateConditions = conditions;
                break;
            case 'bool':
            case 'boolean':
                that.booleanConditions = conditions;
                break;
        }
    }

    getConditions(filterType) {
        const that = this;
        let array = new Array();

        switch (filterType) {
            case 'numeric':
                array = that.numericConditions.slice(0);
                break;
            case 'string':
                array = that.stringConditions.slice(0);
                break;
            case 'date':
            case 'time':
                array = that.dateConditions.slice(0);
                break;
            case 'bool':
            case 'boolean':
                array = that.booleanConditions.slice(0);
                break;
        }
        return array;
    }

    generateFilterKey() {
        const S4 = function () {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        };
        return (S4() + '-' + S4() + '-' + S4());
    }
   
    createFilter(filterType, filterValue, filterCondition, customfilter, formatString, locale, timeOnly) {
        if (filterType === null || filterType === undefined) {
            return null;
        }

        switch (filterType) {
            case 'int':
            case 'float':
            case 'int64':
            case 'double':
            case 'numeric':
            case 'number':
            case 'numericFilter':
                return new JQX.Utilities.NumericFilter(filterValue, filterCondition.toUpperCase());
            case 'string':
            case 'stringFilter':
                return new JQX.Utilities.StringFilter(filterValue, filterCondition.toUpperCase(), locale);
            case 'date':
            case 'time':
            case 'dateFilter':
                return new JQX.Utilities.DateFilter(filterValue, filterCondition.toUpperCase(), formatString, locale, timeOnly);
            case 'bool':
            case 'boolean':
            case 'booleanFilter':
                return new JQX.Utilities.BooleanFilter(filterValue, filterCondition.toUpperCase());
            case 'custom':
                return new JQX.Utilities.CustomFilter(filterValue, filterCondition.toUpperCase(), customfilter);
        }

        throw new Error('jqxGrid: There is no such filter type. The available filter types are: "numericFilter", "stringFilter", "dateFilter" and "booleanFilter"');
    }

    getFilters() {
        const that = this;
        let filtersArray = new Array();

        for (let i = 0; i < that.filters.length; i++) {
            const filter = that.filters[i];

            if (filter instanceof FilterGroup) {
                let filters = filter.getFilters();

                filtersArray.push({value: filters, logicalOperator: that.logicalOperators[i], type: 'FilterGroup'});
            }
            else {
                const filterObject = { value: filter.value, condition: filter.condition, logicalOperator: that.logicalOperators[i], type: filter.type };

                if (filter.data) {
                    filterObject.id = filter.data;
                }

                filtersArray.push(filterObject);
            }
        }

        return filtersArray;
    }

    addFilter(logicalOperator, filter) {
        const that = this;

        that.filters[that.filters.length] = filter;
        filter.key = that.generateFilterKey();
        that.logicalOperators[that.logicalOperators.length] = logicalOperator;
    }

    removeFilter(filter) {
        const that = this;

        for (let i = 0; i < that.filters.length; i++) {
            if (that.filters[i].key === filter.key) {
                that.filters.splice(i, 1);
                that.logicalOperators.splice(i, 1);
                break;
            }
        }
    }

    getOperatorAt(index) {
        const that = this;

        if (index === undefined || index === null) {
            return null;
        }

        if (index < 0 || index > that.filters.length) {
            return null;
        }

        return that.logicalOperators[index];
    }

    setOperatorAt(index, logicalOperator) {
        const that = this;

        if (index === undefined || index === null) {
            return null;
        }

        if (index < 0 || index > that.filters.length) {
            return null;
        }

        that.logicalOperators[logicalOperator] = logicalOperator;
    }

    getFilterAt(index) {
        const that = this;

        if (index === undefined || index === null) {
            return null;
        }

        if (index < 0 || index > that.filters.length) {
            return null;
        }

        return that.filters[index];
    }

    setFilterAt(index, filter) {
        const that = this;

        if (index === undefined || index === null) {
            return null;
        }

        if (index < 0 || index > that.filters.length) {
            return null;
        }

        filter.key = that.generateFilterKey();
        that.filters[index] = filter;
    }

    clear() {
        const that = this;

        that.filters = new Array();
        that.logicalOperators = new Array();
    }

    getUniqueValues(details, context) {
        const data = details.data,
            uniqueValues = [],
            treeViewSource = [],
            timeOnly = details.filterType === 'dateFilter' && details.displayMode === 'timePicker';
        let compareFunction,
            blanks = false;

        for (let i = 0; i < data.length; i++) {
            let currentValue = data[i][details.dataField];

            if (currentValue === '' || currentValue === null || currentValue === undefined) {
                blanks = true;
                continue;
            }

            let label;

            if (timeOnly) {
                label = new JQX.Utilities.DateTime(currentValue).toString(details.formatString);
            }
            else {
                label = currentValue.toString();
            }

            if (uniqueValues.indexOf(label) === -1) {
                uniqueValues.push(label);
                treeViewSource.push({ label: label, value: currentValue, customAttribute: 'default-item' });
            }
        }

        switch (details.filterType) {
            case 'numericFilter':
            case 'booleanFilter':
                compareFunction = function (a, b) {
                    return a.value - b.value;
                };
                break;
            case 'stringFilter':
                compareFunction = function (a, b) {
                    return new Intl.Collator().compare(a.value, b.value);
                };
                break;
            case 'dateFilter':
                if (timeOnly) {
                    compareFunction = function (a, b) {
                        try {
                            const aHours = a.value.getHours(),
                                bHours = b.value.getHours();

                            if (aHours !== bHours) {
                                return aHours - bHours;
                            }

                            const aMinutes = a.value.getMinutes(),
                                bMinutes = b.value.getMinutes();

                            if (aMinutes !== bMinutes) {
                                return aMinutes - bMinutes;
                            }

                            const aSeconds = a.value.getSeconds(),
                                bSeconds = b.value.getSeconds();

                            if (aSeconds !== bSeconds) {
                                return aSeconds - bSeconds;
                            }

                            return 0;
                        }
                        catch (error) {
                            return -1;
                        }
                    };
                }
                else {
                    compareFunction = function (a, b) {
                        try {
                            return a.value.getTime() - b.value.getTime();
                        }
                        catch (error) {
                            return -1;
                        }
                    };
                }

                break;
        }

        treeViewSource.sort(compareFunction);

        if (details.filterType === 'booleanFilter') {
            treeViewSource.map(function (item) {
                item.label = item.label.toUpperCase();
            });
        }

        if (blanks) {
            treeViewSource.push({ label: context.localize('blanks'), value: '', customAttribute: 'default-item' });
        }

        return treeViewSource;
    }
});

JQX.Utilities.Assign('StringFilter', class StringFilter {
    constructor(filterValue, condition, locale) {
        const that = this;

        that.value = filterValue;
        that.condition = condition;
        that.locale = locale || 'en';
        that.type = 'stringFilter';
    }

    evaluate(value) {
        const that = this,
            filterValue = that.value,
            condition = that.condition;

        if (value === null || value === undefined || value === '') {
            if (condition === 'NULL')
                return true;

            if (condition === 'EQUAL' && value === filterValue) {
                return true;
            }

            if (condition === 'NOT_EQUAL' && value !== filterValue) {
                return true;
            }

            if (condition !== 'EMPTY')
                return false;
            else if (value === '')
                return true;
        }

        let val = '';

        try {
            val = value.toString();
        }
        catch (error) {
            return true;
        }

        const compare = function (val, filterValue) {
            const locale = that.locale;

            switch (condition) {
                case 'EQUAL':
                    return val.localeCompare(filterValue, locale, { sensitivity: 'accent' }) === 0;
                case 'EQUAL_CASE_SENSITIVE':
                    return val.localeCompare(filterValue, locale, { sensitivity: 'variant' }) === 0;
                case 'NOT_EQUAL':
                    return val.localeCompare(filterValue, locale, { sensitivity: 'accent' }) !== 0;
                case 'NOT_EQUAL_CASE_SENSITIVE':
                    return val.localeCompare(filterValue, locale, { sensitivity: 'variant' }) !== 0;
                case 'CONTAINS':
                    return val.toLowerCase().indexOf(filterValue.toLowerCase()) !== -1;
                case 'CONTAINS_CASE_SENSITIVE':
                    return val.indexOf(filterValue) !== -1;
                case 'DOES_NOT_CONTAIN':
                    return val.toLowerCase().indexOf(filterValue.toLowerCase()) === -1;
                case 'DOES_NOT_CONTAIN_CASE_SENSITIVE':
                    return val.indexOf(filterValue) === -1;
                case 'EMPTY':
                    return val === '';
                case 'NOT_EMPTY':
                    return val !== '';
                case 'NOT_NULL':
                    return val !== null;
                case 'STARTS_WITH':
                    val = val.substring(0, filterValue.length);
                    return val.localeCompare(filterValue, locale, { sensitivity: 'accent' }) === 0;
                case 'ENDS_WITH':
                    val = val.substring(val.length - filterValue.length, val.length);
                    return val.localeCompare(filterValue, locale, { sensitivity: 'accent' }) === 0;
                case 'ENDS_WITH_CASE_SENSITIVE':
                    val = val.substring(val.length - filterValue.length, val.length);
                    return val.localeCompare(filterValue, locale, { sensitivity: 'variant' }) === 0;
                case 'STARTS_WITH_CASE_SENSITIVE':
                    val = val.substring(0, filterValue.length);
                    return val.localeCompare(filterValue, locale, { sensitivity: 'variant' }) === 0;
                default:
                    return false;
            }
        }

        const filterValues = new Array();

        if (filterValue && filterValue.indexOf)
            if (filterValue.indexOf('|') >= 0 || filterValue.indexOf(' AND ') >= 0 || filterValue.indexOf(' OR ') >= 0 || filterValue.indexOf(' and ') >= 0 || filterValue.indexOf(' or ') >= 0) {
                const result = compare(val, filterValue);

                if (result) {
                    return result;
                }

                const andLowerCaseFilters = filterValue.indexOf(' and ') >= 0 ? filterValue.split(' and ') : new Array(),
                    orLowerCaseFilters = filterValue.indexOf(' or ') >= 0 ? filterValue.split(' or ') : new Array(),
                    delimiterFilters = filterValue.indexOf('|') >= 0 ? filterValue.split('|') : new Array();
                let andFilters = filterValue.indexOf(' AND ') >= 0 ? filterValue.split(' AND ') : new Array(),
                    orFilters = filterValue.indexOf(' OR ') >= 0 ? filterValue.split(' OR ') : new Array();

                if (delimiterFilters.length > 0) {
                    for (let i = 0; i < delimiterFilters.length; i++) {
                        delimiterFilters[i] = delimiterFilters[i].trim;
                    }
                }

                const commaFilters = filterValue.indexOf(' ') >= 0 ? filterValue.split(' ') : new Array();

                if (commaFilters.length > 0) {
                    for (let i = 0; i < commaFilters.length; i++) {
                        commaFilters[i] = commaFilters[i].trim;
                    }
                }

                andFilters = andFilters.concat(commaFilters);
                andFilters = andFilters.concat(andLowerCaseFilters);
                orFilters = orFilters.concat(delimiterFilters);
                orFilters = orFilters.concat(orLowerCaseFilters);

                if (andFilters.length > 0) {
                    for (let i = 0; i < andFilters.length; i++) {
                        if (!andFilters[i].indexOf(' OR ') >= 0) {
                            filterValues.push(andFilters[i]);
                        }
                    }
                }
                if (orFilters.length > 0) {
                    for (let i = 0; i < orFilters.length; i++) {
                        if (!orFilters[i].indexOf(' AND ') >= 0) {
                            filterValues.push(orFilters[i]);
                        }
                    }
                }

                let filterresult = undefined;

                for (let j = 0; j < filterValues.length; j++) {
                    const value = filterValues[j],
                        result = compare(val, value),
                        filteroperator = j < andFilters.length ? 'and' : 'or';

                    if (filterresult === undefined) {
                        filterresult = result;
                    }
                    else {
                        if (filteroperator === 'or') {
                            filterresult = filterresult || result;
                        }
                        else {
                            filterresult = filterresult && result;
                        }
                    }
                }
                return filterresult;
            }

        return compare(val, filterValue);
    }
});

JQX.Utilities.Assign('BooleanFilter', class BooleanFilter {
    constructor(filterValue, condition) {
        const that = this;

        that.value = filterValue;
        that.condition = condition;
        that.type = 'booleanFilter';
    }

    evaluate(value) {
        const that = this,
            filterValue = that.value,
            condition = that.condition;

        const val = value;

        switch (condition) {
            case 'EQUAL':
                return val === filterValue;
            case 'NOT_EQUAL':
                return val !== filterValue;
            case 'NULL':
                return value === null || value === undefined || value === '';
            case 'NOT_NULL':
                return !(value === null || value === undefined || value === '');
            default:
                return false;
        }
    }
});

JQX.Utilities.Assign('NumericFilter', class NumericFilter {
    constructor(filterValue, condition) {
        const that = this;

        that.value = filterValue;
        that.condition = condition;
        that.type = 'numericFilter';
    }

    evaluate(value) {
        const that = this;
        let filterValue = that.value,
            condition = that.condition;

        if (value === null || value === undefined || value === '') {
            if (condition === 'NOT_NULL')
                return false;

            if (condition === 'NULL')
                return true;
            else {
                switch (condition) {
                    case 'EQUAL':
                        return value === filterValue;
                    case 'NOT_EQUAL':
                        return value !== filterValue;
                }
                return false;
            }
        }
        else {
            if (condition === 'NULL')
                return false;

            if (condition === 'NOT_NULL')
                return true;
        }

        let val = value;

        try {
            val = parseFloat(val);
        }
        catch (error) {
            if (value.toString() !== '')
                return false;
        }

        const compare = function (val, filterValue) {
            if (typeof val === 'number' && typeof filterValue !== 'number') {
                filterValue = parseFloat(filterValue);
            }

            switch (condition) {
                case 'EQUAL':
                    return val === filterValue;
                case 'NOT_EQUAL':
                    return val !== filterValue;
                case 'GREATER_THAN':
                    return val > filterValue;
                case 'GREATER_THAN_OR_EQUAL':
                    return val >= filterValue;
                case 'LESS_THAN':
                    return val < filterValue;
                case 'LESS_THAN_OR_EQUAL':
                    return val <= filterValue;
                case 'STARTS_WITH':
                    filterValue = filterValue.toString().toLowerCase();
                    return val.toString().toLowerCase().substring(0, filterValue.length) === filterValue;
                case 'ENDS_WITH':
                    val = val.toString().toLowerCase();
                    filterValue = filterValue.toString().toLowerCase();
                    return val.substring(val.length - filterValue.length, val.length) === filterValue;
                case 'ENDS_WITH_CASE_SENSITIVE':
                    val = val.toString();
                    filterValue = filterValue.toString();
                    return val.substring(val.length - filterValue.length, val.length) === filterValue;
                case 'STARTS_WITH_CASE_SENSITIVE':
                    filterValue = filterValue.toString();
                    return val.toString().substring(0, filterValue.length) === filterValue;
                case 'CONTAINS':
                    return val.toString().toLowerCase().indexOf(filterValue.toString().toLowerCase()) !== -1;
                case 'CONTAINS_CASE_SENSITIVE':
                    return val.toString().indexOf(filterValue.toString()) !== -1;
                case 'DOES_NOT_CONTAIN':
                    return val.toString().toLowerCase().indexOf(filterValue.toString().toLowerCase()) === -1;
                case 'DOES_NOT_CONTAIN_CASE_SENSITIVE':
                    return val.toString().indexOf(filterValue.toString()) === -1;
                default:
                    return true;
            }
        }

        let filterValues = new Array();

        if (filterValue && filterValue.indexOf)
            if (filterValue.indexOf('|') >= 0 || filterValue.indexOf(' AND ') >= 0 || filterValue.indexOf(' OR ') >= 0 || filterValue.indexOf(' and ') >= 0 || filterValue.indexOf(' or ') >= 0) {
                let result = compare(val, filterValue);

                if (result) {
                    return result;
                }

                filterValue = filterValue.toString();
                const andLowerCaseFilters = filterValue.indexOf(' and ') >= 0 ? filterValue.split(' and ') : new Array(),
                    orLowerCaseFilters = filterValue.indexOf(' or ') >= 0 ? filterValue.split(' or ') : new Array(),
                    delimiterFilters = filterValue.indexOf('|') >= 0 ? filterValue.split('|') : new Array();
                let andFilters = filterValue.indexOf(' AND ') >= 0 ? filterValue.split(' AND ') : new Array(),
                    orFilters = filterValue.indexOf(' OR ') >= 0 ? filterValue.split(' OR ') : new Array();

                andFilters = andFilters.concat(andLowerCaseFilters);
                orFilters = orFilters.concat(orLowerCaseFilters);
                if (delimiterFilters.length > 0) {
                    for (let i = 0; i < delimiterFilters.length; i++) {
                        delimiterFilters[i] = delimiterFilters[i].trim;
                    }
                }
                orFilters = orFilters.concat(delimiterFilters);

                if (andFilters.length > 0) {
                    for (let i = 0; i < andFilters.length; i++) {
                        if (!andFilters[i].indexOf(' OR ') >= 0) {
                            filterValues.push(andFilters[i]);
                        }
                    }
                }
                if (orFilters.length > 0) {
                    for (let i = 0; i < orFilters.length; i++) {
                        if (!orFilters[i].indexOf(' AND ') >= 0) {
                            filterValues.push(orFilters[i]);
                        }
                    }
                }

                let filterresult = undefined;

                for (let j = 0; j < filterValues.length; j++) {
                    const value = filterValues[j];

                    if (value && value.indexOf && value.indexOf('..') >= 0) {
                        const values = value.toString().split('..');

                        if (values.length === 2) {
                            result = val >= values[0] && val <= values[1];
                        }
                    }
                    else {
                        result = compare(val, value);
                    }

                    const filteroperator = j < andFilters.length ? 'and' : 'or';

                    if (filterresult === undefined) {
                        filterresult = result;
                    }
                    else {
                        if (filteroperator === 'or') {
                            filterresult = filterresult || result;
                        }
                        else {
                            filterresult = filterresult && result;
                        }
                    }
                }
                return filterresult;
            }
        if (filterValue && filterValue.indexOf && filterValue.indexOf('..') >= 0) {
            filterValues = filterValue.toString().split('..');
            if (filterValues.length === 2) {
                return val >= filterValues[0] && val <= filterValues[1];
            }
        }
        return compare(val, filterValue);
    }
});

JQX.Utilities.Assign('DateFilter', class DateFilter {
    constructor(filterValue, condition, formatString, locale, timeOnly) {
        const that = this,
            parseAttemptDateTime = new JQX.Utilities.DateTime();

        that.value = filterValue;
        that.type = 'dateFilter';

        if (formatString !== undefined) {
            const parsedDate = parseAttemptDateTime.parseDate(filterValue, formatString);

            if (parsedDate !== null) {
                that.filterdate = parsedDate;
            }
            else {
                const result = parseAttemptDateTime.tryparseDate(filterValue);

                if (result !== null) {
                    that.filterdate = result;
                }
            }
        }
        else {
            const tmpvalue = new Date(filterValue);

            if (tmpvalue.toString() === 'NaN' || tmpvalue.toString() === 'Invalid Date') {
                that.filterdate = parseAttemptDateTime.tryparseDate(filterValue);
            }
            else {
                that.filterdate = tmpvalue;
            }
        }
        if (!that.filterdate) {
            const tmpvalue = new Date(filterValue);

            if (tmpvalue.toString() === 'NaN' || tmpvalue.toString() === 'Invalid Date') {
                that.filterdate = parseAttemptDateTime.tryparseDate(filterValue);
            }
            else {
                that.filterdate = tmpvalue;
            }
        }

        that.condition = condition;
        that.formatString = formatString;
        that.timeOnly = timeOnly;
    }

    evaluate(value) {
        const that = this,
            condition = that.condition,
            formatString = that.formatString;
        let filterValue = that.value;

        if (that.timeOnly) {
            return that.evaluateTimeOnly(value);
        }

        if (value === null || value === undefined || value === '') {
            if (condition === 'NOT_NULL') {
                return false;
            }

            if (condition === 'NULL') {
                return true;
            }
            else {
                switch (condition) {
                    case 'EQUAL':
                        return value === filterValue;
                    case 'NOT_EQUAL':
                        return value !== filterValue;
                }
                return false;
            }
        }
        else {
            if (condition === 'NULL')
                return false;

            if (condition === 'NOT_NULL')
                return true;
        }

        let val = new Date(),
            compareTimePart;

        val.setFullYear(1900, 0, 1);
        val.setHours(12, 0, 0, 0);

        try {
            const parseAttemptDateTime = new JQX.Utilities.DateTime(),
                tmpvalue = new Date(value);

            if (tmpvalue.toString() === 'NaN' || tmpvalue.toString() === 'Invalid Date') {
                value = parseAttemptDateTime.tryparseDate(value);
            }
            else {
                value = tmpvalue;
            }

            val = value;
            compareTimePart = false;

            if (formatString !== undefined) {
                if (formatString.indexOf('t') >= 0 || formatString.indexOf('T') >= 0 || formatString.indexOf(':') >= 0 || formatString.indexOf('f') >= 0) {
                    compareTimePart = true;
                    if (filterValue && filterValue.toString().indexOf(':') === -1) {
                        const result = parseAttemptDateTime.tryparseDate(filterValue.toString() + ':00');

                        if (result !== null) {
                            that.filterdate = result;
                        }
                    }
                }
            }
            if (!compareTimePart) {
                val.setHours(0);
                val.setMinutes(0);
                val.setSeconds(0);
            }
        }
        catch (error) {
            if (value.toString() !== '')
                return false;
        }

        if (that.filterdate !== null) {
            filterValue = that.filterdate;
        }
        else if (filterValue && filterValue.indexOf &&
            (filterValue.indexOf(':') !== -1 || !isNaN(parseInt(filterValue)))) {

            const tmpFilter = new Date(val);

            tmpFilter.setHours(12, 0, 0, 0);

            const timeStrings = filterValue.split(':');

            for (let i = 0; i < timeStrings.length; i++) {
                if (i === 0) {
                    tmpFilter.setHours(timeStrings[i]);
                }
                if (i === 1) {
                    tmpFilter.setMinutes(timeStrings[i]);
                }
                if (i === 2) {
                    tmpFilter.setSeconds(timeStrings[i]);
                }
            }

            filterValue = tmpFilter;
        }

        if (compareTimePart) {
            if (filterValue && filterValue.setFullYear) {
                if (val && val.getFullYear) {
                    if (formatString.indexOf('d') === -1 && formatString.indexOf('M') === -1 && formatString.indexOf('y') === -1) {
                        filterValue.setFullYear(val.getFullYear(), val.getMonth(), val.getDate());
                    }
                }
            }
        }

        const compare = function (val, filterValue) {
            if (val === null) val = '';
            switch (condition) {
                case 'EQUAL':
                    return val.toString() === filterValue.toString();
                case 'NOT_EQUAL':
                    return val.toString() !== filterValue.toString();
                case 'GREATER_THAN':
                    return val > filterValue;
                case 'GREATER_THAN_OR_EQUAL':
                    return val >= filterValue;
                case 'LESS_THAN':
                    return val < filterValue;
                case 'LESS_THAN_OR_EQUAL':
                    return val <= filterValue;
                case 'STARTS_WITH':
                    filterValue = filterValue.toString().toLowerCase();
                    return val.toString().toLowerCase().substring(0, filterValue.length) === filterValue;
                case 'ENDS_WITH':
                    val = val.toString().toLowerCase();
                    filterValue = filterValue.toString().toLowerCase();
                    return val.substring(val.length - filterValue.length, val.length) === filterValue;
                case 'ENDS_WITH_CASE_SENSITIVE':
                    val = val.toString();
                    filterValue = filterValue.toString();
                    return val.substring(val.length - filterValue.length, val.length) === filterValue;
                case 'STARTS_WITH_CASE_SENSITIVE':
                    filterValue = filterValue.toString();
                    return val.toString().substring(0, filterValue.length) === filterValue;
                case 'CONTAINS':
                    return val.toString().toLowerCase().indexOf(filterValue.toString().toLowerCase()) !== -1;
                case 'CONTAINS_CASE_SENSITIVE':
                    return val.toString().indexOf(filterValue.toString()) !== -1;
                case 'DOES_NOT_CONTAIN':
                    return val.toString().toLowerCase().indexOf(filterValue.toString().toLowerCase()) === -1;
                case 'DOES_NOT_CONTAIN_CASE_SENSITIVE':
                    return val.toString().indexOf(filterValue.toString()) === -1;
                default:
                    return true;
            }
        }

        let filterValues = new Array();

        if (filterValue && filterValue.indexOf)
            if (filterValue.indexOf('|') >= 0 || filterValue.indexOf(' AND ') >= 0 || filterValue.indexOf(' OR ') >= 0 || filterValue.indexOf(' and ') >= 0 || filterValue.indexOf(' or ') >= 0) {
                let result = compare(val, filterValue);

                if (result) {
                    return result;
                }

                const andLowerCaseFilters = filterValue.indexOf(' and ') >= 0 ? filterValue.split(' and ') : new Array(),
                    orLowerCaseFilters = filterValue.indexOf(' or ') >= 0 ? filterValue.split(' or ') : new Array(),
                    delimiterFilters = filterValue.indexOf('|') >= 0 ? filterValue.split('|') : new Array();
                let andFilters = filterValue.indexOf(' AND ') >= 0 ? filterValue.split(' AND ') : new Array(),
                    orFilters = filterValue.indexOf(' OR ') >= 0 ? filterValue.split(' OR ') : new Array();

                andFilters = andFilters.concat(andLowerCaseFilters);
                orFilters = orFilters.concat(orLowerCaseFilters);
                if (delimiterFilters.length > 0) {
                    for (let i = 0; i < delimiterFilters.length; i++) {
                        delimiterFilters[i] = delimiterFilters[i].trim;
                    }
                }
                orFilters = orFilters.concat(delimiterFilters);

                if (andFilters.length > 0) {
                    for (let i = 0; i < andFilters.length; i++) {
                        if (!andFilters[i].indexOf(' OR ') >= 0) {
                            filterValues.push(andFilters[i]);
                        }
                    }
                }
                if (orFilters.length > 0) {
                    for (let i = 0; i < orFilters.length; i++) {
                        if (!orFilters[i].indexOf(' AND ') >= 0) {
                            filterValues.push(orFilters[i]);
                        }
                    }
                }

                let filterresult = undefined;

                for (let j = 0; j < filterValues.length; j++) {
                    const value = filterValues[j];
                    if (value && value.indexOf && value.indexOf('..') >= 0) {
                        const values = value.toString().split('..');
                        if (values.length === 2) {
                            result = val >= values[0] && val <= values[1];
                        }
                    }
                    else {
                        result = compare(val, value);
                    }

                    const filteroperator = j < andFilters.length ? 'and' : 'or';

                    if (filterresult === undefined) {
                        filterresult = result;
                    }
                    else {
                        if (filteroperator === 'or') {
                            filterresult = filterresult || result;
                        }
                        else {
                            filterresult = filterresult && result;
                        }
                    }
                }

                return filterresult;
            }
        if (filterValue && filterValue.indexOf && filterValue.indexOf('..') >= 0) {
            filterValues = filterValue.toString().split('..');
            if (filterValues.length === 2) {
                return val >= filterValues[0] && val <= filterValues[1];
            }
        }
        return compare(val, filterValue);
    }

    evaluateTimeOnly(value) {
        const that = this,
            filterValue = that.value;

        if (!filterValue) {
            if (!value) {
                return true;
            }

            return false;
        }
        else if (!value || !(value instanceof Date)) {
            return false;
        }

        const valueHours = value.getHours(),
            filterValueHours = filterValue.getHours();

        if (valueHours !== filterValueHours) {
            return false;
        }

        const valueMinutes = value.getMinutes(),
            filterValueMinutes = filterValue.getMinutes();

        if (valueMinutes !== filterValueMinutes) {
            return false;
        }

        const valueSeconds = value.getSeconds(),
            filterValueSeconds = filterValue.getSeconds();

        if (valueSeconds !== filterValueSeconds) {
            return false;
        }

        return true;
    }
});

JQX.Utilities.Assign('CustomFilter', class CustomFilter {
    constructor(filterValue, condition, customfilter) {
        const that = this;

        that.value = filterValue;
        that.condition = condition;
        that.customfilter = customfilter;
    }

    evaluate(value) {
        const that = this;

        return that.customfilter(that.value, value, that.condition);
    }
});

JQX.FilterGroup = JQX.Utilities.FilterGroup;
JQX.StringFilter = JQX.Utilities.StringFilter;
JQX.NumericFilter = JQX.Utilities.NumericFilter;
JQX.DateFilter = JQX.Utilities.DateFilter;
JQX.CustomFilter = JQX.Utilities.CustomFilter;

let bigIntNativeSupport;

try {
    BigInt;
    bigIntNativeSupport = true;
}
catch (error) {
    bigIntNativeSupport = false;
}

// BigNumber class in JQX.Utilities
JQX.Utilities.Assign('BigNumber', class UtilitiesBigNumber {
    //+ Jonas Raoni Soares Silva
    //@ http://jsfromhell.com/classes/bignumber [rev. #4]

    constructor(n, p, r) {
        var o = this, i;

        if (JQX.Utilities.BigNumber.bigIntSupport) {
            if (n instanceof JQX.Utilities.BigNumber) {
                if (Array.isArray(n._d)) {
                    n = (n._s ? '-' : '') + (n._d.slice(0, n._f).join('') || '0') + (n._f != n._d.length ? '.' + n._d.slice(n._f).join('') : '');
                }
                else {
                    return new JQX.Utilities.BigNumber(n._d);
                }
            }

            try {
                if (n === null) {
                    o._d = BigInt(0);
                }
                else if (typeof n === 'string' && n.toLowerCase().indexOf('e') !== -1) {
                    o._d = BigInt(parseFloat(n));
                }
                else {
                    o._d = BigInt(n);
                }
            }
            catch (error) {
                try {
                    const numberParts = n.toString().split('.');
                    let result = BigInt(numberParts[0]),
                        firstDecimalDigit = parseInt(numberParts[1].charAt(0));

                    if (result > 0 && firstDecimalDigit >= 5) {
                        result = result + BigInt(1);
                    }
                    else if (result < 0) {
                        if (firstDecimalDigit > 5) {
                            result = result - BigInt(1);
                        }
                        else if (firstDecimalDigit === 5) {
                            let iterator = 1,
                                nextChar = numberParts[1].charAt(iterator),
                                roundDown = false;

                            while (nextChar !== '') {
                                iterator++;
                                nextChar = numberParts[1].charAt(iterator);

                                if (nextChar !== '0') {
                                    roundDown = true;
                                    break;
                                }
                            }

                            if (roundDown) {
                                result = result - BigInt(1);
                            }
                        }
                    }

                    o._d = result;
                }
                catch (error) {
                    o._d = BigInt(0);
                }
            }

            o._f = o._d.toString().replace('-', '').length;
            o._s = o._d < 0;
            return;
        }

        if (n instanceof JQX.Utilities.BigNumber) {
            if (typeof n._d === 'bigint') {
                return new JQX.Utilities.BigNumber(n._d.toString());
            }

            for (i in { precision: 0, roundType: 0, _s: 0, _f: 0 }) o[i] = n[i];
            o._d = n._d.slice();

            if (n._s && n._d.length === 1 && n._d[0] === 0) {
                // n is -0
                o._s = false;
            }

            return;
        }

        if (n !== undefined) {
            if (n === '-0') {
                n = '0';
            }

            // exponential notation support
            if (new RegExp(/e/i).test(n)) {
                var stringExponential = n.toString().toLowerCase(),
                    indexOfE = stringExponential.indexOf('e'),
                    mantissa = new JQX.Utilities.BigNumber(stringExponential.slice(0, indexOfE)),
                    exponent = stringExponential.slice(indexOfE + 2),
                    sign = stringExponential.slice(indexOfE + 1, indexOfE + 2),
                    bigTen = new JQX.Utilities.BigNumber(10),
                    multyplyBy = bigTen.pow(sign + exponent),
                    result = mantissa.multiply(multyplyBy);

                n = result.toString();
            }
        }

        o.precision = isNaN(p = Math.abs(p)) ? JQX.Utilities.BigNumber.defaultPrecision : p;
        o.roundType = isNaN(r = Math.abs(r)) ? JQX.Utilities.BigNumber.defaultRoundType : r;
        o._s = (n += '').charAt(0) == '-';
        o._f = ((n = n.replace(/[^\d.]/g, '').split('.', 2))[0] = n[0].replace(/^0+/, '') || '0').length;
        for (i = (n = o._d = (n.join('') || '0').split('')).length; i; n[--i] = +n[i]);
        o.round();
    }

    static get defaultPrecision() {
        return 40;
    }

    static get defaultRoundType() {
        return 4;
    }

    static get bigIntSupport() {
        return bigIntNativeSupport && JQX.Utilities.BigNumber.ignoreBigIntNativeSupport !== true;
    }

    add(n) {
        if (JQX.Utilities.BigNumber.bigIntSupport) {
            return new JQX.Utilities.BigNumber(this._d + new JQX.Utilities.BigNumber(n)._d);
        }

        let that = this.normalizeOperand(this);

        n = that.normalizeOperand(n);

        if (that.isZero() && that._s) { // that.toString() is '-0'
            that._s = false;
        }

        if (n === 0 || (n.constructor === JQX.Utilities.BigNumber && n._d.length === 1 && n._d[0] === 0)) {
            return new JQX.Utilities.BigNumber(that);
        }

        if (that._s != (n = new JQX.Utilities.BigNumber(n))._s)
            return n._s ^= 1, that.subtract(n);
        var o = new JQX.Utilities.BigNumber(that), a = o._d, b = n._d, la = o._f,
            lb = n._f, i, r;
        n = Math.max(la, lb);
        la != lb && ((lb = la - lb) > 0 ? o._zeroes(b, lb, 1) : o._zeroes(a, -lb, 1));
        i = (la = a.length) == (lb = b.length) ? a.length : ((lb = la - lb) > 0 ? o._zeroes(b, lb) : o._zeroes(a, -lb)).length;
        for (r = 0; i; r = (a[--i] = a[i] + b[i] + r) / 10 >>> 0, a[i] %= 10);
        return r && ++n && a.unshift(r), o._f = n, o.round();
    }

    subtract(n) {
        if (JQX.Utilities.BigNumber.bigIntSupport) {
            return new JQX.Utilities.BigNumber(this._d - new JQX.Utilities.BigNumber(n)._d);
        }

        let that = this.normalizeOperand(this);

        n = that.normalizeOperand(n);

        if (that.isZero() && that._s) { // that.toString() is '-0'
            that._s = false;
        }

        if (n === 0 || (n.constructor === JQX.Utilities.BigNumber && n._d.length === 1 && n._d[0] === 0)) {
            return new JQX.Utilities.BigNumber(that);
        }

        if (that._s != (n = new JQX.Utilities.BigNumber(n))._s)
            return n._s ^= 1, that.add(n);
        var o = new JQX.Utilities.BigNumber(that), c = o.abs().compare(n.abs()) + 1, a = c ? o : n, b = c ? n : o, la = a._f, lb = b._f, d = la, i, j;
        a = a._d, b = b._d, la != lb && ((lb = la - lb) > 0 ? o._zeroes(b, lb, 1) : o._zeroes(a, -lb, 1));
        for (i = (la = a.length) == (lb = b.length) ? a.length : ((lb = la - lb) > 0 ? o._zeroes(b, lb) : o._zeroes(a, -lb)).length; i;) {
            if (a[--i] < b[i]) {
                for (j = i; j && !a[--j]; a[j] = 9);
                --a[j], a[i] += 10;
            }
            b[i] = a[i] - b[i];
        }
        return c || (o._s ^= 1), o._f = d, o._d = b, o.round();
    }

    multiply(n) {
        if (JQX.Utilities.BigNumber.bigIntSupport) {
            return new JQX.Utilities.BigNumber(this._d * new JQX.Utilities.BigNumber(n)._d);
        }

        let that = this.normalizeOperand(this);

        n = that.normalizeOperand(n);

        var o = new JQX.Utilities.BigNumber(that), r = o._d.length >= (n = new JQX.Utilities.BigNumber(n))._d.length, a = (r ? o : n)._d,
            b = (r ? n : o)._d, la = a.length, lb = b.length, x = new JQX.Utilities.BigNumber, i, j, s;
        for (i = lb; i; r && s.unshift(r), x.set(x.add(new JQX.Utilities.BigNumber(s.join('')))))
            for (s = (new Array(lb - --i)).join('0').split(''), r = 0, j = la; j; r += a[--j] * b[i], s.unshift(r % 10), r = (r / 10) >>> 0);
        return o._s = o._s != n._s, o._f = ((r = la + lb - o._f - n._f) >= (j = (o._d = x._d).length) ? that._zeroes(o._d, r - j + 1, 1).length : j) - r, o.round();
    }

    divide(n) {
        if (JQX.Utilities.BigNumber.bigIntSupport) {
            return new JQX.Utilities.BigNumber(this._d / new JQX.Utilities.BigNumber(n)._d);
        }

        let that = this.normalizeOperand(this);

        n = that.normalizeOperand(n);

        if ((n = new JQX.Utilities.BigNumber(n)) == '0')
            throw new Error('Division by 0');
        else if (that == '0')
            return new JQX.Utilities.BigNumber;
        var o = new JQX.Utilities.BigNumber(that), a = o._d, b = n._d, la = a.length - o._f,
            lb = b.length - n._f, r = new JQX.Utilities.BigNumber, i = 0, j, s, l, f = 1, c = 0, e = 0;
        r._s = o._s != n._s, r.precision = Math.max(o.precision, n.precision),
            r._f = +r._d.pop(), la != lb && o._zeroes(la > lb ? b : a, Math.abs(la - lb));
        n._f = b.length, b = n, b._s = false, b = b.round();
        for (n = new JQX.Utilities.BigNumber; a[0] == '0'; a.shift());
        out:
        do {
            for (l = c = 0, n == '0' && (n._d = [], n._f = 0); i < a.length && n.compare(b) == -1; ++i) {
                (l = i + 1 == a.length, (!f && ++c > 1 || (e = l && n == '0' && a[i] == '0')))
                    && (r._f == r._d.length && ++r._f, r._d.push(0));
                (a[i] == '0' && n == '0') || (n._d.push(a[i]), ++n._f);
                if (e)
                    break out;
                if ((l && n.compare(b) == -1 && (r._f == r._d.length && ++r._f, 1)) || (l = 0))
                    while (r._d.push(0), n._d.push(0), ++n._f, n.compare(b) == -1);
            }
            if (f = 0, n.compare(b) == -1 && !(l = 0))
                while (l ? r._d.push(0) : l = 1, n._d.push(0), ++n._f, n.compare(b) == -1);
            var y;
            for (s = new JQX.Utilities.BigNumber, j = 0; n.compare(y = s.add(b)) + 1 && ++j; s.set(y));
            n.set(n.subtract(s)), !l && r._f == r._d.length && ++r._f, r._d.push(j);
        }
        while ((i < a.length || n != '0') && (r._d.length - r._f) <= r.precision);
        return r.round();
    }

    mod(n) {
        if (JQX.Utilities.BigNumber.bigIntSupport) {
            return new JQX.Utilities.BigNumber(this._d % new JQX.Utilities.BigNumber(n)._d);
        }

        let that = this.normalizeOperand(this);

        n = that.normalizeOperand(n);

        var result = that.subtract(that.divide(n).intPart().multiply(n));
        if (result.isZero() && result._s) {
            result._s = !(result._s);
        }
        return result;
    }

    pow(n) {
        if (JQX.Utilities.BigNumber.bigIntSupport) {
            let result = BigInt(1);

            for (let i = BigInt(0); i < new JQX.Utilities.BigNumber(n)._d; i = i + BigInt(1)) {
                result = result * this._d;
            }

            return new JQX.Utilities.BigNumber(result);
            // Use the following solution when UglifyJS supports **
            //return new JQX.Utilities.BigNumber(this._d ** new JQX.Utilities.BigNumber(n)._d);
        }

        let that = this.normalizeOperand(this);

        n = that.normalizeOperand(n);

        var o = new JQX.Utilities.BigNumber(that), i;
        if ((n = (new JQX.Utilities.BigNumber(n)).intPart()) == 0) return o.set(1);
        for (i = Math.abs(n); --i; o.set(o.multiply(that)));
        return n < 0 ? o.set((new JQX.Utilities.BigNumber(1)).divide(o)) : o;
    }

    set(n) {
        n = new JQX.Utilities.BigNumber(n);
        this._d = n._d;
        this._f = n._f;
        this._s = n._s;
        return this;
    }

    compare(n) {
        if (JQX.Utilities.BigNumber.bigIntSupport) {
            const otherNumber = new JQX.Utilities.BigNumber(n)._d;

            if (this._d === otherNumber) {
                return 0;
            }

            if (this._d > otherNumber) {
                return 1;
            }

            return -1;
        }

        let that = this.normalizeOperand(this);

        n = that.normalizeOperand(n);

        var a = that, la = that._f, b = new JQX.Utilities.BigNumber(n), lb = b._f, r = [-1, 1], i, l, arr;
        if (a.isZero() && b.isZero()) {
            return 0;
        }
        if (a._s != b._s)
            return a._s ? -1 : 1;
        if (la != lb)
            return r[(la > lb) ^ a._s];
        for (la = (arr = a._d).length, lb = (b = b._d).length, i = -1, l = Math.min(la, lb); ++i < l;)
            if (arr[i] != b[i])
                return r[(arr[i] > b[i]) ^ a._s];
        return la != lb ? r[(la > lb) ^ a._s] : 0;
    }

    negate() {
        if (JQX.Utilities.BigNumber.bigIntSupport) {
            return new JQX.Utilities.BigNumber(this._d * BigInt(-1));
        }

        let that = this.normalizeOperand(this);

        var n = new JQX.Utilities.BigNumber(that); return n._s ^= 1, n;
    }

    abs() {
        if (JQX.Utilities.BigNumber.bigIntSupport) {
            return new JQX.Utilities.BigNumber(this._d < 0 ? this._d * BigInt(-1) : this._d);
        }

        let that = this.normalizeOperand(this);

        var n = new JQX.Utilities.BigNumber(that); return n._s = 0, n;
    }

    intPart() {
        if (JQX.Utilities.BigNumber.bigIntSupport) {
            return new JQX.Utilities.BigNumber(this._d);
        }

        let that = this.normalizeOperand(this);

        return new JQX.Utilities.BigNumber((that._s ? '-' : '') + (that._d.slice(0, that._f).join('') || '0'));
    }

    valueOf(radix, wordLength) {
        let that = this.normalizeOperand(this);

        return that.toString(radix, wordLength);
    }

    toString(radix, wordLength, leadingZeros) {
        function negativeBinary(result, radix, wordLength) {
            var reversedResult = '';

            if (String.prototype.repeat) {
                var zeroPadding = '0'.repeat(wordLength - result.length);
                result = zeroPadding + result;
            } {
                while (result.length < wordLength) {
                    result = '0' + result;
                }
            }

            reversedResult = result.replace(/0/g, 'a');
            reversedResult = reversedResult.replace(/1/g, 'b');
            reversedResult = reversedResult.replace(/a/g, '1');
            reversedResult = reversedResult.replace(/b/g, '0');

            var plusOne = true;
            var finalResult = '';

            for (var j = reversedResult.length - 1; j >= 0; j--) {
                var currentDigit = reversedResult.charAt(j);
                var newDigit;

                if (currentDigit === '0') {
                    if (plusOne === true) {
                        newDigit = '1';
                        plusOne = false;
                    }
                    else {
                        newDigit = '0';
                    }
                }
                else {
                    if (plusOne === true) {
                        newDigit = '0';
                    }
                    else {
                        newDigit = '1';
                    }
                }
                finalResult = newDigit + '' + finalResult;
            }

            switch (radix) {
                case 2:
                    return finalResult;
                case 8:
                    var totalOct, zeroesToAdd;
                    switch (wordLength) {
                        case 8:
                            totalOct = 3;
                            zeroesToAdd = '0';
                            break;
                        case 16:
                            totalOct = 6;
                            zeroesToAdd = '00';
                            break;
                        case 32:
                            totalOct = 11;
                            zeroesToAdd = '0';
                            break;
                        case 64:
                            totalOct = 22;
                            zeroesToAdd = '00';
                            break;
                    }

                    finalResult = zeroesToAdd + finalResult;
                    var octResult = '';
                    for (var k = totalOct; k >= 1; k--) {
                        var currentOct = finalResult[k * 3 - 3] + '' + finalResult[k * 3 - 2] + '' + finalResult[k * 3 - 1];
                        octResult = parseInt(currentOct, 2).toString(8) + '' + octResult;
                    }
                    return octResult;
                case 16:
                    var totalHex;
                    switch (wordLength) {
                        case 8:
                            totalHex = 2;
                            break;
                        case 16:
                            totalHex = 4;
                            break;
                        case 32:
                            totalHex = 8;
                            break;
                        case 64:
                            totalHex = 16;
                            break;
                    }

                    var hexResult = '';
                    for (var l = totalHex; l >= 1; l--) {
                        var currentHex = finalResult[l * 4 - 4] + '' + finalResult[l * 4 - 3] + '' + finalResult[l * 4 - 2] + '' + finalResult[l * 4 - 1];
                        hexResult = parseInt(currentHex, 2).toString(16) + '' + hexResult;
                    }
                    return hexResult.toUpperCase();
            }
        }

        function toBinary(positiveNumber) {
            var two = new JQX.Utilities.BigNumber(2),
                remainder,
                remaindersArray = [],
                temp;
            if (positiveNumber === undefined) {
                temp = o;
            }
            else {
                temp = positiveNumber;
            }
            do {
                remainder = temp.mod(two);
                remaindersArray.push(remainder.toString());
                temp = temp.subtract(remainder).divide(two).intPart();
            }
            while (temp.compare(new JQX.Utilities.BigNumber(0)) === 1);

            return remaindersArray.reverse().join('');
        }
        function toOctal(binary) {
            var result = '';
            while (binary.length % 3 !== 0) {
                binary = '0' + binary;
            }
            for (var k = binary.length / 3; k >= 1; k--) {
                var currentOct = binary[k * 3 - 3] + '' + binary[k * 3 - 2] + '' + binary[k * 3 - 1];
                result = parseInt(currentOct, 2).toString(8) + '' + result;
            }
            return result;
        }
        function toHexadecimal(binary) {
            var result = '';
            while (binary.length % 4 !== 0) {
                binary = '0' + binary;
            }
            for (var l = binary.length / 4; l >= 1; l--) {
                var currentHex = binary[l * 4 - 4] + '' + binary[l * 4 - 3] + '' + binary[l * 4 - 2] + '' + binary[l * 4 - 1];
                result = parseInt(currentHex, 2).toString(16) + '' + result;
            }
            return result;
        }

        let o, decimal;

        if (JQX.Utilities.BigNumber.bigIntSupport) {
            o = this;

            if (Array.isArray(o._d)) {
                decimal = (o._s ? '-' : '') + (o._d.slice(0, o._f).join('') || '0') + (o._f != o._d.length ? '.' + o._d.slice(o._f).join('') : '');
            }
            else {
                decimal = this._d.toString();
            }
        }
        else {
            o = this.normalizeOperand(this);
            decimal = (o._s ? '-' : '') + (o._d.slice(0, o._f).join('') || '0') + (o._f != o._d.length ? '.' + o._d.slice(o._f).join('') : '');
        }

        if (radix === undefined || radix === 10) {
            return decimal;
        }

        let result;

        if (o.compare(0) > -1) {
            switch (radix) {
                case 2:
                    result = toBinary();

                    if (leadingZeros) {
                        result = result.padStart(wordLength, '0');
                    }

                    break;
                case 8:
                    result = toOctal(toBinary());
                    break;
                case 16:
                    result = toHexadecimal(toBinary()).toUpperCase();

                    if (leadingZeros) {
                        result = result.padStart(wordLength / 4, '0');
                    }

                    break;
            }
        }
        else {
            var positiveNumber = o.negate(),
                positiveBinary = toBinary(positiveNumber);
            result = negativeBinary(positiveBinary, radix, wordLength);
        }

        return result;
    }

    _zeroes(n, l, t) {
        var s = ['push', 'unshift'][t || 0];
        for (++l; --l; n[s](0));
        return n;
    }

    round() {
        if ('_rounding' in this) return this;
        var $ = JQX.Utilities.BigNumber, r = this.roundType, b = this._d, d, p, n, x;
        for (this._rounding = true; this._f > 1 && !b[0]; --this._f, b.shift());
        for (d = this._f, p = this.precision + d, n = b[p]; b.length > d && !b[b.length - 1]; b.pop());
        x = (this._s ? '-' : '') + (p - d ? '0.' + this._zeroes([], p - d - 1).join('') : '') + 1;
        if (b.length > p) {
            n && (r == $.DOWN ? false : r == $.UP ? true : r == $.CEIL ? !this._s
                : r == $.FLOOR ? this._s : r == $.HALF_UP ? n >= 5 : r == $.HALF_DOWN ? n > 5
                    : r == $.HALF_EVEN ? n >= 5 && b[p - 1] & 1 : false) && this.add(x);
            b.splice(p, b.length - p);
        }
        return delete this._rounding, this;
    }

    isZero() {
        return this._d.length === 1 && this._d[0] === 0;
    }

    normalizeOperand(n) {
        if (n instanceof JQX.Utilities.BigNumber &&
            typeof n._d === 'bigint') {
            return new JQX.Utilities.BigNumber(n._d.toString());
        }

        return n;
    }
});

/**
 * A class for instantiating a number processor object.
 */
JQX.Utilities.Assign('NumericProcessor', class NumericProcessor {
    constructor(context, numericFormatProperty) {
        switch (context[numericFormatProperty]) {
            case 'integer':
                return new JQX.Utilities.IntegerNumericProcessor(context, numericFormatProperty);
            case 'floatingPoint':
                return new JQX.Utilities.DecimalNumericProcessor(context, numericFormatProperty);
            case 'complex':
                return new JQX.Utilities.ComplexNumericProcessor(context, numericFormatProperty);
        }
    }
});

/**
 * A base class for processesing numbers.
 */
JQX.Utilities.Assign('BaseNumericProcessor', class BaseNumericProcessor {
    constructor(context, numericFormatProperty) {
        const that = this;

        that.context = context;
        that._longestLabelSize = 0;
        that.numericFormatProperty = numericFormatProperty;
        that.regexScientificNotation = new RegExp(/^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)(Y|Z|E|P|T|G|M|k|c|m|u|n|p|f|a|z|y){1}$/); // regular expressions for scientific notation
        that.regexNoLeadingZero = new RegExp(/^(-)?[.]\d+$/);
        that.regexLeadingZero = new RegExp(/^[+\-]?(0+)[1-9]+|^[+\-]?(0{2,})[.]|^(0{2,})$/);
        that.prefixesToPowers = { 'Y': 24, 'Z': 21, 'E': 18, 'P': 15, 'T': 12, 'G': 9, 'M': 6, 'k': 3, 'c': -2, 'm': -3, 'u': -6, 'n': -9, 'p': -12, 'f': -15, 'a': -18, 'z': -21, 'y': -24 };

        if (window.NIComplex) {
            that.complexConstructor = window.NIComplex;
        }
        else {
            that.complexConstructor = JQX.Utilities.Complex;
        }
    }

    prepareForValidation(initialValidation, programmaticValue, value) {
        const that = this.context,
            initialOrProgrammatic = initialValidation || programmaticValue !== undefined;

        value = value.toString();
        value = value.replace(/\s/g, '');
        value = that._discardDecimalSeparator(value);

        if (this.regexLeadingZero.test(value)) {
            const testResult = this.regexLeadingZero.exec(value);

            if (testResult[1]) {
                value = value.replace(testResult[1], '');
            }
            else if (testResult[2]) {
                value = value.replace(testResult[2], '0');
            }
            else {
                value = value.replace(testResult[3], '0');
            }
        }

        if (this.regexNoLeadingZero.test(value)) {
            if (value.charAt(0) === '-') {
                value = '-0' + value.slice(1);
            }
            else {
                value = '0' + value;
            }
        }
        else if ((that[this.numericFormatProperty] === 'integer' && (that._radixNumber === 10 || initialOrProgrammatic) || that[this.numericFormatProperty] === 'floatingPoint') && this.regexScientificNotation.test(value)) { // scientific notation test
            value = this.scientificToDecimal(value);
        }

        let complexNumberIsEntered = false,
            enteredComplexNumber;

        if (that[this.numericFormatProperty] === 'complex' && that._regexSpecial.nonNumericValue.test(value) === false) {
            try {
                if (that._regexSpecial.exaValue.test(value)) {
                    // handles ambiguous "exa" case
                    const indexOfExa = value.indexOf('E'),
                        realPart = parseFloat(value.slice(0, indexOfExa)) * Math.pow(10, 18),
                        imaginaryPart = parseFloat(value.slice(indexOfExa + 1, -1));

                    enteredComplexNumber = new this.complexConstructor(realPart, imaginaryPart);
                }
                else {
                    enteredComplexNumber = new this.complexConstructor(value);
                }
                complexNumberIsEntered = true;
            }
            catch (error) {
                complexNumberIsEntered = false;
            }
        }

        // if the entered value is not a number
        if (complexNumberIsEntered === false &&
            (!initialOrProgrammatic && that._regex[that._radixNumber].test(value) === false ||
                initialOrProgrammatic && that._regex[10].test(value) === false)) {
            that._handleNonNumericValue(initialValidation, programmaticValue, value);
            return;
        }

        return { value: value, enteredComplexNumber: enteredComplexNumber };
    }

    /**
     * Checks if a number is in exponential notation.
     */
    isENotation(value) {
        const eNotationRegex = new RegExp(/e/i);

        return eNotationRegex.test(value.toString());
    }

    /**
     * Converts a number in scientific notation to a plain number.
     */
    scientificToDecimal(scientificValue) {
        const parts = this.regexScientificNotation.exec(scientificValue),
            numericPart = parts[1],
            prefix = parts[2],
            number = parseFloat(numericPart) * (Math.pow(10, this.prefixesToPowers[prefix]));

        return number;
    }

    /**
     * Creates a label dummy element.
     */
    _createMeasureLabel() {
        const context = this.context,
            measureLabel = document.createElement('div');

        measureLabel.className = 'jqx-label';
        measureLabel.style.position = 'absolute';
        measureLabel.style.visibility = 'hidden';
        if (context.scalePosition !== 'far') {
            context._measureLabelScale = context.$.scaleNear;
        }
        else {
            context._measureLabelScale = context.$.scaleFar;
        }
        context._measureLabelScale.appendChild(measureLabel);

        return measureLabel;
    }

    /**
     * Adds a major tick and its respective label.
     */
    _addMajorTickAndLabel(htmlValue, labelSize, plot, value, middle) {
        const that = this.context,
            leftOrTop = that._settings.leftOrTop,
            offset = this.valueToPx(value);

        let currentTick = '',
            currentLabel = '';

        if (parseInt(offset) > parseInt(that._measurements.trackLength)) {
            return { tick: currentTick, label: currentLabel };
        }

        if (that.logarithmicScale) {
            htmlValue = that._formatLabel(Math.pow(10, value));
        }

        if (that.nodeName.toLowerCase() === 'jqx-tank' || that._intervalHasChanged) {
            let tickIntervalLabelSize = that._tickIntervalHandler.labelsSize;

            if (middle) {
                that._labelDummy.innerHTML = htmlValue;

                let tickPosition = this.valueToPx(value),
                    maxPosition = this.valueToPx(that._drawMax),
                    minPosition = this.valueToPx(that._drawMin),
                    labelSize = that._labelDummy[that._settings.size],
                    labelOtherSize = that.orientation === 'vertical' ? that._labelDummy.offsetWidth : that._labelDummy.offsetHeight,
                    distanceToMin = (labelSize + tickIntervalLabelSize.minLabelSize) / 2,
                    distanceToMax = (labelSize + tickIntervalLabelSize.maxLabelSize) / 2;

                that._normalLayout ?
                    plot = (tickPosition + distanceToMax < maxPosition) && (tickPosition - distanceToMin > minPosition) :
                    plot = (tickPosition - distanceToMax > maxPosition) && (tickPosition + distanceToMin < minPosition);

                if (labelOtherSize > this._longestLabelSize) {
                    this._longestLabelSize = labelOtherSize;
                }

            }
            else {
                this._longestLabelSize = Math.max(tickIntervalLabelSize.minLabelOtherSize, tickIntervalLabelSize.maxLabelOtherSize, this._longestLabelSize);
            }
        }

        that._tickValues.push(value);

        currentTick = '<div style="' + leftOrTop + ': ' + offset + 'px;" class="jqx-tick"></div>';

        if (plot !== false) {
            if (labelSize === undefined) {
                that._labelDummy.innerHTML = htmlValue;
                labelSize = that._labelDummy[that._settings.size];
            }
            const labelOffset = offset - labelSize / 2;

            currentLabel += '<div class="jqx-label' + (middle ? ' jqx-label-middle' : '') + '" style="' + leftOrTop + ': ' + labelOffset + 'px;">' + htmlValue + '</div>';
        }

        return { tick: currentTick, label: currentLabel };
    }

    /**
     * Gets the internal numeric word length based on the "wordLength" property.
     */
    getWordLength(wordLength) {
        this.context._unsigned = wordLength.charAt(0) === 'u';

        switch (wordLength) {
            case 'int8':
            case 'uint8':
                return 8;
            case 'int16':
            case 'uint16':
                return 16;
            case 'int32':
            case 'uint32':
                return 32;
            case 'int64':
            case 'uint64':
                return 64;
        }
    }

    /**
     * Returns the angle equivalent of a value.
     */
    getAngleByValue(value, calculateDrawValue, returnDegrees) {
        const that = this.context;

        if (calculateDrawValue !== false && that.logarithmicScale) {
            value = Math.log10(value);
        }

        const angleOffset = (value - that._drawMin) * that._angleRangeCoefficient;
        let degrees;

        if (!that.inverted) {
            degrees = that.endAngle - angleOffset;
        }
        else {
            degrees = that.startAngle + angleOffset;
        }

        if (returnDegrees) {
            return degrees;
        }
        return degrees * Math.PI / 180 + Math.PI / 2;
    }

    /**
     * Returns the value equivalent of an angle.
     */
    getValueByAngle(angle, integer) {
        const that = this.context;
        let minuendAngle, subtrahendAngle, value;

        if (!that.inverted) {
            minuendAngle = that.endAngle;
            subtrahendAngle = angle;
        }
        else {
            minuendAngle = angle;
            subtrahendAngle = that._normalizedStartAngle;
        }

        while (minuendAngle < subtrahendAngle) minuendAngle += 360;

        value = ((minuendAngle - subtrahendAngle) / that._angleDifference) * that._range + parseFloat(that._drawMin);

        if (that.logarithmicScale) {
            if (that.customInterval) {
                return parseFloat(Math.pow(10, this.getCoercedValue(value, true)).toFixed(12));
            }

            value = Math.pow(10, value);
        }

        if (integer && !that.coerce) {
            return Math.round(value);
        }

        value = this.createDescriptor(value, undefined, true, true);

        return this.getCoercedValue(value, false);
    }

    /**
     * Updates the values of the Gauge and its digital display and fires the "change" event.
     */
    updateGaugeValue(newValue) {
        const that = this.context,
            oldValue = that.value;

        that.value = newValue;
        that._drawValue = that.logarithmicScale ? Math.log10(newValue).toString() : newValue;
        that._number = this.createDescriptor(that.value);
        that.$.digitalDisplay.value = newValue;
        that.$.fireEvent('change', { 'value': newValue, 'oldValue': oldValue });

        delete that._valueBeforeCoercion;
    }

    /**
     * Validates the start or end value of a Gauge color range.
     */
    validateColorRange(value) {
        const that = this.context;

        return Math.min(Math.max(value, that.min), that.max);
    }

    /**
     * Returns a value based on the passed "draw" value.
     */
    getActualValue(value) {
        if (!this.context.logarithmicScale) {
            return value;
        }
        else {
            return Math.pow(10, value);
        }
    }

    /**
     * Draws minor ticks on a Gauge logarithmic scale.
     */
    drawGaugeLogarithmicScaleMinorTicks(majorTickValues, majorStep, drawMinor) {
        const that = this.context;
        let firstWholePower;

        if (majorStep instanceof JQX.Utilities.BigNumber) {
            majorStep = parseFloat(majorStep.toString());
        }

        for (let i in majorTickValues) {
            firstWholePower = i;
            if (i >= 0 && i % 1 === 0) {
                break;
            }
        }

        // positive powers
        for (let i = parseFloat(firstWholePower); i < that._drawMax; i += majorStep) {
            for (let j = 2; j <= 9; j++) {
                const value = j * Math.pow(10, i + majorStep - 1);

                if (value < that.max) {
                    drawMinor(value);
                }
            }
        }

        // negative powers
        for (let i = parseFloat(firstWholePower); i > that._drawMin; i -= majorStep) {
            for (let j = 2; j <= 9; j++) {
                const value = j * Math.pow(10, i - 1);

                if (value > that.min) {
                    drawMinor(value);
                }
            }
        }
    }

    /**
     * Returns the difference between two angles.
     */
    _getAngleDifference(angle1, angle2) {
        const phi = Math.abs(angle2 - angle1) % 360,
            distance = phi > 180 ? 360 - phi : phi;

        return distance;
    }

    /**
     * Plots custom ticks.
     */
    addCustomTicks() {
        const numericProcessor = this,
            that = numericProcessor.context,
            normalScale = !that.logarithmicScale;
        let ticks = '',
            labels = '';

        function createTickAndLabel(i) {
            const currentLabel = that.customTicks[i],
                value = normalScale ? numericProcessor.createDescriptor(currentLabel) : Math.log10(currentLabel),
                middle = i > 0 && i < that.customTicks.length - 1,
                currentTickAndLabel = numericProcessor._addMajorTickAndLabel(that._formatLabel(currentLabel), undefined, true, value, middle);

            ticks += currentTickAndLabel.tick;
            labels += currentTickAndLabel.label;
        }

        numericProcessor._longestLabelSize = 0;
        that._tickValues = [];
        that._labelDummy = numericProcessor._createMeasureLabel();

        if (!that._normalLayout) {
            for (let i = that.customTicks.length - 1; i >= 0; i--) {
                createTickAndLabel(i);
            }
        }
        else {
            for (let i = 0; i < that.customTicks.length; i++) {
                createTickAndLabel(i);
            }
        }

        if (that.nodeName.toLowerCase() === 'jqx-tank') {
            that._updateScaleWidth(numericProcessor._longestLabelSize);
        }

        that._appendTicksAndLabelsToScales(ticks, labels);
    }

    /**
     * Plots the Gauge's custom ticks.
     */
    addGaugeCustomTicks() {
        const numericProcessor = this,
            that = numericProcessor.context,
            distance = that._distance,
            majorTickWidth = that._measurements.radius - distance.majorTickDistance;
        let drawTick, drawLabel;

        if (that.ticksVisibility !== 'none' && that._plotTicks !== false) {
            drawTick = function (angle) {
                that._drawTick(angle, majorTickWidth, 'major');
            };
        }
        else {
            drawTick = function () { };
        }

        if (that.labelsVisibility !== 'none' && that._plotLabels !== false) {
            drawLabel = function (angle, currentLabel, middle) {
                that._drawLabel(angle, currentLabel, distance.labelDistance, middle);
            };
        }
        else {
            drawLabel = function () { };
        }

        function createTickAndLabel(i) {
            const currentLabel = that.customTicks[i],
                value = numericProcessor.createDescriptor(currentLabel),
                angle = numericProcessor.getAngleByValue(value, true),
                middle = i > 0 && i < that.customTicks.length - 1;

            drawTick(angle);
            drawLabel(angle, currentLabel, middle);
        }

        for (let i = that.customTicks.length - 1; i >= 0; i--) {
            createTickAndLabel(i);
        }
    }
});

/**
 * A class for processesing integer numbers.
 */
JQX.Utilities.Assign('IntegerNumericProcessor', class IntegerNumericProcessor extends JQX.Utilities.BaseNumericProcessor {
    constructor(context, numericFormatProperty) {
        super(context, numericFormatProperty);

        const that = this;

        that.context = context;
        that.defaultMins = { int8: '-128', uint8: '0', int16: '-32768', uint16: '0', int32: '-2147483648', uint32: '0', int64: '-9223372036854775808', uint64: '0' };
        that.defaultMaxs = { int8: '127', uint8: '255', int16: '32767', uint16: '65535', int32: '2147483647', uint32: '4294967295', int64: '9223372036854775807', uint64: '18446744073709551615' };
    }

    createDescriptor(initialValue, supportsENotation, validateConstruction, validateMinMax, discardRadix) {
        const that = this.context;
        let returnValue;

        if (initialValue.constructor !== JQX.Utilities.BigNumber) {
            let radix = !discardRadix && that._radixNumber ? that._radixNumber : 10;

            if (radix === 10 && supportsENotation && initialValue.constructor !== JQX.Utilities.BigNumber && this.isENotation(initialValue)) {
                if (JQX.Utilities.BigNumber.bigIntSupport) {
                    initialValue = new JQX.Utilities.BigNumber(Math.round(initialValue));
                }
                else {
                    initialValue = new JQX.Utilities.NumberRenderer(initialValue).largeExponentialToDecimal();
                }
            }
            if (that._toBigNumberDecimal) {
                returnValue = that._toBigNumberDecimal(initialValue.toString(radix, that._wordLengthNumber), radix);
            }
            else {
                returnValue = new JQX.Utilities.BigNumber(initialValue);
            }
        }
        else {
            returnValue = new JQX.Utilities.BigNumber(initialValue);
        }
        if (validateConstruction) {
            // if the entered number is negative and the "wordLength" is "uint", the number is set to 0
            if (that._unsigned && returnValue.compare(0) === -1) {
                returnValue = returnValue.set(0);
            }
            if (validateMinMax) {
                // if the entered number is outside the range defined by "min" and "max", the number is changed to the value of "min" or "max"
                returnValue = this.validate(returnValue, that._minObject, that._maxObject);
            }
            returnValue = this.round(returnValue);
        }
        return returnValue;
    }

    /**
    * Returns a rounded BigNumber object
    */
    round(value) {
        const context = this.context;

        // eslint-disable-next-line
        if (value instanceof window.JQX.Utilities.BigNumber && typeof value._d === 'bigint') {
            return value;
        }
        else if (value instanceof window.JQX.Utilities.BigNumber === false ||
            !context._wordLengthNumber || context._wordLengthNumber < 64) {
            return new JQX.Utilities.BigNumber(Math.round(value.toString()));
        }

        const fraction = value.mod(1);

        if (!(fraction._d.length === 1 && fraction._d[0] === 0)) {
            // if the entered number is with a decimal value, it is rounded up or down to its nearest integer equivalent

            value = value.intPart();
            if (!value._s) {
                // round positive number
                if (fraction._d[1] > 4) {
                    value = value.add(1);
                }
            }
            else {
                // round negative number
                if (fraction._d[1] > 5 ||
                    fraction._d[1] === 5 && fraction._d[2]) {
                    value = value.add(-1);
                }
            }
        }
        return value;
    }

    /**
     * Validates value.
     */
    validate(initialValue, min, max) {
        let returnValue;

        if (initialValue.compare(min) === -1) {
            returnValue = min;
        }
        else if (initialValue.compare(max) === 1) {
            returnValue = max
        }
        else {
            returnValue = initialValue;
        }
        return returnValue;
    }

    /**
     * Validates min/max.
     */
    validateMinMax(validateMin, validateMax) {
        const that = this.context;

        let defaultMin = this.defaultMins[that.wordLength],
            defaultBigMin = new JQX.Utilities.BigNumber(defaultMin),
            defaultMax = this.defaultMaxs[that.wordLength],
            defaultBigMax = new JQX.Utilities.BigNumber(defaultMax),
            numericScale = that.mode !== 'date';

        if (that._numberRenderer === undefined) {
            that._numberRenderer = new JQX.Utilities.NumberRenderer();
        }

        if (validateMin && numericScale) {
            if (that.min !== null) {
                that.min = that.min.toString().replace(/\s/g, '');
                if (this.regexScientificNotation.test(that.min)) {
                    that.min = this.scientificToDecimal(that.min);
                }
            }
            let currentBigMin = this.round(new JQX.Utilities.BigNumber(that.min));

            if (that.min !== null && (!that._minIsNull || !that._initialized) && currentBigMin.compare(defaultBigMin) >= 0) {
                that._minObject = currentBigMin;
            }
            else {
                that._minIsNull = true;
                that.min = defaultMin;
                that._minObject = defaultBigMin;
            }
        }

        if (validateMax && numericScale) {
            if (that.max !== null) {
                that.max = that.max.toString().replace(/\s/g, '');
                if (this.regexScientificNotation.test(that.max)) {
                    that.max = this.scientificToDecimal(that.max);
                }
            }
            let currentBigMax = this.round(new JQX.Utilities.BigNumber(that.max));

            if (that.max !== null && (!that._maxIsNull || !that._initialized) && currentBigMax.compare(defaultBigMax) <= 0) {
                that._maxObject = currentBigMax;
            }
            else {
                that._maxIsNull = true;
                that.max = defaultMax;
                that._maxObject = defaultBigMax;
            }
        }

        if (!numericScale) {
            that._minObject = new JQX.Utilities.BigNumber(that.min);
            that._maxObject = new JQX.Utilities.BigNumber(that.max);
        }

        if (!this.compare(that._minObject, that._maxObject)) {
            //Set default values
            that._minObject = defaultBigMin;
            that._maxObject = defaultBigMax;
            that._drawMin = that.logarithmicScale ? 0 : defaultMin;
            that._drawMax = that.logarithmicScale ? 10 : defaultMax;
            that.min = defaultMin;
            that.max = defaultMax;
        }

        if (!numericScale) {
            that._minDate = JQX.Utilities.DateTime.fromFullTimeStamp(that.min);
            that._maxDate = JQX.Utilities.DateTime.fromFullTimeStamp(that.max);
        }
    }

    /**
     * Converts value to pixels.
     */
    valueToPx(value) {
        const ignored = JQX.Utilities.BigNumber.ignoreBigIntNativeSupport;

        JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = true;

        const that = this.context,
            lengthRangeRatio = new JQX.Utilities.BigNumber(that._measurements.trackLength).divide(new JQX.Utilities.BigNumber(that._range));

        let result;

        if (that._normalLayout) {
            const drawMin = that._drawMin instanceof JQX.Utilities.BigNumber ? that._drawMin : new JQX.Utilities.BigNumber(that._drawMin);

            value = new JQX.Utilities.BigNumber(value);
            result = parseFloat((lengthRangeRatio.multiply(value.subtract(drawMin))).toString());
        }
        else {
            const drawMax = that._drawMax instanceof JQX.Utilities.BigNumber ? that._drawMax : new JQX.Utilities.BigNumber(that._drawMax);

            result = parseFloat(this.round(((drawMax.subtract(value)).multiply(lengthRangeRatio))).toString());
        }

        JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;
        return result;
    }

    /**
    * Returns the value equivalent of a pixel offset.
    */
    pxToValue(px) {
        const that = this.context,
            ignored = JQX.Utilities.BigNumber.ignoreBigIntNativeSupport;
        let result;

        JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = true;

        if (that._normalLayout) {
            result = that._valuePerPx.multiply(px - that._trackStart);
        }
        else {
            result = that._valuePerPx.multiply(that._trackEnd - px);
        }

        result = this.round(result).toString();

        JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;

        if (that.logarithmicScale) {
            let power = parseFloat(result) + parseFloat(that._drawMin);

            //that._drawValue = power;
            return new JQX.Utilities.BigNumber(Math.round(Math.pow(10, power)));
        }

        let returnedValue = this.createDescriptor(that._minObject.add(result), false, true, true);
        //that._drawValue = returnedValue;

        return returnedValue;
    }

    /**
     * BigNumber compare method.
     */
    compare(initialValue, otherValue, thorough) {
        if ((initialValue === null || otherValue === null) && initialValue !== otherValue) {
            return true;
        }

        if (initialValue.constructor !== JQX.Utilities.BigNumber) {
            initialValue = new JQX.Utilities.BigNumber(initialValue);
        }

        const result = initialValue.compare(otherValue);

        if (thorough !== true) {
            return result !== 0;
        }

        return result;
    }

    /**
     * Increments/Decrements value. Keyboard navigation operations.
     */
    incrementDecrement(initialValue, operation, stepObject) {
        const that = this.context;

        let returnValue;

        if (initialValue.constructor !== JQX.Utilities.BigNumber) {
            initialValue = new JQX.Utilities.BigNumber(initialValue);
        }

        if (operation === 'add') {
            returnValue = initialValue.add(stepObject);
            if (that._drawMax !== undefined) {
                return returnValue.compare(that._drawMax) > 0 ? new JQX.Utilities.BigNumber(that._drawMax) : returnValue;
            }
        }
        else {
            returnValue = initialValue.subtract(stepObject);
            if (that._drawMin !== undefined) {
                return returnValue.compare(that._drawMin) < 0 ? new JQX.Utilities.BigNumber(that._drawMin) : returnValue;
            }
        }
        return returnValue;
    }

    /**
     * Renders the value. Scientific notation renderer.
     */
    render(initialValue, ignoreRadixNumber) {
        const context = this.context;

        if (!context.scientificNotation && ignoreRadixNumber === true) {
            return new JQX.Utilities.NumberRenderer(new JQX.Utilities.BigNumber(initialValue)).bigNumberToExponent(context.significantDigits);
        }

        // scientific notation
        let returnValue = initialValue;

        if (context.scientificNotation && ignoreRadixNumber === true) {
            returnValue = new JQX.Utilities.NumberRenderer(returnValue).toScientific(context.significantDigits, context.precisionDigits);
        }
        else if (typeof initialValue !== 'string') {
            returnValue = initialValue.toString(context._radixNumber, context._wordLengthNumber, context.leadingZeros);
        }

        return returnValue;
    }

    /**
     * Adds tank\'s ticks and labels.
     */
    addTicksAndLabels() {
        const ignored = JQX.Utilities.BigNumber.ignoreBigIntNativeSupport;

        JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = true;

        const that = this.context,
            trackLength = that._measurements.trackLength,
            normalLayout = that._normalLayout,
            ticksFrequency = that._majorTicksInterval,
            tickscount = this.round(new JQX.Utilities.BigNumber(that._range).divide(ticksFrequency)),
            ticksDistance = trackLength / tickscount,
            min = new JQX.Utilities.BigNumber(that._drawMin),
            max = new JQX.Utilities.BigNumber(that._drawMax);


        let first, second, distanceModifier, last, firstLabelValue, firstLabelSize, lastLabelValue, lastLabelSize, currentTickAndLabel, ticks = '', labels = '';

        that._tickValues = [];
        this._longestLabelSize = 0;

        if (normalLayout) {
            first = min;
            second = ticksFrequency.add(first.subtract(first.mod(ticksFrequency)));
            distanceModifier = second.subtract(first);
            firstLabelValue = that._formatLabel(min);
            firstLabelSize = that._tickIntervalHandler.labelsSize.minLabelSize;
            last = max;
            lastLabelValue = that._formatLabel(max);
            lastLabelSize = that._tickIntervalHandler.labelsSize.maxLabelSize;
        }
        else {
            first = max;
            second = first.subtract(first.mod(ticksFrequency));
            distanceModifier = first.subtract(second);
            firstLabelValue = that._formatLabel(max);
            firstLabelSize = that._tickIntervalHandler.labelsSize.maxLabelSize;
            last = min;
            lastLabelValue = that._formatLabel(min);
            lastLabelSize = that._tickIntervalHandler.labelsSize.minLabelSize;
        }

        that._labelDummy = this._createMeasureLabel();

        currentTickAndLabel = this._addMajorTickAndLabel(firstLabelValue, firstLabelSize, true, first); // first tick and label
        ticks += currentTickAndLabel.tick;
        labels += currentTickAndLabel.label;

        // special case for second tick and label
        const distanceFromFirstToSecond = distanceModifier.divide(ticksFrequency).multiply(ticksDistance);

        if (second.compare(that.max) !== 0 && distanceFromFirstToSecond.compare(trackLength) < 0) {
            // second item rendering
            const secondItemHtmlValue = that._formatLabel(second.toString()),
                plotSecond = distanceFromFirstToSecond.compare(firstLabelSize) > 0;

            currentTickAndLabel = this._addMajorTickAndLabel(secondItemHtmlValue, undefined, plotSecond, second, true);
            ticks += currentTickAndLabel.tick;
            labels += currentTickAndLabel.label;
        }
        currentTickAndLabel = this.addMiddleMajorTicks(tickscount, ticksDistance, distanceFromFirstToSecond, distanceModifier, normalLayout, ticksFrequency);
        ticks += currentTickAndLabel.tick;
        labels += currentTickAndLabel.label;
        currentTickAndLabel = this._addMajorTickAndLabel(lastLabelValue, lastLabelSize, true, last); // last tick and label
        ticks += currentTickAndLabel.tick;
        labels += currentTickAndLabel.label;

        if (that.mode !== 'date') {
            ticks += this.addMinorTicks(normalLayout);
        }

        that._measureLabelScale.removeChild(that._labelDummy);
        delete that._labelDummy;
        delete that._measureLabelScale;

        if (that.nodeName.toLowerCase() === 'jqx-tank') {
            that._updateScaleWidth(this._longestLabelSize);
        }

        that._appendTicksAndLabelsToScales(ticks, labels);
        JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;
    }

    /**
    * Adds the middle major ticks and their respective labels.
    */
    addMiddleMajorTicks(tickscount, ticksDistance, distanceFromFirstToSecond, distanceModifier, normalLayout, ticksFrequency) {
        const that = this.context;

        let majorTicks = '', majorLabels = '', valuePlusExponent;

        for (let i = 1; i < tickscount; i++) {
            let number = distanceFromFirstToSecond.add(i * ticksDistance), value;

            if (normalLayout) {
                value = ticksFrequency.multiply(i).add(distanceModifier.add(new JQX.Utilities.BigNumber(that._drawMin)));
            }
            else {
                value = new JQX.Utilities.BigNumber(that._drawMax).subtract(distanceModifier).subtract(ticksFrequency.multiply(i));

                // if the value of the penultimate is 0 we add the exponent to accurately calculate its size
                if (i === tickscount - 1 && value.compare(0) === 0) {
                    that._numberRenderer.numericValue = that._tickIntervalHandler.nearestPowerOfTen;
                    valuePlusExponent = that._numberRenderer.bigNumberToExponent(1);
                }
            }
            if (value.compare(that._drawMax) !== 0) {
                let htmlValue = that._formatLabel(value.toString()),
                    plot = true;

                that._labelDummy.innerHTML = valuePlusExponent ? valuePlusExponent : htmlValue;
                let dimensionValue = that._labelDummy[that._settings.size];

                if (number.add(dimensionValue).compare(tickscount * ticksDistance) >= 0) {      // + 5 is an experimental value
                    plot = false; // does not plot the second to last label if it intersects with the last one
                }

                const currentTickAndLabel = this._addMajorTickAndLabel(htmlValue, undefined, plot, value, true);

                majorTicks += currentTickAndLabel.tick;
                majorLabels += currentTickAndLabel.label;
            }
        }
        return { tick: majorTicks, label: majorLabels };
    }

    /**
     * Adds minor ticks.
     */
    addMinorTicks(normalLayout) {
        function addMinorTick(i) {
            if (tickValues.indexOf(i) === -1 && i % minorTicksInterval === 0) {
                minorTicks += '<div style="' + leftOrTop + ': ' + that._numericProcessor.valueToPx(i) + 'px;" class="jqx-tick jqx-tick-minor"></div>';
            }
        }

        const that = this.context,
            tickValues = that._tickValues,
            nearestPowerOfTen = that._tickIntervalHandler.nearestPowerOfTen,
            minorTicksInterval = that._minorTicksInterval,
            leftOrTop = that._settings.leftOrTop;

        let firstTickValue, secondTickValue, lastTickValue, minorTicks = '';

        if (normalLayout) {
            firstTickValue = tickValues[0];
            secondTickValue = tickValues[1];
            lastTickValue = tickValues[tickValues.length - 1]
        }
        else {
            firstTickValue = tickValues[tickValues.length - 1];
            secondTickValue = tickValues[tickValues.length - 2];
            lastTickValue = tickValues[0]
        }


        if (that.logarithmicScale) {
            addMinorTickOnLogarithmicScale();
        }
        else {
            // minor ticks from the beginning to the second major tick
            for (let i = secondTickValue; firstTickValue.compare(i) < 0; i = i.subtract(nearestPowerOfTen)) {
                addMinorTick(i);
            }

            // minor ticks from the second major tick to the end
            for (let i = secondTickValue.add(nearestPowerOfTen); lastTickValue.compare(i) > 0; i = i.add(nearestPowerOfTen)) {
                addMinorTick(i);
            }
        }

        function addMinorTickOnLogarithmicScale() {
            let trackLength = that._measurements.trackLength,
                partialTrackLength = trackLength / tickValues.length,
                modifierCoef = 0.1;

            if (partialTrackLength < 20) {
                modifierCoef = 1;
            }
            else if ((partialTrackLength >= 20) && (partialTrackLength < 40)) {
                modifierCoef = (secondTickValue - firstTickValue) > 1 ? 1 : 0.5;
            }
            else if ((partialTrackLength >= 40) && (partialTrackLength < 80)) {
                modifierCoef = 0.2;
            }

            let nearestPowerOf10BelowMax = Math.floor(that._drawMax),
                distanceToNearestPowerOf10 = that._drawMax - nearestPowerOf10BelowMax,
                ticksOnPowerOf10 = (that._drawMax - that._drawMin) > tickValues.length;

            for (let j = that._drawMax; j > 0; j = j - 1) {
                let range = distanceToNearestPowerOf10 > 0 ? Math.pow(10, j - distanceToNearestPowerOf10 + 1) : Math.pow(10, j),
                    modifier = range * modifierCoef;

                for (let i = range; i > 0; i = (i - modifier)) {
                    if ((i < that.max) && (i > that.min)) {
                        let value = new JQX.Utilities.BigNumber(Math.log10(i));

                        if (((value % 1 === 0) && ticksOnPowerOf10) || !ticksOnPowerOf10) {
                            minorTicks += '<div style="' + leftOrTop + ': ' + that._numericProcessor.valueToPx(value) + 'px;" class="jqx-tick jqx-tick-minor"></div>';
                        }
                    }
                }
            }

        }

        return minorTicks;
    }

    /**
     * Validates custom ticks.
     */
    validateCustomTicks() {
        const that = this.context,
            numericScale = that.mode !== 'date';
        let validCustomTicks = [];

        for (let i = 0; i < that.customTicks.length; i++) {
            let currentTick = that.customTicks[i];

            if (numericScale) {
                currentTick = this.createDescriptor(currentTick, false, true);
            }
            else if (currentTick._d === undefined) {
                currentTick = JQX.Utilities.DateTime.validateDate(currentTick).getTimeStamp();
            }

            if (currentTick.compare(that._minObject) >= 0 && currentTick.compare(that._maxObject) <= 0) {
                validCustomTicks.push(currentTick);
            }
        }

        validCustomTicks.sort(function (a, b) {
            return a.compare(b);
        });

        if (numericScale) {
            for (let i = 0; i < validCustomTicks.length; i++) {
                validCustomTicks[i] = validCustomTicks[i].toString();
            }

            validCustomTicks = validCustomTicks.filter(function (element, index, array) {
                return !index || element !== array[index - 1];
            });
        }

        that.customTicks = validCustomTicks.slice(0);
    }

    /**
     * Plots the Gauge's ticks and labels.
     */
    addGaugeTicksAndLabels() {
        const ignored = JQX.Utilities.BigNumber.ignoreBigIntNativeSupport;

        JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = true;

        const that = this.context,
            numericProcessor = this,
            maxLabelHeight = Math.max(that._tickIntervalHandler.labelsSize.minLabelSize, that._tickIntervalHandler.labelsSize.maxLabelSize),
            majorStep = that._majorTicksInterval,
            minorStep = that._minorTicksInterval,
            majorTickValues = {},
            distance = that._distance,
            radius = that._measurements.radius,
            majorTickWidth = radius - distance.majorTickDistance,
            minorTickWidth = radius - distance.minorTickDistance,
            bigDrawMin = new JQX.Utilities.BigNumber(that._drawMin),
            bigDrawMax = new JQX.Utilities.BigNumber(that._drawMax);
        let drawMajor, drawMinor, addLabel, currentAngle, angleAtMin, angleAtMax;

        if (that.ticksVisibility !== 'none' && that._plotTicks !== false) {
            drawMajor = function (angle) {
                that._drawTick(angle, majorTickWidth, 'major');
            };

            drawMinor = function (value) {
                that._drawTick(numericProcessor.getAngleByValue(value, true), minorTickWidth, 'minor');
            };
        }
        else {
            drawMajor = function () { };
            drawMinor = function () { };
        }

        if (that.labelsVisibility !== 'none' && that._plotLabels !== false) {
            addLabel = function (angle, currentLabel, middle) {
                that._drawLabel(angle, currentLabel, distance.labelDistance, middle);
            };
        }
        else {
            addLabel = function () { };
        }

        if (!that.inverted) {
            angleAtMin = that.endAngle;
            angleAtMax = that.startAngle;
        }
        else {
            angleAtMin = that.startAngle;
            angleAtMax = that.endAngle;
        }

        // first major tick and label
        currentAngle = numericProcessor.getAngleByValue(bigDrawMin, false);
        drawMajor(currentAngle);
        majorTickValues[that._drawMin.toString()] = true;
        addLabel(currentAngle, that.min, false);

        let second = bigDrawMin.subtract(bigDrawMin.mod(majorStep)),
            firstMinTick;

        if (bigDrawMin.compare(0) !== -1) {
            second = second.add(majorStep);
        }

        // determines the value at the first minor tick
        for (let i = new JQX.Utilities.BigNumber(second); i.compare(bigDrawMin) !== -1; i = i.subtract(minorStep)) {
            firstMinTick = i;
        }

        // second major tick and label
        currentAngle = numericProcessor.getAngleByValue(second, false);
        drawMajor(currentAngle);
        majorTickValues[second.toString()] = true;
        if (2 * Math.PI * that._measurements.innerRadius * (this._getAngleDifference(angleAtMin, numericProcessor.getAngleByValue(second, false, true)) / 360) > maxLabelHeight) {
            addLabel(currentAngle, this.getActualValue(second), second.compare(bigDrawMax) === -1);
        }

        let i;
        // middle major ticks and labels
        for (i = second.add(majorStep); i.compare(bigDrawMax.subtract(majorStep)) === -1; i = i.add(majorStep)) {
            currentAngle = numericProcessor.getAngleByValue(i, false);
            drawMajor(currentAngle);
            majorTickValues[i.toString()] = true;
            addLabel(currentAngle, this.getActualValue(i), true);
        }

        if (majorTickValues[i.toString()] === undefined && i.compare(bigDrawMax) !== 1) {
            // second-to-last major tick and label
            currentAngle = numericProcessor.getAngleByValue(i, false);
            drawMajor(currentAngle);
            majorTickValues[i.toString()] = true;
            if (2 * Math.PI * that._measurements.innerRadius * (this._getAngleDifference(angleAtMax, numericProcessor.getAngleByValue(i, false, true)) / 360) >= maxLabelHeight) {
                addLabel(currentAngle, this.getActualValue(i), true);
            }

            if (that._normalizedStartAngle !== that.endAngle) {
                // last major tick and label
                currentAngle = numericProcessor.getAngleByValue(bigDrawMax, false);
                drawMajor(currentAngle);
                if (2 * Math.PI * that._measurements.innerRadius * (this._getAngleDifference(angleAtMax, angleAtMin) / 360) >= maxLabelHeight) {
                    addLabel(currentAngle, that.max, false);
                }
            }
        }

        if (that.mode === 'date') {
            JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;
            return;
        }

        // minor ticks
        if (!that.logarithmicScale) {
            for (let j = firstMinTick; j.compare(bigDrawMax) === -1; j = j.add(minorStep)) {
                if (majorTickValues[j.toString()]) {
                    continue; // does not plot minor ticks over major ones
                }
                drawMinor(j);
            }
        }
        else {
            this.drawGaugeLogarithmicScaleMinorTicks(majorTickValues, majorStep, drawMinor);
        }

        JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;
    }

    /**
     * Sets toolTip's value and updates the value of the element.
     */
    updateToolTipAndValue(value, oldValue, changeValue) {
        const that = this.context,
            logarithmicScale = that.logarithmicScale;

        that._updateTooltipValue(value.toString());
        if (logarithmicScale) {
            value = parseFloat(Math.pow(10, parseFloat(value)).toFixed(11));
        }

        value = value instanceof JQX.Utilities.BigNumber ? value : new JQX.Utilities.BigNumber(value);

        const stringifiedValue = value.toString();

        that._number = value;
        that._drawValue = logarithmicScale ? Math.log10(stringifiedValue) : value;

        // eslint-disable-next-line
        if (value.compare(oldValue) !== 0 && changeValue) {
            if (that.mode === 'numeric') {
                that.value = stringifiedValue;
                value = stringifiedValue;
            }
            else {
                oldValue = that._valueDate;
                that._valueDate = JQX.Utilities.DateTime.fromFullTimeStamp(stringifiedValue);
                that.value = value;
                value = that._valueDate;
            }

            if (!that._programmaticValueIsSet) {
                that.$.fireEvent('change', { 'value': value, 'oldValue': oldValue });
            }

            if (that.$.hiddenInput) {
                that.$.hiddenInput.value = value;
            }
        }
    }

    /**
     * Validates the interval property.
     */
    validateInterval(interval) {
        const that = this.context,
            range = that._maxObject.subtract(that._minObject);

        that._validInterval = new JQX.Utilities.BigNumber(interval);
        that._validInterval = this.round(that._validInterval);

        if (that._validInterval.compare(range) === 1) {
            that._validInterval = range;
        }

        that.interval = that._validInterval.toString();
    }

    /**
     * Returns a coerced value based on the interval.
     */
    getCoercedValue(value, useDrawVariables, logarithmicGauge) {
        const that = this.context;

        if (!that.coerce) {
            return value;
        }

        const normalScale = !that.logarithmicScale;

        value = value instanceof JQX.Utilities.BigNumber ? value : new JQX.Utilities.BigNumber(value);

        let minValue, maxValue;

        if (that.customInterval) {
            const customTicks = that.customTicks;

            if (customTicks.length === 0) {
                return value;
            }

            let difference, closestValue;

            if (normalScale || logarithmicGauge) {
                minValue = that._minObject;
                difference = minValue.subtract(value).abs();
                closestValue = minValue;

                for (let i = 0; i < customTicks.length; i++) {
                    const currentTickObject = this.createDescriptor(customTicks[i]),
                        currentDifference = currentTickObject.subtract(value).abs();

                    if (currentDifference.compare(difference) === -1) {
                        difference = currentDifference;
                        closestValue = currentTickObject;
                    }
                }
            }
            else {
                minValue = that._drawMin;
                difference = Math.abs(minValue - parseFloat(value.toString()));
                closestValue = minValue;

                for (let i = 0; i < customTicks.length; i++) {
                    const currentTickObject = Math.log10(customTicks[i]),
                        currentDifference = Math.abs(currentTickObject - value);

                    if (currentDifference < difference) {
                        difference = currentDifference;
                        closestValue = currentTickObject;
                    }
                }

                closestValue = new JQX.Utilities.BigNumber(closestValue);
            }

            return closestValue;
        }

        let interval = that._validInterval;

        if (that.mode === 'date') {
            if (that._dateIncrementMethod === 'addYears') {
                return this.coerceYear(value);
            }
            else if (that._dateIncrementMethod === 'addMonths') {
                return this.coerceMonth(value);
            }
            else {
                interval = new JQX.Utilities.BigNumber(that._dateIntervalNumber).multiply(interval);
            }
        }

        if (useDrawVariables !== false) {
            minValue = new JQX.Utilities.BigNumber(that._drawMin);
            maxValue = new JQX.Utilities.BigNumber(that._drawMax);
        }
        else {
            minValue = new JQX.Utilities.BigNumber(that.min);
            maxValue = new JQX.Utilities.BigNumber(that.max);
        }

        let noMin = value.subtract(minValue),
            remainder = noMin.mod(interval);

        if (remainder.compare(0) === 0) {
            return value;
        }

        let lowerValue = noMin.subtract(remainder),
            greaterValue = lowerValue.add(interval);

        if ((noMin.subtract(lowerValue)).abs().compare((noMin.subtract(greaterValue)).abs()) < 0) {
            return lowerValue.add(minValue);
        }
        else {
            const biggerValue = greaterValue.add(minValue);

            return biggerValue.compare(maxValue) <= 0 ? biggerValue : lowerValue.add(minValue);
        }
    }

    coerceMonth(value) {
        const that = this.context,
            interval = parseFloat(that._validInterval),
            date = JQX.Utilities.DateTime.fromFullTimeStamp(value),
            year = date.year(),
            month = date.month(),
            day = date.day(),
            minYear = that._minDate.year(),
            minMonth = that._minDate.month(),
            totalMonths = (that._maxDate.year() - minYear - 1) * 12 + 12 - minMonth + that._maxDate.month();
        let currentMonths = (year - 1 - minYear) * 12 + (12 - minMonth) + (month);

        if (interval === 1) {
            if ([1, 3, 5, 7, 8, 10, 12].indexOf(month) !== -1) {
                if (day > 16 || day === 16 && date.hour() > 11) {
                    currentMonths++;
                }
            }
            else if (month === 2) {
                if (date.isLeapYear(year)) {
                    if (day > 15 || day === 15 && date.hour() > 11) {
                        currentMonths++;
                    }
                }
                else if (day > 14) {
                    currentMonths++;
                }
            }
            else if (day > 15) {
                currentMonths++;
            }
        }

        currentMonths = this.getCoercedTimePart(0, totalMonths, currentMonths, interval);

        let result = that._minDate.addMonths(currentMonths, true);

        if (result.compare(that._maxDate) === 1) {
            result = that._minDate.addMonths(currentMonths - interval, true);
        }

        that._drawValue = new JQX.Utilities.BigNumber(result.getTimeStamp());
        return that._drawValue;
    }

    coerceYear(value) {
        const that = this.context,
            interval = parseFloat(that._validInterval),
            date = JQX.Utilities.DateTime.fromFullTimeStamp(value),
            maxYear = that._maxDate.year(),
            updatedValueConstructorParameters = JQX.Utilities.DateTime.getConstructorParameters(that._minDate);
        let year = date.year();

        if (date.month() > 6) {
            year++;
        }

        let coercedTimePart = this.getCoercedTimePart(that._minDate.year(), maxYear, year, interval);

        if (coercedTimePart > maxYear) {
            coercedTimePart -= interval;
        }

        updatedValueConstructorParameters[0] = coercedTimePart;
        updatedValueConstructorParameters.unshift(null);

        const valueDate = new (Function.prototype.bind.apply(JQX.Utilities.DateTime, updatedValueConstructorParameters));

        that._drawValue = new JQX.Utilities.BigNumber(valueDate.getTimeStamp());
        return that._drawValue;
    }

    getCoercedTimePart(min, max, value, interval) {
        let noMin = value - min,
            remainder = noMin % interval;

        if (remainder === 0) {
            return value;
        }

        let lowerValue = parseFloat((noMin - remainder).toFixed(12)),
            greaterValue = lowerValue + interval;

        if (max - min <= interval) {
            return value >= min + (max - min) / 2 ? max : min;
        }

        if (Math.abs(noMin - lowerValue) < Math.abs(noMin - greaterValue)) {
            return lowerValue + min;
        }
        else {
            const biggerValue = greaterValue + min;

            return biggerValue > max ? lowerValue + min : biggerValue;
        }
    }

    /**
     * Updates the value of the Tank and the "value" property and triggers the respective events.
     */
    updateValue(value) {
        const that = this.context;

        value = value instanceof JQX.Utilities.BigNumber ? value : new JQX.Utilities.BigNumber(value);

        const renderedValue = this.validate(value, that._minObject, that._maxObject);
        let oldValue = that.value,
            valueDetail, difference;

        that._number = renderedValue;
        that._drawValue = that.logarithmicScale ? Math.log10(renderedValue) : renderedValue;

        if (that.mode === 'numeric') {
            valueDetail = value.toString();
            that.value = valueDetail;
            difference = this.compare(value, oldValue);
        }
        else {
            oldValue = JQX.Utilities.DateTime.fromFullTimeStamp(oldValue);
            that._valueDate = JQX.Utilities.DateTime.fromFullTimeStamp(value);
            that.value = value;
            value = that._valueDate;
            valueDetail = value;
            difference = value.compare(oldValue) !== 0;
        }

        if (!that._programmaticValueIsSet && (difference || that._scaleTypeChangedFlag)) {
            that.$.fireEvent('change', { 'value': valueDetail, 'oldValue': oldValue });
        }

        if (that.$.hiddenInput) {
            that.$.hiddenInput.value = value;
        }

        that._moveThumbBasedOnValue(that._drawValue);
    }

    /**
     * Returns value per pixel.
     */
    getValuePerPx(range, pxRange) {
        const ignored = JQX.Utilities.BigNumber.ignoreBigIntNativeSupport;

        JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = true;

        const result = new JQX.Utilities.BigNumber(range).divide(pxRange);

        JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;
        return result;
    }

    /**
     * Restricts the thumbs to not pass each other.
     */
    restrictValue(values) {
        if (values[1].constructor === JQX.Utilities.BigNumber) {
            if (values[1].compare(values[0]) === -1) {
                values[1].set(values[0]);
            }
        }
        else {
            if (values[1] < values[0]) {
                values[1] = values[0];
            }
        }
    }

    /**
     * Returns the angle equivalent of a value.
     */
    getAngleByValue(value, calculateDrawValue, returnDegrees) {
        const that = this.context,
            ignored = JQX.Utilities.BigNumber.ignoreBigIntNativeSupport;

        JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = true;

        if (that._wordLengthNumber < 64) {
            JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;
            return super.getAngleByValue(parseFloat(value.toString()), calculateDrawValue, returnDegrees);
        }

        if (value instanceof JQX.Utilities.BigNumber === false) {
            value = new JQX.Utilities.BigNumber(value);
        }

        if (calculateDrawValue !== false && that.logarithmicScale) {
            value = new JQX.Utilities.BigNumber(Math.log10(value.toString()));
        }

        const angleOffset = value.subtract(that._drawMin).multiply(that._angleRangeCoefficient);
        let degrees;


        if (!that.inverted) {
            degrees = angleOffset.multiply(-1).add(that.endAngle);
        }
        else {
            degrees = angleOffset.add(that.startAngle);
        }

        degrees = parseFloat(degrees.toString());
        JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;

        if (returnDegrees) {
            return degrees;
        }

        return degrees * Math.PI / 180 + Math.PI / 2;
    }

    /**
     * Returns the value equivalent of an angle.
     */
    getValueByAngle(angle) {
        const that = this.context;

        if (that._wordLengthNumber < 64) {
            return super.getValueByAngle(angle, true);
        }

        const ignored = JQX.Utilities.BigNumber.ignoreBigIntNativeSupport;
        let minuendAngle, subtrahendAngle, value;

        JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = true;

        if (!that.inverted) {
            minuendAngle = that.endAngle;
            subtrahendAngle = angle;
        }
        else {
            minuendAngle = angle;
            subtrahendAngle = that._normalizedStartAngle;
        }

        while (minuendAngle < subtrahendAngle) minuendAngle += 360;

        value = new JQX.Utilities.BigNumber((minuendAngle - subtrahendAngle) / that._angleDifference).multiply(that._range).add(that._drawMin);

        if (that.logarithmicScale) {
            value = new JQX.Utilities.BigNumber(Math.pow(10, value.toString()));
        }

        let result;

        if (that.coerce) {
            result = this.getCoercedValue(value, false);
        }
        else {
            result = this.round(value);
        }

        JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;
        return new JQX.Utilities.BigNumber(result);
    }

    /**
     * Updates the values of the Gauge and its digital display and fires the "change" event.
     */
    updateGaugeValue(newValue) {
        if (newValue instanceof JQX.Utilities.BigNumber === false) {
            return super.updateGaugeValue(newValue);
        }

        const that = this.context,
            oldValue = that._getEventValue();

        if (that.mode === 'numeric') {
            that.value = newValue.toString();
            that.$.digitalDisplay.value = that.value;
        }
        else {
            that._valueDate = JQX.Utilities.DateTime.fromFullTimeStamp(newValue);
            that.value = newValue;
            that.$.digitalDisplay.$.input.value = that._valueDate;
        }

        that._drawValue = that.logarithmicScale ? Math.log10(that.value).toString() : that.value;
        that._number = newValue;

        that.$.fireEvent('change', { 'value': that._getEventValue(), 'oldValue': oldValue });
    }

    /**
     * Validates the start or end value of a Gauge color range.
     */
    validateColorRange(value) {
        const that = this.context;

        if (that._wordLengthNumber < 64) {
            return super.validateColorRange(value);
        }

        if (that.mode === 'numeric') {
            value = new JQX.Utilities.BigNumber(value);
        }
        else {
            value = JQX.Utilities.DateTime.validateDate(value);
            value = value.getTimeStamp();
        }

        const bigMin = new JQX.Utilities.BigNumber(that.min),
            bigMax = new JQX.Utilities.BigNumber(that.max);

        if (value.compare(bigMin) === -1) {
            value = bigMin;
        }

        if (value.compare(bigMax) === 1) {
            value = bigMax;
        }

        return value;
    }

    /**
     * Locks the Gauge's interaction with the mouse.
     */
    lockRotation(directionCondition, newValue) {
        const that = this.context;

        if (newValue instanceof JQX.Utilities.BigNumber === false) {
            newValue = new JQX.Utilities.BigNumber(newValue);
        }

        if (directionCondition && newValue.compare(that._number) === -1) {
            that._lockCW = true;
            if (newValue.compare(that._maxObject) === -1) {
                return new JQX.Utilities.BigNumber(that._maxObject);
            }
        }
        else if (!directionCondition && newValue.compare(that._number) === 1) {
            that._lockCCW = true;
            if (newValue.compare(that._minObject) === 1) {
                return new JQX.Utilities.BigNumber(that._minObject);
            }
        }
    }

    /**
     * Gets the angle-range coefficient.
     */
    getAngleRangeCoefficient() {
        const that = this.context,
            ignored = JQX.Utilities.BigNumber.ignoreBigIntNativeSupport;

        JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = true;
        that._angleRangeCoefficient = new JQX.Utilities.BigNumber(that._angleDifference).divide(that._range);
        JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;
    }
});

/**
 * A class for processesing floating point numbers.
 */
JQX.Utilities.Assign('DecimalNumericProcessor', class DecimalNumericProcessor extends JQX.Utilities.BaseNumericProcessor {
    constructor(context, numericFormatProperty) {
        super(context, numericFormatProperty);
        this.context = context;
    }

    /**
     * Returns the precise modulo of the mod operation.
     */
    getPreciseModulo(dividend, divisor, moduloCoefficient) {
        const sign = dividend >= 0 ? 1 : -1;

        dividend = Math.abs(dividend);
        divisor = Math.abs(divisor);

        if (typeof moduloCoefficient === 'undefined') {
            const dividendExponential = dividend.toExponential(),
                divisorExponential = divisor.toExponential(),
                dividendExponent = parseInt(dividendExponential.slice(dividendExponential.indexOf('e') + 1), 10),
                divisorExponent = parseInt(divisorExponential.slice(divisorExponential.indexOf('e') + 1), 10),
                dividendRoundCoefficient = dividendExponent < 0 ? Math.abs(dividendExponent) : 0,
                divisorRoundCoefficient = divisorExponent < 0 ? Math.abs(divisorExponent) : 0,
                roundCoefficient = Math.max(dividendRoundCoefficient, divisorRoundCoefficient);

            this.roundCoefficient = roundCoefficient;

            if (dividend < divisor) {
                return sign * dividend;
            }
            if (dividend === divisor) {
                return 0;
            }
            if ((dividend < -1 || dividend > 1) && (divisor < -1 || divisor > 1 || divisor === 1)) {
                if (dividend % 1 === 0 && divisor % 1 === 0) {
                    return sign * (dividend % divisor);
                }
                else {
                    const ignored = JQX.Utilities.BigNumber.ignoreBigIntNativeSupport;

                    JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = true;

                    const result = sign * parseFloat(new JQX.Utilities.BigNumber(dividend).mod(divisor).toString());

                    JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;
                    return result;
                }
            }

            const moduloCoefficient = Math.pow(10, roundCoefficient);

            return sign * (((dividend * moduloCoefficient) % (divisor * moduloCoefficient)) / moduloCoefficient);
        }
        return sign * (Math.round(dividend * moduloCoefficient) % Math.round(divisor * moduloCoefficient));
    }

    /**
     * Creates a descriptor.
     */
    createDescriptor(initialValue, supportsENotation, validateConstruction, validateMinMax) {
        let returnValue = parseFloat(initialValue);

        if (validateMinMax) {
            returnValue = this.validate(returnValue, this.context._minObject, this.context._maxObject);
        }
        return returnValue;
    }

    /**
     * Returns a rounded number
     */
    round(value) {
        return Math.round(value);
    }

    /**
     * Validates the value.
     */
    validate(initialValue, min, max) {
        let returnValue;

        if (initialValue < min) {
            returnValue = min;
        }
        else if (initialValue > max) {
            returnValue = max;
        }
        else {
            returnValue = initialValue;
        }
        return returnValue;
    }

    /**
     * Validates min/max.
     */
    validateMinMax(validateMin, validateMax) {
        const that = this.context,
            checkSpecialRegexMin = typeof (that._regexSpecial) !== 'undefined' ? that._regexSpecial.inf.test(that.min) : false,
            checkSpecialRegexMax = typeof (that._regexSpecial) !== 'undefined' ? that._regexSpecial.inf.test(that.max) : false;

        if (validateMin) {
            if (that.min === null || checkSpecialRegexMin) {
                that.min = -Infinity;
                that._minObject = -Infinity;
            }
            else {
                that.min = that.min.toString().replace(/\s/g, '');
                if (this.regexScientificNotation.test(that.min)) {
                    that.min = this.scientificToDecimal(that.min);
                }

                that._minObject = that._discardDecimalSeparator(that.min);
            }
        }
        if (validateMax) {
            if (that.max === null || checkSpecialRegexMax) {
                that.max = Infinity;
                that._maxObject = Infinity;
            }
            else {
                that.max = that.max.toString().replace(/\s/g, '');
                if (this.regexScientificNotation.test(that.max)) {
                    that.max = this.scientificToDecimal(that.max);
                }

                that._maxObject = that._discardDecimalSeparator(that.max);
            }
        }

        if (!this.compare(that._minObject, that._maxObject)) {

            //Set default values
            that._maxObject = parseFloat(that._maxObject) + 1;
            that.max = that._maxObject;
        }
    }

    /**
     * Returns the pixel equivalent of a value.
     */
    valueToPx(value) {
        const that = this.context,
            lengthRangeRatio = that._measurements.trackLength / that._range;

        let result;

        if (that._normalLayout) {
            result = lengthRangeRatio * (value - that._drawMin);
        }
        else {
            result = lengthRangeRatio * (that._drawMax - value);
        }

        return Math.round(result);
    }

    /**
     * Returns the value equivalent of a pixel offset.
     */
    pxToValue(px) {
        const that = this.context;

        let result;

        if (that._normalLayout) {
            result = (px - that._trackStart) * that._valuePerPx;
        }
        else {
            result = (that._trackEnd - px) * that._valuePerPx;
        }

        if (that.logarithmicScale) {
            const power = result + parseFloat(that._drawMin);

            return Math.pow(10, power);
        }

        return this.validate(result + that._minObject, that._minObject, that._maxObject);
    }

    /**
     * Decimal compare method.
     */
    compare(initialValue, otherValue, thorough) {
        initialValue = parseFloat(initialValue);
        otherValue = parseFloat(otherValue);

        if (thorough !== true) {
            return initialValue !== otherValue;
        }

        if (initialValue < otherValue) {
            return -1;
        }

        if (initialValue > otherValue) {
            return 1;
        }

        return 0;
    }

    /**
     * Increments/Decrements value. Keyboard navigation operations.
     */
    incrementDecrement(initialValue, operation, stepObject) {
        const that = this.context;

        let returnValue;

        if (operation === 'add') {
            returnValue = parseFloat(initialValue) + parseFloat(stepObject);
            if (that._drawMax !== undefined) {
                return returnValue > parseFloat(that._drawMax) ? that._drawMax : returnValue;
            }
        }
        else {
            returnValue = parseFloat(initialValue) - parseFloat(stepObject);
            if (that._drawMin !== undefined) {
                return returnValue < parseFloat(that._drawMin) ? that._drawMin : returnValue;
            }
        }
        return returnValue;
    }

    /**
     * Renders the value.
     */
    render(initialValue) {
        const that = this.context,
            checkSpecialRegex = typeof (that._regexSpecial) !== 'undefined' ? that._regexSpecial.nonNumericValue.test(initialValue) : false;

        if (checkSpecialRegex) {
            return initialValue;
        }
        else {
            const numberRenderer = new JQX.Utilities.NumberRenderer(initialValue);

            if (that.scientificNotation) {
                return numberRenderer.toScientific(that.significantDigits, that.precisionDigits);
            }
            else {
                return numberRenderer.toDigits(that.significantDigits, that.precisionDigits);
            }
        }
    }

    /**
     * Adds tank's ticks and labels.
     */
    addTicksAndLabels() {
        const that = this.context,
            trackLength = that._measurements.trackLength,
            normalLayout = that._normalLayout,
            ticksFrequency = that._majorTicksInterval,
            tickscount = Math.round(that._range / parseFloat((ticksFrequency.toString()))),
            ticksDistance = trackLength / tickscount,
            min = parseFloat(that._drawMin),
            max = parseFloat(that._drawMax);

        let first, second, distanceModifier, last, firstLabelValue, firstLabelSize, lastLabelValue, lastLabelSize, currentTickAndLabel, ticks = '', labels = '';

        that._tickValues = [];
        this._longestLabelSize = 0;

        if (normalLayout) {
            first = min;

            //handling specific case
            if (that.logarithmicScale && min < 0 && min !== -1) {
                second = parseFloat(first - this.getPreciseModulo(first, ticksFrequency));
            }
            else {
                second = parseFloat(first - this.getPreciseModulo(first, ticksFrequency) + parseFloat(ticksFrequency));
            }

            distanceModifier = second - first;
            firstLabelValue = that._formatLabel(min);
            firstLabelSize = that._tickIntervalHandler.labelsSize.minLabelSize;
            last = max;
            lastLabelValue = that._formatLabel(max);
            lastLabelSize = that._tickIntervalHandler.labelsSize.maxLabelSize;
        }
        else {
            first = max;
            second = parseFloat(first - this.getPreciseModulo(first, ticksFrequency));
            distanceModifier = first - second;
            firstLabelValue = that._formatLabel(max);
            firstLabelSize = that._tickIntervalHandler.labelsSize.maxLabelSize;
            last = min;
            lastLabelValue = that._formatLabel(min);
            lastLabelSize = that._tickIntervalHandler.labelsSize.minLabelSize;
        }

        that._labelDummy = this._createMeasureLabel();

        currentTickAndLabel = this._addMajorTickAndLabel(firstLabelValue, firstLabelSize, true, first); // first tick and label
        ticks += currentTickAndLabel.tick;
        labels += currentTickAndLabel.label;

        // special case for second tick and label
        const distanceFromFirstToSecond = distanceModifier / ticksFrequency * ticksDistance;

        if (second.toString() !== that._drawMax.toString() && distanceFromFirstToSecond < trackLength) {
            // second item rendering
            const secondItemHtmlValue = that._formatLabel(second.toString()),
                plotSecond = firstLabelSize < distanceFromFirstToSecond;

            currentTickAndLabel = this._addMajorTickAndLabel(secondItemHtmlValue, undefined, plotSecond, second, true);
            ticks += currentTickAndLabel.tick;
            labels += currentTickAndLabel.label;
        }

        currentTickAndLabel = this.addMiddleMajorTicks(tickscount, ticksDistance, distanceFromFirstToSecond, distanceModifier, normalLayout, ticksFrequency);
        ticks += currentTickAndLabel.tick;
        labels += currentTickAndLabel.label;
        currentTickAndLabel = this._addMajorTickAndLabel(lastLabelValue, lastLabelSize, true, last); // last tick and label
        ticks += currentTickAndLabel.tick;
        labels += currentTickAndLabel.label;
        ticks += this.addMinorTicks(normalLayout);

        that._measureLabelScale.removeChild(that._labelDummy);
        delete that._labelDummy;
        delete that._measureLabelScale;

        if (that.nodeName.toLowerCase() === 'jqx-tank') {
            that._updateScaleWidth(this._longestLabelSize);
        }

        that._appendTicksAndLabelsToScales(ticks, labels);
    }

    /**
   * Adds the middle major ticks and their respective labels.
   */
    addMiddleMajorTicks(tickscount, ticksDistance, distanceFromFirstToSecond, distanceModifier, normalLayout, ticksFrequency) {
        const that = this.context;

        let majorTicks = '', majorLabels = '';

        for (let i = 1; i < tickscount; i++) {
            let number = i * ticksDistance + distanceFromFirstToSecond,
                value;

            if (normalLayout) {
                value = parseFloat(that._drawMin) + ticksFrequency * i + distanceModifier;
            }
            else {
                value = parseFloat(that._drawMax) - ticksFrequency * i - distanceModifier;
            }
            if (value.toString() !== that._drawMax.toString()) {
                let htmlValue = that._formatLabel(value.toString()),
                    plot = true;

                that._labelDummy.innerHTML = htmlValue;
                let dimensionValue = that._labelDummy[that._settings.size];

                if (number + dimensionValue >= tickscount * ticksDistance) { // + 32 is an Experimental value
                    plot = false;
                }
                const currentTickAndLabel = this._addMajorTickAndLabel(htmlValue, undefined, plot, value, true);

                majorTicks += currentTickAndLabel.tick;
                majorLabels += currentTickAndLabel.label;
            }
        }
        return { tick: majorTicks, label: majorLabels };
    }

    /**
     * Adds minor ticks.
     */
    addMinorTicks(normalLayout) {
        function getPreciseFraction(i) {
            return parseFloat((i).toFixed(roundCoefficient));
        }

        function addMinorTick(i) {
            if (tickValues.indexOf(i) === -1 && that._numericProcessor.getPreciseModulo(i, minorTicksInterval, moduloCoefficient) === 0) {
                minorTicks += '<div style="' + leftOrTop + ': ' + that._numericProcessor.valueToPx(i) + 'px;" class="jqx-tick jqx-tick-minor"></div>';
            }
        }
        const that = this.context,
            tickValues = that._tickValues,
            nearestPowerOfTen = that._tickIntervalHandler.nearestPowerOfTen,
            minorTicksInterval = that._minorTicksInterval,
            roundCoefficient = Math.log10(nearestPowerOfTen) < 0 ? Math.round(Math.abs(Math.log10(nearestPowerOfTen))) : 0,
            moduloCoefficient = Math.pow(10, roundCoefficient),
            leftOrTop = that._settings.leftOrTop;

        let firstTickValue, secondTickValue, lastTickValue, minorTicks = '';

        if (normalLayout) {
            firstTickValue = tickValues[0];
            secondTickValue = tickValues[1];
            lastTickValue = tickValues[tickValues.length - 1]
        }
        else {
            firstTickValue = tickValues[tickValues.length - 1];
            secondTickValue = tickValues[tickValues.length - 2];
            lastTickValue = tickValues[0]
        }

        if (that.logarithmicScale) {
            addMinorTickOnLogarithmicScale();
        }
        else {
            // minor ticks from the beginning to the second major tick
            for (let i = secondTickValue; i > firstTickValue; i = getPreciseFraction(i - nearestPowerOfTen)) {
                addMinorTick(i);
            }

            // minor ticks from the second major tick to the end
            for (let i = getPreciseFraction(secondTickValue + nearestPowerOfTen); i < lastTickValue; i = getPreciseFraction(i + nearestPowerOfTen)) {
                addMinorTick(i);
            }
        }

        function addMinorTickOnLogarithmicScale() {
            let trackLength = that._measurements.trackLength,
                partialTrackLength = trackLength / tickValues.length,
                modifierCoef = 0.1;

            if (partialTrackLength < 20) {
                modifierCoef = 1;
            }
            else if ((partialTrackLength >= 20) && (partialTrackLength < 40)) {
                modifierCoef = (secondTickValue - firstTickValue) > 1 ? 1 : 0.5;
            }
            else if ((partialTrackLength >= 40) && (partialTrackLength < 80)) {
                modifierCoef = 0.2;
            }

            let nearestPowerOf10BelowMax = Math.floor(that._drawMax),
                distanceToNearestPowerOf10 = that._drawMax - nearestPowerOf10BelowMax,
                ticksOnPowerOf10 = (that._drawMax - that._drawMin) > tickValues.length;

            for (let j = that._drawMax; j > that._drawMin - 1; j = j - 1) {
                let range = distanceToNearestPowerOf10 > 0 ? Math.pow(10, j - distanceToNearestPowerOf10 + 1) : Math.pow(10, j),
                    modifier = range * modifierCoef;

                for (let i = range; i > 0; i = (i - modifier)) {
                    if ((i < that.max) && (i > that.min)) {
                        let value = new JQX.Utilities.BigNumber(Math.log10(i));

                        if (((value % 1 === 0) && ticksOnPowerOf10) || !ticksOnPowerOf10) {
                            minorTicks += '<div style="' + leftOrTop + ': ' + that._numericProcessor.valueToPx(value) + 'px;" class="jqx-tick jqx-tick-minor"></div>';
                        }
                    }
                }
            }
        }
        return minorTicks;
    }

    /**
     * Validates custom ticks.
     */
    validateCustomTicks() {
        const that = this.context;
        let validCustomTicks = [];

        for (let i = 0; i < that.customTicks.length; i++) {
            const currentTick = that.customTicks[i],
                currentTickObject = this.createDescriptor(currentTick);

            if (currentTickObject >= that._minObject && currentTickObject <= that._maxObject) {
                validCustomTicks.push(currentTickObject.toString());
            }
        }

        validCustomTicks.sort(function (a, b) {
            return a - b;
        });

        validCustomTicks = validCustomTicks.filter(function (element, index, array) {
            return !index || element !== array[index - 1];
        });

        that.customTicks = validCustomTicks.slice(0);
    }

    /**
     * Plots the Gauge's ticks and labels.
     */
    addGaugeTicksAndLabels() {
        const that = this.context,
            numericProcessor = this,
            maxLabelHeight = Math.max(that._tickIntervalHandler.labelsSize.minLabelSize, that._tickIntervalHandler.labelsSize.maxLabelSize),
            majorStep = that._majorTicksInterval,
            minorStep = that._minorTicksInterval,
            majorTickValues = {},
            distance = that._distance,
            radius = that._measurements.radius,
            majorTickWidth = radius - distance.majorTickDistance,
            minorTickWidth = radius - distance.minorTickDistance;
        let drawMajor, drawMinor, addLabel, currentAngle, angleAtMin, angleAtMax;

        if (that.ticksVisibility !== 'none' && that._plotTicks !== false) {
            drawMajor = function (angle) {
                that._drawTick(angle, majorTickWidth, 'major');
            };

            drawMinor = function (value) {
                that._drawTick(numericProcessor.getAngleByValue(value, true), minorTickWidth, 'minor');
            };
        }
        else {
            drawMajor = function () { };
            drawMinor = function () { };
        }

        if (that.labelsVisibility !== 'none' && that._plotLabels !== false) {
            addLabel = function (angle, currentLabel, middle) {
                that._drawLabel(angle, currentLabel, distance.labelDistance, middle);
            };
        }
        else {
            addLabel = function () { };
        }

        if (!that.inverted) {
            angleAtMin = that.endAngle;
            angleAtMax = that.startAngle;
        }
        else {
            angleAtMin = that.startAngle;
            angleAtMax = that.endAngle;
        }

        // first major tick and label
        currentAngle = numericProcessor.getAngleByValue(that._drawMin, false);
        drawMajor(currentAngle);
        majorTickValues[that._drawMin] = true;
        addLabel(currentAngle, that.min, false);

        let second = that._drawMin - numericProcessor.getPreciseModulo(that._drawMin, majorStep),
            firstMinTick;

        if (that._drawMin >= 0) {
            second += majorStep;
        }

        // determines the value at the first minor tick
        for (let i = second; i >= that._drawMin; i = i - minorStep) {
            firstMinTick = i;
        }

        // second major tick and label
        currentAngle = numericProcessor.getAngleByValue(second, false);
        drawMajor(currentAngle);
        majorTickValues[second] = true;
        if (2 * Math.PI * that._measurements.innerRadius * (this._getAngleDifference(angleAtMin, numericProcessor.getAngleByValue(second, false, true)) / 360) > maxLabelHeight) {
            addLabel(currentAngle, this.getActualValue(second), second < that._drawMax);
        }

        let i;
        // middle major ticks and labels
        for (i = second + majorStep; i < that._drawMax - majorStep; i += majorStep) {
            currentAngle = numericProcessor.getAngleByValue(i, false);
            drawMajor(currentAngle);
            majorTickValues[i] = true;
            addLabel(currentAngle, this.getActualValue(i), true);
        }

        if (majorTickValues[i] === undefined && i <= that._drawMax) {
            // second-to-last major tick and label
            currentAngle = numericProcessor.getAngleByValue(i, false);
            drawMajor(currentAngle);
            majorTickValues[i] = true;
            if (2 * Math.PI * that._measurements.innerRadius * (this._getAngleDifference(angleAtMax, numericProcessor.getAngleByValue(i, false, true)) / 360) >= maxLabelHeight) {
                addLabel(currentAngle, this.getActualValue(i), true);
            }

            if (that._normalizedStartAngle !== that.endAngle) {
                // last major tick and label
                currentAngle = numericProcessor.getAngleByValue(that._drawMax, false);
                drawMajor(currentAngle);
                majorTickValues[that._drawMax] = true;
                if (2 * Math.PI * that._measurements.innerRadius * (this._getAngleDifference(angleAtMax, angleAtMin) / 360) >= maxLabelHeight) {
                    addLabel(currentAngle, that.max, false);
                }
            }
        }

        // minor ticks
        if (!that.logarithmicScale) {
            for (let j = firstMinTick; j < that._drawMax; j += minorStep) {
                if (majorTickValues[j]) {
                    continue; // does not plot minor ticks over major ones
                }
                drawMinor(j);
            }
        }
        else {
            this.drawGaugeLogarithmicScaleMinorTicks(majorTickValues, majorStep, drawMinor);
        }
    }

    /**
     * Sets toolTip's value and updates the value of the element.
     */
    updateToolTipAndValue(value, oldValue, changeValue) {
        const that = this.context,
            logarithmicScale = that.logarithmicScale;

        that._updateTooltipValue(value);
        if (logarithmicScale) {
            value = parseFloat(Math.pow(10, parseFloat(value)).toFixed(11));
        }

        const stringifiedValue = value.toString();

        that._number = value;
        that._drawValue = logarithmicScale ? Math.log10(stringifiedValue) : value;

        // eslint-disable-next-line
        if (stringifiedValue !== oldValue && changeValue) {
            that.value = that._discardDecimalSeparator(stringifiedValue);

            if (!that._programmaticValueIsSet) {
                that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValue });
            }

            if (that.$.hiddenInput) {
                that.$.hiddenInput.value = that.value;
            }
        }
    }

    /**
     * Validates the interval property.
     */
    validateInterval(interval) {
        const that = this.context,
            range = that._maxObject - that._minObject;

        that._validInterval = Math.min(parseFloat(interval), range);
        that.interval = that._validInterval;
    }

    /**
     * Returns a coerced value based on the interval.
     */
    getCoercedValue(value, useDrawVariables, logarithmicGauge) {
        const that = this.context;

        if (!that.coerce) {
            return value;
        }

        let normalScale = !that.logarithmicScale,
            minValue, maxValue;

        if (that.customInterval) {
            const customTicks = that.customTicks;

            if (customTicks.length === 0) {
                return value;
            }

            normalScale = normalScale || logarithmicGauge;

            if (useDrawVariables !== false) {
                minValue = parseFloat(that._drawMin);
            }
            else {
                minValue = that._minObject;
            }

            let difference = Math.abs(minValue - value),
                closestValue = minValue;

            for (let i = 0; i < customTicks.length; i++) {
                const currentTickObject = this.createDescriptor(customTicks[i]),
                    currentTickValue = normalScale ? currentTickObject : Math.log10(currentTickObject),
                    currentDifference = Math.abs(currentTickValue - value);

                if (currentDifference < difference) {
                    difference = currentDifference;
                    closestValue = currentTickValue;
                }
            }

            return closestValue;
        }

        if (useDrawVariables !== false) {
            minValue = parseFloat(that._drawMin);
            maxValue = parseFloat(that._drawMax);
        }
        else {
            minValue = parseFloat(that.min);
            maxValue = parseFloat(that.max);
        }

        let noMin = value - minValue,
            remainder = this.getPreciseModulo(noMin, parseFloat(that.interval)),
            coef = this.roundCoefficient;

        if (remainder === 0) {
            return value;
        }

        if (this.roundCoefficient === 0) {
            coef = 12;
        }

        let lowerValue = parseFloat((noMin - remainder).toFixed(coef)),
            greaterValue = lowerValue + parseFloat(that.interval);

        if (((that.max - that.min) <= parseFloat(that.interval)) && normalScale) {
            let min = minValue,
                max = maxValue;

            return value >= min + (max - min) / 2 ? max : min;
        }

        if (Math.abs(noMin - lowerValue) < Math.abs(noMin - greaterValue)) {
            return lowerValue + minValue;
        }
        else {
            const biggerValue = greaterValue + minValue;

            return biggerValue > maxValue ? lowerValue + minValue : biggerValue;
        }
    }

    /**
       * Updates the value of the Tank and the "value" property and triggers the respective events.
       */
    updateValue(value) {
        const that = this.context,
            renderedValue = this.validate(value, that._minObject, that._maxObject),
            oldActualValue = that.value;

        if (value.toString() !== oldActualValue.toString() || that._scaleTypeChangedFlag) {
            that.value = value.toString();
            that._number = renderedValue;

            if (!that._programmaticValueIsSet) {
                that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldActualValue });
            }
        }
        else {
            that.value = typeof (value) === 'string' ? value : value.toString();
        }

        that._drawValue = that.logarithmicScale ? Math.log10(renderedValue).toString() : renderedValue.toString();
        that._moveThumbBasedOnValue(that._drawValue);

        if (that.$.hiddenInput) {
            that.$.hiddenInput.value = that.value;
        }
    }

    /**
     * Returns value per pixel.
     */
    getValuePerPx(range, pxRange) {
        return parseFloat(range) / pxRange;
    }

    /**
     * Restricts the thumbs to not pass each other.
     */
    restrictValue(values) {
        if (values[1] < values[0]) {
            values[1] = values[0];
        }
    }

    /**
     * Locks the Gauge's interaction with the mouse.
     */
    lockRotation(directionCondition, newValue) {
        const that = this.context;

        if (directionCondition && newValue < that._number) {
            that._lockCW = true;
            if (newValue < that._maxObject) {
                return that._maxObject;
            }
        }
        else if (!directionCondition && newValue > that._number) {
            that._lockCCW = true;
            if (newValue > that._minObject) {
                return that._minObject;
            }
        }
    }

    /**
     * Gets the angle-range coefficient.
     */
    getAngleRangeCoefficient() {
        const that = this.context;

        that._angleRangeCoefficient = that._angleDifference / that._range;
    }
});

/**
 * A class for processesing complex numbers.
 */
JQX.Utilities.Assign('ComplexNumericProcessor', class ComplexNumericProcessor extends JQX.Utilities.BaseNumericProcessor {
    constructor(context, numericFormatProperty) {
        super(context, numericFormatProperty);
        this.context = context;
    }

    /**
     * Creates a Complex number descriptor.
     */
    createDescriptor(initialValue, supportsENotation, validateConstruction, validateMinMax, discardRadix, presetComplexNumber) {
        let returnValue;

        if (presetComplexNumber) {
            returnValue = presetComplexNumber;
        }
        else {
            if (initialValue.constructor === this.complexConstructor) {
                returnValue = new this.complexConstructor(initialValue.realPart, initialValue.imaginaryPart);
            }
            else {
                returnValue = new this.complexConstructor(initialValue);
            }
        }
        if (validateMinMax) {
            returnValue = this.validate(returnValue, this.context._minObject, this.context._maxObject);
        }
        return returnValue;
    }

    /**
     * Validates value.
     */
    validate(initialValue, min, max) {
        let returnValue = initialValue;

        if (min !== -Infinity) {
            if (this.compareComplexNumbers(initialValue, min) === -1) {
                returnValue = new this.complexConstructor(min.realPart, min.imaginaryPart);
            }
        }
        else if (max !== Infinity) {
            if (this.compareComplexNumbers(initialValue, max) === 1) {
                returnValue = new this.complexConstructor(max.realPart, max.imaginaryPart);
            }
        }
        return returnValue;
    }

    /**
     * Complex number compare method.
     */
    compare(initialValue, otherValue, thorough) {
        if (thorough !== true) {
            return this.compareComplexNumbers(initialValue, otherValue) !== 0;
        }

        return this.compareComplexNumbers(initialValue, otherValue);
    }

    /**
     * Validates min/max.
     */
    validateMinMax(validateMin, validateMax) {
        const that = this.context;

        if (validateMin) {
            if (that.min === null || that._regexSpecial.inf.test(that.min)) {
                that.min = -Infinity;
                that._minObject = -Infinity;
            }
            else {
                that._minObject = new this.complexConstructor(that.min);
            }
        }

        if (validateMax) {
            if (that.max === null || that._regexSpecial.inf.test(that.max)) {
                that.max = Infinity;
                that._maxObject = Infinity;
            }
            else {
                that._maxObject = new this.complexConstructor(that.max);
            }
        }
    }

    /**
     * Increments/Decrements value. Keyboard navigation operations.
     */
    incrementDecrement(initialValue, operation) {
        let returnValue = new this.complexConstructor(initialValue.realPart, initialValue.imaginaryPart),
            spinButtonsStepObject = this.context._spinButtonsStepObject;

        if (operation === 'add') {
            returnValue.realPart += spinButtonsStepObject.realPart;
            returnValue.imaginaryPart += spinButtonsStepObject.imaginaryPart;
        }
        else {
            returnValue.realPart -= spinButtonsStepObject.realPart;
            returnValue.imaginaryPart -= spinButtonsStepObject.imaginaryPart;
        }
        return returnValue;
    }

    /**
     * Renders the value. Complex number renderer.
     */
    render(initialValue) {
        let returnValue = initialValue;

        if (this.context._regexSpecial.nonNumericValue.test(initialValue) === false) {
            let realPart = returnValue.realPart,
                imaginaryPart = returnValue.imaginaryPart,
                sign,
                significantDigits = this.context.significantDigits,
                precisionDigits = this.context.precisionDigits;

            if (imaginaryPart >= 0) {
                sign = '+';
            }
            else {
                sign = '-';
                imaginaryPart = Math.abs(imaginaryPart);
            }

            const realPartRenderer = new JQX.Utilities.NumberRenderer(realPart),
                imaginaryPartRenderer = new JQX.Utilities.NumberRenderer(imaginaryPart);

            if (this.context.scientificNotation) {
                realPart = realPartRenderer.toScientific(significantDigits, precisionDigits);
                imaginaryPart = imaginaryPartRenderer.toScientific(significantDigits, precisionDigits);
            }
            else {
                realPart = realPartRenderer.toDigits(significantDigits, precisionDigits);
                imaginaryPart = imaginaryPartRenderer.toDigits(significantDigits, precisionDigits);
            }

            returnValue = `${realPart} ${sign} ${imaginaryPart}i`;
        }
        return returnValue;
    }

    /**
     * Complex number compare method.
     */
    compareComplexNumbers(left, right) {
        if ((left instanceof this.complexConstructor === false) || (right instanceof this.complexConstructor === false)) {
            // if at least one of the numbers is not an JQX.Utilities.Complex object, the numbers are different
            return -1;
        }

        const leftReal = left.realPart,
            rightReal = right.realPart;

        if (leftReal < rightReal) {
            return -1;
        }
        else if (leftReal > rightReal) {
            return 1;
        }
        else {
            const leftImaginary = left.imaginaryPart,
                rightImaginary = right.imaginaryPart;

            if (leftImaginary < rightImaginary) {
                return -1;
            }
            else if (leftImaginary > rightImaginary) {
                return 1;
            }
            else {
                return 0;
            }
        }
    }
});

JQX.Utilities.Assign('NumberRenderer', class NumberRenderer {
    constructor(numericValue) {
        const that = this;

        that.numericValue = numericValue;

        that.powersToPrefixes = { '24': 'Y', '21': 'Z', '18': 'E', '15': 'P', '12': 'T', '9': 'G', '6': 'M', '3': 'k', '0': '', '-2': 'c', '-3': 'm', '-6': 'u', '-9': 'n', '-12': 'p', '-15': 'f', '-18': 'a', '-21': 'z', '-24': 'y' };

        // dummy localization object
        that.localizationObject = {
            currencysymbol: '$',
            currencysymbolposition: 'before',
            decimalseparator: '.',
            thousandsseparator: ',',
            defaultPrecision: 2
        }
    }

    isENotation(value) {
        return new RegExp(/e/i).test(value);
    }

    /**
     * Converts a large exponential value to its decimal representation (used when "inputFormat" is 'integer').
     */
    largeExponentialToDecimal(exponential) {
        let validateExponent;

        if (exponential === undefined) {
            exponential = this.numericValue;
            validateExponent = true;
        }

        let stringExponential = exponential.toString().toLowerCase(),
            indexOfE = stringExponential.indexOf('e'),
            mantissa = new JQX.Utilities.BigNumber(stringExponential.slice(0, indexOfE)),
            sign = stringExponential.slice(indexOfE + 1, indexOfE + 2);

        if (sign !== '+' && sign !== '-') {
            stringExponential = stringExponential.slice(0, indexOfE) + 'e+' + stringExponential.slice(indexOfE + 1);
            sign = '+';
        }

        let exponent = stringExponential.slice(indexOfE + 2),
            bigTen = new JQX.Utilities.BigNumber(10),
            multyplyBy = bigTen.pow(sign + (validateExponent ? Math.min(20, exponent) : exponent)),
            result = mantissa.multiply(multyplyBy);

        return result.toString();
    }

    /**
     * Converts a BigNumber integer value to an exponential value
     */
    bigNumberToExponent(significantDigits, forceExponentialResult) {
        let value = this.numericValue;

        if (value.constructor !== JQX.Utilities.BigNumber) {
            value = new JQX.Utilities.BigNumber(value);
        }

        const numberLength = value._f;
        let numericString = value.toString();

        if (numberLength <= 10) {
            // 32-bit or lower
            if (forceExponentialResult) {
                return parseFloat(numericString).toExponential(significantDigits !== null ? significantDigits - 1 : undefined);
            }
            else {
                return new JQX.Utilities.NumberRenderer(parseFloat(numericString)).toDigits(significantDigits);
            }
        }
        else {
            // 64-bit
            if (significantDigits >= numberLength && !forceExponentialResult) {
                return numericString;
            }
            else {
                let sign;
                if (value._s === false) {
                    sign = '';
                }
                else {
                    sign = '-';
                    numericString = numericString.slice(1);
                }

                const nextDigit = parseFloat(numericString.slice(significantDigits, significantDigits + 1));

                if (nextDigit >= 5) {
                    numericString = new JQX.Utilities.BigNumber(numericString.slice(0, significantDigits)).add(1).toString();
                }

                let digitsAfterDecimalSeparator = numericString.slice(1, significantDigits);

                if (forceExponentialResult) {
                    significantDigits--;

                    if (digitsAfterDecimalSeparator.length > 0 && significantDigits > digitsAfterDecimalSeparator.length) {
                        digitsAfterDecimalSeparator = digitsAfterDecimalSeparator + ('0').repeat(significantDigits - digitsAfterDecimalSeparator.length);
                    }
                    else if (digitsAfterDecimalSeparator.length === 0) {
                        digitsAfterDecimalSeparator = ('0').repeat(significantDigits);
                    }
                }
                else {
                    while (digitsAfterDecimalSeparator.length > 0 && digitsAfterDecimalSeparator.charAt(digitsAfterDecimalSeparator.length - 1) === '0') {
                        digitsAfterDecimalSeparator = digitsAfterDecimalSeparator.slice(0, digitsAfterDecimalSeparator.length - 1);
                    }
                }

                const decimalSeparator = digitsAfterDecimalSeparator.length > 0 ? '.' : '',
                    power = numberLength - 1;

                return sign + numericString.slice(0, 1) + decimalSeparator + digitsAfterDecimalSeparator + 'E+' + power;
            }
        }
    }

    /**
     * Converts a plain number to scientific notation.
     */
    toScientific() {
        const that = this;

        let exponentialValue;

        if (that.numericValue._d) {
            exponentialValue = that.bigNumberToExponent(arguments[0] !== null ? arguments[0] : arguments[1] + 1, true).toLowerCase();
        }
        else {
            exponentialValue = Number(that.numericValue.toString()).toExponential();
        }

        const indexOfE = exponentialValue.indexOf('e'),
            power = exponentialValue.slice(indexOfE + 1);
        let coefficient = parseFloat(exponentialValue.slice(0, indexOfE));

        if (power === '-2') {
            return coefficient + 'c';
        }

        const remainderPower = parseInt(power, 10) % 3;

        if (remainderPower > 0) {
            for (let i = 0; i < remainderPower; i++) {
                coefficient = coefficient * 10;
            }
        }
        else if (remainderPower < 0) {
            const ignored = JQX.Utilities.BigNumber.ignoreBigIntNativeSupport;

            JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = true;
            coefficient = parseFloat(new JQX.Utilities.BigNumber(coefficient).multiply(Math.pow(10, remainderPower)).toString());
            JQX.Utilities.BigNumber.ignoreBigIntNativeSupport = ignored;
        }

        if (power > 0) {
            const removeSign = coefficient >= 0 ? 0 : 1,
                floatFix = exponentialValue.slice(removeSign, indexOfE).length - remainderPower - 2;
            if (floatFix >= 0) {
                coefficient = coefficient.toFixed(floatFix);
            }
        }

        const coefficientRenderer = new JQX.Utilities.NumberRenderer(coefficient);

        coefficient = coefficientRenderer.toDigits(arguments[0], arguments[1]);

        const finalPower = (parseInt(power, 10) - remainderPower),
            scientificValue = coefficient + that.powersToPrefixes[finalPower.toString()];

        return scientificValue;
    }

    /**
     * Converts a BigNumber to scientific notation.
     */
    bigNumberToScientific() {
        const that = this,
            power = that.numericValue._f - 1,
            remainderPower = parseInt(power, 10) % 3,
            finalPower = parseInt(power, 10) - remainderPower;
        let stringRepresentation = that.numericValue.toString(),
            sign, scientificValue;

        if (stringRepresentation.charAt(0) === '-') {
            sign = '-';
            stringRepresentation = stringRepresentation.slice(1);
        }
        else {
            sign = '';
        }

        if (arguments[0] !== null) {
            scientificValue = stringRepresentation.slice(0, arguments[0]);

            if (parseFloat(stringRepresentation.slice(arguments[0], arguments[0] + 1)) >= 5) {
                scientificValue = new JQX.Utilities.BigNumber(scientificValue).add(1).toString();
            }

            while (scientificValue.length > 1 + remainderPower && scientificValue.charAt(scientificValue.length - 1) === '0') {
                scientificValue = scientificValue.slice(0, scientificValue.length - 1);
            }
        }
        else if (arguments[1] !== null) {
            scientificValue = stringRepresentation.slice(0, arguments[1] + 1);

            if (parseFloat(stringRepresentation.slice(arguments[1] + 1, arguments[1] + 2)) >= 5) {
                scientificValue = new JQX.Utilities.BigNumber(scientificValue).add(1).toString();
            }

            if (arguments[1] + remainderPower > scientificValue.length - 1) {
                scientificValue = scientificValue + ('0').repeat(arguments[1] + remainderPower - scientificValue.length + 1);
            }
        }

        if (scientificValue.length > 1 + remainderPower) {
            scientificValue = scientificValue.slice(0, 1 + remainderPower) + '.' + scientificValue.slice(1 + remainderPower);
        }

        return sign + scientificValue + that.powersToPrefixes[finalPower.toString()];
    }

    /**
     * Applies the significant digits or precision digits settings to the number.
     */
    toDigits(significantDigits, precisionDigits) {
        const that = this;
        let renderedValue;

        if (significantDigits !== null) {
            renderedValue = that.applySignificantDigits(significantDigits);
        }
        else if (precisionDigits !== null) {
            renderedValue = that.applyPrecisionDigits(precisionDigits);
        }
        else {
            renderedValue = that.applySignificantDigits(8);
        }
        return renderedValue;
    }

    /**
     * Returns the number with a specified number of significant digits.
     */
    applySignificantDigits(significantDigits) {
        const that = this;

        significantDigits = Math.max(1, Math.min(significantDigits, 21));

        // removes insignificant trailing zeroes
        function removeTrailingZeroes(value) {
            while (value.charAt(value.length - 1) === '0') {
                value = value.slice(0, -1);
            }
            if (value.charAt(value.length - 1) === '.') {
                value = value.slice(0, -1);
            }
            return value;
        }

        let renderedValue = parseFloat(that.numericValue).toPrecision(significantDigits).toUpperCase();

        if (renderedValue.indexOf('.') !== -1) {
            if (that.isENotation(renderedValue)) {
                const indexOfDecimalSeparator = renderedValue.indexOf('.'),
                    indexOfE = renderedValue.indexOf('E')

                let digitsAfterDecimalSeparator = renderedValue.slice(indexOfDecimalSeparator, indexOfE);
                digitsAfterDecimalSeparator = removeTrailingZeroes(digitsAfterDecimalSeparator);
                renderedValue = renderedValue.slice(0, indexOfDecimalSeparator) + digitsAfterDecimalSeparator + renderedValue.slice(indexOfE);
            }
            else {
                renderedValue = removeTrailingZeroes(renderedValue);
            }
        }

        return renderedValue;
    }

    /**
     * Returns the number with a specified number of precision digits.
     */
    applyPrecisionDigits(precisionDigits) {
        const that = this;

        precisionDigits = Math.max(0, Math.min(precisionDigits, 20));

        let renderedValue = parseFloat(that.numericValue).toFixed(precisionDigits);

        if (that.isENotation(renderedValue)) {
            renderedValue = that.largeExponentialToDecimal(renderedValue) + '.' + '0'.repeat(precisionDigits);
        }

        return renderedValue;
    }

    /**
     * Returns the logarithm of a value (for use in logarithmic scales).
     */
    getLogarithm(base) {
        const value = this.numericValue;
        let result;

        if (base === undefined) {
            base = 10;
        }

        if (base === 10) {
            try {
                result = Math.log10(value);
            }
            catch (error) {
                result = Math.log(value) / Math.log(10);
            }
        }
        else {
            result = Math.log(value) / Math.log(base);
        }

        return result;
    }

    /**
     * Applies separators.
     */
    applySeparators(number, noThousandsSeparator) {
        const that = this;

        number = number.toString();

        const dotIndex = number.indexOf('.');

        if (dotIndex !== -1) {
            const integerPart = number.slice(0, dotIndex),
                fractionalPart = number.slice(dotIndex + 1);

            return that.applyThousandsSeparator(integerPart, noThousandsSeparator) + that.localizationObject.decimalseparator + fractionalPart;
        }
        else {
            return that.applyThousandsSeparator(number, noThousandsSeparator);
        }
    }

    /**
     * Applies thousands separator.
     */
    applyThousandsSeparator(number, noThousandsSeparator) {
        if (noThousandsSeparator) {
            return number;
        }

        let sign = '';

        number = number.toString();

        if (number.charAt(0) === '-') {
            sign = '-';
            number = number.slice(1);
        }

        let digits = number.split('').reverse();

        for (let i = 2; i < digits.length - 1; i += 3) {
            digits[i] = this.localizationObject.thousandsseparator + digits[i];
        }

        digits.reverse();
        digits = digits.join('');

        return sign + digits;
    }

    /**
     * Returns a formatted representation of a number.
     */
    formatNumber(number, formatSpecifier, wordLength) {
        const that = this;

        if (arguments[3] === undefined) {
            delete that._ignoreMinus;
        }

        delete that._wordLengthNumber;

        if (!/^([a-zA-Z]\d*)$/g.test(formatSpecifier)) {
            try {
                const result = that.applyCustomFormat(number, formatSpecifier);

                return result;
            }
            catch (error) {
                return number.toString();
            }
        }

        const format = formatSpecifier.slice(0, 1);
        let precision = formatSpecifier.slice(1);

        if (precision !== '') {
            if (isNaN(parseFloat(precision)) || parseFloat(precision) < 0 || parseFloat(precision) > 99) {
                precision = '';
            }
            else if (parseFloat(precision) % 1 !== 0) {
                precision = Math.round(precision);
            }
        }

        if (number._d) {
            that.inputFormat = 'integer';
        }
        else if (number.imaginaryPart) {
            return that.formatComplexNumber(number, formatSpecifier, format, precision);
        }
        else {
            that.inputFormat = 'floatingPoint';
        }

        let numericProcessor = new JQX.Utilities.NumericProcessor(that, 'inputFormat'),
            numericObject = numericProcessor.createDescriptor(number),
            result;

        that._wordLengthNumber = numericProcessor.getWordLength(wordLength ? wordLength : 'int32');

        if (that.inputFormat === 'integer') {
            numericObject = numericProcessor.round(numericObject);
        }

        that.numericValue = numericObject;

        switch (format) {
            case 'C':
            case 'c':
                // Currency
                if (precision === '') {
                    precision = that.localizationObject.defaultPrecision;
                }

                precision = parseFloat(precision);

                if (that.inputFormat === 'floatingPoint') {
                    result = that.applyPrecisionDigits(precision);
                }
                else {
                    result = numericObject.toString() + (precision > 0 ? '.' + ('0').repeat(precision) : '');
                }

                result = that.applySeparators(result);

                if (that.localizationObject.currencysymbolposition === 'before') {
                    if (result.charAt(0) === '-') {
                        return '-' + that.localizationObject.currencysymbol + result.slice(1);
                    }

                    return that.localizationObject.currencysymbol + result;
                }

                return result + ' ' + that.localizationObject.currencysymbol;
            case 'D':
            case 'd': {
                // Decimal; integer-only
                result = numericObject;

                if (that.inputFormat === 'floatingPoint') {
                    result = Math.round(numericObject);
                }

                result = result.toString();

                if (precision === '') {
                    return result;
                }

                let sign = '';

                if (result.charAt(0) === '-') {
                    sign = '-';
                    result = result.slice(1);
                }

                const difference = precision - result.length;

                if (difference > 0) {
                    result = ('0').repeat(difference) + result;
                }

                return sign + result;
            }
            case 'E':
            case 'e':
            case 'U':
            case 'u': {
                // Exponential (scientific)
                if (precision === '') {
                    precision = 6;
                }

                if (that.inputFormat === 'floatingPoint') {
                    result = numericObject.toExponential(precision);
                }
                else {
                    result = that.bigNumberToExponent(parseFloat(precision) + 1, true).toLowerCase();
                }

                const indexOfE = result.indexOf('e'),
                    numbersInExponent = result.slice(indexOfE + 2).length;

                if (numbersInExponent < 3) {
                    result = result.slice(0, indexOfE + 2) + ('0').repeat(3 - numbersInExponent) + result.slice(indexOfE + 2);
                }

                if (format.toLowerCase() === 'u') {
                    return that.exponentialToSuperscript(that.applySeparators(result, true));
                }

                if (format === 'E') {
                    result = result.toUpperCase();
                }

                return that.applySeparators(result, true);
            }
            case 'F':
            case 'f':
            case 'N':
            case 'n':
                // Fixed-point and Number
                if (precision === '') {
                    precision = that.localizationObject.defaultPrecision;
                }

                precision = parseFloat(precision);

                if (that.inputFormat === 'floatingPoint') {
                    result = that.applyPrecisionDigits(precision);
                }
                else {
                    result = numericObject.toString() + (precision > 0 ? '.' + ('0').repeat(precision) : '');
                }

                return that.applySeparators(result, format.toLowerCase() === 'f');
            case 'G':
            case 'g': {
                // General
                if (precision === '' || precision === '0') {
                    if (that.inputFormat === 'floatingPoint') {
                        precision = 15;
                    }
                    else {
                        switch (wordLength) {
                            case 'int8':
                            case 'uint8':
                                precision = 3;
                                break;
                            case 'int16':
                            case 'uint16':
                                precision = 5;
                                break;
                            case 'int64':
                                precision = 19;
                                break;
                            case 'uint64':
                                precision = 20;
                                break;
                            default:
                                precision = 10;
                        }
                    }
                }

                precision = parseFloat(precision);

                let scientificRepresentation = that.formatNumber(number, 'E' + precision, wordLength),
                    eIndex = scientificRepresentation.indexOf('E');
                const exponent = parseInt(scientificRepresentation.slice(eIndex + 1), 10);

                if (exponent > -5 && exponent < precision) {
                    if (that.inputFormat === 'floatingPoint') {
                        return that.applySeparators(that.applySignificantDigits(precision), true);
                    }
                    else {
                        return numericObject.toString();
                    }
                }

                // removes leading zero in exponent
                if (exponent > -100 && exponent < 100) {
                    scientificRepresentation = scientificRepresentation.slice(0, eIndex + 2) + scientificRepresentation.slice(eIndex + 3);
                }

                // removes trailing zeros
                if (scientificRepresentation.indexOf(that.localizationObject.decimalseparator) !== -1) {
                    while (scientificRepresentation.charAt(eIndex - 1) === '0') {
                        scientificRepresentation = scientificRepresentation.slice(0, eIndex - 1) + scientificRepresentation.slice(eIndex);
                        eIndex = scientificRepresentation.indexOf('E');
                    }

                    if (scientificRepresentation.charAt(eIndex - 1) === that.localizationObject.decimalseparator) {
                        scientificRepresentation = scientificRepresentation.slice(0, eIndex - 1) + scientificRepresentation.slice(eIndex);
                    }
                }

                if (format === 'g') {
                    scientificRepresentation = scientificRepresentation.toLowerCase();
                }

                return scientificRepresentation;
            }
            case 'P':
            case 'p':
                // Percent
                if (precision === '') {
                    precision = that.localizationObject.defaultPrecision;
                }

                precision = parseFloat(precision);

                if (that.inputFormat === 'floatingPoint') {
                    that.numericValue = numericObject * 100;
                    result = that.applyPrecisionDigits(precision);
                }
                else {
                    result = (numericObject.multiply(100)).toString() + (precision > 0 ? '.' + ('0').repeat(precision) : '');
                }

                return that.applySeparators(result) + ' %';
            case 'B':
            case 'b':
            case 'O':
            case 'o':
            case 'X':
            case 'x': {
                // Binary, Octal, and Hexadecimal; integer-only
                if (that.inputFormat !== 'integer') {
                    that.inputFormat = 'integer';
                    numericProcessor = new JQX.Utilities.NumericProcessor(that, 'inputFormat');
                    numericObject = numericProcessor.round(numericProcessor.createDescriptor(number));
                }

                let radix;

                switch (format) {
                    case 'B':
                    case 'b':
                        radix = 2;
                        break;
                    case 'O':
                    case 'o':
                        radix = 8;
                        break;
                    default:
                        radix = 16;
                }

                result = numericObject.toString(radix, that._wordLengthNumber);

                if (precision !== '') {
                    const leadingZeros = parseFloat(precision) - result.length;

                    if (leadingZeros > 0) {
                        result = ('0').repeat(leadingZeros) + result;
                    }
                }

                if (format === 'x') {
                    result = result.toLowerCase();
                }

                return result;
            }
            case 'S':
            case 's':
                if (precision === '') {
                    precision = that.localizationObject.defaultPrecision;
                }

                precision = parseFloat(precision);

                return that.toScientific(null, precision).replace('.', that.localizationObject.decimalseparator);
            default:
                return number.toString();
        }
    }

    /**
     * Returns a formatted representation of a complex number.
     */
    formatComplexNumber(number, formatSpecifier, format) {
        const that = this;

        switch (format) {
            case 'E':
            case 'e':
            case 'U':
            case 'u':
            case 'F':
            case 'f':
            case 'G':
            case 'g':
            case 'N':
            case 'n':
            case 'S':
            case 's':
                if (number.imaginaryPart >= 0) {
                    return that.formatNumber(number.realPart, formatSpecifier) + ' + ' + that.formatNumber(number.imaginaryPart, formatSpecifier) + 'i';
                }
                else {
                    return that.formatNumber(number.realPart, formatSpecifier) + ' - ' + that.formatNumber(Math.abs(number.imaginaryPart), formatSpecifier) + 'i';
                }
            default:
                return number.toString();
        }
    }

    /**
     * Returns a formatted representation of a number.
     */
    toString(number, formatSpecifier, wordLength) {
        if (formatSpecifier) {
            return this.formatNumber(number, formatSpecifier, wordLength);
        }
        else {
            return number.toString();
        }
    }

    /**
     * Applies a custom number format.
     */
    applyCustomFormat(number, formatSpecifier) {
        const that = this;

        //formatSpecifier = formatSpecifier.replace(/_.|\[\w*\]|.\*|\*./g, '');
        formatSpecifier = formatSpecifier.replace(/_.|\[\w*\]|\*/g, '');
        formatSpecifier = formatSpecifier.replace(/\?/g, '#');

        const sections = formatSpecifier.split(';');

        if (typeof number === 'string' && isNaN(number)) {
            return sections[sections.length - 1].replace(/"/g, '').replace(/@/g, number.toString());
        }

        if (number._d) {
            that.inputFormat = 'integer';
        }
        else if (number.imaginaryPart) {
            return number.toString();
        }
        else {
            number = parseFloat(number);
            that.inputFormat = 'floatingPoint';
        }

        let numericProcessor = new JQX.Utilities.NumericProcessor(that, 'inputFormat'),
            numericObject = numericProcessor.createDescriptor(number);

        if (that.inputFormat === 'integer') {
            numericObject = numericProcessor.round(numericObject);
        }

        that.numericProcessor = numericProcessor;

        const currentSection = that.getRelevantFormatSection(sections, numericObject);

        if (currentSection === undefined) {
            return number.toString();
        }

        if (currentSection.indexOf('@') !== -1) {
            return sections[sections.length - 1].replace(/"/g, '').replace(/@/g, number.toString());
        }

        const percentage = currentSection.replace(/".*"/g, '').indexOf('%') !== -1,
            textParts = that.getTextParts(currentSection);

        if (textParts.main.toLowerCase().indexOf('e') !== -1) {
            return that.applyCustomExponentialFormat(numericObject, textParts, numericProcessor);
        }

        if (textParts.main.indexOf('/') !== -1) {
            return that.applyCustomFractionalFormat(numericObject, textParts, numericProcessor);
        }

        if (percentage) {
            if (that.inputFormat === 'integer') {
                numericObject = numericObject.multiply(100);
            }
            else {
                numericObject = numericObject * 100;
            }
        }

        if (textParts.main === '') {
            if (!percentage) {
                return textParts.suffix;
            }

            let stringifiedNumber = numericObject.toString();

            if (that._ignoreMinus && stringifiedNumber.charAt(0) === '-') {
                stringifiedNumber = stringifiedNumber.slice(1);
            }

            return stringifiedNumber + textParts.suffix;
        }

        let numberFormat = textParts.main.replace(/[^0#,. \/]/g, ''),
            indexOfPoint = numberFormat.indexOf('.');

        if (indexOfPoint !== -1) {
            numberFormat = numberFormat.substring(0, indexOfPoint + 1) + numberFormat.substring(indexOfPoint + 1).replace(/\./g, '');

            // removes unnecessary trailing zero
            if (numberFormat.charAt(numberFormat.length - 1) === '.') {
                numberFormat = numberFormat.slice(0, numberFormat.length - 1);
            }

            if (indexOfPoint === 0) {
                numberFormat = '#' + numberFormat;
            }
        }

        // scales the number down by 1000 for every trailing comma
        while (numberFormat.charAt(numberFormat.length - 1) === ',') {
            numberFormat = numberFormat.slice(0, numberFormat.length - 1);

            if (that.inputFormat === 'floatingPoint') {
                numericObject /= 1000;
            }
            else {
                numericObject = numericObject.multiply(0.001);
            }
        }

        if (that.inputFormat === 'integer') {
            numericObject = numericProcessor.round(numericObject);
        }

        const thousandsSeparator = numberFormat.indexOf(',') !== -1;

        numberFormat = numberFormat.replace(/,/g, '');

        const numberFormatParts = numberFormat.split('.'),
            wholePartFormat = numberFormatParts[0];
        let decimalPartFormat = numberFormatParts[1],
            result = '';

        if (numberFormatParts.length === 1) {
            if (that.inputFormat === 'floatingPoint') {
                numericObject = numericProcessor.round(numericObject);
            }

            result = numericObject.toString();

            return that.setTextParts(that.formatWholeNumber(result, wholePartFormat, thousandsSeparator), textParts);
        }

        result = numericObject.toString();

        let numberParts = result.split('.'),
            formattedWholeNumber = that.formatWholeNumber(numberParts[0], wholePartFormat, thousandsSeparator),
            decimalNumber = numberParts[1] || '';

        if (decimalPartFormat.length <= decimalNumber.length) {
            result = parseFloat(numericObject.toFixed(decimalPartFormat.length)).toString();
            numberParts = result.split('.');
            formattedWholeNumber = that.formatWholeNumber(numberParts[0], wholePartFormat, thousandsSeparator);
            decimalNumber = numberParts[1] || '';

            if (decimalNumber) {
                return that.setTextParts(formattedWholeNumber + that.localizationObject.decimalseparator + decimalNumber.slice(0, decimalPartFormat.length), textParts);
            }
        }

        decimalPartFormat = decimalPartFormat.slice(decimalNumber.length - decimalPartFormat.length);

        let lastZeroIndex = decimalPartFormat.lastIndexOf('0');

        if (lastZeroIndex === -1) {
            if (decimalNumber === '') {
                return that.setTextParts(formattedWholeNumber, textParts);
            }

            return that.setTextParts(formattedWholeNumber + that.localizationObject.decimalseparator + decimalNumber, textParts);
        }
        else {
            return that.setTextParts(formattedWholeNumber + that.localizationObject.decimalseparator + decimalNumber + '0'.repeat(lastZeroIndex + 1), textParts);
        }
    }

    /**
     * Returns relevant section of custom format specifier.
     */
    getRelevantFormatSection(sections, number) {
        const that = this,
            compareResult = that.numericProcessor.compare(number, 0, true);

        if (compareResult === 1) {
            return sections[0];
        }

        let negativeNumberGroup, zeroGroup;

        if (sections.length >= 3) {
            that._ignoreMinus = true;
            negativeNumberGroup = 1;
            zeroGroup = 2;
        }
        else if (sections.length === 2) {
            that._ignoreMinus = true;
            zeroGroup = 0;
            negativeNumberGroup = 1;
        }
        else if (sections.length === 1) {
            zeroGroup = 0;
            negativeNumberGroup = 0;
        }

        if (compareResult === 0) {
            return sections[zeroGroup];
        }

        if (compareResult === -1) {
            return sections[negativeNumberGroup];
        }
    }

    /**
     * Gets text parts of custom number format.
     */
    getTextParts(currentSection) {
        const withoutQuotedText = currentSection.replace(/"[^"]*"/g, ''),
            quotedSections = currentSection.match(/"[^"]*"/g),
            firstMainIndex = withoutQuotedText.search(/0|#|\./g),
            lastMainIndex = Math.max(withoutQuotedText.lastIndexOf('0'), withoutQuotedText.lastIndexOf('#'), withoutQuotedText.lastIndexOf('.'), withoutQuotedText.lastIndexOf(',')),
            main = withoutQuotedText.slice(firstMainIndex, lastMainIndex + 1);

        if (main === '') {
            return { prefix: '', main: '', suffix: currentSection.replace(/"/g, '') };
        }

        let firstIndex = currentSection.indexOf(main),
            lastIndex = firstIndex + main.length;

        if (quotedSections) {
            for (let i = 0; i < quotedSections.length; i++) {
                const sectionIndex = currentSection.indexOf(quotedSections[i]);

                if (firstIndex >= sectionIndex && lastIndex <= sectionIndex + quotedSections[i].length) {
                    firstIndex = currentSection.indexOf(main, sectionIndex + quotedSections[i].length);
                    lastIndex = firstIndex + main.length;
                }
            }
        }

        const prefix = currentSection.slice(0, firstIndex).replace(/"/g, ''),
            suffix = currentSection.slice(lastIndex).replace(/"/g, '');

        return { prefix: prefix, main: main, suffix: suffix };
    }

    /**
     * Applies custom exponential format.
     */
    applyCustomExponentialFormat(number, textParts, numericProcessor) {
        const that = this;
        let format = textParts.main,
            result;
        const thousandsSeparator = format.indexOf(',') !== -1;

        // format validation - start
        format = format.replace(/[^0#.eE+-]/g, '');

        const indexOfE = format.toLowerCase().indexOf('e');

        format = format.substring(0, indexOfE + 1) + format.substring(indexOfE + 1).replace(/[eE\.]/g, '');

        const eLetter = format.charAt(indexOfE),
            indexOfPoint = format.indexOf('.');

        if (indexOfPoint !== -1) {
            format = format.substring(0, indexOfPoint + 1) + format.substring(indexOfPoint + 1).replace(/\./g, '');
        }

        if (format.charAt(format.length - 1) === '.') {
            format = format.slice(0, format.length - 1);
        }
        // format validation - end

        const parts = format.split(eLetter);
        let firstPart = parts[0];
        const significantParts = firstPart.split('.'),
            significantPart1 = significantParts[0],
            significantPart2 = significantParts[1],
            secondPart = parts[1];
        let numberWholePart = number.toString().split('.')[0].replace(/-/, ''),
            exponentModifier = 0;

        if (numberWholePart === '0' && numericProcessor.compare(number, 0)) {
            let difference = significantPart1.length - 1;

            while (parseInt(number) === 0) {
                exponentModifier++;
                number *= 10;
            }

            numberWholePart = number.toString().split('.')[0].replace(/-/, '');
            exponentModifier += difference;
            number *= Math.pow(10, difference);
        }

        if (thousandsSeparator) {
            firstPart = firstPart.slice(0, 1) + ',' + firstPart.slice(1);
        }

        if (numberWholePart.length <= significantPart1.length) {
            result = that.formatNumber(number, firstPart, undefined, true) + eLetter + that.formatExponent(0 - exponentModifier, secondPart);
        }
        else {
            const exponent = numberWholePart.length - significantPart1.length;
            let visibleNumber = that.inputFormat === 'floatingPoint' ? number / (Math.pow(10, exponent)) : number.divide(Math.pow(10, exponent));

            if (!significantPart2) {
                let roundedVisibleNumber = that.applyThousandsSeparator(numericProcessor.round(visibleNumber).toString(), !thousandsSeparator);

                result = roundedVisibleNumber + eLetter + that.formatExponent(exponent - exponentModifier, secondPart);
            }

            let decimalPartofVisibleNumber = visibleNumber.toString().split('.')[1] || '';

            if (decimalPartofVisibleNumber.length === significantPart2.length) {
                result = that.applySeparators(visibleNumber, !thousandsSeparator) + eLetter + that.formatExponent(exponent - exponentModifier, secondPart);
            }
            else if (decimalPartofVisibleNumber.length < significantPart2.length) {
                result = that.formatNumber(visibleNumber, firstPart, undefined, true) + eLetter + that.formatExponent(exponent - exponentModifier, secondPart);
            }
            else {
                visibleNumber = that.inputFormat === 'floatingPoint' ? visibleNumber.toFixed(significantPart2.length) :
                    visibleNumber = numericProcessor.round(number.divide(Math.pow(10, exponent - significantPart2.length))).divide(Math.pow(10, significantPart2.length));
                result = that.formatNumber(parseFloat(visibleNumber), firstPart, undefined, true) + eLetter + that.formatExponent(exponent - exponentModifier, secondPart);
            }
        }

        return that.setTextParts(result, textParts);
    }

    /**
     * Formats exponent.
     */
    formatExponent(exponent, format) {
        let sign;

        if (['+', '-'].indexOf(format.charAt(0)) !== -1) {
            sign = format.charAt(0);

            if (exponent > 0 && sign === '-' ||
                exponent < 0 && sign === '+') {
                sign = undefined;
            }
        }

        if (exponent < 0) {
            exponent = Math.abs(exponent);
            sign = '-';
        }

        format = format.replace(/[+-]/g, '');
        exponent = this.formatNumber(exponent, format, undefined, true);
        return (sign ? sign : '') + exponent;
    }

    /**
     * Formats a whole number.
     */
    formatWholeNumber(wholeNumber, format, thousandsSeparator) {
        const that = this;
        let sign = '';

        if (wholeNumber.charAt(0) === '-') {
            if (!that._ignoreMinus) {
                sign = '-';
            }

            wholeNumber = wholeNumber.slice(1);
        }

        if (wholeNumber === '0') {
            if (format === '#'.repeat(format.length)) {
                return sign;
            }

            wholeNumber = '';
        }

        if (format.length <= wholeNumber.length) {
            return sign + that.applyThousandsSeparator(wholeNumber, !thousandsSeparator);
        }

        format = format.slice(0, format.length - wholeNumber.length);

        for (let i = format.length - 1; i >= 0; i--) {
            if (format.charAt(i) === '0') {
                wholeNumber = '0' + '' + wholeNumber;
            }
        }

        return sign + that.applyThousandsSeparator(wholeNumber, !thousandsSeparator);
    }

    /**
     * Sets prefix and suffix around formatted number.
     */
    setTextParts(result, textParts) {
        return textParts.prefix + result + textParts.suffix;
    }

    /**
     * Applies custom format with fraction.
     */
    applyCustomFractionalFormat(numericObject, textParts, numericProcessor) {
        const that = this,
            regex = /^([0#,]+[ ]+)?([0#,]+\/[0#,]+)$/;
        let format = textParts.main.trim(),
            result;

        if (!regex.test(format)) {
            return numericObject.toString();
        }

        const formatParts = regex.exec(format);

        formatParts[2] = formatParts[2].replace(/,/g, '');

        if (that.inputFormat === 'integer') {
            const fractionFormatParts = formatParts[2].split('/');

            if (formatParts[1] === undefined) {
                result = that.formatNumber(numericObject, fractionFormatParts[0], undefined, true) + '/' + that.formatNumber(1, fractionFormatParts[1], undefined, true);
            }
            else {
                result = that.formatNumber(numericObject, formatParts[1].trim(), undefined, true);

                if (formatParts[2].indexOf('0') !== -1) {
                    result += ' ' + that.formatNumber(0, fractionFormatParts[0], undefined, true) + '/' + that.formatNumber(1, fractionFormatParts[1], undefined, true);
                }
            }

            return that.setTextParts(result, textParts);
        }

        if (formatParts[1] === undefined) {
            result = (numericObject < 0 ? '-' : '') + that.formatAsFraction(Math.abs(numericObject), formatParts[2]);
        }
        else {
            const wholePartFormat = formatParts[1].trim(),
                decimalPartFormat = formatParts[2];

            result = that.formatNumber(parseInt(numericObject, 10), wholePartFormat, undefined, true) + ' ' +
                that.formatAsFraction(numericProcessor.getPreciseModulo(Math.abs(numericObject), 1), decimalPartFormat);
        }

        return that.setTextParts(result.trim(), textParts);
    }

    /**
     * Formats a decimal number as a fraction.
     */
    formatAsFraction(number, format) {
        const that = this,
            formatParts = format.split('/');

        if (number === 0) {
            if (format.indexOf('0') === -1) {
                return '';
            }

            return that.formatNumber(0, formatParts[0], undefined, true) + '/' + that.formatNumber(1, formatParts[1], undefined, true);
        }

        if (number % 1 === 0) {
            return that.formatNumber(number, formatParts[0], undefined, true) + '/' + that.formatNumber(1, formatParts[1], undefined, true);
        }

        const approximations = [];

        that.approximateFractions(number, approximations);

        const length = formatParts[1].length >= 2 ? 2 : 1;
        let bestApproximationDifference = [], bestApproximationIndex = [];

        approximations.forEach(function (approximation, index) {
            const length = approximation.denominator.toString().length,
                currentDifference = Math.abs(number - approximation.numerator / approximation.denominator);

            if (bestApproximationDifference[length] === undefined) {
                bestApproximationIndex[length] = index;
                bestApproximationDifference[length] = currentDifference;
                return;
            }

            if (currentDifference < bestApproximationDifference[length]) {
                bestApproximationIndex[length] = index;
                bestApproximationDifference[length] = currentDifference;
            }
        });

        let bestApproximation = bestApproximationIndex[length] ? approximations[bestApproximationIndex[length]] : approximations[bestApproximationIndex[1]];

        return that.formatNumber(bestApproximation.numerator, formatParts[0], undefined, true) + '/' + that.formatNumber(bestApproximation.denominator, formatParts[1], undefined, true);
    }

    /**
     * Approximates fractions.
     */
    approximateFractions(d, approximations) {
        const numerators = [0, 1];
        const denominators = [1, 0];

        const maxNumerator = this.getMaxNumerator(d);
        let d2 = d;
        let calcD, prevCalcD = NaN;
        for (let i = 2; i < 1000; i++) {
            const L2 = Math.floor(d2);
            numerators[i] = L2 * numerators[i - 1] + numerators[i - 2];
            if (Math.abs(numerators[i]) > maxNumerator) return;

            denominators[i] = L2 * denominators[i - 1] + denominators[i - 2];

            calcD = numerators[i] / denominators[i];
            if (calcD === prevCalcD) return;

            approximations.push({ numerator: numerators[i], denominator: denominators[i] });

            if (calcD === d) return;

            prevCalcD = calcD;

            d2 = 1 / (d2 - L2);
        }
    }

    /**
     * Gets maximal numerator.
     */
    getMaxNumerator(f) {
        let f2 = null;
        let ixe = f.toString().indexOf('E');
        if (ixe === -1) ixe = f.toString().indexOf('e');
        if (ixe === -1) f2 = f.toString();
        else f2 = f.toString().substring(0, ixe);

        let digits = null;
        const ix = f2.toString().indexOf('.');
        if (ix === -1) digits = f2;
        else if (ix === 0) digits = f2.substring(1, f2.length);
        else if (ix < f2.length) digits = f2.substring(0, ix) + f2.substring(ix + 1, f2.length);

        let L = digits;

        const numDigits = L.toString().length;
        const L2 = f;
        let numIntDigits = L2.toString().length;
        if (L2 === 0) numIntDigits = 0;
        const numDigitsPastDecimal = numDigits - numIntDigits;

        for (let i = numDigitsPastDecimal; i > 0 && L % 2 === 0; i--) L /= 2;
        for (let i = numDigitsPastDecimal; i > 0 && L % 5 === 0; i--) L /= 5;

        return L;
    }

    /**
     * Represents an exponential value with superscripts.
     */
    exponentialToSuperscript(exponentialValue) {
        const indexOfE = exponentialValue.indexOf('e'),
            power = exponentialValue.slice(indexOfE + 1).replace(/0{1,2}/, '');
        let scientificValue = exponentialValue.slice(0, indexOfE + 1);

        scientificValue = scientificValue.replace('e', '10');
        scientificValue += this.toSuperscript(power);
        scientificValue = scientificValue.replace('+', '');

        return scientificValue;
    }

    /**
     * Converts a number to superscript.
     */
    toSuperscript(value, supToNormal) {
        const chars = '-0123456789',
            sup = '';
        let result = '';

        for (let i = 0; i < value.length; i++) {
            if (supToNormal === true) {
                const m = sup.indexOf(value.charAt(i));

                result += (m !== -1 ? chars[m] : value[i]);
            }
            else {
                const n = chars.indexOf(value.charAt(i));

                result += (n !== -1 ? sup[n] : value[i]);
            }
        }

        return result;
    }
});

JQX.Utilities.Assign('TickIntervalHandler', class TickIntervalHandler {
    constructor(context, minLabel, maxLabel, labelClass, dimension, integer, logarithmic) {
        const that = this;

        that.context = context;
        that.minLabel = minLabel;
        that.maxLabel = maxLabel;
        that.labelClass = labelClass;
        that.dimension = dimension;
        that.logarithmic = logarithmic;

        if (!context.customInterval) {
            that.labelsSize = that.getMinAndMaxLabelSize();
        }
        else if (context.customTicks.length > 0) {
            that.labelsSize = that.getCustomTicksLabelSize();
        }
        else {
            that.labelsSize = { minLabelSize: 0, minLabelOtherSize: 0, maxLabelSize: 0, maxLabelOtherSize: 0 };
        }

        if (!integer) {
            that.getNiceInterval = that.getNiceIntervalFloatingPoint;
            that.getPossibleBiggerLabel = that.getPossibleBiggerLabelFloatingPoint;
        }
        else {
            that.getNiceInterval = that.getNiceIntervalInteger;
            that.getPossibleBiggerLabel = that.getPossibleBiggerLabelInteger;
        }
    }

    getInterval(type, min, max, track) {
        function getSectorArcLength() {
            let arcLength = 2 * Math.PI * radius * (Math.abs(context.startAngle - context.endAngle) / 360); // for angles in degrees
            //let arcLength = Math.abs(context.startAngle - context.endAngle) * radius; // for angles in radians
            return Math.round(arcLength);
        }

        const context = this.context,
            radius = context._measurements.innerRadius;
        let largestLabelSize, multiplier = 1;

        if (type === 'radial') {
            largestLabelSize = Math.max(this.labelsSize.minLabelSize, this.labelsSize.minLabelOtherSize, this.labelsSize.maxLabelSize, this.labelsSize.maxLabelOtherSize);
            multiplier = 1.35;
            //multiplier = 5.25 / Math.max(1, Math.log10(radius * 2)); // original formula: 5.25 / Math.Max(1.0, Math.Log10(panelLogicalSize.Height))
        }
        else {
            largestLabelSize = Math.max(this.labelsSize.minLabelSize, this.labelsSize.maxLabelSize);
            multiplier = 1.45;
        }

        largestLabelSize *= multiplier;
        let trackDimension;
        if (type === 'radial') {
            trackDimension = getSectorArcLength();
        }
        else {
            trackDimension = context[this.dimension] - this.labelsSize.minLabelSize / 2 - this.labelsSize.maxLabelSize / 2; // track[this.dimension];
        }

        trackDimension = Math.max(10, trackDimension);

        const divisionCountEstimate = Math.ceil(trackDimension / largestLabelSize),
            minorDivisionCountEstimate = type === 'radial' ? divisionCountEstimate * 4 : divisionCountEstimate * 3;
        let majorInterval = this.getNiceInterval(min, max, divisionCountEstimate, true),
            minorInterval = this.getNiceInterval(min, max, minorDivisionCountEstimate);

        context._cachedLabelsSize = this.labelsSize;

        if (divisionCountEstimate > 2 && !context.customInterval) {
            const possibleSecondLabel = this.getPossibleBiggerLabel(divisionCountEstimate, majorInterval);

            if (possibleSecondLabel.length > Math.max(this.minLabel.length, this.maxLabel.length)) {
                const oldMinLabel = this.minLabel;
                this.minLabel = possibleSecondLabel;
                this.labelsSize = this.getMinAndMaxLabelSize();
                context._cachedLabelsSize = this.labelsSize;
                const adjustedResult = this.getInterval(type, min, max, track);
                this.minLabel = oldMinLabel;
                this.labelsSize = this.getMinAndMaxLabelSize();
                return adjustedResult;
            }
        }

        return { major: majorInterval, minor: minorInterval };
    }

    getNiceIntervalFloatingPoint(min, max, divisionCountEstimate, majorInterval) {
        const rangeDelta = max - min,
            exponent = Math.floor(Math.log10(rangeDelta) - Math.log10(divisionCountEstimate));
        let nearestPowerOfTen = Math.pow(10, exponent),
               factor = divisionCountEstimate * nearestPowerOfTen;
        let niceFactor;
        if (rangeDelta < 2 * factor) {
            niceFactor = 1;
        }
        else if (rangeDelta < 3 * factor) {
            niceFactor = 2;
        }
        else if (rangeDelta < 7 * factor) {
            niceFactor = 5;
        }
        else {
            niceFactor = 10;
        }
        let niceInterval = niceFactor * nearestPowerOfTen;

        if (majorInterval && this.context._range / niceInterval > divisionCountEstimate) {
            switch (niceFactor) {
                case 5:
                    niceFactor = 10;
                    break;
                case 2:
                    niceFactor = 5;
                    break;
                case 1:
                    niceFactor = 2;
                    break;
            }
            niceInterval = niceFactor * nearestPowerOfTen;
        }
        this.nearestPowerOfTen = nearestPowerOfTen;

        if (this.logarithmic && majorInterval) {
            return Math.max(1, niceInterval);
        }
        return niceInterval;
    }

    getPossibleBiggerLabelFloatingPoint(divisionCountEstimate, majorInterval) {
        const context = this.context;
        let secondValue = parseFloat(context.min - context._numericProcessor.getPreciseModulo(parseFloat(context.min), majorInterval) + parseFloat(majorInterval)),
            currentDrawValue = secondValue,
            largestLabel, currentLabel;

        if (this.logarithmic) {
            secondValue = Math.pow(10, secondValue);
        }
        largestLabel = context._formatLabel(secondValue);

        for (let i = 1; i < divisionCountEstimate; i++) {
            currentDrawValue = currentDrawValue + majorInterval;

            if (currentDrawValue >= context._drawMax) {
                break;
            }

            if (!this.logarithmic) {
                currentLabel = currentDrawValue;
            }
            else {
                currentLabel = Math.pow(10, currentDrawValue);
            }
            currentLabel = context._formatLabel(currentLabel);
            if (currentLabel.length > largestLabel.length) {
                largestLabel = currentLabel;
            }
        }

        return largestLabel;
    }

    getNiceIntervalInteger(min, max, divisionCountEstimate, majorInterval) {
        const rangeDelta = new JQX.Utilities.BigNumber(max).subtract(new JQX.Utilities.BigNumber(min)),
            exponent = Math.floor(Math.log10(rangeDelta.toString()) - Math.log10(divisionCountEstimate)),
            nearestPowerOfTen = new JQX.Utilities.BigNumber(10).pow(new JQX.Utilities.BigNumber(exponent)),
            factor = new JQX.Utilities.BigNumber(divisionCountEstimate).multiply(nearestPowerOfTen);
        let niceFactor;
        if (rangeDelta.compare(new JQX.Utilities.BigNumber(2 * factor)) === -1) {
            niceFactor = 1;
        }
        else if (rangeDelta.compare(new JQX.Utilities.BigNumber(3 * factor)) === -1) {
            niceFactor = 2;
        }
        else if (rangeDelta.compare(new JQX.Utilities.BigNumber(7 * factor)) === -1) {
            niceFactor = 5;
        }
        else {
            niceFactor = 10;
        }
        let niceInterval = new JQX.Utilities.BigNumber(niceFactor).multiply(nearestPowerOfTen);

        if (majorInterval && new JQX.Utilities.BigNumber(this.context._range).divide(niceInterval).compare(divisionCountEstimate) === 1) {
            switch (niceFactor) {
                case 5:
                    niceFactor = 10;
                    break;
                case 2:
                    niceFactor = 5;
                    break;
                case 1:
                    niceFactor = 2;
                    break;
            }
            niceInterval = new JQX.Utilities.BigNumber(niceFactor).multiply(nearestPowerOfTen);
        }

        if (niceInterval.compare(1) === -1) {
            niceInterval = new JQX.Utilities.BigNumber(1);
        }

        this.nearestPowerOfTen = nearestPowerOfTen;

        return niceInterval;
    }

    getPossibleBiggerLabelInteger(divisionCountEstimate, majorInterval) {
        const context = this.context,
            bigTen = new JQX.Utilities.BigNumber(10);
        let secondValue = new JQX.Utilities.BigNumber(context.min).subtract(new JQX.Utilities.BigNumber(context.min).mod(majorInterval)).add(majorInterval),
            currentDrawValue = secondValue,
            largestLabel, currentLabel;

        if (this.logarithmic) {
            secondValue = bigTen.pow(secondValue);
        }
        largestLabel = context._formatLabel(secondValue);

        for (let i = 1; i < divisionCountEstimate; i++) {
            currentDrawValue = currentDrawValue.add(majorInterval);

            if (currentDrawValue.compare(context._drawMax) !== -1) {
                break;
            }

            if (!this.logarithmic) {
                currentLabel = currentDrawValue;
            }
            else {
                currentLabel = bigTen.pow(currentDrawValue);
            }
            currentLabel = context._formatLabel(currentLabel);
            if (currentLabel.length > largestLabel.length) {
                largestLabel = currentLabel;
            }
        }

        return largestLabel;
    }

    getMinAndMaxLabelSize() {
        const that = this,
            context = that.context,
            container = context.$.container,
            measureLabel = document.createElement('span');

        measureLabel.className = that.labelClass;
        measureLabel.style.position = 'absolute';
        measureLabel.style.visibility = 'hidden';

        container.appendChild(measureLabel);

        measureLabel.innerHTML = that.minLabel;
        const minLabelSize = measureLabel[that.dimension],
            minLabelOtherSize = measureLabel[context._settings.otherSize];

        measureLabel.innerHTML = that.maxLabel;
        const maxLabelSize = measureLabel[that.dimension],
            maxLabelOtherSize = measureLabel[context._settings.otherSize];

        container.removeChild(measureLabel);

        return { minLabelSize: minLabelSize, minLabelOtherSize: minLabelOtherSize, maxLabelSize: maxLabelSize, maxLabelOtherSize: maxLabelOtherSize };
    }

    getCustomTicksLabelSize() {
        const that = this,
            context = that.context,
            container = context.$.container,
            measureLabel = document.createElement('span'),
            customTicks = context.customTicks;

        measureLabel.className = that.labelClass;
        measureLabel.style.position = 'absolute';
        measureLabel.style.visibility = 'hidden';

        container.appendChild(measureLabel);

        measureLabel.innerHTML = context._formatLabel(customTicks[0]);

        let labelSize = measureLabel[that.dimension],
            labelOtherSize = measureLabel[context._settings.otherSize];

        for (let i = 1; i < context.customTicks.length; i++) {
            measureLabel.innerHTML = context._formatLabel(context.customTicks[i]);

            const currentSize = measureLabel[that.dimension],
                currentOtherSize = measureLabel[context._settings.otherSize];

            if (currentSize > labelSize) {
                labelSize = currentSize;
            }

            if (currentOtherSize > labelOtherSize) {
                labelOtherSize = currentOtherSize;
            }
        }

        container.removeChild(measureLabel);

        return { minLabelSize: labelSize, minLabelOtherSize: labelOtherSize, maxLabelSize: labelSize, maxLabelOtherSize: labelOtherSize };
    }
});
/**
* Button custom element.
*/
JQX('jqx-button', class Button extends JQX.ContentElement {
    // Button's properties.
    static get properties() {
        return {
            'value': {
                type: 'string'
            },
            'name': {
                type: 'string'
            },
            'type': {
                value: 'button',
                type: 'string'
            },
            'clickMode': {
                allowedValues: ['hover', 'press', 'release', 'pressAndRelease'],
                type: 'string',
                value: 'release'
            }
        };
    }


    /**
    * CSS files needed for the element (ShadowDOM)
    */
    static get styleUrls() {
        return [
            'jqx.button.css'
        ]
    }

    /** Button's template. */
    template() {
        return '<button class=\'jqx-button\' inner-h-t-m-l=\'[[innerHTML]]\' id=\'button\' type=\'[[type]]\' name=\'[[name]]\' value=\'[[value]]\' disabled=\'[[disabled]]\' role=\'button\'></button>';
    }

    static get listeners() {
        return {
            'button.down': '_downHandler',
            'button.mouseenter': '_mouseEnterHandler',
            'button.mouseleave': '_mouseLeaveHandler',
            'button.touchend': '_touchEndHandler',
            'button.click': '_clickHandler',
            'button.up': '_upHandler',
            'up': '_upHandler',
            'button.focus': '_focusHandler',
            'button.blur': '_blurHandler'
        };
    }

    focus() {
        const that = this;

        if (!that.$.button) {
            HTMLElement.prototype.focus.call(that);
            return;
        }

        that.$.button.focus();
    }

    blur() {
        const that = this;

        if (!that.$.button) {
            HTMLElement.prototype.blur.call(that);
            return;
        }

        that.$.button.blur();
    }

    _upHandler(event) {
        const that = this;

        event.stopPropagation();
        that.$.setAttributeValue('active', false);
    }

    _focusHandler() {
        const that = this;

        that.$.setAttributeValue('focus', true);
    }

    _blurHandler() {
        const that = this;

        that.$.setAttributeValue('focus', false);
    }

    _clickHandler(event) {
        const that = this;

        if ((that.clickMode !== 'release' && that.clickMode !== 'pressAndRelease') || that.readonly) {
            event.preventDefault();
            event.stopPropagation();
        }
    }

    _downHandler(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        //if (!that.enableShadowDOM) {
        //    event.originalEvent.stopPropagation();
        //}

        if (that.hasRippleAnimation) {
            JQX.Utilities.Animation.Ripple.animate(that, event.pageX, event.pageY);
        }

        that.$.setAttributeValue('active', true);

        if ((that.clickMode === 'press' || that.clickMode === 'pressAndRelease') && !that.readonly) {
            const buttons = ('buttons' in event) ? event.buttons : event.which;

            that.$.fireEvent('click', { buttons: buttons, clientX: event.clientX, clientY: event.clientY, pageX: event.pageX, pageY: event.pageY, screenX: event.screenX, screenY: event.screenY });
        }
    }

    _mouseEnterHandler(event) {
        const that = this;

        if (that.readonly) {
            return;
        }

        that.$button.setAttributeValue('hover', true);
        that.$.setAttributeValue('hover', true);

        if (that.clickMode === 'hover') {
            const buttons = ('buttons' in event) ? event.buttons : event.which;

            that.$.fireEvent('click', { buttons: buttons, clientX: event.clientX, clientY: event.clientY, pageX: event.pageX, pageY: event.pageY, screenX: event.screenX, screenY: event.screenY });
        }
    }

    _touchEndHandler() {
        const that = this;

        setTimeout(function () {
            that.$button.setAttributeValue('hover', false);
            that.$.setAttributeValue('hover', false);
        }, 300);
    }

    _mouseLeaveHandler() {
        const that = this;

        that.$button.setAttributeValue('hover', false);
        that.$.setAttributeValue('hover', false);
    }

    /**
* Called when a property is changed.
*/
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this;

        if (propertyName === 'disabled') {
            that._setFocusable();

            if (that.$button) {
                that.$button.setAttributeValue('hover', false);
            }

            that.$.setAttributeValue('hover', false);

            if (that instanceof JQX.RepeatButton) {
                that._stopRepeat();
            }
        }
        else if (propertyName === 'unfocusable') {
            that._setFocusable();
        }
    }

    /**
     * Sets tab index 
     */
    _setFocusable() {
        const that = this;

        const target = that.$.button ? that.$.button : that;

        if (that.disabled || that.unfocusable) {
            target.removeAttribute('tabindex');
            target.tabIndex = -1;
            return;
        }

        target.tabIndex = that.tabIndex > 0 ? that.tabIndex : 0;
    }

    ready() {
        const that = this;

        super.ready();

        that._setFocusable();
    }
});

/**
* Repeat Button.
*/
JQX('jqx-repeat-button', class RepeatButton extends JQX.Button {
    // button's properties.
    static get properties() {
        return {
            'delay': {
                value: 50,
                type: 'number'
            },
            'initialDelay': {
                value: 150,
                type: 'number'
            }
        };
    }

    static get listeners() {
        return {
            'button.mousedown': '_startRepeat',
            'button.mouseenter': '_updateInBoundsFlag',
            'button.mouseleave': '_updateInBoundsFlag',
            'document.mouseup': '_stopRepeat'
        };
    }

    _clickHandler(event) {
        const that = this;

        if (that.clickMode !== 'release' || that.preventDefaultClick || that.readonly || that.disabled) {
            event.preventDefault();
            event.stopPropagation();
            that.preventDefaultClick = false;
        }
    }

    _updateInBoundsFlag(event) {
        const that = this;

        that._isPointerInBounds = true;

        if (event.type === 'mouseleave') {
            that._isPointerInBounds = false;

            that.$button.setAttributeValue('hover', false);
            that.$.setAttributeValue('hover', false);
        }
        else {
            that.$button.setAttributeValue('hover', true);
            that.$.setAttributeValue('hover', true);
        }

        const buttons = ('buttons' in event) ? event.buttons : event.which;
        if (buttons !== 1) {
            that._stopRepeat(event);
        }
    }

    _startRepeat(event) {
        const that = this;
        if (!that._initialTimer && !that.readonly) {
            that._initialTimer = setTimeout(function () {
                that._repeatTimer = setInterval(() => {
                    if (that._isPointerInBounds) {
                        const buttons = ('buttons' in event) ? event.buttons : event.which;

                        that.$.fireEvent('click', { buttons: buttons, clientX: event.clientX, clientY: event.clientY, pageX: event.pageX, pageY: event.pageY, screenX: event.screenX, screenY: event.screenY });
                        that.preventDefaultClick = true;
                    }
                }, that.delay);
            }, that.initialDelay);
        }
    }

    _stopRepeat() {
        const that = this;

        if (that.readonly) {
            return;
        }

        that.$.setAttributeValue('active', false);

        if (that._repeatTimer) {
            clearInterval(that._repeatTimer);
            that._repeatTimer = null;
        }

        if (that._initialTimer) {
            clearTimeout(that._initialTimer);
            that._initialTimer = null;
        }
    }
});

/**
* Toggle Button.
*/
JQX('jqx-toggle-button', class ToggleButton extends JQX.Button {
    // Toggle Button's properties.
    static get properties() {
        return {
            'checked': {
                value: false,
                type: 'boolean?'
            },
            'falseContent': {
                value: '',
                reflectToAttribute: false,
                type: 'string'
            },
            'indeterminateContent': {
                value: '',
                reflectToAttribute: false,
                type: 'string'
            },
            'indeterminate': {
                value: false,
                type: 'boolean'
            },
            'trueContent': {
                value: '',
                reflectToAttribute: false,
                type: 'string'
            },
            'indeterminateTemplate': {
                value: null,
                type: 'any'
            },
            'trueTemplate': {
                value: null,
                type: 'any'
            },
            'falseTemplate': {
                value: null,
                type: 'any'
            },
            'type': {
                value: 'toggle',
                type: 'string',
                defaultReflectToAttribute: true,
                readonly: true
            }
        };
    }

    /**
    * Toggle Button's event listeners.
    */
    static get listeners() {
        return {
            'keydown': '_keyHandler',
            'keyup': '_keyHandler',
            'dragstart': '_dragStartHandler',
            'button.click': '_buttonClickHandler',
            'button.mouseenter': '_buttonMouseEnterHandler',
            'button.mouseleave': '_buttonMouseLeaveHandler',
            'document.up': '_documentUpHandler'
        };
    }

    /** Called when the element is ready. Used for one-time configuration of the ToggleButton. */
    ready() {
        super.ready();
    }

    /**
     * Overrides the inherited "click" handler of the inner button element.
     */
    _buttonClickHandler() { }

    _buttonMouseLeaveHandler() {
        const that = this;

        that.removeAttribute('hover');
    }

    /**
     * Changes the check state on hover.
     */
    _buttonMouseEnterHandler() {
        const that = this;

        that.setAttribute('hover', '');

        if ((that.disabled) || (that.readonly) || (that.clickMode !== 'hover')) {
            return;
        }

        that._changeCheckState('pointer');
        that.focus();
        that._updateHidenInputNameAndValue();
    }

    /** Changes the check state wneh widget container is clicked. */
    _documentUpHandler() {
        const that = this;

        if (!that._pressed) {
            return;
        }

        that._pressed = false;

        if ((that.disabled) || (that.readonly) || (that.clickMode === 'press')) {
            return;
        }

        that._changeCheckState('pointer');
        that.focus();
        that._updateHidenInputNameAndValue();
    }

    _downHandler(event) {
        const that = this;

        if (that.disabled || that.readonly) {
            return;
        }

        if (that.hasRippleAnimation) {
            JQX.Utilities.Animation.Ripple.animate(that, event.pageX, event.pageY);
        }

        that._pressed = true;

        if (that.clickMode === 'press' || that.clickMode === 'pressAndRelease') {
            that._changeCheckState('pointer');
            that.$.fireEvent('click');
            that._updateHidenInputNameAndValue();
        }

        if (that.clickMode === 'press') {
            event.preventDefault();
            event.stopPropagation();
        }
    }

    _dragStartHandler(event) {
        event.preventDefault();
    }

    /** Changes the check state when spacebar is pressed. */
    _keyHandler(event) {
        const that = this;

        if ((that.disabled !== true) && !that.readonly && (event.keyCode === 32)) {
            if (event.type === 'keydown') {
                event.preventDefault();
                return;
            }

            if (that.switchMode === 'none') {
                return;
            }

            that._changeCheckState('keyboard');
            that._updateHidenInputNameAndValue();
        }
    }

    /** Changes the check state. */
    _changeCheckState(changeType) {
        const that = this;

        let oldValue = null;

        if (that.checked === null) {
            that.checked = true;
        }
        else {
            oldValue = that.checked;
            that.checked = !that.checked;
        }

        that._handleTextSelection();

        that.$.fireEvent('change', { 'value': that.checked, 'oldValue': oldValue, changeType: changeType });
    }

    _handleTextSelection() {
        const that = this;

        that.$.addClass('jqx-unselectable');

        if (that.timer) {
            clearTimeout(that.timer);
        }

        that.timer = setTimeout(() => that.$.removeClass('jqx-unselectable'), 500);
    }

    /**
    * Called when a property is changed.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);
        const that = this;

        if (propertyName === 'checked') {
            that.$.fireEvent('change', { 'value': newValue, 'oldValue': oldValue, changeType: 'api' });
        }

        switch (propertyName) {
            case 'trueTemplate':
                that._handleTemplate(true);
                break;
            case 'falseTemplate':
                that._handleTemplate(false);
                break;
            case 'indeterminateTemplate':
                that._handleTemplate();
                break;
        }
    }

    _htmlBindOnInitialization() {
        const that = this;

        that._bindContentProperty('trueContent', 'jqx-true-content');
        that._bindContentProperty('falseContent', 'jqx-false-content');
        that._bindContentProperty('indeterminateContent', 'jqx-indeterminate-content');
    }

    _bindContentProperty(propertyName, className) {
        const that = this;

        if (!that.$[propertyName + 'Container']) {
            return;
        }

        let testElement = document.createElement('div');

        testElement.innerHTML = that.innerHTML;

        let elements = testElement.getElementsByClassName(className),
            element;

        if (elements.length > 0) {
            for (let i = 0; i < elements.length; i++) {
                element = elements[i];
            }
        }

        if (that[propertyName] === '') {
            that[propertyName] = element === undefined ? '' : element.outerHTML;
        }

        that.$[propertyName + 'Container'].innerHTML = that[propertyName];
    }

    _updateContentProperties() {
        const that = this;

        update('trueContent');
        update('falseContent');
        update('indeterminateContent');

        function update(property) {
            if (that.$[property + 'Container']) {
                that[property] = that.$[property + 'Container'].innerHTML;
            }
        }
    }

    _updateHidenInputValue() {
        const that = this;

        if (!that.$.hiddenInput) {
            return;
        }

        let inputValue;

        if (that.checked === null) {
            inputValue = 'null';
        }
        else if (that.checked === false) {
            inputValue = 'off';
        }
        else {
            inputValue = that.value || 'on';
        }

        that.$.hiddenInput.setAttribute('value', inputValue);
    }

    _updateHidenInputName() {
        const that = this;

        if (!that.$.hiddenInput) {
            return;
        }

        let inputName = that.checked === false ? '' : that.name || '';

        that.$.hiddenInput.setAttribute('name', inputName);
    }

    _updateHidenInputNameAndValue() {
        const that = this;

        that._updateHidenInputName();
        that._updateHidenInputValue();
    }

    /**
     * Apply a template to true/false/indeterminate states of the elements.
     */
    _handleTemplate(state, oldValue) {
        const that = this;
        let template, templateTarget, value;


        if (state === true) {
            template = that.trueTemplate;
            templateTarget = that.$.trueContentContainer;
            value = that.trueContent;
        }
        else if (state === false) {
            template = that.falseTemplate;
            templateTarget = that.$.falseContentContainer;
            value = that.falseContent;
        }
        else {
            template = that.indeterminateTemplate;
            templateTarget = that.$.indeterminateContentContainer;
            value = that.indeterminateContent;
        }

        if (oldValue) {
            templateTarget.innerHTML = value ? value : '';
        }

        if (template === null || !template) {
            return;
        }

        if (typeof template === 'function') {
            template(templateTarget, { value: value });
            return;
        }

        if (!('content' in document.createElement('template'))) {
            that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() }));
            return;
        }

        template = document.getElementById(template);
        if (template === null || !('content' in template)) {
            that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: 'template' }));
            return;
        }

        const content = template.content,
            childrenCount = content.childNodes.length,
            regex = /{{\w+}}/g;
        let bindingString,
            bindingDetails = [];

        for (let i = 0; i < childrenCount; i++) {
            bindingString = regex.exec(content.childNodes[i].innerHTML);
            while (bindingString) {
                bindingDetails.push({ childNodeIndex: i, bindingString: bindingString[0] });
                bindingString = regex.exec(content.childNodes[i].innerHTML);
            }
        }

        const bindingsCount = bindingDetails.length;
        let clone = document.importNode(template.content, true),
            bindingHolderElement,
            bindingStringsCount;

        for (let b = 0; b < bindingsCount; b++) {
            bindingHolderElement = clone.childNodes[bindingDetails[b].childNodeIndex];
            bindingStringsCount = bindingDetails.length;
            for (let i = 0; i < bindingStringsCount; i++) {
                bindingHolderElement.innerHTML = bindingHolderElement.innerHTML.replace(bindingDetails[b].bindingString, value);
            }
        }

        templateTarget.innerHTML = '';
        for (let i = 0; i < clone.childNodes.length; i++) {
            if (clone.childNodes[i].outerHTML) {
                templateTarget.innerHTML += clone.childNodes[i].outerHTML;
            }
        }
    }
});


/**
* CheckBox custom element.
*/
JQX('jqx-check-box', class CheckBox extends JQX.ToggleButton {
    // CheckBox's properties.
    static get properties() {
        return {
            'checkMode': {
                value: 'both',
                allowedValues: ['both', 'input', 'label'],
                type: 'string'
            },
            'type': {
                value: 'checkbox',
                type: 'string',
                defaultReflectToAttribute: true,
                readonly: true
            }
        };
    }

    /** CheckBox's Html template. */
    template() {
        return `<div id='container' class='jqx-container'>
                 <div class ='jqx-overlay'></div>
                 <span id='checkBoxInput' class ='jqx-input'></span>
                 <span id='checkBoxLabel' inner-h-t-m-l='[[innerHTML]]' class ='jqx-label'><content></content></span>
                 <input id='hiddenInput' class ='jqx-hidden-input' type='hidden'>
               </div>`;
    }

    static get listeners() {
        return {
            'down': '_downHandler',
            'document.up': '_documentUpHandler',
            'checkBoxInput.mouseenter': '_mouseEnterHandler',
            'checkBoxInput.mouseleave': '_mouseLeaveHandler',
            'focus': '_focusHandler',
            'blur': '_blurHandler'
        };
    }


    /**
    * CSS files needed for the element (ShadowDOM)
    */
    static get styleUrls() {
        return [
            'jqx.checkbox.css'
        ]
    }

    _focusHandler() {
        const that = this;

        that.$.setAttributeValue('focus', true);
    }

    _blurHandler() {
        const that = this;

        that.$.setAttributeValue('focus', false);
    }

    _mouseEnterHandler() {
        const that = this;

        that.$.setAttributeValue('hover', true);
    }

    _mouseLeaveHandler() {
        const that = this;

        that.$.setAttributeValue('hover', false);
    }

    /** Called when the element is ready. Used for one-time configuration of the CheckBox. */
    ready() {
        const that = this;

        super.ready();

        if (that.indeterminate) {
            that._valueCashe = that.checked;
            that.checked = null;
        }

        that._updateHidenInputNameAndValue();
    }

    /**
  * Updates CheckBox when a property is changed.
  * @param {string} propertyName The name of the property.
  * @param {number/string} oldValue The previously entered value.
  * @param {number/string} newValue The new entered value.
  */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this;

        that._updateContentProperties();

        switch (propertyName) {
            case 'indeterminate':
                if (newValue) {
                    that._valueCashe = that.checked;
                    that.checked = null;
                }
                else {
                    that.checked = that._valueCashe;
                }
                that._updateHidenInputNameAndValue();
                break;
            case 'value':
                that._updateHidenInputNameAndValue();
                break;
            case 'checked':
                that._updateHidenInputNameAndValue();
                break;
            case 'name':
                that._updateHidenInputName();
                break;
        }
    }

    /** Changes the check state on click. */
    _documentUpHandler(event) {
        const that = this,
            target = that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target;

        if (!that._pressed) {
            return;
        }

        that._pressed = false;
        that.$.setAttributeValue('active', false);

        if (that.disabled || that.readonly ||
            that.checkMode === 'input' && target !== that.$.checkBoxInput ||
            that.checkMode === 'label' && target !== that.$.checkBoxLabel) {
            return;
        }

        if (that.clickMode === 'press') {
            event.preventDefault();
            event.stopPropagation();
            return;
        }

        that._changeCheckState('pointer');
        that.focus();
        that._handleTextSelection();
        that._updateHidenInputNameAndValue();
    }

    /** Changes the check state on mouse down. */
    _downHandler(event) {
        const that = this,
            target = that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target;

        if (that.disabled || that.readonly ||
            that.checkMode === 'input' && target !== that.$.checkBoxInput ||
            that.checkMode === 'label' && target !== that.$.checkBoxLabel) {
            return;
        }

        that.$.setAttributeValue('active', true);

        if (that.hasRippleAnimation) {
            const rect = that.$.checkBoxInput.getBoundingClientRect(),
                windowScrollX = window.scrollX || window.pageXOffset,
                windowScrollY = window.scrollY || window.pageYOffset;

            JQX.Utilities.Animation.Ripple.animate(that.$.checkBoxInput, rect.left + rect.width / 2 + windowScrollX, rect.top + rect.height / 2 + windowScrollY);
        }

        that._pressed = true;

        if (that.clickMode === 'press' || that.clickMode === 'pressAndRelease') {
            that._changeCheckState('pointer');
            that.$.fireEvent('click');
            that.focus();
            that._updateHidenInputNameAndValue();
        }
    }
});

/**
* LED custom element.
*/
JQX('jqx-led', class Led extends JQX.ToggleButton {
    // LED's properties.
    static get properties() {
        return {
            'shape': {
                value: 'round',
                allowedValues: ['round', 'square'],
                type: 'string'
            }
        };
    }

   /**
   * CSS files needed for the element (ShadowDOM)
   */
    static get styleUrls() {
        return [
            'jqx.led.css'
        ]
    }

    /** LED's Html template. */
    template() {
        return `<div id='container' class='jqx-container'>
                 <div id='ledAnimation' class ='jqx-animation'></div>
                 <div id='button' class='jqx-input'>
                    <span id='falseContentContainer' inner-h-t-m-l='[[falseContent]]' class ='jqx-false-content-container'></span>
                    <span id='indeterminateContentContainer' inner-h-t-m-l='[[indeterminateContent]]' class ='jqx-indeterminate-content-container'></span>
                    <span id='trueContentContainer' inner-h-t-m-l='[[trueContent]]' class ='jqx-true-content-container'></span>
                 </div>
                 <input id='hiddenInput' class ='jqx-hidden-input' type='hidden'>
               </div>`;
    }

    /** Called when the element is ready. Used for one-time configuration of the Switch Button. */
    ready() {
        const that = this;

        super.ready();

        that._htmlBindOnInitialization();

        if (that.indeterminate) {
            that._valueCashe = that.checked;
            that.checked = null;
        }

        that._handleTemplate(true);
        that._handleTemplate(false);
        that._handleTemplate();

        that._updateHidenInputNameAndValue();
    }

    /**
   * Updates the LED when a property is  changed.
   * @param {string} propertyName The name of the property.
   * @param {number/string} oldValue The previously entered value.
   * @param {number/string} newValue The new entered value.
   */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this;

        switch (propertyName) {
            case 'indeterminate':
                if (newValue) {
                    that._valueCashe = that.checked;
                    that.checked = null;
                }
                else {
                    that.checked = that._valueCashe;
                }
                that._updateHidenInputNameAndValue();
                break;
            case 'trueContent':
                that.trueContent = newValue;
                that._handleTemplate(true);
                break;
            case 'falseContent':
                that.falseContent = newValue;
                that._handleTemplate(false);
                break;
            case 'indeterminateContent':
                that.indeterminateContent = newValue;
                that._handleTemplate();
                break;
            case 'value':
                that._updateHidenInputNameAndValue();
                break;
            case 'checked':
                that._updateHidenInputNameAndValue();
                break;
            case 'name':
                that._updateHidenInputName();
                break;
        }
    }

    /** Changes the state wneh widget is clicked. */
    _documentUpHandler(event) {
        const that = this;

        if (!that._pressed || that.readonly) {
            return;
        }

        if (that.clickMode === 'press') {
            event.preventDefault();
            event.stopPropagation();
            that._pressed = false;
            return;
        }

        super._documentUpHandler(event);
        that.indeterminate = false;
        that._updateHidenInputNameAndValue();
        that._pressed = false;
    }

    _mouseDownHandler() {
        const that = this;

        if (that.readonly || that.disabled) {
            return;
        }

        that._pressed = true;

        if (that.clickMode === 'press' || that.clickMode === 'pressAndRelease') {
            that._changeCheckState('pointer');
            that.$.fireEvent('click');
            that.indeterminate = false;
            that._updateHidenInputNameAndValue();
        }
    }
});

/**
* Power Button custom element.
*/
JQX('jqx-power-button', class PowerButton extends JQX.ToggleButton {

    /**
    * CSS files needed for the element (ShadowDOM)
    */
    static get styleUrls() {
        return [
            'jqx.powerbutton.css'
        ]
    }

    /** PowerButton's Html template. */
    template() {
        return `<div id='container' class='jqx-container'>
                 <div id='powerButtonAnimation' class ='jqx-animation'></div>
                 <span id='button' class ='jqx-input'></span>
                 <input id='hiddenInput' class ='jqx-hidden-input' type='hidden'>
               </div>`;
    }

    /** Called when the element is ready. Used for one-time configuration of the PowerButton. */
    ready() {
        const that = this;

        super.ready();
        that._updateHidenInputNameAndValue();
    }
});

/**
* RadioButton custom element.
*/
JQX('jqx-radio-button', class RadioButton extends JQX.ToggleButton {
    // RadioButton's properties.
    static get properties() {
        return {
            'checkMode': {
                value: 'both',
                allowedValues: ['both', 'input', 'label'],
                type: 'string'
            },
            'type': {
                value: 'radio',
                type: 'string',
                defaultReflectToAttribute: true,
                readonly: true
            },
            'groupName': {
                value: '',
                type: 'string'
            }
        };
    }

    /** RadioButton's Html template. */
    template() {
        return `<div  id='container' class='jqx-container'>
                 <div class ='jqx-overlay'></div>
                 <span id='radioButtonInput' class ='jqx-input'></span>
                 <span id='radioButtonLabel' inner-h-t-m-l='[[innerHTML]]' class ='jqx-label'><content></content></span>
                 <input id='hiddenInput' class ='jqx-hidden-input' type='hidden'>
               </div>`;
    }

    static get listeners() {
        return {
            'down': '_downHandler',
            'document.up': '_documentUpHandler',
            'mouseenter': '_elementMouseEnterHandler',
            'radioButtonInput.mouseenter': '_radioMouseEnterHandler',
            'radioButtonInput.mouseleave': '_radioMouseLeaveHandler',
            'focus': '_focusHandler',
            'blur': '_blurHandler'

        };
    }

    static get styleUrls() {
        return [
            'jqx.radiobutton.css'
        ]
    }

    _radioMouseEnterHandler() {
        const that = this;

        that.$.setAttributeValue('hover', true);
    }

    _radioMouseLeaveHandler() {
        const that = this;

        that.$.setAttributeValue('hover', false);
    }

    _focusHandler() {
        const that = this;

        that.$.setAttributeValue('focus', true);
    }

    _blurHandler() {
        const that = this;

        that.$.setAttributeValue('focus', false);
    }

    _mouseEnterHandler() {
        const that = this;

        that.$.setAttributeValue('hover', true);
    }

    _mouseLeaveHandler() {
        const that = this;

        that.$.setAttributeValue('hover', false);
    }


    /** Called when the element is ready. Used for one-time configuration of the RadioButton. */
    ready() {
        const that = this;

        super.ready();
        that._handleMultipleCheckedInstances();
        that._updateHidenInputNameAndValue();
    }

    /**
     * Radio button down handler.
     */
    _downHandler(event) {
        const that = this,
            target = that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target;

        if (that.disabled || that.readonly ||
            that.checkMode === 'input' && target !== that.$.radioButtonInput ||
            that.checkMode === 'label' && target !== that.$.radioButtonLabel) {
            return;
        }

        that.$.setAttributeValue('active', true);

        if (that.hasRippleAnimation) {
            const rect = that.$.radioButtonInput.getBoundingClientRect(),
                windowScrollX = window.scrollX || window.pageXOffset,
                windowScrollY = window.scrollY || window.pageYOffset;

            JQX.Utilities.Animation.Ripple.animate(that.$.radioButtonInput, rect.left + rect.width / 2 + windowScrollX, rect.top + rect.height / 2 + windowScrollY);
        }

        if (that._preventAction) {
            that._preventAction = false;
            return;
        }

        if (that.clickMode === 'release' || that.clickMode === 'pressAndRelease') {
            that._pressed = true;
        }

        if (that.clickMode === 'press' || that.clickMode === 'pressAndRelease') {
            if (that.clickMode === 'pressAndRelease') {
                if (that.groupName === '') {
                    that._checkedBeforeChange = that.parentNode.querySelector('jqx-radio-button[checked]');
                }
                else {
                    that._checkedBeforeChange = document.querySelector('jqx-radio-button[group-name="' + that.groupName + '"][checked]');
                }
            }

            that._handleMouseInteraction();
        }
    }

    /**
     * Radio button mouseenter handler.
     */
    _elementMouseEnterHandler() {
        const that = this;

        if (that.clickMode === 'hover' && !that.disabled && !that.readonly) {
            that._handleMouseInteraction();
        }
    }

    /**
     * Document up handler.
     */
    _documentUpHandler(event) {
        const that = this,
            target = that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target;

        if (!that._pressed || that.disabled || that.readonly ||
            that.checkMode === 'input' && target !== that.$.radioButtonInput ||
            that.checkMode === 'label' && target !== that.$.radioButtonLabel) {
            return;
        }

        if (that.clickMode === 'release') {
            that._handleMouseInteraction();
        }
        else {
            // clickMode: 'pressAndRelease'
            if (that._checkedBeforeChange === null) {
                that.$.fireEvent('change', { 'value': false, 'oldValue': true, 'changeType': 'pointer' });
                that.checked = false;
            }
            else {
                that._checkedBeforeChange._changeCheckState('pointer');
            }

            that.focus();
            that._updateHidenInputNameAndValue();
        }

        that.$.setAttributeValue('active', false);

        that._pressed = false;
    }

    /**
     * Handles interaction with the mouse.
     */
    _handleMouseInteraction() {
        const that = this;

        that._handleTextSelection();

        that._changeCheckState('pointer');
        that.focus();
        that._updateHidenInputNameAndValue();
    }

    /**
     * Reduce checked items in group to 1(latest selected item)
     */
    _handleMultipleCheckedInstances() {
        const that = this,
            checkedRadioButtons = Array.from(document.querySelectorAll('jqx-radio-button[group-name="' + that.groupName + '"][checked]')),
            count = checkedRadioButtons.length;

        if (count < 2) {
            return;
        }

        checkedRadioButtons.forEach((item, i) => (i < (count - 1)) && (item.checked = false));

    }

    /** Changes the check state. */
    _changeCheckState(changeType) {
        const that = this;

        let radioButtonsGroup = document.querySelectorAll('jqx-radio-button[group-name="' + that.groupName + '"]');

        if ((that.checked === true && changeType === 'api') || (that.checked === false)) {
            if (radioButtonsGroup.length > 0) {
                that._changeCheckStateInGroup(radioButtonsGroup, changeType);
            }
            else {
                let parent = that.parentNode;
                radioButtonsGroup = parent.querySelectorAll('jqx-radio-button:not([group-name])');
                that._changeCheckStateInGroup(radioButtonsGroup, changeType);
            }
        }
    }

    /** Changes the check states in group of radio buttons. */
    _changeCheckStateInGroup(elements, changeType) {
        const that = this;

        for (let i = 0; i < elements.length; i++) {
            elements[i]._isUpdating = true;

            if (elements[i] === that) {
                that.checked = true;
                that.$.fireEvent('change', { 'value': true, 'oldValue': false, 'changeType': changeType });
            }
            else if (elements[i].checked) {
                elements[i].checked = false;
            }

            elements[i]._isUpdating = false;
        }
    }

    /**
    * Updates the radio button/radio group when checked property is changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
    * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        switch (propertyName) {
            case 'value':
                that._updateHidenInputNameAndValue();
                break;
            case 'checked':
                if (!that._isUpdating) {
                    that._changeCheckState('api');
                }
                that._updateHidenInputNameAndValue();
                break;
            case 'name':
                that._updateHidenInputName();
                break;
            default:
                super.propertyChangedHandler(propertyName, oldValue, newValue);
                break;
        }
    }
});

/**
* Switch Button custom element.
*/
JQX('jqx-switch-button', class SwitchButton extends JQX.ToggleButton {
    // Switch Button's properties.
    static get properties() {
        return {
            'inverted': {
                value: false,
                type: 'boolean'
            },
            'orientation': {
                value: 'horizontal',
                allowedValues: ['horizontal', 'vertical'],
                type: 'string'
            },
            'switchMode': {
                value: 'default',
                allowedValues: ['default', 'click', 'drag', 'none'],
                type: 'string'
            },
            'clickMode': {
                value: 'release',
                allowedValues: ['press', 'release', 'pressAndRelease'],
                type: 'string'
            }
        };
    }

    /**
     * Switch Button's event listeners.
     */
    static get listeners() {
        return {
            'container.down': '_mouseDownHandler',
            'document.move': '_drag',
            'document.up': '_switchThumbDropHandler',
            'mouseenter': '_switchButtonOnMouseEnter',
            'mouseleave': '_switchButtonOnMouseLeave',
            'resize': '_resizeHandler',
            'container.resize': '_resizeHandler',
            'document.selectstart': '_selectStartHandler'
        };
    }

    /** Switch Button's Html template. */
    template() {
        return `<div  id='container' class='jqx-container'>
                    <div  id='innerContainer' class ='jqx-inner-container'>
                           <span id='falseContentContainer' inner-h-t-m-l='[[falseContent]]' class ='jqx-false-content-container'></span>
                           <span id='switchThumb' class ='jqx-thumb'></span>
                           <span id='trueContentContainer' inner-h-t-m-l='[[trueContent]]' class ='jqx-true-content-container'></span>
                    </div>
                    <input id='hiddenInput' class ='jqx-hidden-input' type='hidden'>
               </div>`;
    }

    /** Called when the element is ready. Used for one-time configuration of the Switch Button. */
    ready() {
        const that = this;

        super.ready();

        let animationType = that.animation;

        if (that.hasAnimation) {
            that.animation = 'none';
        }

        that._supportCSSVariables = JQX.Utilities.Core.CSSVariablesSupport() && Boolean(window.getComputedStyle(that.$.container).getPropertyValue('--jqx-switch-button-default-width'));
        that._htmlBindOnInitialization();
        that._resizeHandler();
        that._initializePrivateVariables();
        that._getContainersSizeAndBreakPoint();

        if (that.indeterminate) {
            that._valueCache = that.checked;
            that.checked = null;
        }

        that._handleTemplate(true); //Set the True Content
        that._handleTemplate(false); //Set the False Content
        that._handleTemplate(); // Set the Indeterminate Content

        that._updateHidenInputNameAndValue();
        that._updateThumbPosition();

        that.animation = animationType;
    }

    /** Changes the check state and fires event on mouse up. */
    _mouseDownHandler(event) {
        const that = this;

        if (that.disabled || that.readonly || that.switchMode === 'none') {
            return;
        }

        if (event.originalEvent.target.closest('.jqx-thumb') === that.$.switchThumb && (that.switchMode === 'default' || that.switchMode === 'drag')) {
            that._switchThumbDragStartHandler(event);
        }

        that._isSwitchClicked = that;

        that._updateContentProperties();

        if ((that.clickMode !== 'release') && (that.switchMode === 'click')) {
            that._updateStateOnClick();
            that.$.fireEvent('click');
            that.indeterminate = false;
            that._updateHidenInputNameAndValue();
        }
    }

    /** Changes the check state and updates CSS variables */
    _updateStateOnClick() {
        const that = this;

        that._changeCheckState();
        that.focus();
    }

    _drag(event) {
        const that = this;

        if (!that._mouseDown) {
            return;
        }

        if (JQX.Utilities.Core.isMobile) {
            event.originalEvent.preventDefault();
        }

        that._switchThumbDragHandler(event);
    }

    /** Changes the check state wneh widget's thumb is dragged. */
    _switchThumbDragStartHandler(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        if ((that.switchMode === 'click') && (that.clickMode !== 'release')) {
            event.preventDefault();
            event.stopPropagation();
        }

        if (that._isInactiveOn('drag')) {
            return;
        }

        that._mouseDown = true;
        that._getContainersSizeAndBreakPoint();
        that._pointerPosition = (that.orientation === 'vertical' ? event.pageY : event.pageX);
        event.preventDefault();
    }

    _selectStartHandler(event) {
        const that = this;

        if (that._mouseDown) {
            event.preventDefault();
        }
    }

    /** Changes the check state wneh widget's thumb is dragged. */
    _switchThumbDragHandler(event) {
        const that = this;

        if (that._isInactiveOn('drag')) {
            return;
        }

        if (that._mouseDown === false) {
            that._removeDragStyles();
            return;
        }

        if (!that.hasAttribute('dragged')) {
            that.setAttribute('dragged', '');
        }

        //delete that._isSwitchClicked;

        let innerContainer = that.$.innerContainer,
            offset = that.$.container.getBoundingClientRect(),
            scrollDistance = that.orientation === 'vertical' ? (document.body.scrollTop || document.documentElement.scrollTop) : (document.body.scrollLeft || document.documentElement.scrollLeft),
            containerOffset = that.orientation === 'vertical' ? offset.top + scrollDistance : offset.left + scrollDistance,
            diff = that.orientation === 'vertical' ? (that._pointerPosition - innerContainer.offsetTop) : (that._pointerPosition - innerContainer.offsetLeft),
            pointerInRange = (that._pointerPosition >= containerOffset && that._pointerPosition <= containerOffset + that._switchContainerSize);
        const maxLeft = -1 * (that.offsetWidth - that.$.switchThumb.offsetWidth),
            maxTop = -1 * (that.offsetHeight - that.$.switchThumb.offsetHeight);

        that._pointerPosition = that.orientation === 'vertical' ? event.pageY : event.pageX;
        if (pointerInRange) {
            let currentPosition = that._pointerPosition - diff;

            if (currentPosition < -that._switchTrackLength) currentPosition = -that._switchTrackLength;
            if (currentPosition > 0) currentPosition = 0;
            that.orientation === 'vertical' ? (that.$.innerContainer.style.top = Math.max(maxTop, currentPosition) + 'px') : (that.$.innerContainer.style.left = Math.max(maxLeft, currentPosition) + 'px');
        }
    }

    /** Document Up Event Handler */
    _switchThumbDropHandler() {
        const that = this;

        if (that.hasAttribute('dragged')) {
            that._endDrag();
        }
        else if (that._isSwitchClicked) {
            that._endClick();
        }

        that._mouseDown = false;
        delete that._isSwitchClicked;
    }

    /**
     * Ends the dragging operation
     */
    _endDrag() {
        const that = this;

        that.indeterminate = false;
        that._updateHidenInputNameAndValue();

        if (that._isInactiveOn('drag') || !that._mouseDown) {
            return;
        }

        that.removeAttribute('dragged');

        let switchOnPosition = (that.orientation === 'vertical' ? (that.$.innerContainer.offsetTop + that.$.switchThumb.offsetTop + that.$.switchThumb.clientHeight / 2) : (that.$.innerContainer.offsetLeft + that.$.switchThumb.offsetLeft + that.$.switchThumb.clientWidth / 2));

        const switchAfterBreakPoint = switchOnPosition > that._switchBreakPoint;

        if (that.checked !== null) {
            if (!that.inverted === (switchAfterBreakPoint === that.checked)) {
                that._changeCheckState(!that.checked);
            }
        }
        else {
            switchAfterBreakPoint ? that._changeCheckState(that.inverted) : that._changeCheckState(!that.inverted);
        }

        that._removeDragStyles();
        that._updateThumbPosition();
    }

    /**
     * Ends the click operation
     */
    _endClick() {
        const that = this;

        //Click Handler
        that._resizeHandler();

        if (that.disabled || that.readonly) {
            return;
        }

        if (that._isInactiveOn('click')) {
            return;
        }

        if (that.clickMode !== 'release' && that.clickMode !== 'pressAndRelease') {
            //event.preventDefault();
            //event.stopPropagation();
        }
        else {
            that._updateStateOnClick();
        }

        that.indeterminate = false;
        that._updateHidenInputNameAndValue();
    }

    /**
    * Switch button onMouseEnter event handler.
    **/
    _switchButtonOnMouseEnter() {
        const that = this;

        if (that.disabled || that.readonly) {
            return;

        }

        that.$.addClass('hovered');
    }

    /**
    * Switch button onMouseLeave event handler.
    **/
    _switchButtonOnMouseLeave() {
        const that = this;

        if (that.disabled || that.readonly) {
            return;
        }

        that.$.removeClass('hovered');
    }

    /** Checks is handler active in particular switch mode. */
    _isInactiveOn(switchMode) {
        const that = this,
            isInactive = ((that.disabled) || that.readonly || (that.switchMode !== switchMode));

        if (that.switchMode === 'default') {
            return false;
        }

        return isInactive;
    }

    /** Changes the check state wneh spacebar is pressed. */
    _keyUpHandler(event) {
        const that = this;

        if (that.disabled || that.readonly || (event.keyCode !== 32) || that.switchMode === 'none') {
            return;
        }

        that._getContainersSizeAndBreakPoint();
        that._changeCheckState();
    }

    /** Initializes private variables. */
    _initializePrivateVariables() {
        const that = this;

        that._switchContainerSize = that._switchTrackLength = that._switchBreakPoint = that._pointerPosition = 0;
        that._mouseDown = false;
    }

    /** Changes the check state. */
    _changeCheckState(optionalValue) {
        const that = this;
        let oldValue = that.checked;

        if ((oldValue === null) && (optionalValue !== undefined)) {
            that.$.fireEvent('change', { 'value': optionalValue, 'oldValue': null });
            that.checked = optionalValue;
            that._updateThumbPosition();
            return;
        }

        if (that.checked === null) {
            that.checked = true;
        }
        else {
            that.checked = !that.checked;
        }

        that._updateThumbPosition();

        that.$.fireEvent('change', { 'value': that.checked, 'oldValue': oldValue });
        that._updateHidenInputNameAndValue();
    }

    /**
    * Get the actual width of the Switch Button and Switch Button's breakpoint.
    */
    _getContainersSizeAndBreakPoint() {
        const that = this;

        that._switchContainerSize = (that.orientation === 'vertical' ? that.$.container.clientHeight : that.$.container.clientWidth);
        that._switchTrackLength = (that.orientation === 'vertical' ? (that._switchContainerSize - that.$.switchThumb.clientHeight) : (that._switchContainerSize - that.$.switchThumb.clientWidth));
        that._switchBreakPoint = that._switchContainerSize / 2;
    }

    /**
    * Remove styles, related to absolute positioning of the thumb when it's dragged
    */
    _removeDragStyles() {
        const that = this;
        that._supportCSSVariables ? that.$.innerContainer.removeAttribute('style') : that.$.innerContainer.style.left = '';
        that._supportCSSVariables ? that.$.innerContainer.removeAttribute('style') : that.$.innerContainer.style.top = '';
        that._mouseDown = false;
    }

    /**
    * Called when a property is changed.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        super.propertyChangedHandler(propertyName, oldValue, newValue);
        that._updateContentProperties();

        switch (propertyName) {
            case 'indeterminate':
                if (newValue) {
                    that._valueCache = that.checked;
                    that.checked = null;
                }
                else {
                    that.checked = that._valueCache;
                }
                break;
            case 'trueContent':
                that.trueContent = newValue;
                break;
            case 'falseContent':
                that.falseContent = newValue;
                break;
            case 'orientation':
                that._resizeHandler();
                break;
        }

        that._getContainersSizeAndBreakPoint();
        that._removeDragStyles();
        that._resizeHandler();
    }

    /** Resize handler **/
    _resizeHandler() {
        const that = this;

        if (!document.body.contains(that)) {
            return;
        }

        const computedStyles = window.getComputedStyle(that, null),
            borderTopWidth = parseInt(computedStyles.getPropertyValue('border-top-width')),
            borderRightWidth = parseInt(computedStyles.getPropertyValue('border-right-width')),
            borderBottomWidth = parseInt(computedStyles.getPropertyValue('border-bottom-width')),
            borderLeftWidth = parseInt(computedStyles.getPropertyValue('border-left-width')),
            newWidth = that.orientation === 'vertical' ? (that.offsetHeight - (borderTopWidth + borderBottomWidth)) : (that.offsetWidth - (borderLeftWidth + borderRightWidth));

        that._getContainersSizeAndBreakPoint();

        if (that._supportCSSVariables) {
            that.$.container.style.setProperty('--jqx-switch-button-default-width', newWidth + 'px');
        }
        else {
            that._innerContainerSize = newWidth;
            that.$.innerContainer.style.height = that.$.innerContainer.style.width = '';
            that.$.trueContentContainer.style.height = that.$.trueContentContainer.style.width = '';
            that.$.falseContentContainer.style.height = that.$.falseContentContainer.style.width = '';

            if (that.orientation === 'horizontal') {
                that.$.innerContainer.style.setProperty('width', (2 * newWidth - that.$.switchThumb.clientWidth) + 'px');
                that.$.trueContentContainer.style.setProperty('width', that._switchTrackLength + 'px');
                that.$.falseContentContainer.style.setProperty('width', that._switchTrackLength + 'px');
            }
            else {
                that.$.innerContainer.style.setProperty('height', (2 * newWidth - that.$.switchThumb.clientHeight) + 'px');
                that.$.trueContentContainer.style.setProperty('height', that._switchTrackLength + 'px');
                that.$.falseContentContainer.style.setProperty('height', that._switchTrackLength + 'px');
            }

            that._updateThumbPosition();
        }
    }

    /**
     * Updates the thumb position when the browser doesn't support CSS variables
     */
    _updateThumbPosition() {
        const that = this;

        if (that._supportCSSVariables || (that.inverted ? that.checked === true : that.checked === false) || !that._innerContainerSize) {
            that.$.innerContainer.style.left = that.$.innerContainer.style.top = '';
            return;
        }

        if (that.inverted ? that.checked === false : that.checked) {
            if (that.orientation === 'horizontal') {
                that.$.innerContainer.style.left = (-1 * (that._innerContainerSize - that.$.switchThumb.offsetWidth)) + 'px';
                that.$.innerContainer.style.top = '';
            }
            else {
                that.$.innerContainer.style.top = (-1 * (that._innerContainerSize - that.$.switchThumb.offsetHeight)) + 'px';
                that.$.innerContainer.style.left = '';
            }
        }

        if (that.checked === null) {
            if (that.orientation === 'horizontal') {
                that.$.innerContainer.style.left = (-1 * (that._innerContainerSize / 2 - that.$.switchThumb.offsetWidth / 2)) + 'px';
                that.$.innerContainer.style.top = '';
            }
            else {
                that.$.innerContainer.style.top = (-1 * (that._innerContainerSize / 2 - that.$.switchThumb.offsetHeight / 2)) + 'px';
                that.$.innerContainer.style.left = '';
            }
        }
    }
});

/**
* DropDownLst custom element.
*/
JQX('jqx-drop-down-list', class DropDownList extends JQX.ContentElement {

    /** 
    * DropDownList's properties 
    */
    static get properties() {
        return {
            'autoCloseDelay': {
                value: 100,
                type: 'number'
            },
            'dataSource': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'displayLoadingIndicator': {
                value: false,
                type: 'boolean'
            },
            'displayMember': {
                value: '',
                type: 'string'
            },
            'dropDownAppendTo': {
                value: null,
                type: 'any'
            },
            'dropDownButtonPosition': {
                allowedValues: ['none', 'left', 'right', 'top', 'bottom'],
                value: 'right',
                type: 'string'
            },
            'dropDownMinHeight': {
                value: '',
                type: 'any',
                validator: '_propertyValidator'
            },
            'dropDownHeight': {
                value: '',
                type: 'any',
                validator: '_propertyValidator'
            },
            'dropDownMaxHeight': {
                value: '',
                type: 'any',
                validator: '_propertyValidator'
            },
            'dropDownOpenMode': {
                allowedValues: ['none', 'default', 'dropDownButton', 'auto'],
                value: 'default',
                type: 'string'
            },
            'dropDownOverlay': {
                value: false,
                type: 'boolean'
            },
            'dropDownPlaceholder': {
                value: 'No Items',
                type: 'string'
            },
            'dropDownPosition': {
                allowedValues: ['auto', 'top', 'bottom', 'overlay-top', 'overlay-center', 'overlay-bottom', 'center-bottom', 'center-top'],
                value: 'auto',
                type: 'string'
            },
            'dropDownMinWidth': {
                value: '',
                type: 'any',
                validator: '_propertyValidator'
            },
            'dropDownWidth': {
                value: '',
                type: 'any',
                validator: '_propertyValidator'
            },
            'dropDownMaxWidth': {
                value: '',
                type: 'any',
                validator: '_propertyValidator'
            },
            'filterable': {
                value: false,
                type: 'boolean'
            },
            'filterInputPlaceholder': {
                value: '',
                type: 'string'
            },
            'filterCallback': {
                value: null,
                type: 'function?'
            },
            'filterMode': {
                value: 'startsWithIgnoreCase',
                allowedValues: ['contains', 'containsIgnoreCase', 'doesNotContain', 'doesNotContainIgnoreCase', 'equals', 'equalsIgnoreCase', 'startsWith', 'startsWithIgnoreCase', 'endsWith', 'endsWithIgnoreCase', 'custom'],
                type: 'string'
            },
            'grouped': {
                value: false,
                type: 'boolean'
            },
            'groupMember': {
                value: '',
                type: 'string'
            },
            'hint': {
                value: '',
                type: 'string'
            },
            'horizontalScrollBarVisibility': {
                type: 'string',
                value: 'auto',
                allowedValues: ['auto', 'disabled', 'hidden', 'visible']
            },
            'incrementalSearchDelay': {
                value: 700,
                type: 'number?'
            },
            'incrementalSearchMode': {
                value: 'startsWithIgnoreCase',
                allowedValues: ['contains', 'containsIgnoreCase', 'doesNotContain', 'doesNotContainIgnoreCase', 'equals', 'equalsIgnoreCase', 'startsWith', 'startsWithIgnoreCase', 'endsWith', 'endsWithIgnoreCase'],
                type: 'string'
            },
            'inputMember': {
                value: 'label',
                type: 'string'
            },
            'itemTemplate': {
                value: null,
                type: 'any'
            },
            'itemHeight': {
                value: null,
                type: 'number?'
            },
            'label': {
                value: '',
                type: 'string'
            },
            'loadingIndicatorPlaceholder': {
                value: 'Loading...',
                type: 'string'
            },
            'loadingIndicatorPosition': {
                value: 'center',
                allowedValues: ['bottom', 'center', 'top'],
                type: 'string'
            },
            'messages': {
                extend: true,
                value: {
                    'en': {
                        'invalidNode': '{{elementType}}: Invalid parameter "{{node}}" when calling {{method}}.'
                    }
                },
                type: 'object'
            },
            'name': {
                value: '',
                type: 'string'
            },
            'opened': {
                value: false,
                type: 'boolean'
            },
            'placeholder': {
                value: '',
                type: 'string'
            },
            'renderMode': {
                allowedValues: ['outlined', 'filled', 'underlined'],
                value: 'outlined',
                type: 'string'
            },
            'resizeMode': {
                value: 'none',
                allowedValues: ['none', 'horizontal', 'vertical', 'both'],
                type: 'string'
            },
            'resizeIndicator': {
                value: false,
                type: 'boolean'
            },
            'selectionDisplayMode': {
                value: 'plain',
                allowedValues: ['plain', 'placeholder', 'tokens'],
                type: 'string'
            },
            'selectionMode': {
                value: 'one',
                allowedValues: ['none', 'oneOrManyExtended', 'zeroOrMany', 'oneOrMany', 'zeroOrOne', 'one', 'checkBox', 'radioButton'],
                type: 'string'
            },
            'selectedIndexes': {
                value: [],
                type: 'array'
            },
            'selectedValues': {
                value: [],
                type: 'array'
            },
            'sorted': {
                value: false,
                type: 'boolean'
            },
            'tokenTemplate': {
                value: null,
                type: 'any'
            },
            'type': {
                value: 'list',
                type: 'string',
                defaultReflectToAttribute: true,
                readonly: true
            },
            'valueMember': {
                value: '',
                type: 'string'
            },
            'virtualized': {
                value: false,
                type: 'boolean'
            },
            'verticalScrollBarVisibility': {
                type: 'string',
                value: 'auto',
                allowedValues: ['auto', 'disabled', 'hidden', 'visible']
            }
        }
    }

    /**
    * DropDownList's event listeners.
    */
    static get listeners() {
        return {
            'actionButton.down': '_buttonsDownHandler',
            'actionButton.mouseenter': '_buttonsMouseEventsHandler',
            'actionButton.mouseleave': '_buttonsMouseEventsHandler',
            'actionButton.focus': '_buttonsFocusHandler',
            'actionButton.blur': '_buttonsFocusHandler',
            'document.selectstart': '_selectStartHandler',
            'document.dragstart': '_dragStartHandler',
            'document.down': '_documentDownHandler',
            'document.up': '_documentUpHandler',
            'document.move': '_documentMoveHandler',
            'dropDownButton.down': '_buttonsDownHandler',
            'dropDownButton.mouseenter': '_buttonsMouseEventsHandler',
            'dropDownButton.mouseleave': '_buttonsMouseEventsHandler',
            'keydown': '_keyDownHandler',
            'keyup': '_keyUpHandler',
            'focus': '_focusEventHandler',
            'blur': '_blurEventHandler',
            'dropDownButton.focus': '_buttonsFocusHandler',
            'dropDownButton.blur': '_buttonsFocusHandler',
            'dropDownContainer.transitionend': '_dropDownTransitionendHandler',
            'listBox.change': '_listBoxChangeHandler',
            'listBox.itemClick': '_listBoxItemClickHandler',
            'listBox.keydown': '_listBoxKeyDownHandler',
            'listBox.bindingComplete': '_bindingCompleteHandler',
            'mouseenter': '_mouseEnterHandler',
            'mouseleave': '_mouseLeaveHandler',
            'resize': '_resizeHandler',
            'resizeBar.move': '_resizeBarMoveHandler',
            'styleChanged': '_styleChangedHandler',
            'wheel': '_mouseWheelHandler'
        };
    }

    /**
    * DropDownList's HTML template.
    */
    template() {
        return `<div id="container">
                    <span class="jqx-label" id="label">[[label]]</span>
                    <div id="content" class="jqx-content">
                        <div class="jqx-buttons-container" id="buttonsContainer">
                            <span id="actionButton" class="jqx-input jqx-action-button"></span>
                            <span id="dropDownButton" class="jqx-drop-down-button">
                                <span id="arrow"></span>
                            </span>
                        </div>
                        <div id="dropDownContainer" class="jqx-drop-down jqx-drop-down-container jqx-visibility-hidden">
                            <jqx-list-box id="listBox" unfocusable
                                    animation="[[animation]]"
                                    data-source="[[dataSource]]"
                                    disabled="[[disabled]]"
                                    display-loading-indicator="[[displayLoadingIndicator]]"
                                    display-member="[[displayMember]]"
                                    filterable="[[filterable]]"
                                    filter-callback="[[filterCallback]]"
                                    filter-mode="[[filterMode]]"
                                    filter-input-placeholder="[[filterInputPlaceholder]]"
                                    grouped="[[grouped]]"
                                    group-member="[[groupMember]]"
                                    item-height="[[itemHeight]]"
                                    item-template="[[itemTemplate]]"
                                    incremental-search-delay="[[incrementalSearchDelay]]"
                                    incremental-search-mode="[[incrementalSearchMode]]"
                                    loading-indicator-placeholder="[[loadingIndicatorPlaceholder]]"
                                    loading-indicator-position="[[loadingIndicatorPosition]]"
                                    name="[[name]]"
                                    placeholder="[[dropDownPlaceholder]]"
                                    readonly="[[readonly]]"
                                    selected-indexes="{{selectedIndexes}}"
                                    selection-mode="[[selectionMode]]"
                                    selected-values="{{selectedValues}}"
                                    sorted="[[sorted]]"
                                    theme="[[theme]]"
                                    value-member="[[valueMember]]"
                                    horizontal-scroll-bar-visibility="[[horizontalScrollBarVisibility]]"
                                    vertical-scroll-bar-visibility="[[verticalScrollBarVisibility]]"
                                    virtualized="[[virtualized]]">
                                <content></content>
                            </jqx-list-box>
                            <div id="resizeBar" class="jqx-drop-down-resize-bar">
                                <div></div>
                            </div>
                         </div>
                    </div>
                    <span class="jqx-hint" id="hint">[[hint]]</span>
                </div>`;
    }

    /*
    * CSS files needed for the element (ShadowDOM)
    */
    static get styleUrls() {
        return [
            'jqx.dropdownlist.css',
            'jqx.dropdown.css'
        ]
    }

    /**
    * Updates the DropDownList when a property is changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
    * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this;

        switch (propertyName) {
            case 'animation':
                that.$.dropDownContainer.setAttribute('animation', that.animation);
                break;
            case 'disabled':
                that._setFocusable();
                that.close();
                that._positionDetection.handleAutoPositioning();
                break;
            case 'dataSource':
            case 'displayMember':
            case 'inputMember':
                //when selectedValues is 0 and displayMember is changed set actionButton text to default.
                if (that.$.actionButton) {
                    that.$.actionButton.innerHTML = that.placeholder;
                }

                //Check the new listBox size
                that._setDropDownSize();
                that._positionDetection.checkBrowserBounds('vertically');
                that._positionDetection.positionDropDown();
                that._positionDetection.checkBrowserBounds('horizontally');
                break;
            case 'dropDownAppendTo':
                that._positionDetection.dropDownAppendToChangedHandler();
                break;
            case 'dropDownOpenMode':
                that._setFocusable();

                //Close the dropDownList without throwing events.
                that.$dropDownContainer.addClass('jqx-visibility-hidden');
                that.$.dropDownButton.removeAttribute('selected');
                that.removeAttribute('drop-down-button-focus');
                that.removeAttribute('action-button-focus');
                that.opened = false;
                break;
            case 'dropDownOverlay':
                if (!newValue) {
                    that._positionDetection.removeOverlay();
                }

                break;
            case 'dropDownPosition':
                that._positionDetection.dropDownPositionChangedHandler();
                break;
            case 'dropDownMinWidth':
            case 'dropDownWidth':
            case 'dropDownMaxWidth':
            case 'dropDownHeight':
            case 'dropDownMinHeight':
            case 'dropDownMaxHeight':
                that._setDropDownSize();
                break;
            case 'opened':
                if (that.disabled || that.readonly) {
                    return;
                }

                newValue ? that.open() : that.close();
                break;
            case 'placeholder':
                that._applySelection();
                break;
            case 'readonly':
                that.close();
                break;
            case 'resizeIndicator':
                if (newValue) {
                    that.$.dropDownContainer.setAttribute('resize-indicator', '');
                }
                else {
                    that.$.dropDownContainer.removeAttribute('resize-indicator');
                }

                break;
            case 'resizeMode':
                that.$.dropDownContainer.setAttribute('resize-mode', that.resizeMode);
                break;
            case 'selectedValues':
            case 'selectedIndexes':
                if (newValue.length === 0) {
                    that.$.actionButton.innerHTML = that.placeholder;
                }
                else {
                    that._applySelection();
                }
                break;
            case 'selectionDisplayMode':
                that._applySelection();
                break;
            case 'tokenTemplate':
                that._tokenTemplate = that._validateTemplate(that.tokenTemplate);
                that._applySelection();
                break;
            case 'unfocusable':
                that._setFocusable();
                break;
        }
    }

    /**
    * Appends a jqx-list-item to the end of the DropDownList.
    */
    appendChild(node) {
        const that = this;

        if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!node) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'appendChild', node: 'node' }));
            return
        }

        that.$.listBox.appendChild(node);

        if (that._dropDownSize && that._dropDownSize.height === 'auto') {
            that._setDropDownSize();
        }
    }

    /**
    * Called when the element is attached from the DOM.
    */
    attached() {
        const that = this;

        super.attached();

        if (!that.isCompleted || !that.$.dropDownContainer) {
            return;
        }

        that._positionDetection.dropDownAttached('_setDropDownSize');
        that._positionDetection.checkBrowserBounds();
    }

    /**
     * Called when the element is detached from the DOM.
     */
    detached() {
        const that = this;

        super.detached();

        if (!that.$.dropDownContainer) {
            return;
        }

        that.close();
        that._positionDetection.dropDownDetached();
    }

    /**
    * Removes all items from DOM.
    */
    clearItems() {
        const that = this;

        if (!that.$.listBox) {
            return;
        }

        that.$.listBox.clearItems();
        that.$.actionButton.innerHTML = that.placeholder;
    }

    /**
    * Unselects all items.
    */
    clearSelection() {
        const that = this;

        if (!that.$.listBox) {
            return;
        }

        that.$.listBox.clearSelection();
        that.$.actionButton.innerHTML = that.placeholder;
    }

    /**
    * Hides the drop down list.
    */
    close() {
        const that = this;

        if (that.$dropDownContainer.hasClass('jqx-visibility-hidden')) {
            return;
        }

        const isClosingEventPrevented = that.$.fireEvent('closing').defaultPrevented;

        if (isClosingEventPrevented) {
            return;
        }

        that.$dropDownContainer.addClass('jqx-visibility-hidden');
        that.$.fireEvent('close');

        if (that.$.dropDownButton) {
            that.$.dropDownButton.removeAttribute('selected');
        }

        that.opened = false;
        that._preventDropDownClose = false;
        that._positionDetection.removeOverlay(true);

        if (that._edgeMacFF && !that.hasAnimation && that.$.dropDownContainer) {
            that.$.dropDownContainer.style.top = that.$.dropDownContainer.style.left = '';
            that.$dropDownContainer.addClass('not-in-view');
        }
    }

    /**
    * Creates a clone of the element.
    */
    cloneNode() {
        const that = this;

        if (!that.$.listBox) {
            return;
        }

        let clone = HTMLElement.prototype.cloneNode.apply(that, Array.prototype.slice.call(arguments, 0, 1));

        //Set only those properties that have reflectToAttribute set to false.
        clone.dataSource = that.dataSource;
        return clone;
    }

    /**
    * Ensures the desired item is visible by scrolling to it.
    */
    ensureVisible(item) {
        const that = this;

        if (!that.$.listBox) {
            return;
        }

        that.$.listBox.ensureVisible(item);
    }

    /**
    * Returns a JQX.ListItem element if it's value is matched.
    */
    getItem(value) {
        const that = this;

        if (!that.$.listBox) {
            return;
        }

        return that.$.listBox.getItem(value);
    }

    /**
    * Returns an array with the items from the list.
    */
    get items() {
        const that = this;

        if (!that.$ || !that.$.listBox) {
            return;
        }

        return that.$.listBox.items;
    }

    /**
    * Returns the focused item;
    */
    get _focusedItem() {
        const that = this;

        if (!that.$ || !that.$.listBox) {
            return;
        }

        return that.$.listBox._focusedItem;
    }

    /**
    * Inserts an item at a specified position.
    * @param {number} index The index at which a new item will be inserted.
    * @param {string/object/array} item Describes the properties of the item that will be inserted. 
     If string is passed, it will be processed as the label for the new item. 
     If an object is passed, it must contain valid properties for the item, e.g. { label, value, group, disabled }.
     If an array is passed, multiple items will be inserted in the list with the coressponding settings.
    */
    insert(index, item) {
        const that = this;

        if (!that.$.listBox) {
            return;
        }

        that.$.listBox.insert(index, item);

        //Add the item to the ActionButton if the item is selected.
        that._applySelection()

        if (that._dropDownSize && that._dropDownSize.height === 'auto') {
            that._setDropDownSize();
        }
    }

    /**
    * Inserts a jqx-list-item to the DropDownList at a certain position.
    */
    insertBefore(newNode, referenceNode) {
        const that = this;

        if (!that.isCompleted) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!newNode || !referenceNode) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'insertBefore', node: 'newNode/referenceNode' }));
            return;
        }

        if (!that.$.listBox) {
            return;
        }

        that.$.listBox.insertBefore(newNode, referenceNode);

        if (that._dropDownSize && that._dropDownSize.height === 'auto') {
            that._setDropDownSize();
        }
    }

    /**
    * Shows the drop down List.
    */
    open() {
        const that = this,
            getFirstFocusableItem = function () {
                for (let i = 0; i < that.items.length; i++) {
                    if (!that.items[i].disabled) {
                        return that.items[i];
                    }
                }
            };

        if (that.disabled || !that.offsetHeight) {
            return;
        }

        if (!that.$dropDownContainer.hasClass('jqx-visibility-hidden')) {
            return;
        }

        if (that.$dropDownContainer.hasClass('not-in-view')) {
            that.$dropDownContainer.removeClass('not-in-view');
        }

        that.$.dropDownContainer.style.transition = null;

        if (that.dropDownAppendTo && that.dropDownAppendTo.length > 0) {
            const rect = that.getBoundingClientRect();

            // handles the case, when the dropdown is opened, while it is still part of the dropdownlist's tree. 
            if (that.$.container.contains(that.$.dropDownContainer)) {
                let iterations = 0;
                const interval = setInterval(function () {
                    const rect = that.getBoundingClientRect();

                    iterations++;

                    if (rect.top === that._positionTop && iterations < 10) {
                        return;
                    }

                    that.open();
                    clearInterval(interval);
                    that._positionTop = rect.top;
                }, 100);

                return;
            }
            else if (rect.top !== that._positionTop) {
                that._positionTop = rect.top;
            }
        }

        const isOpeningEventPrevented = that.$.fireEvent('opening').defaultPrevented;

        if (isOpeningEventPrevented) {
            return;
        }

        that.opened = true;

        that._positionDetection.placeOverlay();
        that._positionDetection.checkBrowserBounds('vertically');
        that._positionDetection.positionDropDown();
        that._positionDetection.checkBrowserBounds('horizontally');

        that.$dropDownContainer.removeClass('jqx-visibility-hidden');
        that.$.fireEvent('open');

        if (that.$.dropDownButton) {
            if (that.dropDownOpenMode === 'dropDownButton') {
                that.$.dropDownButton.setAttribute('selected', '');
            }
            else {
                that.$.dropDownButton.removeAttribute('selected');
            }
        }

        if (that.$.listBox && !that._focusedItem || (that._focusedItem && !that._focusedItem._focused)) {
            if (that.selectedIndexes.length > 0) {
                that._focus(that.items[that.selectedIndexes[0]]);
            }
            else {
                that._focus(getFirstFocusableItem);
            }
        }

        if (that.$.input && !JQX.Utilities.Core.isMobile) {
            that.$.input.focus();
        }
    }

    /**
    * DropDownList ready method.
    */
    ready() {
        super.ready();

        const that = this;

        if (that.$.dropDownContainer) {
            that._positionDetection = new JQX.Utilities.PositionDetection(that, that.$.dropDownContainer, that.$.container, 'close');
            that._positionDetection.getDropDownParent(true);
            that._positionDetection.setDropDownPosition();
            that._calculateDropDownSize();
            that.$.dropDownContainer.setAttribute('resize-mode', that.resizeMode);

            if (that.resizeIndicator) {
                that.$.dropDownContainer.setAttribute('resize-indicator', '');
            }

            that._positionDetection.handleAutoPositioning();
        }

        if (that.opened) {
            that.open();
        }

        //Used for the scroll handling
        that._positionTop = that.getBoundingClientRect().top;



        that._edgeMacFF = JQX.Utilities.Core.Browser.Edge ||
            JQX.Utilities.Core.Browser.Firefox && navigator.platform.toLowerCase().indexOf('mac') !== -1;

        if (that._edgeMacFF && that.hasAnimation && that.$.dropDownContainer) {
            that.$dropDownContainer.addClass('not-in-view');
        }

        that._createElement();
    }

    /**
    * Removes an item from the list box.
    * @param {number} index The index at which a new item will be inserted.
    */
    remove(index) {
        const that = this;

        if (!that.$.listBox) {
            return;
        }

        that.$.listBox.remove(index);

        //Remove the item from the ActionButton if its present.
        that._applySelection();

        if (that._dropDownSize && that._dropDownSize.height === 'auto') {
            that._setDropDownSize();
        }
    }

    /**
    * Removes a jqx-list-item frop the DropDownList.
    */
    removeChild(node) {
        const that = this;

        if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!node || !(node instanceof JQX.ListItem)) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'removeChild', node: 'node' }));
            return
        }

        that.$.listBox.removeChild(node);

        if (that._dropDownSize && that._dropDownSize.height === 'auto') {
            that._setDropDownSize();
        }
    }

    /**
    * Selects an item by its HTML Element or Value.
    */
    select(item) {
        const that = this;

        if (!that.$.listBox) {
            return;
        }

        that.$.listBox.select(item);
    }

    /**
    * Sets tab index 
    */
    _setFocusable() {
        const that = this;

        if (that.disabled || that.unfocusable) {
            that.removeAttribute('tabindex');
            that.$.actionButton.removeAttribute('tabindex');
            that.$.dropDownButton.removeAttribute('tabindex');
            return;
        }

        let index = that.tabIndex > 0 ? that.tabIndex : 0;

        if (that.dropDownOpenMode === 'dropDownButton') {
            that.removeAttribute('tabindex');
            that.$.actionButton.setAttribute('tabindex', index);
            that.$.dropDownButton.setAttribute('tabindex', index);
        }
        else {
            that.$.actionButton.removeAttribute('tabindex');
            that.$.dropDownButton.removeAttribute('tabindex');
            that.tabIndex = index;
        }
    }

    /**
    * Checks for missing modules.
    */
    static get requires() {
        return {
            'JQX.ListBox': 'jqxlistbox.js'
        }
    }

    /**
    * Unselects an item by its HTML Element or Value.
    */
    unselect(item) {
        const that = this;

        if (!that.$.listBox) {
            return;
        }

        that.$.listBox.unselect(item);
    }

    /**
    * Updates an item from the list.
    * @param {number} index The index at which a new item will be inserted.
    * @param {string/object} settings The settings that will be applied to the item that will be updated.
      If a string is passed, it will be considered as the new label for the item.
      If an object is passed, it will should describe valid properties for the item, e.g. { label, value, group, disabled}.
    */
    update(index, details) {
        const that = this;

        if (!that.$.listBox) {
            return;
        }

        that.$.listBox.update(index, details);
        that._applySelection();
    }

    /**
     * Resizebar mousemouve event handler. 
     * @param {any} event
     */
    _resizeBarMoveHandler(event) {
        //Used to prevent page scrolling on iOS devices
        if (event.originalEvent.type === 'touchmove') {
            event.originalEvent.preventDefault();
        }
    }

    /**
     * Creates a token for the selected items
     */
    _createToken() {
        const that = this;
        let icon;
        const fragment = document.createDocumentFragment(),
            lastSelectedIndex = that.selectedIndexes[that.selectedIndexes.length - 1];

        if (that.selectionDisplayMode === 'plain' && (that.selectionMode === 'one' || that.selectionMode === 'zeroOrOne' || that.selectionMode === 'radioButton')) {
            icon = '';
        }
        else {
            if (that.selectionDisplayMode === 'tokens') {
                if (that.selectedIndexes.length === 1 && (['oneOrManyExtended', 'oneOrMany', 'one', 'radioButton'].indexOf(that.selectionMode) > -1)) {
                    icon = '';
                }
                else {
                    icon = '&#10006';
                }
            }
            else {
                icon = that.selectedIndexes.length === 1 ? '' : ',';
            }
        }

        const selectedIndexes = that.selectedIndexes,
            items = that.$.listBox._items;

        for (let i = 0; i < selectedIndexes.length; i++) {
            const selectedIndex = selectedIndexes[i];

            if (items[selectedIndex]) {
                fragment.appendChild(that._applyTokenTemplate(items[selectedIndex][that.inputMember],
                    that.selectionDisplayMode !== 'tokens' && selectedIndex === lastSelectedIndex ? '' : icon));
            }
        }

        return fragment;
    }
    /**
    * Sets the selection mode for the DropDownList.
    */
    _applySelection() {
        const that = this;

        if (that.selectionDisplayMode === 'placeholder' || that.selectedIndexes.length === 0) {
            that.$.actionButton.innerHTML = that.placeholder;
            return;
        }

        if (!that.$.listBox._items || that.$.listBox._items.length === 0) {
            return;
        }

        that.$.actionButton.innerHTML = '';
        that.$.actionButton.appendChild(that._createToken());
    }

    /**
    * Applies a template to the tokens
    */
    _applyTokenTemplate(label, icon) {
        const that = this;
        const element = document.createElement('span'),
            token = function () {
                return '<span class=\'jqx-drop-down-list-selection-label\'>' + label +
                    '</span><span class=\'jqx-drop-down-list-unselect-button\'>' + icon + '</span>';
            };

        element.classList.add('jqx-token');

        if (that._tokenTemplate) {
            let content = document.importNode(that._tokenTemplate.content, true);
            const childrenCount = content.childNodes.length,
                regex = /{{\w+}}/g;
            let bindingString;

            for (let i = 0; i < childrenCount; i++) {
                bindingString = regex.exec(content.childNodes[i].innerHTML);

                if (bindingString) {
                    content.childNodes[i].innerHTML = content.childNodes[i].innerHTML.replace(bindingString[0], token());
                }

                if (content.childNodes[i].outerHTML) {
                    element.innerHTML += content.childNodes[i].outerHTML;
                }
            }
        }
        else if (typeof that.tokenTemplate === 'function') {
            that.tokenTemplate(element, { label: label, iconSeparator: icon });
        }
        else {
            element.innerHTML = token();
        }

        return element;
    }

    /**
     * BindingComplete event Handler. When the dataSource or size of listBox is changed.
     */
    _bindingCompleteHandler() {
        const that = this;

        if (!that.$.listBox) {
            return;
        }

        requestAnimationFrame(() => {
            that._setDropDownSize();
            that._positionDetection.checkBrowserBounds();
        });
    }

    /**
    * Action/DropDown button mouse down event handler.
    */
    _buttonsDownHandler(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        if (that.hasRippleAnimation) {
            if (!that.$.buttonsContainer || that.dropDownOpenMode === 'dropDownButton') {
                JQX.Utilities.Animation.Ripple.animate(event.target, event.pageX, event.pageY);
            }
            else {
                const target = that.$.buttonsContainer;

                target.firstElementChild.noRipple = true;
                JQX.Utilities.Animation.Ripple.animate(target, event.pageX, event.pageY);
                target.firstElementChild.noRipple = false;
            }
        }

        that._preventsSelectStart = true;

        if (that.dropDownOpenMode === 'dropDownButton' && event.target === that.$.actionButton) {
            that.$.actionButton.setAttribute('active', '');
        }

        //Used to handle closing after blur event is thrown
        if (that.opened) {
            that._preventDropDownClose = true;
        }
    }

    /**
    * DropDownList container mouse enter/leave events handler.
    */
    _buttonsMouseEventsHandler(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        if (event.type === 'mouseenter') {
            that.setAttribute('hover', '');
            event.target.setAttribute('hover', '');
        }
        else {
            that.removeAttribute('hover');
            event.target.removeAttribute('hover');
        }
    }

    /**
    * Calculates the dropDownSize and creates an object with the sizes
    */
    _calculateDropDownSize() {
        const that = this;

        that._dropDownSize = {};

        const computedStyle = window.getComputedStyle(that.$.dropDownContainer);
        const topBorder = parseFloat(computedStyle.getPropertyValue('border-top-width').trim()),
            bottomBorder = parseFloat(computedStyle.getPropertyValue('border-bottom-width').trim()),
            topMargin = parseFloat(computedStyle.getPropertyValue('margin-top').trim()),
            bottomMargin = parseFloat(computedStyle.getPropertyValue('margin-bottom').trim()),
            topPaddinng = parseFloat(computedStyle.getPropertyValue('padding-top').trim()),
            bottomPaddinng = parseFloat(computedStyle.getPropertyValue('padding-bottom').trim());

        if (JQX.Utilities.Core.CSSVariablesSupport()) {
            that._dropDownSize.width = computedStyle.getPropertyValue('--jqx-drop-down-list-drop-down-width').trim();
            that._dropDownSize.height = computedStyle.getPropertyValue('--jqx-drop-down-list-drop-down-height').trim();
        }

        if (!that._dropDownSize.width || that._dropDownSize.width.indexOf('initial') > -1) {
            that._dropDownSize.width = that.offsetWidth;
        }

        if (!that._dropDownSize.height) {
            that._dropDownSize.height = 'auto';
        }

        that._dropDownSize.minHeight = parseFloat(computedStyle.getPropertyValue('min-height').trim());
        that._dropDownSize.maxHeight = parseFloat(computedStyle.getPropertyValue('max-height').trim());
        that._dropDownSize.borderWidth = (isNaN(topBorder) ? 0 : topBorder) + (isNaN(bottomBorder) ? 0 : bottomBorder);
        that._dropDownSize.paddingWidth = (isNaN(topPaddinng) ? 0 : topPaddinng) + (isNaN(bottomPaddinng) ? 0 : bottomPaddinng);
        that._dropDownSize.marginWidth = (isNaN(topMargin) ? 0 : topMargin) + (isNaN(bottomMargin) ? 0 : bottomMargin);
    }



    /**
    * Initializes the element.
    */
    _createElement() {
        const that = this;

        that._tokenTemplate = that._validateTemplate(that.tokenTemplate);

        //Set properties.
        that._applySelection();
        that._setDropDownSize();
        that._setFocusable();

        //Flag indicator for the ripple effect. Used to append the ripple to that specific element, not his firstElementChild like it's done usually.
        //Used in class Ripple, method animate() in jqxelement.
        that.$.arrow.noRipple = true;
    }

    /**
    * Document mouse down event handler.
    */
    _documentDownHandler(event) {
        const that = this;

        if (that.disabled || that.readonly) {
            return;
        }

        let target = event.originalEvent.target;

        if (target === that._overlay) {
            that._overlayDown = true;
        }

        if (that.enableShadowDOM) {
            target = event.originalEvent.composedPath()[0];

            let rootElement = target.getRootNode().host;

            while (rootElement) {
                if (rootElement.closest('.jqx-drop-down-container') === that.$.dropDownContainer) {
                    that._isDropDownClicked = true;
                }

                rootElement = rootElement.getRootNode().host;
            }
        }
        else {
            that._isDropDownClicked = target.closest('.jqx-drop-down-container') === that.$.dropDownContainer;
        }

        that._buttonClicked = target.closest('.jqx-action-button') || target.closest('.jqx-drop-down-button');

        if (that.$.listBox) {
            let listItem = target.closest('jqx-list-item');

            if (!that.$.listBox.contains(listItem)) {
                listItem = undefined;
            }

            if (that.hasRippleAnimation && listItem) {
                JQX.Utilities.Animation.Ripple.animate(listItem, event.pageX, event.pageY);
            }

            if (listItem || target === that.$.listBox.$.filterInput || target.closest('.jqx-token')) {
                that._preventDropDownClose = true;
            }
        }

        if (that._isDropDownClicked) {
            that._preventDropDownClose = true;
        }

        if (target !== that.$.resizeBar || that.resizeMode === 'none') {
            return;
        }

        if (!that._resizeDetails) {
            that._resizeDetails = {};
        }

        const computedStyle = that.$.dropDownContainer.getBoundingClientRect();

        that._resizeDetails.started = true;
        that._resizeDetails.x = event.pageX;
        that._resizeDetails.y = event.pageY;
        that._resizeDetails.width = that.$.dropDownContainer.offsetWidth;
        that._resizeDetails.height = that.$.dropDownContainer.offsetHeight;
        that._resizeDetails.offsetXL = event.clientX - computedStyle.left;
        that._resizeDetails.offsetXR = computedStyle.left + that.$.dropDownContainer.offsetWidth - event.clientX;
        that._resizeDetails.offsetY = computedStyle.top + that.$.dropDownContainer.offsetHeight - event.clientY;
        that._resizeDetails.offsetYtop = event.clientY - computedStyle.top;
        that._preventDropDownClose = true;
    }


    /**
     * Document Move Event handler
     * @param {any} event
     */
    _documentMoveHandler(event) {
        const that = this,
            target = that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target;

        if (that.dropDownOpenMode === 'auto' && that.dropDownAppendTo !== null) {
            if (that.contains(target) || that.$.dropDownContainer.contains(target)) {
                that._isElementHovered = true;
            }
            else {
                that._isElementHovered = false;
                that._autoClose();
            }
        }

        if (!that._resizeDetails || (that._resizeDetails && !that._resizeDetails.started)) {
            return;
        }

        that.setAttribute('resizing', '');

        if (!that._resizeDetails.resizeEventFired) {
            that.$.fireEvent('resizeStart', {
                'position': { left: event.pageX, top: event.pageY }
            });

            that._resizeDetails.resizeEventFired = true;
        }

        const doc = document.documentElement,
            computedStyle = that.$.dropDownContainer.getBoundingClientRect(),
            dropDownStyle = that.getBoundingClientRect(),
            direction = that.$.dropDownContainer.hasAttribute('top') ? 'top' : 'bottom';
        let size;

        function verticalResize() {
            size = event.pageY - that._resizeDetails.y;

            if (direction === 'bottom') {
                //6 is the margin of document.body, we don't want scrollbars to be shown
                that._resizeDetails.height = Math.min(doc.clientHeight - computedStyle.top - 6,
                    Math.max(0, that._resizeDetails.height + size));

                that._resizeDetails.y = Math.max(computedStyle.top + doc.scrollTop - that._resizeDetails.offsetY,
                    Math.min(doc.clientHeight + doc.scrollTop - that._resizeDetails.offsetY * 1.5, event.pageY));
            }
            else {
                that._resizeDetails.height = Math.min(that._dropDownSize.maxHeight, Math.max(0, Math.min(dropDownStyle.top, that._resizeDetails.height - size)));

                size = Math.max(0, computedStyle.top + (computedStyle.height - Math.max(that._dropDownSize.minHeight, that._resizeDetails.height)));

                if (that.dropDownAppendTo && that.dropDownAppendTo.length > 0) {
                    const margin = Math.abs(parseFloat(getComputedStyle(that.$.dropDownContainer).getPropertyValue('margin-bottom'))) || 0;

                    that.$.dropDownContainer.style.top = that.dropDownAppendTo && that.dropDownAppendTo.length > 0 ? (margin + size) + 'px' : '';
                }

                const minYCondition = dropDownStyle.top + doc.scrollTop + that._resizeDetails.offsetYtop;

                that._resizeDetails.y = Math.max(that._resizeDetails.offsetYtop,
                    Math.min(minYCondition, Math.max(minYCondition - that._dropDownSize.maxHeight, event.pageY)));
            }

            that.$.dropDownContainer.style.height = that._resizeDetails.height + 'px';
        }

        function horizontalResize() {
            //Resize only from corner
            //if (that._resizeDetails.offsetXR > 20) {
            //    return;
            //}

            size = event.pageX - that._resizeDetails.x;

            //6 is the margin of document.body, we don't want scrollbars to be shown
            that._resizeDetails.width = Math.min(doc.clientWidth - computedStyle.left - 6,
                Math.max(0, that._resizeDetails.width + size));

            that.$.dropDownContainer.style.width = that._resizeDetails.width + 'px';

            that._resizeDetails.x = Math.max(computedStyle.left + doc.scrollLeft - that._resizeDetails.offsetXR,
                Math.min(doc.clientWidth + doc.scrollLeft - that._resizeDetails.offsetXR * 1.5, event.pageX));
        }

        switch (that.resizeMode) {
            case 'vertical':
                verticalResize();
                break;
            case 'horizontal':
                horizontalResize();
                break;
            case 'both':
                horizontalResize();
                verticalResize();
                break;
        }
    }

    /**
    * Document Up handler.
    */
    _documentUpHandler(event) {
        const that = this;

        that.$.actionButton.removeAttribute('active');

        if (that._resizeDetails && that._resizeDetails.started) {
            that._resizeDetails.started = that._resizeDetails.resizeEventFired = false;
            that.removeAttribute('resizing');
            that._preventDropDownClose = false;
            that.focus();

            that.$.fireEvent('resizeEnd', {
                'position': { left: event.pageX, top: event.pageY }
            });
            return;
        }

        if (that.disabled || that._isDropDownClicked || that.readonly) {
            delete that._isDropDownClicked;
            return;
        }

        if (that._overlayDown) {
            that.close();
            delete that._overlayDown;
            return;
        }

        let target = event.originalEvent.target,
            rootElement = target.closest ? target.closest('jqx-drop-down-list') : undefined;

        if (that.enableShadowDOM) {
            target = event.originalEvent.composedPath()[0];
            rootElement = target.getRootNode().host;
        }

        that._preventsSelectStart = false;

        if (typeof (target) === 'undefined' || target === that.$.resizeBar) {
            return;
        }

        if (that.selectionDisplayMode === 'tokens' && target.classList.contains('jqx-drop-down-list-selection-label') && rootElement === that) {
            if (that.dropDownOpenMode !== 'none') {
                that.open();
            }

            let item = that.$.listBox._items.filter(item => item[that.inputMember].toString() === target.textContent)[0];

            //Scroll to that item and focus it.
            that.$.listBox._scrollView.scrollTop = item.offsetTop;
            that._focus(item);
            return;
        }

        if (that.selectionDisplayMode === 'tokens' && target.classList.contains('jqx-drop-down-list-unselect-button') && rootElement === that) {
            if (that.selectedIndexes.length === 1 && ['zeroOrMany', 'zeroOrOne', 'checkBox'].indexOf(that.selectionMode) < 0) {
                return;
            }

            that.unselect(that.$.listBox._items.filter(item => item[that.inputMember].toString() === target.previousElementSibling.textContent)[0]);
            return;
        }

        const isActionButtonPressed = target.closest('.jqx-action-button');

        if (that._buttonClicked) {
            if (that.dropDownOpenMode === 'dropDownButton' && isActionButtonPressed && that._buttonClicked === that.$.actionButton) {
                that.$.fireEvent('actionButtonClick');
            }
            else if (target.closest('.jqx-drop-down-button') === that._buttonClicked || isActionButtonPressed === that._buttonClicked) {
                that.$.fireEvent('dropDownButtonClick');
            }
        }

        that._buttonClicked = undefined;

        if (isActionButtonPressed === that.$.actionButton || target.closest('.jqx-drop-down-button') === that.$.dropDownButton) {
            if (that.dropDownOpenMode === 'dropDownButton' && isActionButtonPressed === that.$.actionButton) {
                that.close();
                return;
            }

            //Open/Close the dropDownList
            that.$dropDownContainer.hasClass('jqx-visibility-hidden') && that.dropDownOpenMode !== 'none' ? that.open() : that.close();
            return;
        }

        target = that._getUpEventTarget(target);

        if (target === undefined) {
            return;
        }

        if (target !== 'dropDownContainer' && target !== 'item' || target === 'item' && that.selectionMode !== 'checkBox' && that.selectionMode.indexOf('Many') < 0) {
            that.close();
        }
    }

    /**
    * DragStarted Event Handler
    * @param {any} event
    */
    _dragStartHandler(event) {
        const that = this;

        if (that._resizeDetails && that._resizeDetails.started) {
            event.preventDefault();
        }
    }

    /**
    * Dropdown transitionend handler.
    */
    _dropDownTransitionendHandler() {
        const that = this;

        if (that._edgeMacFF && !that.opened && that.hasAnimation) {
            that.$.dropDownContainer.style.top = that.$.dropDownContainer.style.left = '';
            that.$dropDownContainer.addClass('not-in-view');
        }
    }

    /**
    * Focuses an item. Accepts a JQX.ListItem element or a string, representing the value of an item.
    */
    _focus(item) {
        this.$.listBox._focus(item);
    }

    /**
     * Element/DropDownButton blur event handler
     * @param {any} event
     */
    _blurEventHandler() {
        const that = this;

        if (that.$.dropDownButton) {
            that.removeAttribute('focus');
            that.$.dropDownButton.removeAttribute('focus');
        }

        if (that.$.actionButton) {
            that.removeAttribute('focus');
            that.$.actionButton.removeAttribute('focus');
        }

        //NOT Applicable to jqxDropDownButton, because the contento of the popup is focusable !
        if (that.nodeName && that.nodeName === 'JQX-DROP-DOWN-LIST' && !that._preventDropDownClose) {
            that.close();
        }
    }

    /**
     * Element focus event handler
     */
    _focusEventHandler() {
        const that = this;

        if (that.$.dropDownButton) {
            that.setAttribute('focus', '');
            that.$.dropDownButton.setAttribute('focus', '');
        }

        if (that.$.actionButton) {
            that.setAttribute('focus', '');
            that.$.actionButton.setAttribute('focus', '');
        }

        that.removeAttribute('drop-down-button-focus');
        that.removeAttribute('action-button-focus');
    }

    /**
     * DropDownList drop-down-button and action-button focus/blur handlers
     * @param {any} event
     */
    _buttonsFocusHandler(event) {
        const that = this;

        if (event.target === that.$.dropDownButton) {
            if (event.type === 'focus') {
                that.setAttribute('drop-down-button-focus', '');
            }
            else {
                that.removeAttribute('drop-down-button-focus');

                //NOT Applicable to jqxDropDownButton, because the contento of the popup is focusable !
                if (that.nodeName && that.nodeName === 'JQX-DROP-DOWN-LIST' && !that._preventDropDownClose) {
                    that.close();
                }
            }
        }
        else {
            event.type === 'focus' ? that.setAttribute('action-button-focus', '') : that.removeAttribute('action-button-focus');
        }
    }

    /**
     * Gets the target of a document up event.
     */
    _getUpEventTarget(originalTarget) {
        const that = this;
        let target = originalTarget;

        while (target) {
            if (target instanceof JQX.ListItem && target.ownerListBox === that.$.listBox) {
                if (target.unselectable || target.disabled) {
                    return;
                }

                target = 'item';
                break;
            }
            else if (target === that.$.dropDownContainer) {
                target = 'dropDownContainer';
                break;
            }

            target = target.parentElement;
        }

        if (that.enableShadowDOM && target !== null) {
            target = originalTarget.getRootNode().host;

            while (target) {
                if (target === that.$.dropDownContainer) {
                    target = 'dropDownContainer';
                    break;
                }

                target = target.parentElement;
            }
        }

        return target;
    }

    /**
    * DropDown keydown event handler.
    */
    _keyDownHandler(event) {
        const that = this,
            activeElement = that.enableShadowDOM ? (that.shadowRoot.activeElement || document.activeElement) : document.activeElement,
            target = that.enableShadowDOM ? event.composedPath()[0] : event.target;

        if (that.$.listBox && target === that.$.listBox.$.filterInput ||
            (activeElement !== that && activeElement !== that.$.dropDownButton && activeElement !== that.$.actionButton)) {
            return;
        }

        switch (event.key) {
            case 'Enter':
            case ' ':
                target.setAttribute('active', '');
                event.preventDefault();

                if (target !== that.$.actionButton) {
                    that._keyPressed = true;

                    if (that.opened) {
                        if (that._focusedItem) {
                            that.select(that._focusedItem);
                        }

                        if ((event.key === 'Enter' && ['none'].indexOf(that.selectionMode) < 0) || (event.key === ' ' && ['none', 'one', 'radioButton'].indexOf(that.selectionMode) > -1)) {
                            that.close();
                        }
                    }
                    else if (!that.opened && !that.readonly && that.dropDownOpenMode !== 'none') {
                        that.open();
                    }
                }

                break;
            case 'End':
            case 'Home':
            case 'PageUp':
            case 'PageDown':
            case 'ArrowUp':
            case 'ArrowDown':
                if (that.readonly) {
                    return;
                }

                if (event.altKey) {
                    that._keyPressed = false;
                    that.$dropDownContainer.hasClass('jqx-visibility-hidden') ? that.open() : that.close();
                    return;
                }

                event.preventDefault();
                that.$.listBox._handleKeyStrokes(event.key);
                break;
            case 'Escape':
                event.preventDefault();
                that.close();
                break;
            default:
                if (that.readonly) {
                    return;
                }

                if (that.selectionMode === 'oneOrManyExtended') {
                    that.$.listBox._keysPressed[event.key] = true;
                }

                that.$.listBox._applyIncrementalSearch(event.key);
                break;
        }
    }

    /**
    * DropDown key up event handler.
    */
    _keyUpHandler(event) {
        const that = this,
            target = that.enableShadowDOM ? event.composedPath()[0] : event.target;

        if (that.$.listBox && target === that.$.listBox.$.filterInput) {
            return;
        }

        if (event.key === 'Enter' || event.key === ' ') {
            target.removeAttribute('active');

            if (!that.$dropDownContainer.hasClass('jqx-visibility-hidden')) {
                that._keyPressed = false;
                //that.$.listBox.focus();
            }
        }

        if (that.$.listBox && that.selectionMode === 'oneOrManyExtended') {
            that.$.listBox._keysPressed[event.key] = false;
        }
    }

    /**
    * DropDownList Change event handler.
    */
    _listBoxChangeHandler(event) {
        const that = this;

        if ((that.dropDownAppendTo && that.dropDownAppendTo.length > 0) || that.enableShadowDOM) {
            that.$.fireEvent('change', event.detail);
        }

        if (that.autoComplete === 'list' && event.detail) {
            const lastSelectedItem = that.$.listBox._items[event.detail.index];

            that._lastSelectedItem = lastSelectedItem ? lastSelectedItem : undefined;
        }

        that._applySelection(that.selectionMode, event.detail);
    }

    /**
     * ListBox itemClick event handler
     * @param {any} event
     */
    _listBoxItemClickHandler(event) {
        const that = this;

        if ((that.dropDownAppendTo && that.dropDownAppendTo.length > 0) || that.enableShadowDOM) {
            that.$.fireEvent(event.type, event.detail);
        }

        if (that.selectionMode !== 'checkBox' && that.selectionMode.indexOf('Many') < 0) {
            that.close();
        }

        if (that.nodeName === 'JQX-COMBO-BOX' && !JQX.Utilities.Core.isMobile) {
            that.$.input.focus();
        }

        delete that._isDropDownClicked;
    }

    /**
    * DropDownList key down handler.
    */
    _listBoxKeyDownHandler(event) {
        const that = this;

        if (event.key === 'Enter') {
            that.close();
            that.dropDownOpenMode === 'dropDownButton' ? that.$.dropDownButton.focus() : that.focus();
            event.stopPropagation();
            return;
        }

        if (event.key === 'Escape') {
            that.close();
            return;
        }
    }

    /**
    * Element container mouse enter event handler.
    */
    _mouseEnterHandler() {
        const that = this;

        that._isElementHovered = true;

        if (that.tagName.indexOf('JQX-DROP-DOWN-') > -1 && that.dropDownOpenMode === 'auto' && !that.disabled && !that.readonly) {
            that.open();
        }
    }

    /**
    * Element container mouse leave event handler.
    */
    _mouseLeaveHandler() {
        const that = this;

        that.removeAttribute('hover');
        that._isElementHovered = false;

        if (that.dropDownOpenMode === 'auto' && !that.disabled && !that.readonly) {
            that._autoClose()
        }
    }

    /**
    * Mouse wheel event handler.
    */
    _mouseWheelHandler(event) {
        const that = this;

        if (that.disabled || that.readonly || (that.items && that.items.length === 0)) {
            return;
        }

        if (that.$dropDownContainer && !that.$dropDownContainer.hasClass('jqx-visibility-hidden')) {
            return;
        }

        if (that.$.listBox) {
            event.preventDefault();
            that.$.listBox._handleKeyStrokes(event.deltaY > 0 ? 'ArrowDown' : 'ArrowUp');
        }
    }

    /**
     * Automatically closes the dropdown.
     */
    _autoClose() {
        const that = this;

        that._autoCloseTimeout = setTimeout(function () {
            if (!that._isElementHovered) {
                that.close();
            }

            clearTimeout(that._autoCloseTimeout);
        }.bind(that), that.autoCloseDelay);
    }

    /**
    * Validates the value of the property
    * @param {any} oldValue - the old value
    * @param {any} value - the new value
    */
    _propertyValidator(oldValue, newValue) {
        if (typeof newValue !== 'number' && typeof newValue !== 'string') {
            return oldValue;
        }

        return newValue;
    }

    /**
     * Resize handler - recalculate the size of the popup if the element is initialized with a different size.
     */
    _resizeHandler() {
        const that = this;

        if (that.resizeMode === 'none') {
            that._calculateDropDownSize();
            that._setDropDownSize();
        }
    }

    /**
    * Document select start event handler.
    */
    _selectStartHandler(event) {

        if (this._preventsSelectStart) {
            event.preventDefault();
        }
    }

    /**
    * Set DropDown Size.
    */
    _setDropDownSize() {
        const that = this;

        if (!that._dropDownSize) {
            that._calculateDropDownSize();
        }

        ['dropDownMinWidth', 'dropDownMinHeight', 'dropDownMaxWidth', 'dropDownMaxHeight'].forEach((name) => {
            that.$.dropDownContainer.style[name.replace('dropDown', '').replace(/^./, 'm')] = that[name] ? that[name] + (that[name].toString().endsWith('%') ? '%' : 'px') : null;
        });

        if (that.dropDownWidth) {
            if (that.dropDownWidth !== 'auto') {
                that.$.dropDownContainer.style.width = (that.dropDownWidth === 'initial' ? that.offsetWidth : parseFloat(that.dropDownWidth)) + 'px';
            }
            else {
                that.$.dropDownContainer.style.width = 'auto';
                if (that.$.listBox) {
                    let horizontalOffset = 2 + 2 * parseInt(window.getComputedStyle(that.$.listBox.$.itemsContainer).getPropertyValue('--jqx-list-item-horizontal-offset'));

                    that.$.dropDownContainer.style.width = horizontalOffset + that.$.listBox._scrollWidth + 'px';
                }
            }
        }
        else {
            that.$.dropDownContainer.style.width = that._dropDownSize.width === 'auto' ? 'auto' : (parseFloat(that._dropDownSize.width) || 0) + 'px';
        }

        if (that.dropDownHeight && that.dropDownHeight !== 'auto') {
            that.$.dropDownContainer.style.height = parseFloat(that.dropDownHeight) + ((that.dropDownHeight + '').indexOf('%') > -1 ? '%' : 'px');
        }
        else {
            if (that.$.listBox && (that._dropDownSize.height === 'auto' || that.dropDownHeight === 'auto')) {
                that.$.dropDownContainer.style.height = '';

                let verticalOffset = 2 * parseInt(window.getComputedStyle(that.$.listBox.$.itemsContainer).getPropertyValue('--jqx-list-item-vertical-offset'));

                if (isNaN(verticalOffset)) {
                    verticalOffset = 6;
                }

                let dropDownHeight = verticalOffset;

                if (that.$.listBox.items.length > 0) {
                    that.$.listBox.items.map(item => dropDownHeight += item.height || item.offsetHeight);
                }

                dropDownHeight = dropDownHeight + that._dropDownSize.paddingWidth + that._dropDownSize.borderWidth;

                that.$.dropDownContainer.style.height = dropDownHeight + 'px';
            }
            else {
                that.$.dropDownContainer.style.height = that._dropDownSize.height;
            }
        }

        if (that.$.listBox) {
            that.$.listBox._refreshLayout();
        }
    }

    /**
     * Style changed event handler
     * @param {any} event
     */
    _styleChangedHandler(event) {
        const that = this;

        if (that.dropDownAppendTo && that.dropDownAppendTo.length > 0) {
            const styleProperties = event.detail.styleProperties,
                fontProperties = ['font-size', 'font-family', 'font-style', 'font-weight'];

            for (let s = 0; s < fontProperties.length; s++) {
                if (styleProperties[fontProperties[s]]) {
                    that.$.dropDownContainer.style[fontProperties[s]] = styleProperties[fontProperties[s]].value;
                }
            }

        }

        if (that._dropDownSize.height === 'auto') {
            that._setDropDownSize();
        }
    }

    /**
    * Checks for HTMLTemplate support and returns it's content.
    */
    _validateTemplate(template) {
        const that = this;

        if (!template) {
            return;
        }

        if (typeof template === 'function') {
            return;
        }

        if (!('content' in document.createElement('template'))) {
            that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() }));
            return;
        }

        if (!(template instanceof HTMLTemplateElement)) {
            template = document.getElementById(template);
        }

        if (template === null || !('content' in template)) {
            that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: 'tokenTemplate' }));
            return;
        }

        return template;
    }
});

/**
* ComboBox custom element.
*/
JQX('jqx-combo-box', class ComboBox extends JQX.DropDownList {

    /** 
    * ComboBox's properties 
    */
    static get properties() {
        return {
            'autoComplete': {
                allowedValues: ['none', 'manual', 'auto', 'inline', 'list'],
                type: 'string',
                value: 'none'
            },
            'autoCompleteDelay': {
                value: 700,
                type: 'number'
            },
            'autoOpenShortcutKey': {
                value: [],
                type: 'array'
            },
            'escKeyMode': {
                allowedValues: ['none', 'previousValue', 'clearValue'],
                type: 'string',
                value: 'none'
            },
            'minLength': {
                type: 'number',
                value: 2
            },
            'value': {
                value: '',
                type: 'string'
            }
        }
    }

    /**
    * ComboBox's event listeners.
    */
    static get listeners() {
        return {
            'input.focus': '_inputFocusHandler',
            'input.blur': '_inputFocusHandler',
            'dropDownButton.focus': '_dropDownButtonFocusHandler',
            'dropDownButton.blur': '_dropDownButtonFocusHandler',
            'input.change': '_inputChangeEventHandler',
            'input.mouseenter': '_buttonsMouseEventsHandler',
            'input.mouseleave': '_buttonsMouseEventsHandler',
            'document.down': '_documentDownHandler',
            'document.up': '_documentUpHandler',
            'document.selectstart': '_selectStartHandler',
            'dropDownButton.down': '_buttonsDownHandler',
            'dropDownButton.mouseenter': '_buttonsMouseEventsHandler',
            'dropDownButton.mouseleave': '_buttonsMouseEventsHandler',
            'keydown': '_keyDownHandler',
            'keyup': '_keyUpHandler',
            'listBox.change': '_listBoxChangeHandler',
            'listBox.itemClick': '_listBoxItemClickHandler',
            'listBox.keydown': '_listBoxKeyDownHandler',
            'wheel': '_mouseWheelHandler'
        }
    }

    /**
    * CSS files needed for the element (ShadowDOM)
    */
    static get styleUrls() {
        return [
            'jqx.combobox.css'
        ]
    }

    /**
    * ComboBox's HTML template.
    */
    template() {
        return `<div id="container">
                    <span class="jqx-label" id="label">[[label]]</span>
                    <div id="content" class="jqx-content">
                         <div id="selectionField" class ="jqx-input jqx-selection-field">
                             <input id="input" placeholder="[[placeholder]]" autocomplete="off"/>
                             <div class="jqx-combo-box-auto-complete-string" id="autoCompleteString"></div>
                         </div>
                        <span id="dropDownButton" class ="jqx-drop-down-button jqx-unselectable">
                            <span id="arrow"></span>
                        </span>
                         <div id="dropDownContainer" class="jqx-drop-down jqx-drop-down-container jqx-visibility-hidden">
                            <jqx-list-box id="listBox"
                                    animation="[[animation]]"
                                    unfocusable="true"
                                    data-source="[[dataSource]]"
                                    disabled="[[disabled]]"
                                    display-loading-indicator="[[displayLoadingIndicator]]"
                                    display-member="[[displayMember]]"
                                    filterable="[[filterable]]"
                                    filter-callback="[[filterCallback]]"
                                    filter-mode="[[filterMode]]"
                                    filter-input-placeholder="[[filterInputPlaceholder]]"
                                    grouped="[[grouped]]"
                                    group-member="[[groupMember]]"
                                    item-height="[[itemHeight]]"
                                    item-template="[[itemTemplate]]"
                                    incremental-search-delay="[[incrementalSearchDelay]]"
                                    incremental-search-mode="[[incrementalSearchMode]]"
                                    loading-indicator-placeholder="[[loadingIndicatorPlaceholder]]"
                                    loading-indicator-position="[[loadingIndicatorPosition]]"
                                    name="[[name]]"
                                    placeholder="[[dropDownPlaceholder]]"
                                    readonly="[[readonly]]"
                                    selected-indexes="{{selectedIndexes}}"
                                    selection-mode="[[selectionMode]]"
                                    selected-values="{{selectedValues}}"
                                    sorted="[[sorted]]"
                                    theme="[[theme]]"
                                    value-member="[[valueMember]]"
                                    horizontal-scroll-bar-visibility="[[horizontalScrollBarVisibility]]"
                                    vertical-scroll-bar-visibility="[[verticalScrollBarVisibility]]"
                                    virtualized="[[virtualized]]">
                                <content></content>
                            </jqx-list-box>
                            <div id="resizeBar" class="jqx-drop-down-resize-bar">
                                <div></div>
                            </div>
                         </div>
                    </div>
                    <span class="jqx-hint" id="hint">[[hint]]</span>
                </div>`;
    }

    /**
    * Updates the ComboBox when a property is changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
    * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        switch (propertyName) {
            case 'autoComplete':
                if (newValue === 'list') {
                    that.$.listBox.$.filterInput.value = '';

                    //Context Fix
                    let listBoxContext = that.$.listBox.context;

                    that.$.listBox.context = that.$.listBox;
                    that.$.listBox._filterItems(true);
                    that.$.listBox.context = listBoxContext;

                    that._setDropDownSize();
                }

                that._autoComplete(true);
                break;
            case 'dataSource':
            case 'displayMember':
                //when selectedValues is 0 and displayMember is changed set actionButton text to default.
                that._clearSelection(true);

                //Check the new listBox size
                that._setDropDownSize();
                that._positionDetection.checkBrowserBounds('vertically');
                that._positionDetection.positionDropDown();
                that._positionDetection.checkBrowserBounds('horizontally');

                //Issue: When changing dataSource from property, the items are not added right away so size isnt calculated properly. Needs a new event or sth...
                //that._setDropDownSize();
                break;
            case 'disabled':
                //Needed, because spans are inserted before the input in advanced selectionDisplayMode and atr syncronization doesn't affect the input.
                that.$.input.disabled = newValue;
                that._setFocusable();
                that.close();

                if (that._positionDetection) {
                    that._positionDetection.handleAutoPositioning();
                }

                break;
            case 'readonly':
                //Needed, because spans are inserted before the input in advanced selectionDisplayMode and atr syncronization doesn't affect the input.
                that.$.input.readOnly = newValue;
                that.close();
                break;
            case 'selectedValues':
            case 'selectedIndexes':
                that._clearSelection(true);
                that._applySelection(that.selectionMode);
                break;
            case 'selectionMode':
            case 'selectionDisplayMode':
                that._clearSelection();
                that._applySelectionDisplayMode();

                if (that.selectionDisplayMode === 'tokens') {
                    that._currentSelection = undefined;
                }

                that._applySelection(that.selectionMode);
                break;
            case 'tokenTemplate':
                if (that.$.selectionField) {
                    while (that.$.selectionField.firstElementChild.nodeName === 'SPAN') {
                        that.$.selectionField.removeChild(that.$.selectionField.firstElementChild)
                    }
                }

                that._tokenTemplate = that._validateTemplate(that.tokenTemplate);
                that._applySelection();
                break;
            case 'value':
                that._queryItems(true);
                break;
            default:
                super.propertyChangedHandler(propertyName, oldValue, newValue);
                break;
        }
    }

    /**
    * Removes all items from the ComboBox.
    */
    clearItems() {
        const that = this;

        that.$.listBox.clearItems();
        that._clearSelection(true);
    }

    /**
    * Unselects all items.
    */
    clearSelection() {
        const that = this;

        that.$.listBox.clearSelection();
        that._clearSelection(arguments[0] ? false : true);
    }

    /*
     ** Blur Method
    */
    blur() {
        this.$.input.blur();
    }

    /**
     * Focus method
     */
    focus() {
        this.$.input.focus();
    }

    /**
    * Sets tab index 
    */
    _setFocusable() {
        const that = this;

        if (!that.disabled && !that.unfocusable) {
            let index = that.tabIndex > 0 ? that.tabIndex : 0;

            that.$.input.tabIndex = index;
            that.dropDownOpenMode === 'dropDownButton' ? that.$.dropDownButton.setAttribute('tabindex', index) : that.$.dropDownButton.removeAttribute('tabindex');

            //that.$.dropDownButton.setAttribute('tabindex', index);
            return;
        }

        that.$.input.tabIndex = -1;
        that.$.dropDownButton.removeAttribute('tabindex');
    }

    /**
     * Handles the autoComplete functionaltiy 
     */
    _autoComplete(noSelectionRefresh) {
        const that = this;

        if (that.autoComplete === 'list') {
            return;
        }

        if (that.$.listBox._items.length === 0 && typeof that.dataSource !== 'function') {
            that.close();
            return;
        }

        const value = that.$.input.value.length < that.minLength ? '' :
            (that.displayMode === 'escaped' ? that._toDefaultDisplayMode(that.$.input.value) : that.$.input.value), //displayMode is a jqxTextBox property
            isItemFocused = function (items) {
                for (let i = 0; i < items.length; i++) {
                    if (items[i]._focused && items[i].hasAttribute('focus')) {
                        return true;
                    }
                }
            };

        let selectedItem;

        if (that.$.listBox.selectedValues.length === 1) {
            selectedItem = that.$.listBox.getItem(that.$.listBox.selectedValues[0]);
        }

        that.$.autoCompleteString.textContent = '';
        that.$.listBox.$.filterInput.value = that.autoComplete === 'none' || that.$.input.value.length < that.minLength ? '' : value;

        const queryCallback = function () {
            if (!that.$.listBox.isAttached || !that.$.input) {
                return;
            }

            const activeElement = that.enableShadowDOM ? that.shadowRoot.activeElement : document.activeElement;

            that._setDropDownSize();

            if (that.opened) {
                that._positionDetection.positionDropDown();
                that._positionDetection.checkBrowserBounds();
            }

            if (that.$.listBox._filteredItems && that.$.listBox._filteredItems.length > 0) {
                that.$.listBox._scrollView.scrollTop = that.$.listBox._filteredItems[0].offsetTop;

                if (that.autoComplete !== 'none' && that.$.input.value.length >= that.minLength && !isItemFocused(that.$.listBox._filteredItems)) {
                    that._focus(that.$.listBox._filteredItems[0]);
                }

                if (activeElement === that.$.input && that.autoComplete === 'inline' && that.$.input.value.length >= that.minLength) {
                    that._updateAutoCompleteHelper();
                }

                if (selectedItem && selectedItem[that.inputMember] === that.$.listBox._filteredItems[0][that.inputMember] && selectedItem.value === that.$.listBox._filteredItems[0].value) {
                    that.$.listBox.context = that.$.listBox;
                    that.$.listBox._select(that.$.listBox._filteredItems[0], true);
                    that.$.listBox.context = listBoxContext;
                }

                if (value !== that.$.listBox._filteredItems[0][that.inputMember] || (JQX.TextBox && that instanceof JQX.TextBox && that.dropDownOpenMode === 'auto')) {
                    if (that._closedFromKeyCombination) {
                        that._closedFromKeyCombination = false;
                        return;
                    }

                    if (value.length < that.minLength && !(JQX.TextBox && that instanceof JQX.TextBox && that.dropDownOpenMode === 'auto')) {
                        that.close();
                        return;
                    }

                    if (that.isCompleted && that.dropDownOpenMode !== 'none' && activeElement === that.$.input) {
                        that.open();
                    }
                }

                return;
            }

            that.close();
        }

        //Context Fix
        let listBoxContext = that.$.listBox.context;

        that.$.listBox.context = that.$.listBox;
        that.$.listBox._filterItems(noSelectionRefresh ? true : false, queryCallback, JQX.TextBox && that instanceof JQX.TextBox && that.dropDownOpenMode === 'auto');
        that.$.listBox.context = listBoxContext;

    }

    /**
     * Updates the autoComplete string highlighter
     */
    _updateAutoCompleteHelper() {
        const that = this;

        that.$.autoCompleteString.style.width = that.$.input.offsetWidth + 'px';
        that.$.autoCompleteString.style.height = that.$.input.offsetHeight + 'px';
        that.$.autoCompleteString.style.left = that.$.input.offsetLeft + 'px';
        that.$.autoCompleteString.style.top = that.$.input.offsetTop + 'px';

        if (!that._focusedItem) {
            that.$.autoCompleteString.textContent = '';
            return;
        }

        if (that._focusedItem[that.inputMember].length !== that.$.input.value.length) {
            that.$.autoCompleteString.textContent = that.$.input.value + that._focusedItem[that.inputMember].slice(that.$.input.value.length);
        }
    }

    /**
    * Fills the selection field with the labels selected items.
    */
    _applySelection(mode, details) {
        const that = this;

        function createSelectionTags() {
            while (that.$.selectionField.firstElementChild.nodeName === 'SPAN') {
                that.$.selectionField.removeChild(that.$.selectionField.firstElementChild)
            }

            let fragment = document.createDocumentFragment(), element, icon;

            if (that.selectionDisplayMode === 'tokens') {
                if (that.selectedIndexes.length === 1 && (that.selectionMode === 'oneOrManyExtended' || that.selectionMode === 'oneOrMany')) {
                    icon = '';
                }
                else {
                    icon = '&#10006'
                }
            }
            else {
                icon = ',';
            }

            that.selectedIndexes.map(index => {
                element = that._applyTokenTemplate(that.$.listBox._items[index][that.inputMember], icon);
                element._value = that.$.listBox._items[index].value;
                fragment.appendChild(element);
            });

            that.$.selectionField.insertBefore(fragment, that.$.input);
            that._currentSelection = that.selectedIndexes.map(i => that.$.listBox._items[i][that.inputMember]);
            that.$.container.setAttribute('has-value', '');
            that._oldValue = that.value = that._currentSelection.toString();
            that._positionDetection.positionDropDown();
        }

        that.$.autoCompleteString.textContent = '';

        if (that.selectedIndexes.length === 0) {
            that._clearSelection(details && that.$.input.value === that.$.listBox._items[details.index][that.inputMember]);
            return;
        }

        if (!that.$.listBox._items || that.$.listBox._items.length === 0) {
            return;
        }

        if (that.selectionMode === 'one' || that.selectionMode === 'zeroOrOne' || that.selectionMode === 'radioButton') {
            if (that._currentSelection && that._currentSelection.length > that.selectedIndexes.length) {
                that._currentSelection = that.selectedIndexes.map(i => that.$.listBox._items[i][that.inputMember]);
                that.$.input.value = that._currentSelection.toString();
                that._oldValue = that.value = that._currentSelection.toString();
                return;
            }

            that._clearSelection();
            that._currentSelection = that.selectedIndexes.map(i => that.$.listBox._items[i][that.inputMember]);
            that.$.input.value = that._currentSelection.toString();
            that._oldValue = that.value = that._currentSelection.toString();

            that.$.container.setAttribute('has-value', '');

            if (that.autoComplete !== 'none' && typeof that.dataSource !== 'function') {
                that._autoComplete(true);
                that.close();
            }
        }
        else {
            that.$.input.value = '';
            that.$.input.placeholder = '';
            that.$.container.setAttribute('has-value', '');

            if (!that._currentSelection || that.selectionMode === 'oneOrManyExtended' || (that.selectionMode === 'radioButton' && !that.grouped)) {
                createSelectionTags();
                return;
            }

            const selectionTags = that.$.selectionField.getElementsByClassName('jqx-token');

            if (that._currentSelection.length < that.selectedIndexes.length) {
                let selectedLabels = that.selectedIndexes.map(index => that.$.listBox._items[index][that.inputMember]);

                for (let i = 0; i < selectedLabels.length; i++) {
                    if (that._currentSelection.indexOf(selectedLabels[i]) < 0) {
                        const item = that.$.listBox._items[that.selectedIndexes[i]];
                        let element, icon;

                        if (that.selectionDisplayMode === 'tokens') {
                            if (that.selectedIndexes.length === 1 && (that.selectionMode === 'oneOrManyExtended' || that.selectionMode === 'oneOrMany')) {
                                icon = '';
                            }
                            else {
                                icon = '&#10006'
                            }
                        }
                        else {
                            icon = ',';
                        }

                        if (that.selectedIndexes.length === 1 && (that.selectionMode === 'oneOrManyExtended' || that.selectionMode === 'oneOrMany')) {
                            icon = '';
                        }

                        element = that._applyTokenTemplate(item[that.inputMember], icon);
                        element._value = item.value;
                        that.$.selectionField.insertBefore(element, that.$.input);
                    }
                }

                if (that.autoComplete !== 'none' && (that.$.listBox._filteredItems && that.$.listBox._filteredItems.length !== that.$.listBox._items.length)) {
                    that._autoComplete(true);
                }

                that._positionDetection.positionDropDown();
            }
            else if ((that._currentSelection.length > 0 && selectionTags.length === 0) ||
                (that._currentSelection.length === that.selectedIndexes.length && that._currentSelection.toString() !== that.selectedValues.toString())) {
                createSelectionTags();
                return;
            }
            else {
                if (!details) {
                    return;
                }

                for (let t = 0; t < selectionTags.length; t++) {
                    if (selectionTags[t]._value === details.value) {
                        that.$.selectionField.removeChild(selectionTags[t]);
                        break;
                    }
                }
            }

            that._currentSelection = that.selectedIndexes.map(i => that.$.listBox._items[i][that.inputMember]);
            that._oldValue = that.value = that._currentSelection.toString();
        }
    }

    /**
    * Sets the selection mode for the ComboBox.
    */
    _applySelectionDisplayMode() {
        const that = this;

        if (that.selectionMode === 'one' || that.selectionMode === 'zeroOrOne' || that.selectionMode === 'radioButton') {
            that.$.removeClass('auto-height');
        }
        else {
            that.$.addClass('auto-height');
        }
    }

    /**
     * BindingComplete event Handler. When the dataSource or size of listBox is changed.
     */
    _bindingCompleteHandler() {
        const that = this;

        that._queryItems();
        that._setDropDownSize();
    }

    /**
    * ComboBox container mouse enter/leave events handler.
    */
    _buttonsMouseEventsHandler(event) {
        const that = this;

        if (that.disabled || that.readonly) {
            return;
        }

        if (event.type === 'mouseenter') {
            event.target.setAttribute('hover', '');
            that.setAttribute('hover', '');

            if (that.dropDownOpenMode === 'auto' && !(JQX.TextBox && that instanceof JQX.TextBox)) {
                if (event.target === that.$.dropDownButton) {
                    that.open();
                    that.$.input.focus();
                }
                else {
                    that.close();
                }
            }
        }
        else {
            event.target.removeAttribute('hover');
            that.removeAttribute('hover');
        }
    }

    /**
    * Initializes the element.
    */
    _createElement() {
        const that = this;

        that._tokenTemplate = that._validateTemplate(that.tokenTemplate);

        //Set properties.
        that._applySelectionDisplayMode();
        that._applySelection(that.selectionMode);

        if (that.autoComplete !== 'none') {
            that._autoComplete(true);
            that.$.input.autocomplete = 'off';
        }

        that._setDropDownSize();
        that.$.input.disabled = that.disabled;
        that.$.input.readOnly = that.readonly;
        that._setFocusable();

        if (that.$.input.value.length > 0 && that.selectedIndexes.length === 0) {
            that.$.container.setAttribute('has-value', '');
            that._oldValue = that.value = that.$.input.value;
        }

        //Flag indicator for the ripple effect. Used to append the ripple to that specific element, not his firstElementChild like it's done usually.
        //Used in class Ripple, method animate() in jqxelement.
        that.$.arrow.noRipple = true;
    }

    /**
    * Reset the input and clears the selection field.
    */
    _clearSelection(resetInput) {
        const that = this;

        if (resetInput) {
            that.$.input.value = '';
            that.value = '';
        }

        that.$.input.placeholder = that.placeholder;
        that.$.autoCompleteString.textContent = '';
        that._currentSelection = [];

        if (that.$.selectionField) {
            while (that.$.selectionField.firstElementChild.nodeName === 'SPAN') {
                that.$.selectionField.removeChild(that.$.selectionField.firstElementChild)
            }
        }

        if (that.autoComplete !== 'none' && that.autoComplete !== 'list' && that.$.input.value.length > 0) {
            if (that._autoCompleteTimer) {
                clearTimeout(that._autoCompleteTimer);
            }

            if (typeof that.dataSource !== 'function') {
                that._autoCompleteTimer = setTimeout(function () {
                    that._autoComplete(true);
                }, that.autoCompleteDelay);
            }
        }

        if (!that.$.input.value.length) {
            that.$.container.removeAttribute('has-value');
        }
    }

    _documentDownHandler(event) {
        const that = this;

        super._documentDownHandler(event);

        let target = event.originalEvent.target;
        if (that.enableShadowDOM) {
            target = event.originalEvent.composedPath()[0];
        }

        if (target === that.$.dropDownButton && that.dropDownOpenMode !== 'none' && !JQX.Utilities.Core.isMobile) {
            requestAnimationFrame(() => that.$.input.focus());
        }
    }
    /**
    * Document Up handler.
    */
    _documentUpHandler(event) {
        const that = this;
        let target = event.originalEvent.target,
            rootElement = target.closest ? target.closest('jqx-combo-box') : undefined;

        if (that.enableShadowDOM) {
            target = event.originalEvent.composedPath()[0];
            rootElement = target.getRootNode().host;
        }

        const originalTarget = target;

        if (that._resizeDetails && that._resizeDetails.started) {
            that._resizeDetails.started = that._resizeDetails.resizeEventFired = false;
            that.removeAttribute('resizing');
            that._dropDownResized = true;

            that.$.fireEvent('resizeEnd', {
                'position': { left: event.pageX, top: event.pageY }
            });
            return;
        }

        if (that.disabled || that._isDropDownClicked || that.readonly) {
            delete that._isDropDownClicked;
            return;
        }

        if (that._overlayDown) {
            that.close();
            delete that._overlayDown;
            return;
        }

        if (target === that.$.input || typeof (target) === 'undefined' || target === that.$.resizeBar) {
            return;
        }

        if (target === that.$.selectionField) {
            that.$.input.focus();
            return;
        }

        if (target === that.$.dropDownButton && that.dropDownOpenMode !== 'none') {
            that._preventDropDownClose = true;
            that.$dropDownContainer.hasClass('jqx-visibility-hidden') ? that.open() : that.close();

            if (!JQX.Utilities.Core.isMobile) {
                requestAnimationFrame(() => that.$.input.focus());
            }

            return;
        }

        if (target.classList.contains('jqx-drop-down-list-selection-label') &&
            rootElement === that && that.dropDownOpenMode !== 'none') {
            that.open();

            let item = that.$.listBox._items.filter(item => item[that.inputMember].toString() === target.textContent)[0];

            that.$.input.focus();

            //Scroll to that item and focus it.
            that.$.listBox._scrollView.scrollTop = item.offsetTop;
            that._focus(item);
            return;
        }

        if (that.selectionDisplayMode === 'tokens' && target.classList.contains('jqx-drop-down-list-unselect-button') && rootElement === that) {
            if (that.selectedIndexes.length === 1 && ['zeroOrMany', 'zeroOrOne', 'checkBox'].indexOf(that.selectionMode) < 0) {
                return;
            }

            that.unselect(that.$.listBox._items.filter(item => item[that.inputMember].toString() === target.previousElementSibling.textContent)[0]);
            that.$.input.focus();
            return;
        }

        target = that._getUpEventTarget(target);

        if (target === undefined) {
            that.$.input.focus();
            return;
        }

        if ((!that.$dropDownContainer.hasClass('jqx-visibility-hidden') && target !== 'dropDownContainer' && target !== 'item') ||
            (target === 'item' && that.selectionMode.indexOf('Many') < 0) && that.selectionMode !== 'checkBox') {
            that.close();
        }

        if (target === 'item' || (target === 'dropDownContainer' && originalTarget !== that.$.listBox.$.filterInput)) {
            that.$.input.focus();
        }
    }

    /**
     * DropDownButton Focus Handler
     * @param {any} event
     */
    _dropDownButtonFocusHandler(event) {
        const that = this;

        if (event.type === 'focus') {
            if (that.dropDownOpenMode !== 'dropDownButton') {
                that.$.input.focus();
            }

            that.setAttribute('focus', '')
        }
        else {
            that.removeAttribute('focus');
        }
    }

    /**
    * ComboBox input's focus/blur event handler.
    */
    _inputFocusHandler(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        if (event.type === 'focus') {
            that.setAttribute('focus', '');

            if (!that._buttonClicked) {
                that._oldValue = that.$.input.value;
            }
        }
        else {
            that.removeAttribute('focus');

            event.target.value !== '' || (that.selectedIndexes.length !== 0 && event.target.value === '') ?
                that.$.container.setAttribute('has-value', '') : that.$.container.removeAttribute('has-value');

            if (!that._preventDropDownClose) {
                if (that.opened && (that.autoComplete === 'auto' || that.autoComplete === 'inline') && that.$.input.value.length > 0 &&
                    that._focusedItem && !that._focusedItem.selected) {
                    that.select(that._focusedItem);
                }

                that.close();
            }

            if (that.autoComplete === 'list' && !that._buttonClicked) {
                that.$.autoCompleteString.textContent = '';

                if (that._lastSelectedItem) {
                    that.select(that._lastSelectedItem);
                }
                else {
                    that.value = that.$.input.value = that._oldValue;
                }
            }

            if (that.escKeyMode === 'previousValue') {
                that.value = that.$.input.value;
            }
        }
    }

    /**
     * Input change event handler
     * @param {any} event
     */
    _inputChangeEventHandler(event) {
        const that = this;

        event.stopPropagation();

        that.$.fireEvent('change', {
            'oldValue': that._oldValue,
            'newValue': that.$.input.value,
            'selectedItems': that.selectedItems,
            'selectedValues': that.selectedValues
        });
    }

    /**
    * ComboBox keydown event handler.
    */
    _keyDownHandler(event) {
        const that = this,
            target = that.enableShadowDOM ? event.composedPath()[0] : event.target;

        if (that.disabled || that.readonly || target === that.$.listBox.$.filterInput) {
            return;
        }

        const focusedItem = typeof that._focusedItem === 'function' ? that._focusedItem() : that._focusedItem;

        switch (event.key) {
            case 'Enter':
                if (target === that.$.input && focusedItem && that.opened) {
                    if (!focusedItem.disabled) {
                        that.select(focusedItem);
                    }

                    if (!that.$dropDownContainer.hasClass('jqx-visibility-hidden') && that.selectionMode.indexOf('one') > -1) {
                        that.close();
                        that._unfocus();
                    }
                }
                else if (target === that.$.dropDownButton) {
                    that.$.dropDownButton.setAttribute('active', '');
                    that.$dropDownContainer.hasClass('jqx-visibility-hidden') && that.dropDownOpenMode !== 'none' ? that.open() : that.close();
                    that.$.input.focus();
                }
                else {
                    that.close();
                }

                return;
            case 'Escape':
                switch (that.escKeyMode) {
                    case 'none': //Closes the drop down poppup
                        if (!that.$dropDownContainer.hasClass('jqx-visibility-hidden')) {
                            that.close();
                            that._unfocus();
                        }

                        break;
                    case 'clearValue':
                        that.value = that.$.input.value = '';
                        that.close();
                        break;
                    case 'previousValue':
                        that.$.input.value = that._oldValue;
                        break;
                }

                break;
            case 'End':
            case 'Home':
            case 'PageUp':
            case 'PageDown':
            case 'ArrowUp':
            case 'ArrowDown':
                if (that._autoOpenOnKeyDown(event) === true) {
                    return;
                }

                if (event.altKey) {
                    that._closedFromKeyCombination = true;

                    if (that.$dropDownContainer.hasClass('jqx-visibility-hidden') && that.dropDownOpenMode !== 'none') {
                        that.open();

                        if (that.items.length === 0) {
                            return;
                        }

                        if (that.selectedIndexes.length === 0) {
                            that._focus(that.items[0])
                        }
                        else if (that.selectedIndexes.length > 0 && !that.$.listBox._items[that.selectedIndexes[that.selectedIndexes.length - 1]].hidden) {
                            that._focus(that.items[that.selectedIndexes[that.selectedIndexes.length - 1]]);
                        }
                    }
                    else {
                        that.close();
                    }

                    return;
                }

                if (target === that.$.input && that.$dropDownContainer.hasClass('jqx-visibility-hidden')) {
                    if (event.ctrlKey) {
                        event.preventDefault();
                        that.$.listBox._handleKeyStrokes(event.key);
                    }

                    return;
                }

                if (((event.key === 'PageUp' || event.key === 'PageDown') && !focusedItem) || target === that.$.listBox.$.filterInput) {
                    return;
                }

                event.preventDefault();

                if (!focusedItem || (focusedItem && !focusedItem._focused)) {
                    that._focus(that.items[0]);
                    return;
                }

                that.$.listBox._handleKeyStrokes(event.key);
                //Update the autoComplete if it's manual

                if (that.autoComplete === 'inline' || that.autoComplete === 'list') {
                    that._updateAutoCompleteHelper();
                }

                break;
            case 'Backspace':
                if (that.$.input.previousElementSibling) {
                    if (that.$.input.value.length === 0) {
                        if (that.selectedIndexes.length === 1 && ['zeroOrMany', 'zeroOrOne', 'checkBox'].indexOf(that.selectionMode) < 0) {
                            return;
                        }

                        const itemToBeRemoved = that.$.listBox.getItem(that.$.input.previousElementSibling._value);

                        if (itemToBeRemoved) {
                            that.unselect(itemToBeRemoved);
                        }
                        else if (that.$.selectionField.firstElementChild && that.$.selectionField.firstElementChild.nodeName === 'SPAN') {
                            that.$.selectionField.removeChild(that.$.selectionField.firstElementChild)
                        }
                    }

                    return;
                }

                if (that.selectedIndexes.length > 1) {
                    that.clearSelection(true);
                }

                break;
            default:
                if (target === that.$.input && that.selectionMode === 'oneOrManyExtended') {
                    that.$.listBox._keysPressed[event.key] = true;
                }

                if (that._autoOpenOnKeyDown(event) === true) {
                    return;
                }
        }
    }

    /**
     * Handles auto opening on specific key down
     * @param {any} event
     */
    _autoOpenOnKeyDown(event) {
        const that = this;

        if (that.opened || (!that.opened && that.autoOpenShortcutKey.indexOf(event.key) < 0)) {
            return;
        }

        const focusedItem = typeof that._focusedItem === 'function' ? that._focusedItem() : that._focusedItem;

        that.open();

        if (!focusedItem || (focusedItem && !focusedItem._focused)) {
            if (event.key === 'ArrowDown') {
                that._focus(that.items[0]);
            }
            else if (event.key === 'ArrowUp') {
                that._focus(that.items[that.items.length - 1]);
            }

            that.ensureVisible(that._focusedItem);
        }

        return true;
    }

    /**
    * ComboBox key up event handler.
    */
    _keyUpHandler(event) {
        const that = this,
            target = that.enableShadowDOM ? event.composedPath()[0] : event.target;

        if (that.disabled || (that.escKeyMode === 'none' && event.key === 'Escape') || target === that.$.listBox.$.filterInput) {
            return;
        }

        if (target === that.$.input && that.selectionMode === 'oneOrManyExtended') {
            that.$.listBox._keysPressed[event.key] = false;
        }

        if (['one', 'radioButton', 'zeroOrOne'].indexOf(that.selectionMode) > -1 && that.selectedIndexes.length === 1 &&
            that.$.input.value !== (that._currentSelection ? that._currentSelection[0] : undefined)) {
            that.unselect(that.$.listBox._items[that.selectedIndexes[0]]);
        }

        if (event.key === 'Enter') {
            that.$.dropDownButton.removeAttribute('active');
            return;
        }

        if (target === that.$.input && event.key.indexOf('Arrow') < 0 && ['Control', 'Shift'].indexOf(event.key) < 0) {
            if (that.value === that.$.input.value) {
                return;
            }

            if (that._currentSelection) {
                that.value = that._currentSelection.toString() + (that._currentSelection.length > 0 ? ',' : '') + that.$.input.value;
            }
            else {
                that.value = that.$.input.value;
            }

            that.$.autoCompleteString.textContent = '';

            if (that._closedFromKeyCombination) {
                that._closedFromKeyCombination = false;
                return;
            }

            //that._unfocus();

            if (that.autoComplete !== 'none' && that.autoComplete !== 'list') {
                if (that.$.input.value !== (that._currentSelection ? that._currentSelection.toString() : undefined) ||
                    (that.$.listBox._filteredItems && that.$.listBox._filteredItems.length !== that.$.listBox._items.length)) {
                    if (that._autoCompleteTimer) {
                        clearTimeout(that._autoCompleteTimer);
                    }

                    that._autoCompleteTimer = setTimeout(function () {
                        that._autoComplete(true);
                    }, that.autoCompleteDelay);
                }
            }
            else {
                if (that.$.input.value.length > 0) {
                    that._queryItems();
                }

                if (that._focusedItem) {
                    that.open();

                    if (event.key !== ' ') {
                        that.$.listBox._scrollView.scrollTop = that._focusedItem.offsetTop;
                    }
                }
            }

            if ((that.autoComplete !== 'none' && that.autoComplete !== 'list') && that.$.listBox._filteredItems && that.$.listBox._filteredItems.length === that.$.listBox._items.length) {
                that.close();
                return;
            }
        }
    }

    /**
     * Checks if input's value matches an item from the listBox
     */
    _queryItems(selectItem) {
        const that = this;

        if (!that.value || !that.$.input) {
            that.close();
            return;
        }

        let foundItems = that.$.listBox._queryItems(that.$.input.previousElementSibling ? that.$.input.value : that.value, that.incrementalSearchMode);

        if (foundItems.length === 0) {
            that._unfocus();
        }

        for (let i = 0; i < foundItems.length; i++) {
            if (!foundItems[i].hidden) {
                if (selectItem && !foundItems[i].selected) {
                    that.select(foundItems[i]);
                }

                that._focus(foundItems[i]);
                break;
            }
        }

        if (that.autoComplete === 'list' && (that.enableShadowDOM ? that.shadowRoot.activeElement : document.activeElement) === that.$.input &&
            that.$.input.value.length >= that.minLength) {
            that._updateAutoCompleteHelper();
        }
    }

    /**
    * Document select start event handler.
    */
    _selectStartHandler(event) {
        const that = this;

        if (that._resizeDetails && that._resizeDetails.started) {
            event.preventDefault();
        }
    }

    /**
    * Unfocuses the focused list item from the ComboBox.
    */
    _unfocus() {
        const that = this;

        if (!that._focusedItem) {
            return;
        }

        that._focusedItem._focused = false;
        that.$.listBox._focusedItem = undefined;
    }
});
/**
* DropDownButton custom element.
*/
JQX('jqx-drop-down-button', class DropDownButton extends JQX.ContentElement {
    /** 
     * DropDownButton's properties
     */
    static get properties() {
        return {
            'autoCloseDelay': {
                value: 100,
                type: 'number'
            },
            'dropDownAppendTo': {
                value: null,
                type: 'any'
            },
            'dropDownButtonPosition': {
                allowedValues: ['none', 'left', 'right', 'top', 'bottom'],
                value: 'right',
                type: 'string'
            },
            'dropDownHeight': {
                value: '',
                type: 'any',
                validator: '_propertyValidator'
            },
            'dropDownMaxHeight': {
                value: '',
                type: 'any',
                validator: '_propertyValidator'
            },
            'dropDownMaxWidth': {
                value: '',
                type: 'any',
                validator: '_propertyValidator'
            },
            'dropDownMinHeight': {
                value: '',
                type: 'any',
                validator: '_propertyValidator'
            },
            'dropDownMinWidth': {
                value: '',
                type: 'any',
                validator: '_propertyValidator'
            },
            'dropDownOpenMode': {
                allowedValues: ['none', 'default', 'dropDownButton', 'auto'],
                value: 'default',
                type: 'string'
            },
            'dropDownOverlay': {
                value: false,
                type: 'boolean'
            },
            'dropDownPlaceholder': {
                value: 'No Items',
                type: 'string'
            },
            'dropDownPosition': {
                allowedValues: ['auto', 'top', 'bottom', 'overlay-top', 'overlay-center', 'overlay-bottom', 'center-bottom', 'center-top'],
                value: 'auto',
                type: 'string'
            },
            'dropDownWidth': {
                value: '',
                type: 'any',
                validator: '_propertyValidator'
            },
            'hint': {
                value: '',
                type: 'string'
            },
            'horizontalScrollBarVisibility': {
                type: 'string',
                value: 'auto',
                allowedValues: ['auto', 'disabled', 'hidden', 'visible']
            },
            'label': {
                value: '',
                type: 'string'
            },
            'messages': {
                extend: true,
                value: {
                    'en': {
                        'invalidNode': 'jqx-drop-down-button: Invalid parameter "{{node}}" when calling {{method}}.'
                    }
                },
                type: 'object'
            },
            'opened': {
                value: false,
                type: 'boolean'
            },
            'placeholder': {
                value: '',
                type: 'string'
            },
            'resizeIndicator': {
                value: false,
                type: 'boolean'
            },
            'resizeMode': {
                value: 'none',
                allowedValues: ['none', 'horizontal', 'vertical', 'both'],
                type: 'string'
            },
            'verticalScrollBarVisibility': {
                type: 'string',
                value: 'auto',
                allowedValues: ['auto', 'disabled', 'hidden', 'visible']
            }
        }
    }

    /**
    * DropDownButton's event listeners.
    */
    static get listeners() {
        return {
            'actionButton.down': '_buttonsDownHandler',
            'actionButton.mouseenter': '_buttonsMouseEventsHandler',
            'actionButton.mouseleave': '_buttonsMouseEventsHandler',
            'actionButton.focus': '_buttonsFocusHandler',
            'actionButton.blur': '_buttonsFocusHandler',
            'document.selectstart': '_selectStartHandler',
            'document.dragstart': '_dragStartHandler',
            'document.down': '_documentDownHandler',
            'document.up': '_documentUpHandler',
            'document.move': '_documentMoveHandler',
            'dropDownButton.down': '_buttonsDownHandler',
            'dropDownButton.mouseenter': '_buttonsMouseEventsHandler',
            'dropDownButton.mouseleave': '_buttonsMouseEventsHandler',
            'keydown': '_keyDownHandler',
            //'keyup': '_keyUpHandler',
            'focus': '_focusEventHandler',
            'blur': '_blurEventHandler',
            'dropDownButton.focus': '_buttonsFocusHandler',
            'dropDownButton.blur': '_buttonsFocusHandler',
            'dropDownContainer.transitionend': '_dropDownTransitionendHandler',
            'mouseenter': '_mouseEnterHandler',
            'mouseleave': '_mouseLeaveHandler',
            'resize': '_resizeHandler',
            'resizeBar.move': '_resizeBarMoveHandler',
            'styleChanged': '_styleChangedHandler'
        };
    }

    /**
    * DropDownButton's HTML template.
    */
    template() {
        return `<div id="container">
                    <span class="jqx-label" id="label">[[label]]</span>
                    <div id="content" class="jqx-content">
                        <div id="buttonsContainer" class="jqx-buttons-container">
                            <span id="actionButton" class="jqx-input jqx-action-button">[[placeholder]]</span>
                            <span id="dropDownButton" class="jqx-drop-down-button">
                                <span id="arrow"></span>
                            </span>
                        </div>
                        <div id="dropDownContainer" class="jqx-drop-down jqx-drop-down-container jqx-visibility-hidden">
                            <jqx-scroll-viewer id="scrollViewer"                            
                                right-to-left="[[right-to-left]]"
                                horizontal-scroll-bar-visibility="[[horizontalScrollBarVisibility]]"
                                vertical-scroll-bar-visibility="[[verticalScrollBarVisibility]]">
                                <content></content>
                            </jqx-scroll-viewer>
                            <div id="resizeBar" class="jqx-drop-down-resize-bar">
                                <div></div>
                            </div>
                         </div>
                    </div>
                    <span class="jqx-hint" id="hint">[[hint]]</span>
                </div>`;
    }

    /**
    * Called when the element is attached from the DOM.
    */
    attached() {
        const that = this;

        super.attached();

        if (!that.isCompleted || !that.$.dropDownContainer) {
            return;
        }

        that._positionDetection.dropDownAttached('_setDropDownSize');
        that._positionDetection.checkBrowserBounds();
    }

    /**
     * Called when the element is detached from the DOM.
     */
    detached() {
        const that = this;

        super.detached();

        if (!that.$.dropDownContainer) {
            return;
        }

        that.close();
        that._positionDetection.dropDownDetached();
    }

    /**
    * Updates the DropDownButton when a property is changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
    * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        switch (propertyName) {
            case 'disabled':
            case 'unfocusable':
                that._setFocusable();
                break;
            case 'dropDownAppendTo':
                that._positionDetection.dropDownAppendToChangedHandler();
                break;
            case 'dropDownHeight':
            case 'dropDownMaxHeight':
            case 'dropDownMaxWidth':
            case 'dropDownMinHeight':
            case 'dropDownMinWidth':
            case 'dropDownWidth':
                that._setDropDownSize();
                break;
            case 'dropDownOpenMode':
                that._setFocusable();
                that.close();
                break;
            case 'dropDownOverlay':
                if (!newValue) {
                    that._positionDetection.removeOverlay();
                }

                break;
            case 'dropDownPlaceholder':
                if (that.$.dropDownContainer.hasAttribute('empty')) {
                    that.$.scrollViewer.$.scrollViewerContentContainer.innerHTML = newValue;

                    if (that.opened) {
                        that.$.scrollViewer.refresh();
                    }
                }

                break;
            case 'dropDownPosition':
                that._positionDetection.dropDownPositionChangedHandler();
                break;
            case 'innerHTML':
                // It is necessary to apply the new HTML directly to scrollViewerContentContainer due to a conflict in innerHTML binding of scrollViewer (removed)
                if (newValue.trim() === '') {
                    that.$.dropDownContainer.setAttribute('empty', '');
                    requestAnimationFrame(() => that.$.scrollViewer.$.scrollViewerContentContainer.innerHTML = that.dropDownPlaceholder);
                }
                else {
                    that.$.dropDownContainer.removeAttribute('empty');
                    that.$.scrollViewer.$.scrollViewerContentContainer.innerHTML = newValue;
                }

                if (that.opened) {
                    that.$.scrollViewer.refresh();
                }

                break;
            case 'opened':
                if (newValue) {
                    that.open();
                }
                else {
                    that.close();
                }

                break;
            case 'placeholder':
                if (oldValue === '' || newValue === '') {
                    that._setFocusable();
                }

                break;
            case 'resizeIndicator':
                if (newValue) {
                    that.$.dropDownContainer.setAttribute('resize-indicator', '');
                }
                else {
                    that.$.dropDownContainer.removeAttribute('resize-indicator');
                }

                break;
            case 'resizeMode':
                that.$.dropDownContainer.setAttribute('resize-mode', that.resizeMode);

                if (that.opened) {
                    that.$.scrollViewer.refresh();
                }

                break;
        }
    }

    /**
     * Appends html nodes fo the element
     * @param {any} node - HTML element to be appended
     */
    appendChild(node) {
        const that = this;

        if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!node) {
            that.error(that.localize('invalidNode', { method: 'removeChild', node: 'node' }));
            return;
        }

        that.$.scrollViewer.appendChild(node);
    }

    /**
     * Removes content from the element
     * @param {any} node - node to be removed
     */
    removeChild(node) {
        const that = this;

        if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!node) {
            that.error(that.localize('invalidNode', { method: 'removeChild', node: 'node' }));
            return
        }

        if (!that.$.dropDownContainer.contains(node)) {
            return;
        }

        that.$.scrollViewer.removeChild(node);
    }

    /**
     * Removes the content completely
     */
    removeAll() {
        const that = this;

        if (that.isCompleted) {
            that.$.scrollViewer.removeAll();
        }
    }

    _open() {
        const that = this;

        if (that.disabled || !that.offsetHeight) {
            return;
        }

        if (!that.$dropDownContainer.hasClass('jqx-visibility-hidden')) {
            return;
        }

        if (that.$dropDownContainer.hasClass('not-in-view')) {
            that.$dropDownContainer.removeClass('not-in-view');
        }

        that.$.dropDownContainer.style.transition = null;

        if (that.dropDownAppendTo && that.dropDownAppendTo.length > 0) {
            const rect = that.getBoundingClientRect();

            // handles the case, when the dropdown is opened, while it is still part of the DropDownButton's tree.
            if (that.$.container.contains(that.$.dropDownContainer)) {
                let iterations = 0;
                const interval = setInterval(function () {
                    const rect = that.getBoundingClientRect();

                    iterations++;

                    if (rect.top === that._positionTop && iterations < 10) {
                        return;
                    }

                    that.open();
                    clearInterval(interval);
                    that._positionTop = rect.top;
                }, 100);

                return;
            }
            else if (rect.top !== that._positionTop) {
                that._positionTop = rect.top;
            }
        }

        const isOpeningEventPrevented = that.$.fireEvent('opening').defaultPrevented;

        if (isOpeningEventPrevented) {
            return;
        }

        that.opened = true;

        that._positionDetection.placeOverlay();
        that._positionDetection.checkBrowserBounds('vertically');
        that._positionDetection.positionDropDown();
        that._positionDetection.checkBrowserBounds('horizontally');

        that.$dropDownContainer.removeClass('jqx-visibility-hidden');
        that.$.fireEvent('open');

        if (that.$.dropDownButton) {
            if (that.dropDownOpenMode === 'dropDownButton') {
                that.$.dropDownButton.setAttribute('selected', '');
            }
            else {
                that.$.dropDownButton.removeAttribute('selected');
            }
        }

        if (that.$.input) {
            that.$.input.focus();
        }

    }
    /**
    * Opens the drop down container
    */
    open() {
        const that = this,
            //NOTE: Will not close other DropDown's on page ! For example, DropDownList, DateTimePickers, etc ...
            dropDownsInDOM = document.querySelectorAll('jqx-drop-down-button, jqx-color-picker');

        //Make sure all dropDownButton popups are closed before openning this one
        for (let i = 0; i < dropDownsInDOM.length; i++) {
            if (dropDownsInDOM[i] !== that && dropDownsInDOM[i].opened) {
                dropDownsInDOM[i].close();
            }
        }

        that._open();
        that.$.scrollViewer.refresh();
    }

    /**
     * Scrolls to a position
     * @param {any} top - Y coordinate
     * @param {any} left - X coordinate
     */
    scrollTo(top, left) {
        const that = this;

        if (!that.isCompleted) {
            return;
        }

        that.$.scrollViewer.scrollTo(top, left);
    }

    ready() {
        super.ready();

        const that = this;

        that._edgeMacFF = JQX.Utilities.Core.Browser.Edge ||
            JQX.Utilities.Core.Browser.Firefox && navigator.platform.toLowerCase().indexOf('mac') !== -1;

        that._positionDetection = new JQX.Utilities.PositionDetection(that, that.$.dropDownContainer, that.$.container, 'close');
        that._positionDetection.getDropDownParent(true);
        that._positionDetection.setDropDownPosition();
        that._calculateDropDownSize();
        that.$.dropDownContainer.setAttribute('resize-mode', that.resizeMode);

        if (that.resizeIndicator) {
            that.$.dropDownContainer.setAttribute('resize-indicator', '');
        }

        that._positionDetection.handleAutoPositioning();

        that._createElement();

        if (that.opened) {
            that.open();
        }
        else if (that.hasAnimation && that._edgeMacFF) {
            that.$dropDownContainer.addClass('not-in-view');
        }

        //Used for the scroll handling
        that._positionTop = that.getBoundingClientRect().top;
    }

    _setDropDownSize() {
        const that = this;

        if (!that._dropDownSize) {
            that._calculateDropDownSize();
        }

        ['dropDownMinWidth', 'dropDownMinHeight', 'dropDownMaxWidth', 'dropDownMaxHeight'].forEach((name) => {
            that.$.dropDownContainer.style[name.replace('dropDown', '').replace(/^./, 'm')] = that[name] ? that[name] + (that[name].toString().endsWith('%') ? '%' : 'px') : null;
        });

        if (that.dropDownWidth) {
            if (that.dropDownWidth !== 'auto') {
                that.$.dropDownContainer.style.width = (that.dropDownWidth === 'initial' ? that.offsetWidth : parseFloat(that.dropDownWidth)) + 'px';
            }
            else {
                that.$.dropDownContainer.style.width = 'auto';
            }
        }
        else {
            that.$.dropDownContainer.style.width = that._dropDownSize.width === 'auto' ? 'auto' : (parseFloat(that._dropDownSize.width) || 0) + 'px';
        }

        if (that.dropDownHeight && that.dropDownHeight !== 'auto') {
            that.$.dropDownContainer.style.height = parseFloat(that.dropDownHeight) + ((that.dropDownHeight + '').indexOf('%') > -1 ? '%' : 'px');
        }
        else {
            that.$.dropDownContainer.style.height = that._dropDownSize.height;
        }
    }

    /**
* Sets tab index 
*/
    _setFocusable() {
        const that = this;

        if (that.disabled || that.unfocusable) {
            that.removeAttribute('tabindex');
            that.$.actionButton.removeAttribute('tabindex');
            that.$.dropDownButton.removeAttribute('tabindex');
            return;
        }

        let index = that.tabIndex > 0 ? that.tabIndex : 0;

        if (that.dropDownOpenMode === 'dropDownButton') {
            that.removeAttribute('tabindex');

            if (that.placeholder === '') {
                that.$.actionButton.removeAttribute('tabindex');
            }
            else {
                that.$.actionButton.setAttribute('tabindex', index);
            }

            that.$.dropDownButton.setAttribute('tabindex', index);
        }
        else {
            that.$.actionButton.removeAttribute('tabindex');
            that.$.dropDownButton.removeAttribute('tabindex');
            that.tabIndex = index;
        }
    }

    _calculateDropDownSize() {
        const that = this;

        that._dropDownSize = {};

        const computedStyle = window.getComputedStyle(that.$.dropDownContainer);
        const topBorder = parseFloat(computedStyle.getPropertyValue('border-top-width').trim()),
            bottomBorder = parseFloat(computedStyle.getPropertyValue('border-bottom-width').trim()),
            topMargin = parseFloat(computedStyle.getPropertyValue('margin-top').trim()),
            bottomMargin = parseFloat(computedStyle.getPropertyValue('margin-bottom').trim()),
            topPaddinng = parseFloat(computedStyle.getPropertyValue('padding-top').trim()),
            bottomPaddinng = parseFloat(computedStyle.getPropertyValue('padding-bottom').trim());

        if (JQX.Utilities.Core.CSSVariablesSupport()) {
            that._dropDownSize.width = computedStyle.getPropertyValue('--jqx-drop-down-list-drop-down-width').trim();
            that._dropDownSize.height = computedStyle.getPropertyValue('--jqx-drop-down-list-drop-down-height').trim();
        }

        if (!that._dropDownSize.width || that._dropDownSize.width.indexOf('initial') > -1) {
            that._dropDownSize.width = that.offsetWidth;
        }

        if (!that._dropDownSize.height) {
            that._dropDownSize.height = 'auto';
        }

        that._dropDownSize.minHeight = parseFloat(computedStyle.getPropertyValue('min-height').trim());
        that._dropDownSize.maxHeight = parseFloat(computedStyle.getPropertyValue('max-height').trim());
        that._dropDownSize.borderWidth = (isNaN(topBorder) ? 0 : topBorder) + (isNaN(bottomBorder) ? 0 : bottomBorder);
        that._dropDownSize.paddingWidth = (isNaN(topPaddinng) ? 0 : topPaddinng) + (isNaN(bottomPaddinng) ? 0 : bottomPaddinng);
        that._dropDownSize.marginWidth = (isNaN(topMargin) ? 0 : topMargin) + (isNaN(bottomMargin) ? 0 : bottomMargin);
    }

    /**
     * Initialization method. Called inside ready method
     */
    _createElement() {
        const that = this;

        if (that.innerHTML.trim() === '') {
            that.$.dropDownContainer.setAttribute('empty', '');
            that.$.scrollViewer.$.scrollViewerContentContainer.innerHTML = that.dropDownPlaceholder;
        }

        that._setDropDownSize();
        that._setFocusable();

        //Flag indicator for the ripple effect. Used to append the ripple to that specific element, not his firstElementChild like it's done usually.
        //Used in class Ripple, method animate() in jqxelement.
        that.$.arrow.noRipple = true;
    }

    /**
    * DragStarted Event Handler
    * @param {any} event
    */
    _dragStartHandler(event) {
        const that = this;

        if (that._resizeDetails && that._resizeDetails.started) {
            event.preventDefault();
        }
    }

    /**
    * Dropdown transitionend handler.
    */
    _dropDownTransitionendHandler() {
        const that = this;

        if (that._edgeMacFF && !that.opened && that.hasAnimation) {
            that.$.dropDownContainer.style.top = that.$.dropDownContainer.style.left = '';
            that.$dropDownContainer.addClass('not-in-view');
        }
    }

    /**
     * Element/DropDownButton blur event handler
     * @param {any} event
     */
    _blurEventHandler() {
        const that = this;

        if (that.$.dropDownButton) {
            that.removeAttribute('focus');
            that.$.dropDownButton.removeAttribute('focus');
        }

        if (that.$.actionButton) {
            that.removeAttribute('focus');
            that.$.actionButton.removeAttribute('focus');
        }
    }

    /**
     * Element focus event handler
     */
    _focusEventHandler() {
        const that = this;

        if (that.$.dropDownButton) {
            that.setAttribute('focus', '');
            that.$.dropDownButton.setAttribute('focus', '');
        }

        if (that.$.actionButton) {
            that.setAttribute('focus', '');
            that.$.actionButton.setAttribute('focus', '');
        }

        that.removeAttribute('drop-down-button-focus');
        that.removeAttribute('action-button-focus');
    }

    /**
     * DropDownButton drop-down-button and action-button focus/blur handlers
     * @param {any} event
     */
    _buttonsFocusHandler(event) {
        const that = this;

        if (event.target === that.$.dropDownButton) {
            if (event.type === 'focus') {
                that.setAttribute('drop-down-button-focus', '');
            }
            else {
                that.removeAttribute('drop-down-button-focus');
            }
        }
        else {
            event.type === 'focus' ? that.setAttribute('action-button-focus', '') : that.removeAttribute('action-button-focus');
        }
    }

    /**
     * Gets the target of a document up event.
     */
    _getUpEventTarget(originalTarget) {
        const that = this;
        let target = originalTarget;

        while (target) {
            if (target === that.$.dropDownContainer) {
                target = 'dropDownContainer';
                break;
            }

            target = target.parentElement;
        }

        if (that.enableShadowDOM && target !== null) {
            target = originalTarget.getRootNode().host;

            while (target) {
                if (target === that.$.dropDownContainer) {
                    target = 'dropDownContainer';
                    break;
                }

                target = target.parentElement;
            }
        }

        return target;
    }

    /**
 * Hides the drop down list.
 */
    close() {
        const that = this;

        if (that.$dropDownContainer.hasClass('jqx-visibility-hidden')) {
            return;
        }

        const isClosingEventPrevented = that.$.fireEvent('closing').defaultPrevented;

        if (isClosingEventPrevented) {
            return;
        }

        that.$dropDownContainer.addClass('jqx-visibility-hidden');
        that.$.fireEvent('close');

        if (that.$.dropDownButton) {
            that.$.dropDownButton.removeAttribute('selected');
        }

        that.opened = false;
        that._preventDropDownClose = false;
        that._positionDetection.removeOverlay(true);

        if (that._edgeMacFF && !that.hasAnimation) {
            that.$.dropDownContainer.style.top = that.$.dropDownContainer.style.left = '';
            that.$dropDownContainer.addClass('not-in-view');
        }
    }

    /**
     * DocumentUp event handler
     * @param {any} event
     */
    _documentUpHandler(event) {
        const that = this,
            isResizing = that.hasAttribute('resizing');

        if (that._resizeDetails && that._resizeDetails.started) {
            that._resizeDetails.started = that._resizeDetails.resizeEventFired = false;
            that.removeAttribute('resizing');
            that._preventDropDownClose = false;
            that.focus();

            that.$.fireEvent('resizeEnd', {
                'position': { left: event.pageX, top: event.pageY }
            });
            return;
        }

        if (that.disabled || that._isDropDownClicked || that.readonly) {
            delete that._isDropDownClicked;
            return;
        }

        if (that._overlayDown) {
            that.close();
            delete that._overlayDown;
            return;
        }

        let target = event.originalEvent.target;

        if (that.enableShadowDOM) {
            target = event.originalEvent.composedPath()[0];
        }

        that._preventsSelectStart = false;

        if (typeof (target) === 'undefined' || target === that.$.resizeBar) {
            return;
        }

        const isActionButtonPressed = target.closest('.jqx-action-button');

        if (that._buttonClicked) {
            if (that.dropDownOpenMode === 'dropDownButton' && isActionButtonPressed && that._buttonClicked === that.$.actionButton) {
                that.$.fireEvent('actionButtonClick');
            }
            else if (target.closest('.jqx-drop-down-button') === that._buttonClicked || isActionButtonPressed === that._buttonClicked) {
                that.$.fireEvent('dropDownButtonClick');
            }
        }

        that._buttonClicked = undefined;

        if ((!that.editable && isActionButtonPressed === that.$.actionButton) || target.closest('.jqx-drop-down-button') === that.$.dropDownButton) {
            if (that.dropDownOpenMode === 'dropDownButton' && isActionButtonPressed === that.$.actionButton) {
                that.close();
                return;
            }

            //Open/Close the DropDownButton
            that.$dropDownContainer.hasClass('jqx-visibility-hidden') && that.dropDownOpenMode !== 'none' ? that.open() : that.close();
            return;
        }

        target = that._getUpEventTarget(target);

        if (target === undefined) {
            return;
        }

        if (target !== 'dropDownContainer' && target !== 'item' || target === 'item' && that.selectionMode !== 'checkBox' && that.selectionMode.indexOf('Many') < 0) {
            that.close();
        }

        if (isResizing && that.$.scrollViewer) {
            that.$.scrollViewer.refresh();
        }
    }

    /**
     * Key down handler 
     * @param {any} event
     */
    _keyDownHandler(event) {
        const that = this,
            activeElement = document.activeElement;

        if (that.disabled || that.readonly ||
            (activeElement !== that && activeElement !== that.$.dropDownButton && activeElement !== that.$.actionButton)) {
            return;
        }

        switch (event.key) {
            case 'Enter':
            case ' ':
                event.preventDefault();

                if (event.target !== that.$.actionButton) {
                    if (that.opened && event.key === 'Enter') {
                        that.close();
                    }
                    else if (!that.opened && !that.readonly && that.dropDownOpenMode !== 'none') {
                        that.open();
                    }
                }

                break;
            case 'End':
                that.$.scrollViewer.scrollTop = that.$.scrollViewer.scrollHeight;
                break;
            case 'Home':
                that.$.scrollViewer.scrollTop = 0;
                break;
            case 'PageUp':
            case 'PageDown':
                that.$.scrollViewer.scrollTop += (event.key.indexOf('Down') > -1 ? 1 : -1) * that.$.dropDownContainer.offsetHeight;
                break;
            case 'ArrowUp':
            case 'ArrowDown':
                if (event.altKey) {
                    if (!that.disabled && !that.readonly && that.dropDownOpenMode !== 'none') {
                        that.$dropDownContainer.hasClass('jqx-visibility-hidden') ? that.open() : that.close();
                    }

                    return;
                }

                event.preventDefault();
                that.$.scrollViewer.scrollTop += (event.key.indexOf('Down') > -1 ? 1 : -1) * 10;
                break;
            case 'Escape':
                event.preventDefault();
                that.close();
                break;
        }
    }

    /**
     * Validates the value of the property
     * @param {any} oldValue - the old value
     * @param {any} value - the new value
     */
    _propertyValidator(oldValue, newValue) {
        if (typeof newValue !== 'number' && typeof newValue !== 'string') {
            return oldValue;
        }

        return newValue;
    }

    /**
     * Element container mouse enter event handler.
     */
    _mouseEnterHandler() {
        const that = this;

        that._isElementHovered = true;

        if (that.dropDownOpenMode === 'auto' && !that.disabled && !that.readonly) {
            that.open();
        }
    }

    /**
     * Element container mouse leave event handler.
     */
    _mouseLeaveHandler() {
        const that = this;

        that.removeAttribute('hover');
        that._isElementHovered = false;

        if (that.dropDownOpenMode === 'auto' && !that.disabled && !that.readonly) {
            that._autoClose()
        }
    }

    /**
     * Automatically closes the dropdown.
     */
    _autoClose() {
        const that = this;

        that._autoCloseTimeout = setTimeout(function () {
            if (!that._isElementHovered) {
                that.close();
            }

            clearTimeout(that._autoCloseTimeout);
        }.bind(that), that.autoCloseDelay);
    }

    /**
     * Document Move Event handler
     * @param {any} event
     */
    _documentMoveHandler(event) {
        const that = this,
            target = that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target;

        if (that.dropDownOpenMode === 'auto' && that.dropDownAppendTo !== null) {
            if (that.contains(target) || that.$.dropDownContainer.contains(target)) {
                that._isElementHovered = true;
            }
            else {
                that._isElementHovered = false;
                that._autoClose();
            }
        }

        if (!that._resizeDetails || (that._resizeDetails && !that._resizeDetails.started)) {
            return;
        }

        that.setAttribute('resizing', '');

        if (!that._resizeDetails.resizeEventFired) {
            that.$.fireEvent('resizeStart', {
                'position': { left: event.pageX, top: event.pageY }
            });

            that._resizeDetails.resizeEventFired = true;
        }

        const doc = document.documentElement,
            computedStyle = that.$.dropDownContainer.getBoundingClientRect(),
            dropDownStyle = that.getBoundingClientRect(),
            direction = that.$.dropDownContainer.hasAttribute('top') ? 'top' : 'bottom';
        let size;

        function verticalResize() {
            size = event.pageY - that._resizeDetails.y;

            if (direction === 'bottom') {
                //6 is the margin of document.body, we don't want scrollbars to be shown
                that._resizeDetails.height = Math.min(doc.clientHeight - computedStyle.top - 6,
                    Math.max(0, that._resizeDetails.height + size));

                that._resizeDetails.y = Math.max(computedStyle.top + doc.scrollTop - that._resizeDetails.offsetY,
                    Math.min(doc.clientHeight + doc.scrollTop - that._resizeDetails.offsetY * 1.5, event.pageY));
            }
            else {
                that._resizeDetails.height = Math.min(that._dropDownSize.maxHeight, Math.max(0, Math.min(dropDownStyle.top, that._resizeDetails.height - size)));

                size = Math.max(0, computedStyle.top + (computedStyle.height - Math.max(that._dropDownSize.minHeight, that._resizeDetails.height)));

                if (that.dropDownAppendTo && that.dropDownAppendTo.length > 0) {
                    const margin = Math.abs(parseFloat(getComputedStyle(that.$.dropDownContainer).getPropertyValue('margin-bottom'))) || 0;

                    that.$.dropDownContainer.style.top = that.dropDownAppendTo && that.dropDownAppendTo.length > 0 ? (margin + size) + 'px' : '';
                }

                const minYCondition = dropDownStyle.top + doc.scrollTop + that._resizeDetails.offsetYtop;

                that._resizeDetails.y = Math.max(that._resizeDetails.offsetYtop,
                    Math.min(minYCondition, Math.max(minYCondition - that._dropDownSize.maxHeight, event.pageY)));
            }

            that.$.dropDownContainer.style.height = that._resizeDetails.height + 'px';
        }

        function horizontalResize() {
            //Resize only from corner
            //if (that._resizeDetails.offsetXR > 20) {
            //    return;
            //}

            size = event.pageX - that._resizeDetails.x;

            //6 is the margin of document.body, we don't want scrollbars to be shown
            that._resizeDetails.width = Math.min(doc.clientWidth - computedStyle.left - 6,
                Math.max(0, that._resizeDetails.width + size));

            that.$.dropDownContainer.style.width = that._resizeDetails.width + 'px';

            that._resizeDetails.x = Math.max(computedStyle.left + doc.scrollLeft - that._resizeDetails.offsetXR,
                Math.min(doc.clientWidth + doc.scrollLeft - that._resizeDetails.offsetXR * 1.5, event.pageX));
        }

        switch (that.resizeMode) {
            case 'vertical':
                verticalResize();
                break;
            case 'horizontal':
                horizontalResize();
                break;
            case 'both':
                horizontalResize();
                verticalResize();
                break;
        }
    }

    /**
     * Document mouse down event handler.
     */
    _documentDownHandler(event) {
        const that = this;

        if (that.disabled || that.readonly) {
            return;
        }

        let target = event.originalEvent.target;

        if (target === that._overlay) {
            that._overlayDown = true;
        }

        if (that.enableShadowDOM) {
            target = event.originalEvent.composedPath()[0];

            let rootElement = target.getRootNode().host;

            while (rootElement) {
                if (rootElement.closest('.jqx-drop-down-container') === that.$.dropDownContainer) {
                    that._isDropDownClicked = true;
                }

                rootElement = rootElement.getRootNode().host;
            }
        }
        else {
            that._isDropDownClicked = target.closest('.jqx-drop-down-container') === that.$.dropDownContainer;
        }

        that._buttonClicked = target.closest('.jqx-action-button') || target.closest('.jqx-drop-down-button');

        if (that._isDropDownClicked) {
            that._preventDropDownClose = true;
        }

        if (target !== that.$.resizeBar || that.resizeMode === 'none') {
            return;
        }

        if (!that._resizeDetails) {
            that._resizeDetails = {};
        }

        const computedStyle = that.$.dropDownContainer.getBoundingClientRect();

        that._resizeDetails.started = true;
        that._resizeDetails.x = event.pageX;
        that._resizeDetails.y = event.pageY;
        that._resizeDetails.width = that.$.dropDownContainer.offsetWidth;
        that._resizeDetails.height = that.$.dropDownContainer.offsetHeight;
        that._resizeDetails.offsetXL = event.clientX - computedStyle.left;
        that._resizeDetails.offsetXR = computedStyle.left + that.$.dropDownContainer.offsetWidth - event.clientX;
        that._resizeDetails.offsetY = computedStyle.top + that.$.dropDownContainer.offsetHeight - event.clientY;
        that._resizeDetails.offsetYtop = event.clientY - computedStyle.top;
        that._preventDropDownClose = true;
    }

    /**
     * Resize handler - recalculate the size of the popup if the element is initialized with a different size.
     */
    _resizeHandler() {
        const that = this;

        if (that.resizeMode === 'none') {
            that._calculateDropDownSize();
            that._setDropDownSize();
        }
    }

    /**
     * Resizebar mousemouve event handler. 
     * @param {any} event
     */
    _resizeBarMoveHandler(event) {
        //Used to prevent page scrolling on iOS devices
        if (event.originalEvent.type === 'touchmove') {
            event.originalEvent.preventDefault();
        }
    }

    /**
     * Style changed event handler
     * @param {any} event
     */
    _styleChangedHandler(event) {
        const that = this;

        if (that.dropDownAppendTo && that.dropDownAppendTo.length > 0) {
            const styleProperties = event.detail.styleProperties,
                fontProperties = ['font-size', 'font-family', 'font-style', 'font-weight'];

            for (let s = 0; s < fontProperties.length; s++) {
                if (styleProperties[fontProperties[s]]) {
                    that.$.dropDownContainer.style[fontProperties[s]] = styleProperties[fontProperties[s]].value;
                }
            }

        }

        if (that._dropDownSize.height === 'auto') {
            that._setDropDownSize();
        }
    }

    /**
     * Action/DropDown button mouse down event handler.
     */
    _buttonsDownHandler(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        if (that.hasRippleAnimation) {
            if (that.dropDownOpenMode === 'dropDownButton') {
                JQX.Utilities.Animation.Ripple.animate(event.target, event.pageX, event.pageY);
            }
            else if(event.target === that.$.dropDownButton || !that.editable) {
                const target = that.$.buttonsContainer;

                target.firstElementChild.noRipple = true;
                JQX.Utilities.Animation.Ripple.animate(target, event.pageX, event.pageY);
                target.firstElementChild.noRipple = false;
            }
        }

        that._preventsSelectStart = true;

        if (that.dropDownOpenMode === 'dropDownButton' && event.target === that.$.actionButton) {
            that.$.actionButton.setAttribute('active', '');
        }

        //Used to handle closing after blur event is thrown
        if (that.opened) {
            that._preventDropDownClose = true;
        }
    }

    /**
     * DropDownList container mouse enter/leave events handler.
     */
    _buttonsMouseEventsHandler(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        if (event.type === 'mouseenter') {
            that.setAttribute('hover', '');
            event.target.setAttribute('hover', '');
        }
        else {
            that.removeAttribute('hover');
            event.target.removeAttribute('hover');
        }
    }

    /**
     * Document select start event handler.
     */
    _selectStartHandler(event) {
        if (this._preventsSelectStart) {
            event.preventDefault();
        }
    }
});

/**
 * Multi Split Button custom element.
 */
JQX('jqx-multi-split-button', class MultiSplitButton extends JQX.DropDownList {
    //Multi Split Button's properties.
    static get properties() {
        return {
            'buttonsDataSource': {
                value: [],
                type: 'array'
            },
            'dropDownOpenMode': {
                allowedValues: ['none', 'dropDownButton', 'auto'],
                value: 'dropDownButton',
                type: 'string'
            }
        };
    }

    template() {
        return `<div id="container">
                    <span class="jqx-label" id="label">[[label]]</span>
                    <div id="content" class="jqx-content">
                        <div id="actionButton" class ="jqx-input jqx-action-button">
                         <template>
                                 <div class="jqx-multi-split-button-buttons" *items={{buttonsDataSource}}><span class="jqx-action-split-button" inner-H-T-M-L={{item}}></span></div>
                          </template>
                        </div>
                        <span id="dropDownButton" class="jqx-drop-down-button">
                            <span id="arrow"></span>
                        </span>
                        <div id="dropDownContainer" class="jqx-drop-down jqx-drop-down-container jqx-visibility-hidden">
                            <jqx-list-box id="listBox" unfocusable
                                    animation="[[animation]]"
                                    data-source="[[dataSource]]"
                                    disabled="[[disabled]]"
                                    display-loading-indicator="[[displayLoadingIndicator]]"
                                    display-member="[[displayMember]]"
                                    filterable="[[filterable]]"
                                    filter-mode="[[filterMode]]"
                                    filter-input-placeholder="[[filterInputPlaceholder]]"
                                    grouped="[[grouped]]"
                                    group-member="[[groupMember]]"
                                    item-height="[[itemHeight]]"
                                    item-template="[[itemTemplate]]"
                                    incremental-search-delay="[[incrementalSearchDelay]]"
                                    incremental-search-mode="[[incrementalSearchMode]]"
                                    loading-indicator-placeholder="[[loadingIndicatorPlaceholder]]"
                                    loading-indicator-position="[[loadingIndicatorPosition]]"
                                    name="[[name]]"
                                    placeholder="[[dropDownPlaceholder]]"
                                    readonly="[[readonly]]"
                                    selected-indexes="{{selectedIndexes}}"
                                    selection-mode="[[selectionMode]]"
                                    selected-values="{{selectedValues}}"
                                    sorted="[[sorted]]"
                                    theme="[[theme]]"
                                    value-member="[[valueMember]]"
                                    horizontal-scroll-bar-visibility="[[horizontalScrollBarVisibility]]"
                                    vertical-scroll-bar-visibility="[[verticalScrollBarVisibility]]"
                                    virtualized="[[virtualized]]">
                                <content></content>
                            </jqx-list-box>
                            <div id="resizeBar" class="jqx-drop-down-resize-bar">
                                <div></div>
                            </div>
                         </div>
                    </div>
                    <span class="jqx-hint" id="hint">[[hint]]</span>
                </div>`;
    }

    static get listeners() {
        return {
            'actionButton.down': '_buttonsDownHandler',
            'actionButton.mouseenter': '_buttonsMouseEventsHandler',
            'actionButton.move': '_buttonsMouseEventsHandler',
            'actionButton.mouseleave': '_buttonsMouseEventsHandler',
            'dropDownButton.mouseenter': '_dropDownButtonMouseEventsHandler',
            'dropDownButton.mouseleave': '_dropDownButtonMouseEventsHandler',
            'actionButton.focus': '_focusEventHandler',
            'actionButton.blur': '_blurEventHandler',
            'dropDownButton.focus': '_focusEventHandler',
            'dropDownButton.blur': '_blurEventHandler'
        }
    }

    /**
     * ActionButton / DropDownButton Blur event handler
     */
    _blurEventHandler() {
        const that = this;

        that.removeAttribute('focus');

        if (!that._preventDropDownClose) {
            that.close();
        }
    }

    /**
     * ActionButton / DropDownButton Focus event handler
     */
    _focusEventHandler() {
        this.setAttribute('focus', '');
    }

    _documentUpHandler(event) {
        const that = this;

        super._documentUpHandler(event);

        const splitButtons = that.querySelectorAll('.jqx-action-split-button');

        for (let i = 0; i < splitButtons.length; i++) {
            const splitButton = splitButtons[i];

            splitButton.removeAttribute('active');
        }

        that.removeAttribute('active');
    }

    _dropDownButtonMouseEventsHandler(event) {
        const that = this;

        if (event.type === 'mouseleave') {
            that.$.dropDownButton.removeAttribute('hover');
            that.removeAttribute('hover');
        }
        else {
            that.$.dropDownButton.setAttribute('hover', '');
            that.setAttribute('hover', '');
        }
    }

    _buttonsDownHandler(event) {
        const that = this;

        const splitButtons = that.querySelectorAll('.jqx-action-split-button');

        for (let i = 0; i < splitButtons.length; i++) {
            const splitButton = splitButtons[i];
            const rect = splitButton.getBoundingClientRect();

            if (event.type !== 'mouseleave') {
                that.setAttribute('active', '');
                splitButtons[i].removeAttribute('active');
                if (rect.left <= event.pageX && event.pageX <= rect.width + rect.left) {
                    splitButtons[i].setAttribute('active', '');
                    that.$.fireEvent('buttonClick', {
                        'index': i,
                        'label': that.buttonsDataSource[i]
                    });
                }
            }
            else {
                splitButtons[i].removeAttribute('active');
                that.removeAttribute('active', '');
            }
        }
    }

    _buttonsMouseEventsHandler(event) {
        const that = this;

        const splitButtons = that.querySelectorAll('.jqx-action-split-button');

        for (let i = 0; i < splitButtons.length; i++) {
            const splitButton = splitButtons[i];
            const rect = splitButton.getBoundingClientRect();

            if (event.type !== 'mouseleave') {
                that.setAttribute('hover', '');
                splitButtons[i].removeAttribute('hover');
                if (rect.left <= event.pageX && event.pageX <= rect.width + rect.left) {
                    splitButtons[i].setAttribute('hover', '');
                }
            }
            else {
                splitButtons[i].removeAttribute('hover');
                that.removeAttribute('hover', '');
            }
        }
    }


    _applySelection() {
        const that = this;

        if (that.buttonsDataSource.length === 0) {
            if (that.selectionDisplayMode === 'placeholder' || that.selectedIndexes.length === 0) {
                that.querySelector('.jqx-template-container').innerHTML = that.placeholder;
                return;
            }

            if (!that.$.listBox._items || that.$.listBox._items.length === 0) {
                return;
            }

            that.querySelector('.jqx-template-container').innerHTML = '<div class="jqx-multi-split-button-buttons"><span class="jqx-action-split-button"></span></div>';
            that.$.actionButton.querySelector('.jqx-action-split-button').appendChild(that._createToken());
        }
    }

    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        if (propertyName === 'dataSource' || propertyName === 'displayMember') {
            //Check the new listBox size
            that._setDropDownSize();
            that._positionDetection.checkBrowserBounds('vertically');
            that._positionDetection.positionDropDown();
            that._positionDetection.checkBrowserBounds('horizontally');

        }
        else {
            super.propertyChangedHandler(propertyName, oldValue, newValue);
        }
    }
});

/**
* TextBox custom element.
*/
JQX('jqx-text-box', class TextBox extends JQX.ComboBox {
    /** 
    * TextBox's properties 
    */
    static get properties() {
        return {
            'autoFocus': {
                value: false,
                type: 'boolean'
            },
            'autoComplete': {
                allowedValues: ['none', 'manual', 'auto', 'inline'],
                type: 'string',
                value: 'manual'
            },
            'displayMode': {
                value: 'default',
                allowedValues: ['default', 'escaped'],
                type: 'string'
            },
            'dropDownOpenMode': {
                allowedValues: ['none', 'default', 'auto'],
                value: 'default',
                type: 'string'
            },
            'enterKeyBehavior': {
                value: 'submit',
                allowedValues: ['submit', 'clearOnSubmit'],
                type: 'string'
            },
            'form': {
                value: '',
                type: 'string'
            },
            'hint': {
                value: null,
                reflectToAttribute: false,
                type: 'any'
            },
            'maxLength': {
                value: null,
                type: 'number?'
            },
            'minLength': {
                value: 2,
                type: 'number'
            },
            'messages': {
                extend: true,
                value: {
                    'en': {
                        'missingReference': '{{elementType}}: Missing reference to {{files}}.'
                    }
                },
                type: 'object'
            },
            'required': {
                value: false,
                type: 'boolean'
            },
            'requiredMessage': {
                value: '',
                type: 'string'
            },
            'selectAllOnFocus': {
                value: false,
                type: 'boolean'
            },
            'selectionMode': {
                value: 'zeroOrOne',
                allowedValues: ['none', 'oneOrManyExtended', 'zeroOrMany', 'oneOrMany', 'zeroOrOne', 'one', 'checkBox', 'radioButton'],
                type: 'string'
            },
            'type': {
                value: 'input',
                type: 'string',
                defaultReflectToAttribute: true,
                readonly: true
            },
            'value': {
                value: '',
                type: 'string'
            }
        }
    }

    /**
    * TextBox's event listeners.
    */
    static get listeners() {
        return {
            'document.up': '_documentUpHandler',
            'focus': '_focusHandler',
            'keydown': '_keyDownHandler',
            'mouseenter': '_mouseEventsHandler',
            'mouseleave': '_mouseEventsHandler',
            'input.blur': '_focusHandler',
            'input.change': '_textBoxChangeHandler',
            'input.focus': '_focusHandler',
            'input.keyup': '_textBoxKeyUpHandler',
            'input.paste': '_textBoxChangeHandler',
            'input.select': '_textBoxSelectHandler',
            'listBox.bindingComplete': '_bindingCompleteHandler'
        }
    }

    /**
    * TextBox's HTML template.
    */
    template() {
        return `<div id="container">
                    <span id="label" inner-h-t-m-l="[[label]]" class="jqx-label"></span>
                    <div id="content" class="jqx-content">
                        <input class="jqx-input" type="text" id="input"
                            disabled="[[disabled]]"
                            maxlength="[[maxLength]]"
                            name="[[name]]"
                            placeholder="[[placeholder]]"
                            readonly="[[readonly]]">
                        <div id="autoCompleteString"></div>
                        <div id="dropDownContainer" class="jqx-drop-down jqx-drop-down-container jqx-visibility-hidden">
                           <jqx-list-box id="listBox"
                               data-source="[[dataSource]]"
                               unfocusable="true"
                               disabled="[[disabled]]"
                               display-loading-indicator="[[displayLoadingIndicator]]"
                               display-member="[[displayMember]]"
                               item-height="[[itemHeight]]"
                               item-template="[[itemTemplate]]"
                               filter-callback="[[filterCallback]]"
                               filter-mode="[[filterMode]]"
                               loading-indicator-placeholder="[[loadingIndicatorPlaceholder]]"
                               loading-indicator-position="[[loadingIndicatorPosition]]"
                               placeholder="[[dropDownPlaceholder]]"
                               readonly="[[readonly]]"
                               selection-mode="[[selectionMode]]"
                               value-member="[[valueMember]]">
                                <content></content>
                            </jqx-list-box>
                         </div>
                    </div>
                    <span id="hint" class ="jqx-hint"></span>
                </div>`;
    }

    /**
    * Updates the TextBox when a property is changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
    * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        switch (propertyName) {
            case 'autoComplete':
                if (that.$.listBox._filteredItems && that.$.listBox._filteredItems.length !== that.$.listBox._items.length) {
                    super._autoComplete(true);
                }

                //Handle HTMLInput's default autocomplete
                that.$.input.autocomplete = newValue !== 'none' ? 'off' : 'on';
                break;

            case 'dataSource':
            case 'valueMember':
                //when selectedValues is 0 and displayMember is changed set actionButton text to default.
                that._clearSelection();

                //Check the new listBox size
                that._setDropDownSize();
                that._positionDetection.checkBrowserBounds('vertically');
                that._positionDetection.positionDropDown();
                that._positionDetection.checkBrowserBounds('horizontally');

                //Issue: When changing dataSource from property, the items are not added right away so size isnt calculated properly. Needs a new event or sth...
                //that._setDropDownSize();
                break;
            case 'displayMember':
            case 'inputMember':
                {
                    const listBox = that.$.listBox;

                    if (listBox.selectedIndexes.length) {
                        const label = listBox._items[listBox.selectedIndexes[0]][that.inputMember];

                        that.$.listBox.$.filterInput.value = label;

                        that.$.input.value = that.displayMode === 'escaped' ?
                            that._toEscapedDisplayMode(label) : that._toDefaultDisplayMode(label);
                        that.set('value', that._toDefaultDisplayMode(that.$.input.value));
                    }

                    break;
                }
            case 'displayMode':
                that.$.input.value = newValue === 'escaped' ? that._toEscapedDisplayMode(that.value) : that.value = that._toDefaultDisplayMode(that.$.input.value);
                break;
            case 'dropDownOpenMode':
                that._setFocusable();
                that.$dropDownContainer.addClass('jqx-visibility-hidden');
                that.opened = false;
                break;
            case 'value':
                if (that.$.input !== document.activeElement || (that.$.input === document.activeElement && that.$.input.value === that._oldValue)) {
                    that.$.input.value = that.displayMode === 'escaped' ? that._toEscapedDisplayMode(that.value) : that.value;
                    that._oldValue = oldValue;
                }

                if (!that.value) {
                    that.clearSelection();
                }

                newValue.length > 0 ? that.$.addClass('has-value') : that.$.removeClass('has-value');
                break;
            case 'hint':
                if (newValue === null) {
                    that.$.hint.innerHTML = '';
                    that.$.removeClass('invalid');
                    return;
                }

                that._handleHintContainer();
                break;
            default:
                super.propertyChangedHandler(propertyName, oldValue, newValue);
                break;
        }
    }

    /**
    * Checks for missing modules.
    */
    static get requires() {
        return {
            'JQX.ComboBox': 'jqxcombobox.js'
        }
    }

    /*
    * CSS files needed for the element (ShadowDOM)
    */
    static get styleUrls() {
        return [
            'jqx.textbox.css'
        ]
    }

    /**
     * Opens the popup
     */
    open() {
        const that = this;

        if (that.$.listBox.items.length === 0 || that.autoComplete === 'none') {
            return;
        }

        if (that.$.input.value.length === 0 && (that.$.listBox._filteredItems && that.$.listBox._filteredItems.length !== that.$.listBox._items.length)) {
            super._autoComplete(true);
            return;
        }

        super.open();
    }

    /**
     * Closes the popup
     */
    close() {
        const that = this;

        super.close();
        that.$.autoCompleteString.textContent = '';

        if (that.$.listBox._focusedItem) {
            that.$.listBox._focusedItem._focused = false;
        }

        if (that.autoComplete === 'none') {
            return;
        }

        if (that.$.input._filteredItems && that.$.input._filteredItems[0] && that.$.input._filteredItems[0] !== that.$.input.value) {
            super._autoComplete(true);
        }
    }

    /**
     * Focus method
     */
    focus() {
        this.$.input.focus();
    }

    /**
    * Sets tab index 
    */
    _setFocusable() {
        const that = this;

        if (that.disabled || that.unfocusable) {
            that.$.input.tabIndex = -1;
            return;
        }

        that.$.input.removeAttribute('tabindex');
    }

    /**
    * Reset Method. Reset to the initialization value
    */
    reset() {
        const that = this;

        if (that.displayMode === 'escaped') {
            that.value = that._initializationValue;
            that.$.input.value = that._toEscapedDisplayMode(that._initializationValue);
        }
        else {
            that.$.input.value = that.value = that._initializationValue;
        }

        if (!that.value && that.$.listBox) {
            that.clearSelection();
        }
    }

    /**
   * BindingComplete event Handler. When the dataSource or size of listBox is changed.
   */
    _bindingCompleteHandler() {
        const that = this;

        if (!that.$.listBox) {
            return;
        }

        that._setDropDownSize();
        that._positionDetection.checkBrowserBounds();
    }

    /**
 * TextBox create method.
 */
    _createElement() {
        const that = this;

        that._browserIsIEorEdge = JQX.Utilities.Core.Browser.IE || JQX.Utilities.Core.Browser.Edge;

        if (that.autoFocus) {
            that.$.input.focus();
        }

        if (that.value) {
            that.$.input.value = that.displayMode === 'escaped' ? that._toEscapedDisplayMode(that.value) : that.value;
        }

        if (that.autoComplete !== 'none') {
            that.$.input.autocomplete = 'off';
        }

        that._setDropDownSize();
        that._handleSelectedText();
        that._setFocusable();
        that._initializationValue = that._oldValue = that.value;
        that.value.length > 0 ? that.$.addClass('has-value') : that.$.removeClass('has-value');
        that._handleHintContainer();
    }

    /**
    * Focus handler. Selects whole text in element's text area on selectAllOnFocus: true
    */
    _focusHandler(event) {
        const that = this;

        if (event.type === 'blur') {
            if (that._isDropDownClicked) {
                return;
            }

            that.removeAttribute('focus');
            that.$.autoCompleteString.textContent = '';
            that.value.length > 0 ? that.$.addClass('has-value') : that.$.removeClass('has-value');

            if ((that.autoComplete === 'auto' || that.autoComplete === 'inline') && that.$.input.value.length > 0 &&
                that.$.listBox._focusedItem && that.$.listBox._focusedItem._focused) {
                that.$.input.value = that.$.listBox._focusedItem[that.inputMember];
            }

            if (!that._preventDropDownClose) {
                that.close();
            }

            if (that._oldValue !== that.value) {
                that.$.fireEvent('change', { oldValue: that._oldValue, newValue: that.value });
            }
            return;
        }

        if (that.disabled) {
            return;
        }

        that.setAttribute('focus', '');
        that._oldValue = that.value;

        if (that.selectAllOnFocus) {
            that.$.input.select();
        }
    }

    /**
    * TextBox container mouse enter/leave events handler.
    */
    _handlePointerInEscapedSymbol(direction) {
        const that = this;

        if (that.displayMode !== 'escaped') {
            return;
        }

        let selectionStart = that.$.input.selectionStart,
            selectionEnd = that.$.input.selectionEnd,
            value = that.$.input.value;

        if (value[selectionStart - 1] !== '\\') {
            return;
        }

        if (!value[selectionStart].match(/n|r|s|t|f/g)) {
            return;
        }

        if (selectionStart === selectionEnd) {
            let pointerPositionModifier = direction === 'next' ? 1 : -1;
            that.$.input.selectionStart = selectionStart + pointerPositionModifier;
            that.$.input.selectionEnd = selectionStart + pointerPositionModifier;
            return;
        }
        else {
            that.$.input.selectionStart = selectionStart - 1;
        }

        if (value[selectionEnd - 1] !== '\\') {
            return;
        }

        if (!value[selectionEnd].match(/n|r|s|t|f/g)) {
            return;
        }

        that.$.input.selectionEnd = selectionEnd + 1;
    }

    /**
     * Handles Text selection
     */
    _handleSelectedText() {
        const that = this;

        if (that.selectionStart === null || that.selectionEnd === null || that.selectionStart === that.selectionEnd || that.selectAllOnFocus) {
            return;
        }

        that.selectionStart = that.selectionStart < 0 ? 0 : that.selectionStart;
        that.selectionEnd = that.selectionEnd > that.value.length ? that.value.length : that.selectionEnd;

        that.$.input.setSelectionRange(that.selectionStart, that.selectionEnd);
    }

    /**
     * Handles the Hint
     */
    _handleHintContainer() {
        const that = this;

        if (!that.hint) {
            return;
        }

        const container = that.$.hint;

        if (typeof that.hint === 'function') {
            const value = that.value,
                invalid = that.hint(value, container);

            invalid ? that.$.addClass('invalid') : that.$.removeClass('invalid');
        }
        else if (typeof that.hint === 'string') {
            container.innerHTML = that.hint;
            that.$.removeClass('invalid');
        }
    }

    /**
    * keyDown event handler.
    */
    _keyDownHandler(event) {
        const that = this;

        function replaceEscapedKeyWith(newValue) {
            let selectionStart = that.$.input.selectionStart,
                selectionEnd = that.$.input.selectionEnd,
                value = that.$.input.value;

            event.preventDefault();
            value = value.substring(0, selectionStart) + newValue + value.substring(selectionEnd, value.length);
            that.value = that._toDefaultDisplayMode(value);
            that.$.input.value = value;
            that.$.input.selectionStart = that.$.input.selectionEnd = selectionStart + 2;
        }

        that._showAutoCompleteHighlighter = false;

        switch (event.key) {
            case 'ArrowUp':
            case 'ArrowDown':
                if (event.altKey) {
                    event.preventDefault();
                    if (event.key === 'ArrowDown') {
                        that.open();
                    }
                    else {
                        that.close();
                    }

                    return;
                }

                if (that.opened) {
                    event.preventDefault();
                    that.$.listBox._handleKeyStrokes(event.key);

                    if (that.autoComplete !== 'inline') {
                        break;
                    }

                    that._showAutoCompleteHighlighter = true;
                    super._updateAutoCompleteHelper();
                }

                break;
            case 'PageUp':
            case 'PageDown':
                event.preventDefault();
                that.$.input.selectionStart = that.$.input.selectionEnd = event.key === 'PageUp' ? 0 : that.$.input.value.length;
                break;
            case 'Enter':
                if (that.opened && that.$.listBox._focusedItem && that.$.listBox._focusedItem._focused) {
                    that.$.listBox.$.filterInput.value = that.$.listBox._focusedItem[that.inputMember];
                    that.$.input.value = that.displayMode === 'escaped' ?
                        that._toEscapedDisplayMode(that.$.listBox._focusedItem[that.inputMember]) : that._toDefaultDisplayMode(that.$.listBox._focusedItem[that.inputMember]);
                    that.select(that.$.listBox._focusedItem);
                    that.close();
                }

                if (that.enterKeyBehavior !== 'default') {
                    const value = that.$.input.value;

                    if (that._oldValue !== value) {
                        event.preventDefault();
                        that.$.fireEvent('change', {
                            'oldValue': that._oldValue,
                            'newValue': value,
                            'type': 'submit'
                        });

                        if (that.enterKeyBehavior === 'clearOnSubmit') {
                            if (JQX.MaskedTextBox && (that instanceof JQX.MaskedTextBox)) {
                                that._cleanMask();
                                that._setMaskToInput();
                                that.$.input.selectionStart = that.$.input.selectionEnd = 0;
                            }
                            else {
                                that.$.input.value = '';
                            }
                        }

                        that._oldValue = that.value = that._toDefaultDisplayMode(that.$.input.value);
                    }

                    that._submitted = true;
                }
                break;
            case 'Escape':
                that.close();
                that._closedFromKeyCombination = true;

                if (that.escKeyMode === 'none') {
                    return;
                }

                switch (that.escKeyMode) {
                    case 'none':
                        break;
                    case 'clearValue':
                        that.value = that.$.input.value = '';
                        break;
                    case 'previousValue':
                        that.$.input.value = that.displayMode === 'escaped' ? that._toEscapedDisplayMode(that._oldValue) : that._oldValue;
                        break;
                }

                break;
            case ' ':
                if (that.displayMode === 'escaped') {
                    replaceEscapedKeyWith('\\s');
                }

                break;
            case 'Backspace':
                if (that.displayMode === 'escaped' && that.$.input.selectionStart === that.$.input.selectionEnd) {
                    let carretPosition = that.$.input.selectionStart;

                    if (that.$.input.value[carretPosition - 2] === '\\' &&
                        (that.$.input.value[carretPosition - 1] === 's' || that.$.input.value[carretPosition - 1] === 'n')) {
                        that.$.input.value = that.$.input.value.substring(0, carretPosition - 2) +
                            that.$.input.value.substring(carretPosition - 2, that.$.input.value.length);
                        that.$.input.selectionStart = carretPosition - 2;
                    }
                }

                break;
        }
    }

    /**
     * Pre-defined ComboBox keyUpHandler
     */
    _keyUpHandler(event) {
        const that = this;

        if (that.disabled || event.key === 'Escape' || event.target === that.$.listBox.$.filterInput) {
            return;
        }

        if (event.target === that.$.input && that.selectionMode === 'oneOrManyExtended') {
            that.$.listBox._keysPressed[event.key] = false;
        }
    }

    /**
     * ListItem click event handler
     * @param {any} event
     */
    _listBoxItemClickHandler(event) {
        const that = this,
            eventDetails = event.detail;

        super._listBoxItemClickHandler(event);

        if (eventDetails.selected) {
            if (that.displayMode === 'escaped') {
                const originalValue = that.$.input.value;

                that.value = that._toDefaultDisplayMode(originalValue);
                that.$.input.value = originalValue;
            }
            else {
                that.value = that.$.input.value;
            }

            if (that._oldValue !== that.value) {
                that.$.fireEvent('change', { oldValue: that._oldValue, newValue: that.value });
                that.$.input.focus();
            }
        }
    }

    _submitKeyUpHandler() {
        const that = this;

        if (that._submitted) {
            if (that.enterKeyBehavior === 'clearOnSubmit') {
                that.$.input.selectionStart = that.$.input.selectionEnd = 0;
            }

            that._submitted = false;
        }
    }

    /**
    * TextBox keyUp event handler.
    */
    _textBoxKeyUpHandler(event) {
        const that = this;

        if (that.disabled || event.altKey || event.ctrlKey) {
            return;
        }

        if (that.displayMode === 'escaped') {
            const originalValue = that.$.input.value;

            that.value = that._toDefaultDisplayMode(that.$.input.value);
            that.$.input.value = originalValue;
        }
        else {
            that.value = that.$.input.value;
        }

        let selectedItem;

        if (that.$.listBox.selectedIndexes.length === 1) {
            selectedItem = that.$.listBox.getItem(that.$.listBox.selectedValues[0]);

            if (that.value !== selectedItem[that.inputMember]) {
                that.unselect(selectedItem);
            }
        }

        if (!that._showAutoCompleteHighlighter) {
            that.$.autoCompleteString.textContent = '';
        }

        if (event.key === 'Alt' || event.key === 'Control' || (!that.opened && event.key === 'Escape') || event.key === 'Enter') {
            that._closedFromKeyCombination = false;
            return;
        }

        if (event.key && event.key.indexOf('Arrow') > -1) {
            that._handlePointerInEscapedSymbol(event.key === 'ArrowRight' ? 'next' : undefined);
            return;
        }

        if (that.autoComplete !== 'none' && (that.$.input.value.length > 0 || that.dropDownOpenMode === 'auto')) {
            const autoComplete = super._autoComplete.bind(that);

            if (that._autoCompleteTimer) {
                clearTimeout(that._autoCompleteTimer);
            }

            if (that.$.listBox._items.length === 0 && typeof that.dataSource !== 'function') {
                that.close();
                return;
            }

            that._autoCompleteTimer = setTimeout(function () {
                autoComplete(true);
            }, that.autoCompleteDelay);
        }
        else {
            that.close();
        }

        if (event.key === 'Enter' && that.value !== that.value && that._browserIsIEorEdge) {
            that.value = that.$.input.value;
            that.$.fireEvent('change', { value: that.value });
        }
    }

    /**
   * ListBox drop down change event handler.
   */
    _listBoxChangeHandler(event) {
        const that = this;

        //Stop listBox's change event. TextBox will throw it's own 'change' event
        event.stopPropagation();

        if (event.detail.selected) {
            const label = that.$.listBox._items[event.detail.index][that.inputMember];

            that.$.listBox.$.filterInput.value = label;

            that.$.input.value = that.displayMode === 'escaped' ?
                that._toEscapedDisplayMode(label) : that._toDefaultDisplayMode(label);
            that.set('value', that._toDefaultDisplayMode(that.$.input.value));
        }

        if (that.autoComplete !== 'none' && typeof that.dataSource !== 'function') {
            that._autoComplete(true);
        }
    }

    /**
    * TextBox container mouse enter/leave events handler.
    */
    _mouseEventsHandler(event) {
        const that = this;

        event.type === 'mouseenter' ? that.setAttribute('hover', '') : that.removeAttribute('hover');
    }

    /**
    * TextBox change handler.
    */
    _textBoxChangeHandler(event) {
        const that = this;

        event.stopPropagation();

        if (that.displayMode === 'escaped') {
            const originalValue = that.$.input.value,
                selectionStart = that.$.input.selectionStart,
                selectionEnd = that.$.input.selectionEnd,
                clipboardData = event.clipboardData || (event.originalEvent && event.originalEvent.clipboardData) || window.clipboardData;

            if (clipboardData) {
                let clipboardValue = clipboardData.getData('text'),
                    value = that.$.input.value;

                event.preventDefault();
                clipboardValue = that._toEscapedDisplayMode(clipboardValue);
                that.$.input.value = value.substring(0, selectionStart) + clipboardValue + value.substring(selectionEnd, value.length);
            }

            that.value = that._toDefaultDisplayMode(that.$.input.value);
            that.$.input.value = originalValue;
        }
        else {
            that.value = that.$.input.value;
        }

        that._handleHintContainer();
    }

    /**
    * TextBox test select handler.
    */
    _textBoxSelectHandler() {
        const that = this;

        if (that.disabled) {
            return;
        }

        that.selectionStart = that.$.input.selectionStart;
        that.selectionEnd = that.$.input.selectionEnd;
    }

    /**
    * Escapes special characters in the string.
    */
    _toEscapedDisplayMode(str) {
        const keyValuePairs = [
            { key: /\r\n|\n\r|\n|\r/g, value: '\\n' },
            { key: /\s/g, value: '\\s' },
            { key: /\n/g, value: '\\n' },
            { key: /\t/g, value: '\\t' },
            { key: /\f/g, value: '\\f' },
            { key: /\r/g, value: '\\r' }
            /*{ key: /\\/g, value: '\\\\' }*/
        ];

        for (let i = 0; i < keyValuePairs.length; i++) {
            str = str.replace(keyValuePairs[i].key, keyValuePairs[i].value)
        }

        return str;
    }

    /**
    * Reverts escaped characters.
    */
    _toDefaultDisplayMode(str) {
        if (!str) {
            str = '';
        }

        const keyValuePairs = [
            { key: /\\s/g, value: ' ' },
            { key: /\\n/g, value: '\n' },
            { key: /\\t/g, value: '\t' },
            { key: /\\f/g, value: '\f' },
            { key: /\\r/g, value: '\r' }
            /*{ key: /\\\\[^n{1}|^s{1}|^t{1}|^f{1}|^r{1}]/g, value: '\\' }*/
        ];

        for (let i = 0; i < keyValuePairs.length; i++) {
            str = str.replace(keyValuePairs[i].key, keyValuePairs[i].value)
        }

        return str;
    }

    /**
    * Document mouse down event handler.
    */
    _documentDownHandler(event) {
        const that = this;

        if (that.disabled || that.readonly) {
            return;
        }

        let target = event.originalEvent.target;

        if (that.enableShadowDOM) {
            target = event.originalEvent.composedPath()[0];

            let rootElement = target.getRootNode().host;

            while (rootElement) {
                if (rootElement.closest('.jqx-drop-down-container') === that.$.dropDownContainer) {
                    that._isDropDownClicked = true;
                }

                rootElement = rootElement.getRootNode().host;
            }
        }
        else {
            that._isDropDownClicked = target.closest('.jqx-drop-down-container') === that.$.dropDownContainer;
        }

        const listItem = event.originalEvent.target.closest('jqx-list-item');

        if (that.hasRippleAnimation && listItem) {
            JQX.Utilities.Animation.Ripple.animate(listItem, event.pageX, event.pageY);
        }

        if (listItem || that._isDropDownClicked) {
            that._preventDropDownClose = true;
        }
    }

    /**
    * Document Up event handler.
    */
    _documentUpHandler(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        let target = that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target;

        if (!target) {
            return;
        }

        if (that.displayMode === 'escaped' && target === that.$.input) {
            that._handlePointerInEscapedSymbol();
        }

        if (that._isDropDownClicked || that.readonly) {
            delete that._isDropDownClicked;
            return;
        }

        if (target === that.$.input && that.dropDownOpenMode === 'auto') {
            super._autoComplete(true);
            return;
        }

        while (target) {
            if (target instanceof JQX.ListItem && target.ownerListBox === that.$.listBox) {
                if (target.unselectable || target.disabled) {
                    return;
                }

                if (that.displayMode === 'escaped') {
                    that.value = target[that.inputMember];
                    that.$.input.value = that._toEscapedDisplayMode(target[that.inputMember]);
                }
                else {
                    that.$.input.value = that.value = target[that.inputMember];
                }

                that.$.fireEvent('change', {
                    'oldValue': that._oldValue,
                    'newValue': that.value,
                    'type': 'submit'
                });

                that._oldValue = that.value;
                (that.enterKeyBehavior === 'clearOnSubmit') && (that.$.input.value = that.value = '');

                super._autoComplete(true);
                that.close();
                target = 'item';
                that.$.input.focus();
                return;
            }
            else if (target === that.$.listBox) {
                target = 'listBox';
                return;
            }

            target = target.parentElement;
        }

        if (target !== 'listBox' && target !== 'item') {
            that.close();
            return;
        }
    }
});
/**
* MaskedTextBox custom element.
*/
JQX('jqx-masked-text-box', class MaskedTextBox extends JQX.TextBox {
    /** 
    * MaskedTextBox's properties 
    */
    static get properties() {
        return {
            'allowPromptAsInput': {
                value: false,
                type: 'boolean'
            },
            'asciiOnly': {
                value: false,
                type: 'boolean'
            },
            'autoShowMask': {
                value: false,
                type: 'boolean'
            },
            'cutCopyMaskFormat': {
                value: 'excludePromptAndLiterals',
                allowedValues: ['excludePromptAndLiterals', 'includePrompt', 'includeLiterals', 'includePromptAndLiterals'],
                type: 'string'
            },
            'hidePromptOnLeave': {
                value: false,
                type: 'boolean'
            },
            'hint': {
                value: '',
                reflectToAttribute: true,
                type: 'string'
            },
            'isOverwriteMode': {
                value: false,
                type: 'boolean'
            },
            'mask': {
                value: '#####',
                type: 'string'
            },
            'maskCompleted': {
                value: false,
                type: 'boolean'
            },
            'maskFull': {
                value: false,
                type: 'boolean'
            },
            'promptChar': {
                value: '_',
                type: 'string'
            },
            'rejectInputOnFirstFailure': {
                value: false,
                type: 'boolean'
            },
            'resetOnPrompt': {
                value: false,
                type: 'boolean'
            },
            'resetOnSpace': {
                value: false,
                type: 'boolean'
            },
            'textMaskFormat': {
                value: 'excludePromptAndLiterals',
                allowedValues: ['excludePromptAndLiterals', 'includePrompt', 'includeLiterals', 'includePromptAndLiterals'],
                type: 'string'
            },
            'validation': {
                value: null,
                type: 'function?',
                reflectToAttribute: false
            },
            'value': {
                value: null,
                reflectToAttribute: true,
                type: 'string?'
            }
        }
    }

    /**
    * MaskedTextBox's event listeners.
    */
    static get listeners() {
        return {
            'mouseenter': '_mouseEventsHandler',
            'mouseleave': '_mouseEventsHandler',
            'input.copy': '_cutCopyHandler',
            'input.change': '_textBoxChangeHandler',
            'input.cut': '_cutCopyHandler',
            'input.paste': '_textBoxPasteHandler',
            'input.keydown': '_textBoxKeyDownHandler',
            'input.keyup': '_textBoxKeyUpHandler',
            'input.blur': '_blurHandler',
            'input.focus': '_focusHandler'
        }
    }

    /**
    * MaskedTextBox's HTML template.
    */
    template() {
        return `<div id="container">
                    <span id="label" inner-h-t-m-l="[[label]]" class ="jqx-label"></span>
                    <input type="text" id="input"
                        autocomplete="off"
                        autocorrect="off"
                        autocapitalize="off"
                        disabled="[[disabled]]"
                        maxlength="[[maxLength]]"
                        minlength="[[minLength]]"
                        name="[[name]]"
                        placeholder="[[placeholder]]"
                        readonly="[[readonly]]">
                    <span id="hint" inner-h-t-m-l="[[hint]]" class ="jqx-hint"></span>
                </div>`;
    }

    /**
    * Updates the MaskedTextBox when a property is  changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value.
    * @param {number/string} newValue The new entered value.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        // super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this;
        let maskValue;

        switch (propertyName) {
            case 'hidePromptOnLeave':
                if (newValue && !that._focused) {
                    that._hidePrompt();
                }
                else if (that._promptHidden) {
                    that._showPrompt();
                }
                break;
            case 'maxLength':
                if (that.mask.length > 0) {
                    that.maxLength = oldValue;
                }
                break;
            case 'maskCompleted':
            case 'maskFull':
                that[propertyName] = oldValue;
                break;
            case 'promptChar':
                that._updatePromptChar();
                break;
            case 'placeholder':
                if (that._isPlaceholderRequired()) {
                    that.$.input.value = ''
                    that.$.removeClass('has-value');
                }
                else {
                    that._updatePromptChar();
                }
                that._updatePromptChar();
                break;
            case 'mask':
                maskValue = that._getValueWithTextMaskFormat({ start: 0, end: that._mask.length }, 'excludePromptAndLiterals');

                if (that._isPlaceholderRequired()) {
                    that.$.input.value = ''
                    that.$.removeClass('has-value');
                }
                else {
                    that._initializeMask();
                    that._setValueToMask(maskValue);
                    that._setMaskToInput();
                    that.maxLength = that._mask.length;

                    if (that._promptHidden) {
                        that._hidePrompt();
                    }
                }
                break;
            case 'value':
                that._overwrite = true;
                that._setValueToMask(newValue);
                that._overwrite = false;

                that._setMaskToInput();

                if (that._promptHidden) {
                    that._hidePrompt();
                }
                break;
            case 'disabled':
                that._setFocusable();
                break;
            case 'readonly':
                break;
            default:
                super.propertyChangedHandler(propertyName, oldValue, newValue);
                break;
        }

        that.value = that._getValueWithTextMaskFormat({ start: 0, end: that._mask.length }, that.textMaskFormat);
    }

    /**
    * MaskedTextBox create element method.
    */
    _createElement() {
        const that = this;

        if (that.autoFocus) {
            that.$.input.focus();
        }

        that._setFocusable();
        that._initializeMask();
        that._updateMaxLength();

        if (that._isPlaceholderRequired()) {
            that.$.input.value = ''
            that.$.removeClass('has-value');
        }
        else {
            that._setValueToMask(that.value)
            that._setMaskToInput();
            that._updateMaskFullAndCompleted();
            that.$.addClass('has-value');
        }

        that.$.input.selectionStart = that.$.input.selectionEnd = 0;
        that._initializationValue = that._value = that.value;
        that._rejectInput = false;
    }

    /**
    * MaskedTextBox blur handler.
    */
    _blurHandler() {
        const that = this,
            requiresPlaceholder = that._isPlaceholderRequired();

        if (that.disabled) {
            return;
        }

        if (that._valueBeforeChange !== that.value) {
            that.$.fireEvent('change', {
                'newValue': that.value,
                'oldValue': that._valueBeforeChange
            });
            that._valueBeforeChange = '';
        }


        that._hidePrompt();
        that._focused = false;
        that._validateMaskValue();

        that.removeAttribute('focus');
        that.$.input.value.length > 0 ? that.$.addClass('has-value') : that.$.removeClass('has-value');


        if (requiresPlaceholder) {
            that.$.input.value = ''
            that.$.removeClass('has-value');
        }
    }

    /*
    * Controlls maskFull and maskCompleted readonly properties
    */
    _updateMaskFullAndCompleted() {
        const that = this;
        let maskFull = true,
            maskCompleted = true,
            hasRequiredChar = false;

        for (let i = 0; i < that._mask.length; i++) {
            const maskElement = that._mask[i];

            if (maskElement.type === 'mask') {
                if (maskElement.required) {
                    hasRequiredChar = true;
                }

                if (maskElement.character === '') {
                    if (maskElement.required) {
                        maskCompleted = false;
                    }

                    maskFull = false;
                }
            }
        }

        if (!maskFull && maskCompleted && !hasRequiredChar) {
            maskCompleted = false;
        }

        that.maskFull = maskFull;
        that.maskCompleted = maskCompleted;
    }

    _isPlaceholderRequired() {
        const that = this,
            hasValue = (that.value && that.value.length > 0),
            hasPlaceholder = (that.placeholder.length > 0),
            isRequired = !hasValue && (hasPlaceholder || that.autoShowMask);

        return isRequired;
    }

    /*
    * Updates mask items with new value, based on the mask settings
    */
    _cleanMask(startsAt, endsAt) {
        const that = this;

        startsAt = startsAt ? startsAt : 0;
        endsAt = endsAt ? endsAt : that._mask.length;

        for (let i = startsAt; i < endsAt; i++) {
            let maskElement = that._mask[i];

            if (maskElement.type === 'mask') {
                that._mask[i].character = '';
            }
        }
    }

    /**
    *  Updates the clipboard data on cut/copy. The format of the value depends on cutCopyMaskFormat - ['excludePromptAndLiterals', 'includePrompt', 'includeLiterals', 'includePromptAndLiterals']
    */
    _cutCopyHandler(event, type) {
        const that = this,
            selectionStart = parseInt(that.$.input.selectionStart, 10),
            selectionEnd = parseInt(that.$.input.selectionEnd, 10),
            selection = that._getValueWithTextMaskFormat({ start: selectionStart, end: selectionEnd });

        if (window.clipboardData) {
            window.clipboardData.setData('text/plain', selection);
            window.clipboardData.setData('text/html', selection);
        }

        if (event) {
            that._preventDefault(event);
        }

        if (type === 'Copy') {
            return selection;
        }

        that._cleanMask(selectionStart, selectionEnd);
        that.value = that._getValueWithTextMaskFormat({ start: 0, end: that._mask.length }, that.textMaskFormat);
        that._setMaskToInput();
        that.$.input.selectionStart = that.$.input.selectionEnd = selectionStart;
        that.maskFull = that.maskCompleted = false;

        return selection;
    }

    _documentUpHandler() {

    }

    /**
    *  Delete handler. Removes single character if selectionStart=selectionEnd or all selected chars aind replaces them with a mask fragment
    */
    _deleteHandler(event) {
        const that = this,
            selectionStart = that.$.input.selectionStart,
            selectionEnd = that.$.input.selectionEnd,
            key = event.key;

        let newSelectionStart = selectionStart;

        that._preventDefault(event);

        if (selectionStart === selectionEnd) {
            if (key === 'Backspace') {
                for (let i = selectionStart; i > 0; i--) {
                    const maskItem = that._mask[i - 1];

                    if (maskItem.type === 'mask') {
                        newSelectionStart = i - 1;
                        maskItem.character = '';
                        break;
                    }
                    else {
                        newSelectionStart = selectionStart - 1;
                        break;
                    }
                }
            }
            else {
                for (let i = selectionStart; i < that._mask.length; i++) {
                    const maskItem = that._mask[i];

                    if (maskItem.type === 'mask') {
                        newSelectionStart = i + 1;
                        maskItem.character = '';
                        break;
                    }
                    else {
                        newSelectionStart = selectionStart + 1;
                        break;
                    }
                }
            }
        }
        else {
            that._cleanMask(selectionStart, selectionEnd);
            if (key === 'Delete') {
                newSelectionStart = selectionEnd;
            }
        }

        that._setMaskToInput();
        that._updateMaskFullAndCompleted();
        that.value = that._getValueWithTextMaskFormat({ start: 0, end: that._mask.length }, that.textMaskFormat);
        that.$.input.selectionStart = that.$.input.selectionEnd = newSelectionStart;
    }

    _findNextOccupiedPosition(start) {
        const that = this,
            maskLength = that._mask.length;
        let nextOccupiedPosition = start;

        for (let i = start; i < maskLength; i++) {
            let maskElement = that._mask[i];

            if ((maskElement.type === 'mask') && (maskElement.character === '')) {
                nextOccupiedPosition++;
            }
            else {
                break;
            }
        }

        return nextOccupiedPosition;
    }

    /**
    * MaskedTextBox focus handler
    */
    _focusHandler(event) {
        const that = this;

        if (event.context.nodeName.toUpperCase() !== 'INPUT') {
            that.$.input.focus();
            return;
        }

        if (that.disabled) {
            return;
        }

        that.setAttribute('focus', '');

        if (that.selectAllOnFocus) {
            that.$.input.select();
        }


        that._showPrompt();
        that._focused = true;


        if (that._isPlaceholderRequired()) {
            that._initializeMask();
            that._setValueToMask(that.value);
            that._setMaskToInput();

            const selectionStart = that._getEditableSelectionStart(0);
            that.$.input.selectionStart = that.$.input.selectionEnd = selectionStart;

        }
    }

    /*
    * Combines mask elements into string and updates input's value
    */
    _setMaskToInput() {
        const that = this;
        let mask = '';

        for (let i = 0; i < that._mask.length; i++) {
            const maskElement = that._mask[i];
            let newCharacter;

            if (maskElement.type === 'literal' || maskElement.type === 'separator' || maskElement.type === 'placeholder' || maskElement.type === 'currency') {
                newCharacter = maskElement.character;
            }
            else if (maskElement.type === 'mask' && maskElement.character !== '') {
                switch (maskElement.escapeSymbol) {
                    case '>':
                        newCharacter = maskElement.character.toUpperCase();
                        break;
                    case '<':
                        newCharacter = maskElement.character.toLowerCase();
                        break;
                    case '|':
                        newCharacter = maskElement.character;
                        break;
                    case '\\':
                        newCharacter = maskElement.character;
                        break;
                    default:
                        newCharacter = maskElement.character;
                        break;
                }
            }
            else {
                newCharacter = maskElement.defaultCharacter;
            }

            mask = mask + newCharacter;
        }

        that.$.input.value = mask;
    }


    /**
    *  Check if the entered character is format symbol
    */
    _getEditableSelectionStart(selectionStart, key) {
        const that = this;

        for (let i = selectionStart; i < that._mask.length; i++) {
            const maskItem = that._mask[i];

            if (maskItem.type !== 'mask') {
                continue;
            }

            if (maskItem.character !== '' && !that.isOverwriteMode &&
                !(key === ' ' && that.resetOnSpace) &&
                !(key === that.promptChar && that.resetOnPrompt)) {
                continue;
            }

            return i;
        }

        return -1;
    }

    _getNonEditableSelectionStart(selectionStart, key) {
        const that = this;

        for (let i = selectionStart; i < that._mask.length; i++) {
            const maskItem = that._mask[i];

            if (maskItem.type === 'mask') {
                continue;
            }

            if (maskItem.character === key) {
                return i;
            }
        }

        return -1;
    }

    /**
    *  Updates value in relation to the textMaskFormat
    */
    _getValueWithTextMaskFormat(range, maskFormat) {
        const that = this,
            rangeStart = range ? range.start : 0,
            rangeEnd = range ? range.end : (that._mask.length || that.$.input.value.length);
        let value = '';

        maskFormat = maskFormat ? maskFormat : that.cutCopyMaskFormat;

        if (maskFormat === 'includePromptAndLiterals') {
            return that.$.input.value.substring(rangeStart, rangeEnd);
        }

        for (let i = rangeStart; i < rangeEnd; i++) {
            const maskElement = that._mask[i];

            switch (maskFormat) {
                case 'excludePromptAndLiterals':
                    if (maskElement.type !== 'mask') {
                        continue;
                    }

                    value = maskElement.character === '' ? (value + ' ') : (value + maskElement.character);
                    break;
                case 'includePrompt':
                    if (maskElement.type !== 'mask') {
                        continue;
                    }

                    value = maskElement.character === '' ? (value + maskElement.defaultCharacter) : (value + maskElement.character);
                    break;
                case 'includeLiterals':
                    if (maskElement.type === 'mask' && maskElement.character === '') {
                        continue;
                    }

                    value = value + maskElement.character;
                    break;
            }
        }

        return value.trim();
    }

    /**
    *  Hides prompt characters on blur when promt is hidden on hidePromptOnLeave=true
    */
    _hidePrompt() {
        const that = this,
            regex = new RegExp(that.promptChar, 'g');

        if (that.disabled || !that.hidePromptOnLeave || that.mask.length === 0) {
            return;
        }

        that.$.input.value = that.$.input.value.replace(regex, ' ');
        that._promptHidden = true;
    }

    /**
     *  Mask string is transformed to array of mask items
     */
    _initializeMask() {
        const that = this;
        let maskLength = that.mask.length,
            escapeSymbol;

        that._mask = [];

        if (that.mask === undefined || that.mask === null || that.mask.length === 0) {
            return;
        }

        for (let i = 0; i < maskLength; i++) {
            const maskChar = that.mask.charAt(i);
            let maskElement = {};

            maskElement.defaultCharacter = that.promptChar;

            switch (maskChar) {
                case '0':
                    maskElement.editable = true;
                    maskElement.required = true;
                    maskElement.escapeSymbol = escapeSymbol;
                    maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask'; // types : mask, literal, placeholder, separator, currency
                    maskElement.maskCharacter = '0';
                    maskElement.regex = '\\d';
                    maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : '';
                    maskElement.defaultCharacter = that.promptChar;

                    escapeSymbol = null;
                    break;
                case '9':
                    maskElement.editable = true;
                    maskElement.required = false;
                    maskElement.escapeSymbol = escapeSymbol;
                    maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask';
                    maskElement.maskCharacter = '9';
                    maskElement.regex = '(\\d|\\s)';
                    maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : '';
                    maskElement.defaultCharacter = that.promptChar;

                    escapeSymbol = null;
                    break;
                case '#':
                    maskElement.editable = true;
                    maskElement.required = false;
                    maskElement.escapeSymbol = escapeSymbol;
                    maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask';
                    maskElement.maskCharacter = '#';
                    maskElement.regex = '(\\d|\\s|[+]|[-])';
                    maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : '';
                    maskElement.defaultCharacter = that.promptChar;

                    escapeSymbol = null;
                    break;
                case 'L':
                    maskElement.editable = true;
                    maskElement.required = true;
                    maskElement.escapeSymbol = escapeSymbol;
                    maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask';
                    maskElement.maskCharacter = 'L';
                    maskElement.regex = '([a-zA-Z--])';
                    maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : '';
                    maskElement.defaultCharacter = that.promptChar;

                    escapeSymbol = null;
                    break;
                case '?':
                    maskElement.editable = true;
                    maskElement.required = false;
                    maskElement.escapeSymbol = escapeSymbol;
                    maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask';
                    maskElement.maskCharacter = '?';
                    maskElement.regex = '[a-zA-Z--]?';
                    maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : '';
                    maskElement.defaultCharacter = that.promptChar;

                    escapeSymbol = null;
                    break;
                case '&':
                    maskElement.editable = true;
                    maskElement.required = true;
                    maskElement.escapeSymbol = escapeSymbol;
                    maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask';
                    maskElement.maskCharacter = '&';
                    maskElement.regex = '[^\\s]';
                    maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : '';
                    maskElement.defaultCharacter = that.promptChar;

                    escapeSymbol = null;
                    break;
                case 'C':
                    maskElement.editable = true;
                    maskElement.required = false;
                    maskElement.escapeSymbol = escapeSymbol;
                    maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask';
                    maskElement.maskCharacter = 'C';
                    maskElement.regex = '.';
                    maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : '';
                    maskElement.defaultCharacter = that.promptChar;

                    escapeSymbol = null;
                    break;
                case 'A':
                    maskElement.editable = true;
                    maskElement.required = true;
                    maskElement.escapeSymbol = escapeSymbol;
                    maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask';
                    maskElement.maskCharacter = 'A';
                    maskElement.regex = '[a-zA-Z--]'; //'[a-zA-Z--]'
                    maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : '';
                    maskElement.defaultCharacter = that.promptChar;

                    escapeSymbol = null;
                    break;
                case 'a':
                    maskElement.editable = true;
                    maskElement.required = false;
                    maskElement.escapeSymbol = escapeSymbol;
                    maskElement.type = maskElement.escapeSymbol === '\\' ? 'literal' : 'mask';
                    maskElement.maskCharacter = 'a';
                    maskElement.regex = '[a-zA-Z--]?'; //'[a-zA-Z--]'
                    maskElement.character = maskElement.escapeSymbol === '\\' ? maskElement.maskCharacter : '';
                    maskElement.defaultCharacter = that.promptChar;

                    escapeSymbol = null;
                    break;
                case '.':
                    maskElement.editable = false;
                    maskElement.required = true;
                    maskElement.escapeSymbol = escapeSymbol;
                    maskElement.type = 'placeholder';
                    maskElement.maskCharacter = '.';
                    maskElement.regex = null;
                    maskElement.character = '.';
                    maskElement.defaultCharacter = that.promptChar;

                    escapeSymbol = null;
                    break;
                case ',':
                    maskElement.editable = false;
                    maskElement.required = true;
                    maskElement.escapeSymbol = escapeSymbol;
                    maskElement.type = 'placeholder';
                    maskElement.maskCharacter = ',';
                    maskElement.regex = null;
                    maskElement.character = ',';
                    maskElement.defaultCharacter = that.promptChar;

                    escapeSymbol = null;
                    break;
                case ':':
                    maskElement.editable = false;
                    maskElement.required = true;
                    maskElement.escapeSymbol = escapeSymbol;
                    maskElement.type = 'separator';
                    maskElement.maskCharacter = ':';
                    maskElement.regex = null;
                    maskElement.character = ':';
                    maskElement.defaultCharacter = that.promptChar;

                    escapeSymbol = null;
                    break;
                case '/':
                    maskElement.editable = false;
                    maskElement.required = true;
                    maskElement.escapeSymbol = escapeSymbol;
                    maskElement.type = 'separator';
                    maskElement.maskCharacter = '/';
                    maskElement.regex = null;
                    maskElement.character = '/';
                    maskElement.defaultCharacter = that.promptChar;

                    escapeSymbol = null;
                    break;
                case '$':
                    maskElement.editable = false;
                    maskElement.required = true;
                    maskElement.escapeSymbol = escapeSymbol;
                    maskElement.type = 'currency';
                    maskElement.maskCharacter = '$';
                    maskElement.regex = null;
                    maskElement.character = '$';
                    maskElement.defaultCharacter = that.promptChar;

                    escapeSymbol = null;
                    break;
                case '<':
                    //  escapeSymbol = escapeSymbol === '|' ? null : '<';
                    if (escapeSymbol) {
                        if (escapeSymbol === '|') {
                            escapeSymbol = null;
                        }
                        else if (escapeSymbol === '\\') {
                            maskElement.editable = false;
                            maskElement.required = true;
                            maskElement.escapeSymbol = escapeSymbol;
                            maskElement.type = 'literal';
                            maskElement.maskCharacter = '<';
                            maskElement.regex = '<';
                            maskElement.character = '<';
                            maskElement.defaultCharacter = that.promptChar;

                            escapeSymbol = null;
                        }
                        else {
                            escapeSymbol = '<';
                        }
                    }
                    else {
                        escapeSymbol = '<';
                    }
                    break;
                case '>':
                    //escapeSymbol = escapeSymbol === '|' ? null : '>';
                    if (escapeSymbol) {
                        if (escapeSymbol === '|') {
                            escapeSymbol = null;
                        }
                        else if (escapeSymbol === '\\') {
                            maskElement.editable = false;
                            maskElement.required = true;
                            maskElement.escapeSymbol = escapeSymbol;
                            maskElement.type = 'literal';
                            maskElement.maskCharacter = '>';
                            maskElement.regex = '>';
                            maskElement.character = '>';
                            maskElement.defaultCharacter = that.promptChar;

                            escapeSymbol = null;
                        }
                        else {
                            escapeSymbol = '>';
                        }
                    }
                    else {
                        escapeSymbol = '>';
                    }
                    break;
                case '|':
                    //escapeSymbol = '|';
                    if (escapeSymbol) {
                        if (escapeSymbol === '\\') {
                            maskElement.editable = false;
                            maskElement.required = true;
                            maskElement.escapeSymbol = escapeSymbol;
                            maskElement.type = 'literal';
                            maskElement.maskCharacter = '|';
                            maskElement.regex = '|';
                            maskElement.character = '|';
                            maskElement.defaultCharacter = that.promptChar;

                            escapeSymbol = null;
                        }
                        else {
                            escapeSymbol = '|';
                        }
                    }
                    else {
                        escapeSymbol = '|';
                    }
                    break;
                case '\\':
                    //escapeSymbol = '\\';
                    if (escapeSymbol) {
                        if (escapeSymbol === '\\') {
                            maskElement.editable = false;
                            maskElement.required = true;
                            maskElement.escapeSymbol = escapeSymbol;
                            maskElement.type = 'literal';
                            maskElement.maskCharacter = '\\';
                            maskElement.regex = '\\'; // Invalid regular expression: /\/: \ at end of pattern
                            maskElement.character = '\\';
                            maskElement.defaultCharacter = that.promptChar;

                            escapeSymbol = null;
                        }
                        else {
                            escapeSymbol = '\\';
                        }
                    }
                    else {
                        escapeSymbol = '\\';
                    }
                    break;
                default: // literals
                    maskElement.editable = false;
                    maskElement.required = true;
                    maskElement.escapeSymbol = escapeSymbol;
                    maskElement.type = 'literal';
                    maskElement.maskCharacter = maskChar;
                    maskElement.regex = null;
                    maskElement.character = maskChar;
                    maskElement.defaultCharacter = maskChar;

                    escapeSymbol = null;
                    break;
            }

            if (escapeSymbol) {
                continue;
            }

            if (maskElement.type) {
                that._mask.push(maskElement);
            }
        }
    }

    /**
     * Base keyDownHandler
     */
    _keyDownHandler() {

    }

    /**
    *  Check if the entered character is allowed symbol
    */
    _validateInput(character, position) {
        const that = this,
            maskElement = that._mask[position],
            regEx = new RegExp(maskElement.regex);

        return regEx.test(character);
    }

    /*
    * Updates mask items with new value, based on the mask settings
    */
    _setValueToMask(value, selection) {
        const that = this,
            newValue = value || '',
            valueLength = newValue.length;

        const selectionStart = selection && selection.start ? selection.start : 0;
        const selectionEnd = selection && selection.end ? selection.end : that._mask.length;

        let latestUpdatedPosition = selectionStart,
            latestValueChar = 0;

        while (latestUpdatedPosition < selectionEnd && latestValueChar < valueLength) {
            if (that._mask[latestUpdatedPosition].type === 'mask') {
                latestValueChar++;
            }

            if (that._setCharAtPosition(newValue.charAt(latestValueChar - 1), latestUpdatedPosition) || that._mask[latestUpdatedPosition].type !== 'mask') {
                latestUpdatedPosition++;
            }
        }

        if (latestUpdatedPosition < selectionEnd) {
            for (let i = latestUpdatedPosition; i < selectionEnd; i++) {
                if (that._mask[i].type === 'mask') {
                    that._mask[i].character = '';
                }
            }
        }

        if (selection) {
            selection.start = latestUpdatedPosition;
        }
    }

    /**
     *  Combination of preventDefault and stopPropagation. Used in several places
     */
    _preventDefault(event) {
        if (event.preventDefault) {
            event.preventDefault();
        }

        if (event.stopPropagation) {
            event.stopPropagation();
        }
    }

    /**
    *  Shows prompt characters on focus when promt is hidden on hidePromptOnLeave=true
    */
    _showPrompt() {
        const that = this;

        if (that.disabled || !that._promptHidden) {
            return;
        }

        that._setMaskToInput();
    }

    /**
    *  MaskedTextBox change handler
    */
    _textBoxChangeHandler() {
        const that = this;

        if (that.disabled || that.readonly) {
            return;
        }

        that.value = that._getValueWithTextMaskFormat({ start: 0, end: that._mask.length }, that.textMaskFormat);

        if (that._valueBeforeChange !== that.value) {
            that.$.fireEvent('change', {
                'newValue': that.value,
                'oldValue': that._valueBeforeChange
            });
            that._valueBeforeChange = '';

            that._validateMaskValue();
        }
    }

    /**
    *  MaskedTextBox key down handler
    */
    _textBoxKeyDownHandler(event) {
        const that = this,
            key = event.key,
            ctrlPressed = event.ctrlKey,
            //shiftPressed = event.shiftKey,
            ctrlHandledKeys = ['a', 'c', 'v', 'x'],
            selectionEnd = that.$.input.selectionEnd,
            asciiRegExpString = 'xxx[\x00-\x7F]+xxx',
            asciiRegExp = new RegExp(asciiRegExpString),
            allSupportedKeyboardCharacters = /^[a-zA-Z---0-9.!@?#"$%&:';()*\+,\/;\-=[\\\]\^_{|}<>~` ]+$/;

        let selectionStart = that.$.input.selectionStart;



        if (ctrlPressed && (ctrlHandledKeys.indexOf(key) > -1)) {
            const performClipboard = function (command, callback) {
                const textArea = document.createElement('textarea');

                textArea.style.position = 'absolute';
                textArea.style.left = '-1000px';
                textArea.style.top = '-1000px';

                document.body.appendChild(textArea);
                textArea.focus();
                if (command === 'Paste') {
                    setTimeout(function () {
                        let value = textArea.value;

                        if (value.length === 0 && window.clipboardData) {
                            // pasteFrom.value = window.clipboardData.getData('Text');
                            textArea.value = window.clipboardData.getData('Text');

                            value = textArea.value;
                        }

                        textArea.parentNode.removeChild(textArea);
                        that.$.input.focus();
                        callback(value);
                    }, 25);
                }
                else {
                    textArea.value = that._cutCopyHandler(null, command);
                    textArea.focus();
                    textArea.setSelectionRange(0, textArea.value.length);
                    setTimeout(function () {
                        document.designMode = 'off';
                        textArea.focus();
                        textArea.parentNode.removeChild(textArea);
                        that.$.input.focus();
                    }, 25);

                    if (window.clipboardData) {
                        window.clipboardData.setData('Text', textArea.value);
                    }
                }
            };

            switch (key) {
                case 'a':
                    that.$.input.setSelectionRange(0, that.$.input.value.length);
                    break;
                case 'c':
                    performClipboard('Copy');
                    break;
                case 'v':
                    performClipboard('Paste', function (text) {
                        const context = that.context;

                        that.context = that;
                        that._textBoxPasteHandler(null, text)
                        that.context = context;
                    });
                    break;
                case 'x':
                    performClipboard('Cut');
                    break;
            }

            return;
        }

        if (key === 'Backspace') {
            that._deleteHandler(event);
            that._updateMaskFullAndCompleted();
            return;
        }


        if (key === 'Delete') {
            that._deleteHandler(event);
            that._updateMaskFullAndCompleted();
            return;
        }

        if (!that.allowPromptAsInput && (key === that.promptChar)) {
            that._preventDefault(event);
            return;
        }

        if (that.disabled || that.readonly || (that.asciiOnly && !asciiRegExp.test(key)) || (!allSupportedKeyboardCharacters.test(key) || key.length > 1)) {
            return;
        }

        that._preventDefault(event);

        if (selectionStart === selectionEnd && selectionStart === that.$.input.value.length) {
            return;
        }

        if (key === ' ' && !that.resetOnSpace) {
            return;
        }

        selectionStart = that._getEditableSelectionStart(selectionStart, key);

        const nonEditableKeyHandler = function () {
            selectionStart = that._getNonEditableSelectionStart(that.$.input.selectionStart, key);
            if (selectionStart !== -1) {
                that.$.input.selectionStart = that.$.input.selectionEnd = selectionStart + 1;
            }
        }

        if (selectionStart === -1) {
            nonEditableKeyHandler();
            return;
        }

        const isChanged = that._setCharAtPosition(key, selectionStart);

        if (isChanged) {
            that._setMaskToInput();
            that._updateMaskFullAndCompleted();
            that.$.input.selectionStart = that.$.input.selectionEnd = selectionStart + 1;
        }
        else {
            nonEditableKeyHandler();
        }
    }

    /**
    *  MaskedTextBox key up handler
    */
    _textBoxKeyUpHandler() {
        const that = this;

        that.value = that._getValueWithTextMaskFormat({ start: 0, end: that._mask.length }, that.textMaskFormat);
    }

    /**
    *  MaskedTextBox paste handler
    */
    _textBoxPasteHandler(event, value) {
        const that = this,
            textBoxValue = that.$.input.value,
            selectionStart = that.$.input.selectionStart;
        let newValue,
            selectionEnd = that.$.input.selectionEnd;

        if (event) {
            that._preventDefault(event);
        }

        if (window.clipboardData && window.clipboardData.getData) {
            newValue = window.clipboardData.getData('Text');
        }
        else if (event && event.clipboardData && event.clipboardData.getData) {
            newValue = event.clipboardData.getData('text/plain');
        }
        else if (value) {
            newValue = value;
        }

        if ((selectionEnd - selectionStart) !== textBoxValue.length) {
            if (selectionStart === selectionEnd) {
                that.$.input.selectionEnd = selectionEnd = that._mask.length;
            }

            if (that.rejectInputOnFirstFailure) {
                let latestTestedValueChar = 0;

                for (let i = selectionStart; i < selectionEnd; i++) {
                    if (that._mask[i].type === 'mask') {
                        if (!that._validateInput(newValue.charAt(latestTestedValueChar), i)) {
                            that.$.input.selectionStart = that.$.input.selectionEnd = selectionStart;
                            return;
                        }
                        else {
                            latestTestedValueChar++;
                        }

                        if (latestTestedValueChar > newValue.length) {
                            break;
                        }
                    }
                }
            }

            const selection = { start: selectionStart, end: selectionEnd };

            that._overwrite = true;
            that._setValueToMask(newValue, selection);
            that._setMaskToInput();
            that._updateMaskFullAndCompleted();

            that.$.input.selectionStart = that.$.input.selectionEnd = selection.start;
            that.value = that._getValueWithTextMaskFormat({ start: 0, end: that._mask.length }, that.textMaskFormat);
        }
    }

    /*
    * Updates custom mask item
    */
    _setCharAtPosition(newChar, position) {
        const that = this,
            maskItem = that._mask[position];

        if (newChar === ' ' && that.resetOnSpace) {
            newChar = '';
        }

        if (maskItem.type !== 'mask' || that.readonly || that.disabled || !maskItem.editable) {
            return false;
        }

        if (newChar === '' && !that.resetOnSpace) {
            return false;
        }

        if (newChar === that.promptChar && !that.resetOnPrompt && that.allowPromptAsInput) {
            return false;
        }

        if (!that.isOverwriteMode && newChar !== '' && newChar !== that.promptChar && maskItem.character !== '' && !that._overwrite) {
            return false;
        }

        const regex = maskItem.regex;

        if (regex) {
            let regExpr = new RegExp(regex, 'i');

            if (regExpr.test(newChar)) {
                switch (maskItem.escapeSymbol) {
                    case '>':
                        newChar = newChar.toUpperCase();
                        break;
                    case '<':
                        newChar = newChar.toLowerCase();
                        break;
                }

                that._mask[position].character = newChar;
                return true;
            }
            else if (that.resetOnSpace && newChar === '') {
                that._mask[position].character = newChar;
                return true;
            }
            else if (that.resetOnPrompt && newChar === that.promptChar && that.allowPromptAsInput) {
                that._mask[position].character = '';
                return true;
            }

            return false;
        }

        return false;
    }

    /**
     *  Updates maxLength property and input's max length
     */
    _updateMaxLength() {
        const that = this;

        if (that._mask.length > 0) {
            that.maxLength = that._mask.length;
        }
    }

    /*
    * Updates prompt char
    */
    _updatePromptChar() {
        const that = this;

        for (let i = 0; i < that._mask.length; i++) {
            let maskElement = that._mask[i];

            maskElement.defaultCharacter = that.promptChar;
        }

        that._setMaskToInput();
    }

    /*
    * Validates the value according to the 'validation' property
    */
    _validateMaskValue() {
        const that = this;

        if (that.readonly || that.disabled || !that.validation || typeof that.validation !== 'function') {
            return;
        }

        const value = that.value;

        const success = that.validation(value);

        if (!success) {
            that.setAttribute('error', '');
        }
        else {
            that.removeAttribute('error');
        }

        that.$.fireEvent('validation', {
            'success': success
        });
    }

    _keyUpHandler() {
        return;
    }

    _resizeHandler() { }
    _selectStartHandler() { }
    _mouseWheelHandler() { }
    _applySelection() { }
    _setDropDownSize() { }
    _styleChangedHandler() { }
});
/**
* MultilineTextBox custom element.
*/
JQX('jqx-multiline-text-box', class MultilineTextBox extends JQX.TextBox {
    /** 
    * MultilineTextBox's properties 
    */
    static get properties() {
        return {
            'autoCapitalize': {
                value: 'none',
                allowedValues: ['none', 'words', 'characters'],
                type: 'string'
            },
            'autoComplete': {
                value: 'off',
                allowedValues: ['on', 'off'],
                type: 'string'
            },
            'autoExpand': {
                value: false,
                type: 'boolean'
            },
            'cols': {
                value: 20,
                type: 'number?'
            },
            'enterKeyBehavior': {
                value: 'newLine',
                allowedValues: ['submit', 'clearOnSubmit', 'newLine'],
                type: 'string'
            },
            'horizontalScrollBarVisibility': {
                type: 'string',
                value: 'auto',
                allowedValues: ['auto', 'disabled', 'hidden', 'visible']
            },
            'minLength': {
                value: 0,
                type: 'number'
            },
            'resizable': {
                value: false,
                type: 'boolean'
            },
            'rows': {
                value: 5,
                type: 'number?'
            },
            'selectionDirection': {
                value: 'none',
                allowedValues: ['forward', 'backward', 'none'],
                type: 'string'
            },
            'selectionEnd': {
                value: 0,
                reflectToAttribute: false,
                type: 'number'
            },
            'selectionStart': {
                value: 0,
                reflectToAttribute: false,
                type: 'number'
            },
            'spellCheck': {
                value: false,
                type: 'boolean'
            },
			'type': {
				value: 'textarea',
				type: 'string',
				defaultReflectToAttribute: true,
				readonly: true
			},		
            'verticalScrollBarVisibility': {
                type: 'string',
                value: 'auto',
                allowedValues: ['auto', 'disabled', 'hidden', 'visible']
            },
            'wrap': {
                value: 'soft',
                allowedValues: ['hard', 'soft', 'off'],
                type: 'string'
            }
        }
    }

    /**
    * MultilineTextBox's event listeners.
    */
    static get listeners() {
        return {
            'down': '_documentDownHandler',
            'document.mousemove': '_documentSelectionOutsideHandler',
            'container.resize': '_handleScrollbarsDisplay',
            'document.move': '_resizeMoveHandler',
            'document.up': '_upHandler',
            'focus': '_focusHandler',
            'horizontalScrollBar.change': '_horizontalScrollbarHandler',
            'keydown': '_keyDownHandler',
            'mouseenter': '_mouseEventsHandler',
            'mouseleave': '_mouseEventsHandler',
            'resize': '_handleScrollbarsDisplay',
            'resizeElement.down': '_resizeDownHandler',
            'styleChanged': '_handleScrollbarsDisplay',
            'input.change': '_textBoxChangeHandler',
            'input.focus': '_focusHandler',
            'input.blur': '_blurHandler',
            'input.keydown': '_textBoxKeyDownHandler',
            'input.keyup': '_keyUpHandler',
            'input.paste': '_textBoxChangeHandler',
            'input.select': '_textBoxSelectHandler',
            'wheel': '_mouseWheelHandler',
            'verticalScrollBar.change': '_verticalScrollbarHandler'
        }
    }

    /**
     * Called when the element is attached to the DOM.
     */
    attached() {
        const that = this;

        super.attached();

        if (!that._scrollView) {
            that._scrollView = new JQX.Utilities.Scroll(that.$.input, that.$.horizontalScrollBar, that.$.verticalScrollBar);
        }
    }

    detached() {
        const that = this;

        super.detached();

        if (that._scrollView) {
            that._scrollView.unlisten();
            delete that._scrollView;
        }
    }

    static get requires() {
        return {
            'JQX.ScrollBar': 'jqxscrollbar.js'
        }
    }

    /**
    * MultilineTextBox's HTML template.
    */
    template() {
        return `<div id="container">
                    <span id="label" inner-h-t-m-l="[[label]]" class="jqx-label"></span>
                    <div id="innerContainer" class="jqx-inner-container">
                            <textarea class="jqx-input" id="input"
                                autocapitalize="[[autoCapitalize]]"
                                autocomplete="off"
                                cols="[[cols]]"
                                disabled="[[disabled]]"
                                maxlength="[[maxLength]]"
                                minlength="[[minLength]]"
                                name="[[name]]"
                                placeholder="[[placeholder]]"
                                readonly="[[readonly]]"
                                required="[[required]]"
                                rows="[[rows]]"
                                spellcheck="[[spellCheck]]"
                                wrap="[[wrap]]"></textarea>
                            <jqx-scroll-bar id="verticalScrollBar" animation="[[animation]]" disabled="[[disabled]]" orientation="vertical"></jqx-scroll-bar>
                            <jqx-scroll-bar id="horizontalScrollBar" animation="[[animation]]" disabled="[[disabled]]"></jqx-scroll-bar>
                            <div id="resizeElement" class="jqx-resize-element"></div>
                    </div>
                            <textarea id="textBoxHidden"
                                class="jqx-text-box-hidden"
                                autocapitalize="[[autoCapitalize]]"
                                autocomplete="off"
                                cols="[[cols]]"
                                disabled="[[disabled]]"
                                inner-h-t-m-l="[[value]]"
                                maxlength="[[maxLength]]"
                                minlength="[[minLength]]"
                                name="[[name]]"
                                placeholder="[[placeholder]]"
                                readonly="[[readonly]]"
                                required="[[required]]"
                                rows="[[rows]]"
                                spellcheck="[[spellCheck]]"
                                wrap="[[wrap]]"></textarea>
                    <span id="hint" class="jqx-hint"></span>
                </div>`;
    }

    /**
    * Updates the TextBox when a property is changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
    * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        switch (propertyName) {
            case 'displayMode':
                switch (newValue) {
                    case 'escaped':
                        that.$.input.value = that._toEscapedDisplayMode(that.value);
                        break;
                    default:
                        that.$.input.value = that.value = that._toDefaultDisplayMode(that.$.input.value);
                        break;
                }

                that._autoExpandUpdate();
                that._handleScrollbarsDisplay();
                break;
            case 'value':
                if (that._preventProgramaticValueChange) {
                    that._userValue = that.displayMode === 'escaped' ? that._toDefaultDisplayMode(that.$.input.value) : that.$.input.value;
                    that._programmaticValue = newValue;
                }
                else {
                    that._userValue = that._programmaticValue = newValue;
                }

                switch (that.displayMode) {
                    case 'escaped':
                        that.$.input.value = that._toEscapedDisplayMode(that._userValue);
                        break;
                    default:
                        that.$.input.value = that._userValue;
                        break;
                }

                that._oldValue = oldValue;
                that._autoExpandUpdate();
                that._handleScrollbarsDisplay();
                break;
            case 'horizontalScrollBarVisibility':
            case 'verticalScrollBarVisibility':
            case 'singleLine':
            case 'wrap':
            case 'resizable':
            case 'placeholder':
                that._autoExpandUpdate();
                that._handleScrollbarsDisplay();
                break;
            case 'selectionEnd':
            case 'selectionStart':
                that._handleSelectedText();
                break;
            case 'rows':
            case 'cols':
                that._updateSizeRowsCols();
                break;
            case 'disabled':
                that._setFocusable();
                break;
            case 'animation':
            case 'readonly':
                break;
            default:
                super.propertyChangedHandler(propertyName, oldValue, newValue);
                break;
        }
    }

    /**
    * Gets selected text in relation to a display mode
    */
    selection(displayMode) {
        const that = this;
        let start = that.$.input.selectionStart,
            end = that.$.input.selectionEnd,
            value = that.value;

        if (that.displayMode === 'escaped') {
            value = that.$.input.value.substring(start, end);

            if (displayMode === 'escaped') {
                return value;
            }
            else {
                return that._toDefaultDisplayMode(value);
            }
        }

        if (displayMode === 'escaped') {
            value = value.substring(start, end);
            return that._toEscapedDisplayMode(value);
        }

        value = value.substring(start, end);
        return value;
    }

    /**
    * Select Method 
    */
    select(start, end) {
        const that = this,
            args = Array.from(arguments).slice(0, 2);

        let selectionStart, selectionEnd;

        for (let i in args) {
            args[i] = parseInt(args[i]) || 0;
        }

        if (args.length === 2) {
            selectionStart = Math.min([start, end]);
            selectionEnd = Math.max([start, end]);
        }
        else {
            selectionStart = args[0];
        }

        if (args.length === 2) {
            selectionStart = parseInt(selectionStart)

            if (selectionStart > 0) {
                selectionStart = selectionStart < that.$.input.length ? that.$.input.length : selectionStart;
            }
            else {
                selectionStart = 0;
            }

            if (selectionEnd < selectionStart) {
                selectionEnd = selectionStart;
            }
            else if (selectionEnd > that.$.input.length) {
                selectionStart = 0;
            }

            that.$.input.focus();
            that.$.input.setSelectionRange(selectionStart, selectionEnd);

            return;
        }
        else if (args.length === 1) {
            that.$.input.focus();
            that.$.input.setSelectionRange(selectionStart, selectionStart + 1);

            return;
        }

        that.$.input.select();
    }

    /**
    * Updates the height of the multiline text box according to the number of text rows
    */
    _autoExpandUpdate() {
        const that = this;

        if (!that.autoExpand) {
            return;
        }

        that.$.textBoxHidden.value = that.$.input.value;
        that.$.textBoxHidden.style.cssText = 'height:0px';
        that.$.input.style.cssText = 'height:' + that.$.textBoxHidden.scrollHeight + 'px';
    }

    _blurHandler() {
        const that = this;

        if (that._outsideAutoScroll) {
            clearInterval(that._outsideAutoScroll); // new
        }

        that.removeAttribute('focus');
        that._preventProgramaticValueChange = false;
        that._oldValue = that.value;
        that.value = that._userValue || that.value;
    }

    /**
    * MultilineTextBox create element method.
    */
    _createElement() {
        const that = this;

        if (that.autoFocus) {
            //that.$.input.focus();
            if (navigator.userAgent.match(/Edge/)) {
                setTimeout(function () {
                    that.$.input.focus();
                    that.setAttribute('focus', '');
                }, 10);
            }
            else {
                that.$.input.focus();
                that.setAttribute('focus', '');
            }
        }

        //  that.autoExpand = (that.theme.indexOf('material') > -1 || that.autoExpand) ? true : false;//

        const wrappedText = that.$.input.innerHTML;

        if (that.value) {
            that.$.input.innerHTML = that.displayMode === 'escaped' ? that._toEscapedDisplayMode(that.value) : that.value;
        }
        else if ((wrappedText.length > 0) && that.displayMode === 'escaped') {
            that.value = wrappedText;
            that.$.input.innerHTML = that._toEscapedDisplayMode(wrappedText)
        }
        else if (wrappedText.length > 0) {
            that.value = wrappedText;
        }

        that._setFocusable();
        that._syncTextBoxContentOnInitialization();
        that._scrollView = new JQX.Utilities.Scroll(that.$.input, that.$.horizontalScrollBar, that.$.verticalScrollBar);
        that._autoExpandUpdate();
        that._handleScrollbarsDisplay();
        that._initializationValue = that._oldValue = that.value;
        that.value.length > 0 ? that.$.addClass('has-value') : that.$.removeClass('has-value');
        that._handleHintContainer();
    }

    /**
    * Handles the display of the scrollbars, based on set properties and text length.
    */
    _handleScrollbarsDisplay(event) {
        const that = this,
            textBox = that.$.input;

        setTimeout(function () {
            switch (that.horizontalScrollBarVisibility) {
                case 'disabled':
                    that.$container.addClass('hscroll');
                    that.$.horizontalScrollBar.disabled = true;
                    break;
                case 'hidden':
                    that.$container.removeClass('hscroll');
                    break;
                case 'visible':
                    that.$container.addClass('hscroll');
                    that._scrollView.scrollWidth = textBox.scrollWidth - textBox.clientWidth;
                    that._scrollView.scrollTo(that.$.input.scrollLeft, true);
                    that.$.horizontalScrollBar.disabled = false;
                    break;
                default:
                    if (textBox.scrollWidth > textBox.clientWidth) {
                        that.$container.addClass('hscroll');

                        that._scrollView.scrollWidth = textBox.scrollWidth - textBox.clientWidth;

                        if (event && event.type === 'resize') {
                            that.$.input.scrollLeft = that._scrollView.scrollLeft;
                        }
                        else {
                            that._scrollView.scrollTo(that.$.input.scrollLeft, true);
                        }
                    }
                    else {
                        that.$container.removeClass('hscroll');
                    }
                    that.$.horizontalScrollBar.disabled = false;
            }

            switch (that.verticalScrollBarVisibility) {
                case 'disabled':
                    that.$container.addClass('vscroll');
                    that.$.verticalScrollBar.disabled = true;
                    break;
                case 'hidden':
                    that.$container.removeClass('vscroll');
                    break;
                case 'visible':
                    that.$container.addClass('vscroll');
                    that._scrollView.scrollHeight = textBox.scrollHeight - textBox.clientHeight;
                    that._scrollView.scrollTo(that.$.input.scrollTop);
                    that.$.verticalScrollBar.disabled = false;
                    break;
                default:
                    if (textBox.scrollHeight > textBox.clientHeight) {
                        that.$container.addClass('vscroll');

                        that._scrollView.scrollHeight = textBox.scrollHeight - textBox.clientHeight;

                        if (event && event.type === 'resize') {
                            that.$.input.scrollTop = that._scrollView.scrollTop;
                        }
                        else {
                            that._scrollView.scrollTo(that.$.input.scrollTop);
                        }
                    }
                    else {
                        that.$container.removeClass('vscroll');
                    }
                    that.$.verticalScrollBar.disabled = false;
            }
        }, 0);

    }

    /**
   * Focus handler. Selects whole text in element's text area on selectAllOnFocus: true
   */
    _focusHandler(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        if (event.target === that) {
            that.$.input.focus();
            that._edgeSelect = false;
            return;
        }

        that.setAttribute('focus', '');

        if (that.selectAllOnFocus) {
            if (navigator.userAgent.match(/Edge/)) {
                const scrollTop = that.$.input.scrollTop;

                if (that._edgeSelect) {
                    that._edgeSelect = false;
                    return;
                }

                setTimeout(function () {
                    that._edgeSelect = true;
                    that.$.input.select();
                    that.$.input.scrollTop = scrollTop;
                }, 5);
            }
            else {
                that.$.input.select();
            }
        }
    }

    /**
    * Horizontal scrollbar handler.
    */
    _horizontalScrollbarHandler(event) {
        const that = this;

        if (that.disabled || that.horizontalScrollBarVisibility === 'hidden' || that.horizontalScrollBarVisibility === 'disabled') {
            return;
        }

        event.stopPropagation();
        that.$.input.scrollLeft = event.detail.value;
    }

    /**
    * keyDown event handler.
    */
    _keyDownHandler(event) {
        const that = this,
            key = event.key,
            shiftKey = event.shiftKey,
            ctrlKey = event.ctrlKey,
            value = that.$.input.value;

        function replaceEscapedKeyWith(newValue) {
            let selectionStart = that.$.input.selectionStart,
                selectionEnd = that.$.input.selectionEnd,
                value = that.$.input.value;

            event.preventDefault();
            that.$.input.value = value.substring(0, selectionStart) + newValue + value.substring(selectionEnd, value.length);
            that.value = that._toDefaultDisplayMode(that.$.input.value);

            that.$.input.selectionStart = selectionStart + 2;
            that.$.input.selectionEnd = selectionStart + 2;
        }

        if (that.allowVerticalScrollbar && that.$.input.selectionEnd > (that.$.input.value.length - 5)) {
            that._scrollView.scrollTo(that._scrollView.scrollTop + (event.deltaY < 0 ? -that.offsetHeight : that.offsetHeight));
        }

        if (key.indexOf('Arrow') > -1) {
            event.stopPropagation();
            return;
        }

        switch (key) {
            case 'Enter': {
                if (that.enterKeyBehavior === 'newLine' && !ctrlKey && !shiftKey) {
                    if (that.displayMode === 'escaped') {
                        replaceEscapedKeyWith('\\n');
                    }

                    break;
                }

                event.preventDefault();

                that._userValue = that.displayMode === 'escaped' ? that._toDefaultDisplayMode(that.$.input.value) : that.$.input.value;
                that.value = that._userValue;

                if (value !== '' && that._userValue !== that._oldValue) {
                    that.$.fireEvent('change', {
                        'oldValue': that._oldValue,
                        'value': value,
                        'type': 'submit'
                    });
                }

                if (that.enterKeyBehavior === 'clearOnSubmit') {
                    that.$.input.value = '';
                }

                that._oldValue = that.value = that._toDefaultDisplayMode(that.$.input.value);
                that._submitted = true;

                if (that.displayMode === 'escaped' && that.enterKeyBehavior.toLowerCase().indexOf('submit') < 0 && !ctrlKey && !shiftKey) {
                    replaceEscapedKeyWith('\\n');
                }

                if ((that.enterKeyBehavior === 'submit') || (that.enterKeyBehavior === 'newLine' && ctrlKey)) {
                    that.$.input.blur();
                }

                break;
            }
            case 'Escape':
                if (that.escKeyMode === 'none') {
                    return;
                }

                switch (that.escKeyMode) {
                    case 'none':
                        break;
                    case 'clearValue':
                        that.value = that.$.input.value = '';
                        break;
                    case 'previousValue':
                        that.$.input.value = that.displayMode === 'escaped' ? that._toEscapedDisplayMode(that._oldValue) : that._oldValue;
                        break;
                }

                break;
            case ' ':
                if (that.displayMode === 'escaped') {
                    replaceEscapedKeyWith('\\s');
                }
                break;
            case 'Backspace':
                if ((that.displayMode === 'escaped') && (that.$.input.selectionStart === that.$.input.selectionEnd)) {
                    let carretPosition = that.$.input.selectionStart;

                    if ((value[carretPosition - 2] === '\\') && ((value[carretPosition - 1] === 's') || (value[carretPosition - 1] === 'n'))) {
                        that.$.input.value = that.$.input.value.substring(0, carretPosition - 2) + that.$.input.value.substring(carretPosition - 2, that.$.input.value.length);
                        that.$.input.selectionStart = carretPosition - 2;
                    }
                }

                if (that._scrollView) {
                    that._handleScrollbarsDisplay();
                }
                break;
        }
    }

    /**
    * TextBox keyUp event handler.
    */
    _keyUpHandler(event) {
        const that = this,
            key = event.key;

        switch (key) {
            case 'ArrowLeft':
            case 'ArrowUp':
            case 'ArrowDown':
                that._handlePointerInEscapedSymbol();
                break;
            case 'ArrowRight':
                that._handlePointerInEscapedSymbol('next');
                break;
        }

        that._autoExpandUpdate();
        that._userValue = that.displayMode === 'escaped' ? that._toDefaultDisplayMode(that.$.input.value) : that.$.input.value;

        that._submitKeyUpHandler();
    }

    /**
   * MultilineTextBox keyDown event handler.
   */
    _textBoxKeyDownHandler(event) {
        const that = this,
            key = event.key;

        if (that._scrollView) {
            that._handleScrollbarsDisplay();
        }

        that._autoExpandUpdate();
        that.value && that.value.length > 0 ? that.$.addClass('has-value') : that.$.removeClass('has-value');

        if (['Enter', 'Escape'].indexOf(key) === -1) {
            that._preventProgramaticValueChange = true;
        }

        if (['ArrowLeft', 'ArrowUp', 'ArrowDown', 'ArrowRight'].indexOf(key) > -1) {
            that._scrollView.scrollTo(that.$.input.scrollTop);
        }

        if (['PageUp', 'PageDown'].indexOf(key) > -1 && JQX.Utilities.Core.Browser.Chrome) {
            if (event.key === 'PageUp') {
                that.$.input.setSelectionRange(0, 0);
                that.$.input.scrollTop = 0;
            }

            if (event.key === 'PageDown') {
                that.$.input.setSelectionRange(that.$.input.value.length, that.$.input.value.length);
                that.$.input.scrollTop = that._scrollView.verticalScrollBar.max;
            }

            event.preventDefault();
        }
    }

    /**
    * Mouse wheel handler.
    */
    _mouseWheelHandler(event) {
        const that = this;

        if (that.disabled || that.$.verticalScrollBar.disabled) {
            return;
        }

        that._scrollView.scrollTo(that._scrollView.scrollTop + (event.deltaY < 0 ? -that.offsetHeight : that.offsetHeight));
        that.$.input.scrollTop += event.deltaY < 0 ? -that.offsetHeight : that.offsetHeight;

        if (that.$.input.scrollTop > 0) {
            event.preventDefault();
        }
    }

    /**
    * Gets the text in the TextBox before widget's initialization
    */
    _syncTextBoxContentOnInitialization() {
        const that = this;
        let value;

        if (that.value === '') {
            value = that.innerHTML;
        }
        else {
            value = that.value;
        }

        if (that.displayMode === 'escaped') {
            if (value.match(/\r\n|\n\r|\n|\r|\s|\t|\f|\r/g)) {
                that.value = that._initializationValue = value;
                that.$.input.value = that._toEscapedDisplayMode(value);
            }
            else {
                that.value = that._initializationValue = that._toDefaultDisplayMode(value);
                that.$.input.value = value;
            }

            return;
        }

        that.$.input.value = that.value = that._initializationValue = value;
    }

    /**
    * TextBox change handler.
    */
    _textBoxChangeHandler(event) {
        const that = this,
            clipboardData = event.clipboardData || (event.originalEvent && event.originalEvent.clipboardData) || window.clipboardData,
            oldValue = that.value;

        if (that.displayMode === 'escaped') {
            const selectionStart = that.$.input.selectionStart,
                selectionEnd = that.$.input.selectionEnd;

            if (clipboardData) {
                let clipboardValue = clipboardData.getData('text'),
                    value = that.$.input.value;

                event.preventDefault();
                clipboardValue = that._toEscapedDisplayMode(clipboardValue);
                that.$.input.value = value.substring(0, selectionStart) + clipboardValue + value.substring(selectionEnd, value.length);
            }

            that.value = that._toDefaultDisplayMode(that.$.input.value);
        }
        else {
            that.value = that.$.input.value;
        }

        that._handleScrollbarsDisplay();
        that.value.length > 0 ? that.$.addClass('has-value') : that.$.removeClass('has-value');

        if (!clipboardData) {
            that.$.fireEvent('change', {
                'value': that.value,
                'oldValue': oldValue,
                'type': 'blur'
            });
        }

        that._handleHintContainer();
    }

    /**
    * Resize Element down handler.
    */
    _resizeDownHandler() {
        const that = this;

        if (that.disabled || !that.resizable) {
            return;
        }

        that._resizeStarted = true;
        that.$container.addClass('jqx-resize');

        if (!that.readonly) {
            that.$.input.setAttribute('readonly', '');
        }
    }

    /**
    * Resize Element move handler.
    */
    _resizeMoveHandler(event) {
        const that = this;

        if (that.disabled || !that.resizable || !that._resizeStarted) {
            return;
        }

        const rectObject = that.getBoundingClientRect(),
            min = { width: 50, height: 50 },
            newWidth = event.clientX - rectObject.left,
            newHeight = event.clientY - rectObject.top;

        if (newWidth > min.width) {
            that.style.width = newWidth + 'px';
        }

        if (newHeight > min.height) {
            that.style.height = newHeight + 'px';
        }
    }

    /**
    * Update size on cols and rows change.
    */
    _updateSizeRowsCols() {
        const that = this;

        that.$.container.removeAttribute('style');

        setTimeout(function () {
            if ((that.horizontalScrollBarVisibility === 'disabled' || that.horizontalScrollBarVisibility === 'hidden') && (that.verticalScrollBarVisibility === 'disabled' || that.verticalScrollBarVisibility === 'hidden')) {
                return;
            }

            const rectObject = that.getBoundingClientRect();

            that.$.container.style.width = rectObject.width + 'px';
            that.$.container.style.height = rectObject.height + 'px';
        }, 0);
    }

    /**
    * Up handler.
    */
    _upHandler(event) {
        const that = this;

        that._selectionStarted = false;

        if (that.disabled) {
            return;
        }

        if (event.originalEvent.target === that.$.input) {
            that._handlePointerInEscapedSymbol();
            return;
        }

        that.$container.removeClass('jqx-resize');

        if (!that.readonly) {
            that.$.input.removeAttribute('readonly');
        }

        if (that._resizeStarted) {
            that.$.input.focus();
        }

        that._resizeStarted = false;
    }

    /**
    * Vertical scrollbar handler.
    */
    _verticalScrollbarHandler(event) {
        const that = this;

        if (that.disabled || that.verticalScrollBarVisibility === 'disabled' || that.verticalScrollBarVisibility === 'hidden') {
            return;
        }

        event.stopPropagation();
        that.$.input.scrollTop = event.detail.value;
    }

    /**
    * Used in drag outside support.
    */
    _documentDownHandler(event) {
        const that = this;

        that._selectionStarted = false;

        if (!event.originalEvent || !that.contains(event.originalEvent.target)) {
            return;
        }

        that._selectionStarted = true;
        that._selectionStartTime = new Date();
        that._pointerDown = { pageX: event.pageX, pageY: event.pageY };
        that._edgeSelect = false;
    }

    _documentSelectionOutsideHandler(event) {
        const that = this,
            coordOffset = 10;

        clearInterval(that._outsideAutoScroll);

        if (!that._selectionStarted) {
            return;
        }

        const inputCoord = that.$.input.getBoundingClientRect(),
            topBound = inputCoord.y + coordOffset,
            bottomBound = inputCoord.y + inputCoord.height - coordOffset;

        if (event.pageY > topBound && event.pageY < bottomBound) {
            return;
        }

        const standardClickDelay = 300;
        const isClick = new Date() - that._selectionStartTime < standardClickDelay;
        const isDrag = !isClick &&
            (Math.abs(that._pointerDown.pageX - event.pageX) >= 3 ||
                Math.abs(that._pointerDown.pageY - event.pageY) >= 3);

        if (!isDrag) {
            return;
        }

        that._outsideAutoScroll = setInterval(function () {
            scrollElement();
            scrollElement(true);
        }, 10);

        function scrollElement(horizontally) {
            const elementCoordinates = that.getBoundingClientRect(),
                documentElement = document.documentElement,
                pointerOffset = horizontally ? elementCoordinates.left + documentElement.scrollLeft - event.pageX : elementCoordinates.top + documentElement.scrollTop - event.pageY,
                suffix = horizontally ? 'Left' : 'Top';

            if (pointerOffset > 0) {
                that.$.input['scroll' + suffix] -= 10;
                that._scrollView['scroll' + suffix] -= 10;
            }
            else {
                that.$.input['scroll' + suffix] += 10;
                that._scrollView['scroll' + suffix] += 10;
            }
        }
    }

    _selectStartHandler() { }
    _styleChangedHandler() { }
});
/**
* PasswordTextBox custom element.
*/
JQX('jqx-password-text-box', class PasswordTextBox extends JQX.TextBox {
    /** 
    * PasswordTextBox's properties 
    */
    static get properties() {
        return {
            'messages': {
                value: {
                    'en': {
                        'passwordStrength': 'Password strength',
                        'short': 'Short',
                        'weak': 'Weak',
                        'far': 'Far',
                        'good': 'Good',
                        'strong': 'Strong',
                        'showPassword': 'Show password'
                    }
                },
                type: 'object',
                extend: true
            },
            'passwordStrength': {
                value: null,
                type: 'function?',
                reflectToAttribute: false
            },
            'showPasswordIcon': {
                value: false,
                type: 'boolean'
            },
            'showPasswordStrength': {
                value: false,
                type: 'boolean'
            },
            'tooltipArrow': {
                value: false,
                type: 'boolean'
            },
            'tooltipDelay': {
                value: 0,
                type: 'number'
            },
            'tooltipPosition': {
                allowedValues: ['bottom', 'top', 'left', 'right', 'absolute'],
                value: 'top',
                type: 'string'
            },
            'tooltipTemplate': {
                value: null,
                type: 'string?'
            },
			'type': {
				value: 'password',
				type: 'string',
				defaultReflectToAttribute: true,
				readonly: true
			},		
            'value': {
                value: '',
                reflectToAttribute: false,
                type: 'string'
            }
        }
    }

    static get requires() {
        return {
            'JQX.Tooltip': 'jqxtooltip.js'
        }
    }

    /**
    * PasswordTextBox's event listeners.
    */
    static get listeners() {
        return {
            'document.up': '_documentUpHandler',
            'blur': '_blurHandler',
            'focus': '_focusHandler',
            'mouseenter': '_mouseEventsHandler',
            'mouseleave': '_mouseEventsHandler',
            'passwordIcon.down': '_showPassword',
            'input.change': '_textBoxChangeHandler',
            'input.paste': '_textBoxChangeHandler',
            'input.keyup': '_textBoxChangeHandler',
            'input.blur': '_blurHandler',
            'input.focus': '_focusHandler'
        }
    }

    /**
    * PasswordTextBox's HTML template.
    */
    template() {
        return `<div id="container">
                    <span id="label" inner-h-t-m-l="[[label]]" class ="jqx-label"></span>
                    <div id="innerContainer" class="jqx-inner-container">
                            <input class ="jqx-input" type="password" id="input"
                                disabled="[[disabled]]"
                                maxlength="[[maxLength]]"
                                minlength="[[minLength]]"
                                name="[[name]]"
                                placeholder="[[placeholder]]"
                                value="[[value]]">
                            <span id="passwordIcon" title="Show Password" class ="jqx-password-icon jqx-hidden">&#xe80a; </span>
                    </div>
                    <span id="hint" class ="jqx-hint"></span>
                    <jqx-tooltip id="tooltip"
                        open-mode="manual"
                        arrow="[[tooltipArrow]]"
                        tooltip-template="[[tooltipTemplate]]"
                        position="[[tooltipPosition]]"
                        delay="[[tooltipDelay]]">
                     </jqx-tooltip>
                </div>`;
    }

    /**
    * Updates the PasswordTextBox when a property is  changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value.
    * @param {number/string} newValue The new entered value.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;
        let strength;

        switch (propertyName) {
            case 'locale':
            case 'messages':
            case 'passwordStrength':
                strength = that._evaluatePasswordStrength();

                that._updateTooltipString(strength);
                that.$.passwordIcon.setAttribute('title', that.localize('showPassword'));
                that._updatePasswordStrengthStyles(strength);
                break;
            case 'tooltipPosition':
                that.$.tooltip.position = that.tooltipPosition;
                break;
            case 'tooltipTemplate':
                that.$.tooltip.tooltipTemplate = that.tooltipTemplate;
                break;
            case 'value':
                strength = that._evaluatePasswordStrength();

                that._updateTooltipString(strength);
                that._updatePasswordStrengthStyles(strength);
                break;
            case 'disabled':
                that._setFocusable();
                break;
            case 'readonly':
                break;
            default:
                super.propertyChangedHandler(propertyName, oldValue, newValue);
                break;
        }
    }

    /**
     * Element's create method
     */
    _createElement() {
        const that = this;

        if (that.autoFocus) {
            that.$.input.focus();
        }

        that._setFocusable();
        that.$.tooltip.selector = that.$.innerContainer;
        that.$.passwordIcon.setAttribute('title', that.localize('showPassword'));
        that._updateTooltipString('short');
        that._updatePasswordStrengthStyles();
        that._initializationValue = that.value;
        that.value.length > 0 ? that.$.addClass('has-value') : that.$.removeClass('has-value');
        that._handleHintContainer();
    }

    /**
    * PasswordTextBox focus handler.
    */
    _focusHandler() {
        const that = this;

        if (that.disabled) {
            return;
        }

        if (that.selectAllOnFocus) {
            that.$.input.select();
        }

        if (that.showPasswordIcon) {
            that.$passwordIcon.removeClass('jqx-hidden');
        }

        that.setAttribute('focus', '');

        that._valueBeforeChange = that.value;

        if (!that.showPasswordStrength) {
            return;
        }

        if (!that._tooltipOpened) {
            that.$.tooltip.open();
            that._tooltipOpened = true;
        }
    }

    /**
    * PasswordTextBox blur handler.
    */
    _blurHandler() {
        const that = this;

        if (that.disabled || that._passwordIconPressed) {
            return;
        }

        if (that._valueBeforeChange !== that.value) {
            that.$.fireEvent('change', {
                'newValue': that.value,
                'oldValue': that._valueBeforeChange
            });
            that._valueBeforeChange = '';
        }

        if (that.showPasswordIcon) {
            that.$passwordIcon.addClass('jqx-hidden');
        }

        that.removeAttribute('focus');
        that.value.length > 0 ? that.$.addClass('has-value') : that.$.removeClass('has-value');

        if (!that._tooltipOpened) {
            return;
        }

        that.$.tooltip.close();
        that._tooltipOpened = false;
    }

    /**
    * Shows password if show passwor icon is pressed.
    */
    _showPassword() {
        const that = this;

        if (that.disabled || !that.showPasswordIcon) {
            return;
        }

        that.$.input.type = 'text';
        that._passwordIconPressed = true;
    }

    /**
    * Hides password.
    */
    _documentUpHandler() {
        const that = this;

        if (that.disabled || !that.showPasswordIcon || !that._passwordIconPressed) {
            return;
        }

        that.$.input.type = 'password';
        that._passwordIconPressed = false;
        that.$.input.focus();
    }

    /**
    *  PasswordTextBox change handler.
    */
    _textBoxChangeHandler() {
        const that = this;

        if (that.disabled || that.readonly) {
            return;
        }

        that.value = that.$.input.value;
        let strength = that._evaluatePasswordStrength();

        that._updateTooltipString(strength);
        that._updatePasswordStrengthStyles(strength);
    }

    /**
    *  Updates container's styles related to the password strength.
    */
    _updatePasswordStrengthStyles(strength) {
        const that = this,
            passwordStrengthOptions = ['short', 'weak', 'far', 'good', 'strong'];

        strength = strength || 'short';

        for (let i = 0; i < passwordStrengthOptions.length; i++) {
            that.$container.removeClass('jqx-password-' + passwordStrengthOptions[i]);
        }

        if (that.disabled) {
            return;
        }

        that.$container.addClass('jqx-password-' + strength);
    }

    /**
    *  Evaluates the strength of the password string.
    */
    _evaluatePasswordStrength() {
        const that = this,
            password = that.$.input.value,
            passwordLength = password.length,
            allowedSymbols = '<>@!#$%^&*()_+[]{}?:;|\'"\\,./~`-=';

        if (that.disabled) {
            return;
        }

        if (that.passwordStrength) {
            return that.passwordStrength(password, allowedSymbols);
        }

        let letters = 0,
            numbers = 0,
            specials = 0,
            passwordStrength = 0;

        for (var i = 0; i < passwordLength; i++) {
            const charAt = password.charAt(i),
                charCodeAt = password.charCodeAt(i);

            if ((charCodeAt > 64 && charCodeAt < 91) || (charCodeAt > 96 && charCodeAt < 123) || (charCodeAt > 127 && charCodeAt < 155) || (charCodeAt > 159 && charCodeAt < 166)) {
                letters += 1;
                continue
            }
            if (isNaN(charAt) === false) {
                numbers += 1;
                continue
            }
            if (allowedSymbols.indexOf(charAt) !== -1) {
                specials += 1;
                continue
            }
        }

        passwordStrength = letters + numbers + 2 * specials + letters * numbers / 2 + passwordLength;

        if (passwordLength < 8) {
            return 'short';
        }
        else {
            if (passwordStrength < 20) {
                return 'weak';
            }
            else if (passwordStrength < 30) {
                return 'far';
            }
            else if (passwordStrength < 40) {
                return 'good';
            }
            else {
                return 'strong';
            }
        }
    }

    _keyUpHandler() { }
    _mouseWheelHandler() { }
    _resizeHandler() { }
    _selectStartHandler() { }
    _setDropDownSize() { }
    _styleChangedHandler() { }

    _updateTooltipString(strength) {
        const that = this;

        that.$.tooltip.value = '<span class="password-strength-label">' + that.localize('passwordStrength') + ':</span><span class="password-strength-value">' + that.localize(strength) + '</span>';
    }
});
JQX.Utilities.Assign('Grid.Column', class Column {
    constructor(column) {
        const that = this;

        if (typeof column !== 'string') {
            Object.assign(that, column);
        }
        else {
            that.label = column;
            that.dataField = column;
        }

        if (!that.dataType) {
            that.dataType = 'string';
        }

        if (!that.columnGroup) {
            that.columnGroup = '';
        }

        that.canNotify = true;

        let align = 'left';

        switch (that.dataType) {
            case 'string':
            case 'date':
                align = 'left';
                break;
            case 'number':
                align = 'right';
                break;
            case 'boolean':
                align = 'center';
                break;
        }

        if (that.index === undefined) {
            that.index = -1;
        }

        if (that.visibleIndex === undefined) {
            that.visibleIndex = -1;
        }

        if (that.selected === undefined) {
            that.selected = false;
        }

        if (!that.label) {
            that.label = '';
        }

        if (!that.menuItems) {
            that.menuItems = null;
        }

        if (!that.icon) {
            that.icon = 'jqx-icon-user';
        }

        if (!that.displayField) {
            that.displayField = that.dataField;
        }

        if (!that.template) {
            that.template = '';
        }

        if (!that.editor) {
            that.editor = 'input';
        }

        if (typeof that.editor === 'string') {
            that.editor = {
                template: that.editor,
                autoFocus: true
            }
        }
        else {
            if (undefined === that.editor.autoFocus) {
                that.editor.autoFocus = true;
            }
        }

        that.menu = null;

        if (that.allowActionButtonAnimation === undefined) {
            if (that.grid) {
                that.allowActionButtonAnimation = that.grid.appearance.allowColumnActionButtonAnimation;
            }
            else {
                that.allowActionButtonAnimation = false;
            }
        }

        if (that.allowSortButtonAnimation === undefined) {
            if (that.grid) {
                that.allowSortButtonAnimation = that.grid.appearance.allowColumnSortButtonAnimation;
            }
            else {
                that.allowSortButtonAnimation = false;
            }
        }

        if (that.autoShowActionButton === undefined) {
            if (that.grid) {
                that.autoShowActionButton = that.grid.appearance.autoShowColumnActionButton;
            }
            else {
                that.autoShowActionButton = false;
            }
        }

        if (that.autoShowSortButton === undefined) {
            if (that.grid) {
                that.autoShowSortButton = that.grid.appearance.autoShowColumnSortButton;
            }
            else {
                that.autoShowSortButton = true;
            }
        }

        if (that.showSortButton === undefined) {
            if (that.grid) {
                that.showSortButton = that.grid.appearance.showColumnSortButton;
            }
            else {
                that.showSortButton = false;
            }
        }

        if (that.showIcon === undefined) {
            if (that.grid) {
                that.showIcon = that.grid.appearance.showColumnIcon;
            }
            else {
                that.showIcon = false;
            }
        }

        if (that.showDescriptionButton === undefined) {
            if (that.grid) {
                that.showDescriptionButton = that.grid.appearance.showColumnDescriptionButton;
            }
            else {
                that.showDescriptionButton = false;
            }
        }

        if (that.showCustomButton === undefined) {
            if (that.grid) {
                that.showCustomButton = that.grid.appearance.showColumnCustomButton;
            }
            else {
                that.showCustomButton = false;
            }
        }

        if (that.showActionButton === undefined) {
            if (that.grid) {
                that.showActionButton = that.grid.appearance.showColumnActionButton;
            }
            else {
                that.showActionButton = false;
            }
        }

        if (that.allowLabelAnimation === undefined) {
            if (that.grid) {
                that.allowLabelAnimation = that.grid.appearance.allowColumnLabelAnimation;
            }
            else {
                that.allowLabelAnimation = false;
            }
        }

        if (that.autoShowFilterButton === undefined) {
            if (that.grid) {
                that.autoShowFilterButton = that.grid.appearance.autoShowColumnFilterButton;
            }
            else {
                that.autoShowFilterButton = false;
            }
        }


        if (that.showFilterButton === undefined) {
            if (that.grid) {
                that.showFilterButton = that.grid.appearance.showColumnFilterButton;
            }
            else {
                that.showFilterButton = false;
            }
        }

        if (that.autoCloseMenu === undefined) {
            if (that.grid) {
                that.autoCloseMenu = that.grid.columnMenu.autoClose;
            }
            else {
                that.autoCloseMenu = true;
            }
        }

        if (!that.formatFunction) {
            that.formatFunction = null;
        }

        if (!that.sortOrder) {
            that.sortOrder = null;
        }

        if (!that.sortIndex) {
            that.sortIndex = null;
        }

        if (!that.filter) {
            that.filter = null;
        }

        if (!that.filterMenuMode) {
            that.filterMenuMode = 'default';
        }

        if (!that.align) {
            that.align = align;
        }

        if (!that.cellsAlign) {
            that.cellsAlign = align;
        }

        if (!that.minWidth) {
            that.minWidth = 30;
        }

        if (!that.width) {
            that.width = 'auto';
        }

        if (that.grid && that.grid.columnWidth) {
            that.width = that.grid.columnWidth;
        }

        if (that.visible === undefined) {
            that.visible = true;
        }

        if (that.allowResize === undefined) {
            that.allowResize = true;
        }

        if (that.allowReorder === undefined) {
            that.allowReorder = true;
        }


        if (that.allowHide === undefined) {
            that.allowHide = true;
        }

        if (that.allowSort === undefined) {
            that.allowSort = true;
        }

        if (that.allowSelect === undefined) {
            that.allowSelect = true;
        }

        if (that.allowSortToggleOnClick === undefined) {
            that.allowSortToggleOnClick = true;
        }

        if (that.allowGroup === undefined) {
            that.allowGroup = true;
        }

        if (that.allowFilter === undefined) {
            that.allowFilter = true;
        }

        if (that.allowEdit === undefined) {
            that.allowEdit = true;
        }

        if (that.allowExport === undefined) {
            that.allowExport = true;
        }

        if (that.description === undefined) {
            that.description = '';
        }

        if (undefined === that.group) {
            that.group = false;
        }

        if (!that.summary) {
            that.summary = [];
        }

        that.selected = false;
        that.sorted = false;
        that.filtered = false;
        that.parent = null;
        that.children = [];
    }

    refresh() {
        const that = this;

        if (that.element) {
            that.element._refresh();
        }
    }

    render() {
        const that = this;

        that.element.column = that;

        if (that.element) {
            that.element._render();
        }
    }

    setProperty(propertyName, value) {
        const that = this;
        const oldValue = that.getProperty(propertyName);

        if (oldValue !== value) {
            that.canNotify = false;
            that[propertyName] = value;
            that.propertyChanged(propertyName, oldValue, value);
            that.canNotify = true;
        }
    }

    getProperty(propertyName) {
        const that = this;

        if (propertyName === 'selected') {
            let selected = false;

            if (that.grid._selection.cells['column' + that.dataField]) {
                selected = null;
            }

            if (that.grid && that.grid._selection.columns[that.dataField]) {
                selected = true;
            }

            that.grid.columns.canNotify = false;
            that[propertyName] = selected;
            that.grid.columns.canNotify = true;

            return selected;
        }

        if (propertyName === 'group') {
            if (that.dataSource && that.dataSource.groupBy) {
                return that.dataSource.groupBy.indexOf(that.dataField) >= 0;
            }

            return false;
        }

        return that[propertyName];
    }

    get properties() {
        return ['allowExport', 'allowGroup', 'allowSelect', 'verticalAlign', 'columnGroup', 'cellsVerticalAlign', 'autoCloseMenu', 'autoShowActionButton', 'autoShowSortButton', 'autoShowFilterButton', 'allowLabelAnimation', 'allowActionButtonAnimation',
            'allowSortButtonAnimation', 'allowHide', 'allowEdit', 'allowFilter', 'allowSort', 'allowSortToggleOnClick', 'allowResize', 'allowReorder', 'canNotify', 'description', 'grid', 'icon', 'menuItems', 'menu', 'summary',
            'cellsFormat', 'formatFunction', 'index', 'sortIndex', 'sortOrder', 'sorted', 'groups', 'element','level', 'group', 'filtered', 'filter', 'filterMenuMode', 'dataField', 'displayField', 'label', 'dataType', 'align', 'cellsAlign',
            'minWidth', 'width', 'visible', 'freeze', 'showActionButton', 'selected', 'showIcon', 'showDescriptionButton', 'adaptiveVisible', 'treeColumn', 'computedWidth', 'computedHeight',
            'overflowWidth', 'parent', 'children', 'onAction', 'left', 'top', 'showCustomButton', 'showFilterButton', 'showSortButton', 'editor', 'template', 'visibleIndex']
    }

    propertyChanged(propertyName, oldValue, newValue) {
        const that = this;

        if (propertyName === 'allowSort' ||
            propertyName === 'allowFilter'
        ) {
            that.refresh();
            return;
        }

        if (propertyName === 'showIcon') {
            that.refresh();
            return;
        }

        if (propertyName === 'visible') {
            that.grid.refresh(that.grid.grouping.enabled);
            return;
        }

        if (propertyName === 'showCustomButton') {
            if (newValue) {
                that.element._showCustomButton();
            }
            else {
                that.element._hideCustomButton();
            }
        }

        if (propertyName === 'showDescriptionButton') {
            if (newValue) {
                that.element._showDescriptionButton();
            }
            else {
                that.element._hideDescriptionButton();
            }
        }

        if (propertyName === 'filter') {
            if (that.filter) {
                that.grid.addFilter(that.dataField, that.filter);
                that.filtered = true;
            }
            else {
                that.grid.removeFilter(that.dataField);
                that.filtered = false;
            }

            if (that.autoShowFilterButton || that.showFilterButton) {
                if (newValue) {
                    that.element._showFilterButton();
                }
                else {
                    that.element._hideFilterButton();
                }
            }
        }

        if (propertyName === 'sortIndex') {
            if (that.grid.sorting.mode === 'many') {
                if (that.grid.context === document) {
                    that.grid.sortBy(that.dataField, that.sortOrder);
                }
            }

            return;
        }

        if (propertyName === 'selected') {
            if (that.selectionColumn) {
                that.refresh();
            }

            if (newValue) {
                if (!that.grid._selection.columns[that.dataField]) {
                    that.grid._selection.columns[that.dataField] = true;
                }
            }
            else if (newValue === false) {
                if (that.grid._selection.columns[that.dataField]) {
                    delete that.grid._selection.columns[that.dataField];
                }
            }

            that.grid._recycle(false);
        }

        if (propertyName === 'sortOrder') {
            that.sorted = false;

            if (newValue === null) {
                that.element._hideSortButton();
            }
            else {
                that.element._showSortButton();
                that.sorted = true;
            }

            if (that.grid.context === document) {
                that.grid.sortBy(that.dataField, that.sortOrder);
            }

            return;
        }

        if (propertyName === 'group') {
            if (that.grid.context === document) {
                if (newValue) {
                    that.grid.addGroup(that.dataField);
                }
                else {
                    that.grid.removeGroup(that.dataField);
                }
            }

            return;
        }

        if (propertyName === 'showActionButton') {
            that.element.allowAnimations = false;

            if (newValue) {
                that.element._showActionButton();
            }
            else {
                that.element._hideActionButton();
            }

            that.element.allowAnimations = true;
        }

        if (propertyName === 'autoShowActionButton') {
            that.element.allowAnimations = false;

            if (!newValue) {
                that.element._showActionButton();
            }
            else {
                that.element._hideActionButton();
            }

            that.element.allowAnimations = true;
        }

        if (propertyName === 'showFilterButton') {
            that.element.allowAnimations = false;

            if (undefined === that._autoShowFilterButton) {
                that._autoShowFilterButton = that.autoShowFilterButton;
            }

            if (newValue) {
                that.autoShowFilterButton = false;
                that.element._showFilterButton();
            }
            else {
                that.element._hideFilterButton();
                that.autoShowFilterButton = that._autoShowFilterButton;
            }

            that.element.allowAnimations = true;
        }

        if (propertyName === 'showSortButton') {
            that.element.allowAnimations = false;

            if (undefined === that._autoShowSortButton) {
                that._autoShowSortButton = that.autoShowSortButton;
            }

            if (newValue) {
                that.autoShowSortButton = false;
                that.element._showSortButton();
            }
            else {
                that.element._hideSortButton();
                that.autoShowSortButton = that._autoShowSortButton;
            }

            that.element.allowAnimations = true;
        }

        if (propertyName === 'autoShowSortButton') {
            that.element.allowAnimations = false;

            that._autoShowSortButton = that.autoShowSortButton;
            if (!newValue) {
                that.element._showSortButton();
            }
            else {
                that.element._hideSortButton();
            }

            that.element.allowAnimations = true;
        }


        if (propertyName === 'menu') {
            if (newValue) {
                that.element.setAttribute('aria-controls', that.menu.id);
            }
            else {
                that.element.removeAttribute('aria-controls');

                if (that.autoShowActionButton) {
                    that.element._hideActionButton();
                }
            }
        }

        if (propertyName === 'label' ||
            propertyName === 'width' ||
            propertyName === 'minWidth') {
            that.grid.refresh();
        }

        if (propertyName === 'freeze') {
            if (!newValue) {
                if (that.freeze === true || that.freeze === 'near') {
                    that.element.removeAttribute('freeze');

                    const index = that.grid._frozenNearColumns.indexOf(that);

                    if (index >= 0) {
                        that.grid._frozenNearColumns.splice(index, 0, 0);
                    }
                }
                else if (that.freeze === 'far') {
                    const index = that.grid._frozenFarColumns.indexOf(that);

                    if (index >= 0) {
                        that.grid._frozenFarColumns.splice(index, 0, 0);
                    }
                }
            }
            else {
                that.element.setAttribute('freeze', '');

                if (that.freeze) {
                    if (that.freeze === true || that.freeze === 'near') {
                        that.grid._frozenNearColumns.push(that);
                    }
                    else {
                        that.grid._frozenFarColumns.push(that);
                    }
                }
            }


            that.grid._createColumnHeaderCellElements();
            that.grid.refresh();
        }
    }

    createElement() {
        const that = this;
        const element = document.createElement('jqx-grid-column');

        element._initialize(that);

        that.element = element;

        that.grid.notify(function (propertyName, oldValue, newValue) {
            switch (propertyName) {
                case 'appearance_allowColumnLabelAnimation':
                    that.setProperty('allowLabelAnimation', newValue);
                    break;
                case 'appearance_allowColumnSortAnimation':
                    that.setProperty('allowSortAnimation', newValue);
                    break;
                case 'appearance_allowColumnSortButtonAnimation':
                    that.setProperty('allowSortButtonAnimation', newValue);
                    break;
                case 'appearance_allowColumnActionButtonAnimation':
                    that.setProperty('allowActionButtonAnimation', newValue);
                    break;
                case 'appearance_allowColumnFilterButtonAnimation':
                    that.setProperty('allowFilterButtonAnimation', newValue);
                    break;
                case 'appearance_autoShowColumnActionButton':
                    that.setProperty('autoShowActionButton', newValue);
                    break;
                case 'appearance_autoShowColumnSortButton':
                    that.setProperty('autoShowSortButton', newValue);
                    break;
                case 'appearance_autoShowColumnFilterButton':
                    that.setProperty('autoShowFilterButton', newValue);
                    break;
                case 'appearance_showColumnActionButton':
                    that.setProperty('showActionButton', newValue);
                    break;
                case 'appearance_showColumnFilterButton':
                    that.setProperty('showFilterButton', newValue);
                    break;
                case 'appearance_showColumnCustomButton':
                    that.setProperty('showCustomButton', newValue);
                    break;
                case 'appearance_showColumnDescriptionButton':
                    that.setProperty('showDescriptionButton', newValue);
                    break;
                case 'appearance_showColumnSortButton':
                    that.setProperty('showSortButton', newValue);
                    break;
                case 'appearance_showFrozenColumnBackground':
                case 'appearance_showSortColumnBackground':
                case 'appearance_showFilterColumnBackground':
                    that.grid._recycle(false);
                    break;
            }
        });

        return element;
    }
});


JQX('jqx-grid-column', class Column extends JQX.BaseElement {
    _showSortButton(refresh) {
        const that = this;

        if (!that.column) {
            return;
        }

        if (that.column.autoGenerated) {
            return;
        }

        that.sortButton.classList.remove('asc');
        that.sortButton.classList.remove('desc');

        if (!that.column.autoShowSortButton) {
            if (that.column.allowSort) {
                that.sortButton.classList.add('jqx-icon-sort', 'jqx-grid-icon');
            }
        }

        if (that.column.sortOrder === 'asc') {
            that.sortButton.classList.add('asc');
        }
        else if (that.column.sortOrder === 'desc') {
            that.sortButton.classList.add('desc');
        }

        if (that.column.showSortButton) {
            that.sortButton.classList.add('show');

            if (refresh !== false) {
                that._refresh();
            }
        }
    }

    _hideSortButton(refresh) {
        const that = this;

        if (!that.column) {
            return;
        }

        that.sortButton.classList.remove('asc');
        that.sortButton.classList.remove('desc');

        if (!that.column.showSortButton || that.column.autoShowSortButton) {
            that.sortButton.classList.remove('show');
            that.sortButton.classList.remove('jqx-icon-sort');

            if (refresh !== false) {
                that._refresh();
            }
        }
    }

    _showFilterButton() {
        const that = this;

        if (!that.column || that.column.autoGenerated) {
            return;
        }

        that.filterButton.classList.add('show');
        that._refresh();
    }

    _hideFilterButton() {
        const that = this;

        if (!that.column) {
            return;
        }

        that.filterButton.classList.remove('show');
        that._refresh();
    }

    _showDescriptionButton() {
        const that = this;

        if (!that.column || that.column.autoGenerated) {
            return;
        }

        that.descriptionButton.setAttribute('title', that.column.description);
        that.descriptionButton.classList.add('show');
        that._refresh();
    }

    _hideDescriptionButton() {
        const that = this;

        if (!that.column) {
            return;
        }

        that.descriptionButton.classList.remove('show');
        that._refresh();
    }

    _showIcon() {
        const that = this;

        if (!that.column || that.column.autoGenerated) {
            return;
        }

        that.icon.classList.add('show');
        that._refresh();
    }

    _hideIcon() {
        const that = this;

        that.icon.classList.remove('show');
        that._refresh();
    }

    _showCustomButton() {
        const that = this;

        if (!that.column || that.column.autoGenerated) {
            return;
        }

        that.customButton.classList.add('show');
        that._refresh();
    }

    _hideCustomButton() {
        const that = this;

        if (!that.column) {
            return;
        }

        that.customButton.classList.remove('show');
        that._refresh();
    }

    _showActionButton() {
        const that = this;

        if (!that.column) {
            return;
        }

        if (that.column.showActionButton && that.column.grid.hasColumnMenu(that.column)) {
            if (that.actionButton) {
                that.actionButton.classList.add('show');
                that._refresh();
            }
        }
    }

    _hideActionButton() {
        const that = this;

        if (!that.column) {
            return;
        }

        if (that.column.showActionButton) {
            if (that.actionButton && !that.hasAttribute('aria-controls')) {
                that.actionButton.classList.remove('show');
                that._refresh();
            }
        }
    }

    _rotate() {
        const that = this;
        const span = document.createElement('span');

        that.label.innerHTML = '';
        span.innerHTML = that.column.label;
        that.label.appendChild(span);

        span.className = 'rotate'
        span.style.transform = 'rotate(' + that.column.rotationAngle + 'deg)';

        return that.column.grid._recycleRotate(that.label, span, that.column.align, that.column.verticalAlign, that.column.label);
    }

    _align() {
        const that = this;

        switch (that.column.align) {
            case 'left':
                that.label.classList.add('align-left');
                break;
            case 'center':
                that.label.classList.add('align-center');
                break;
            case 'right':
                that.label.classList.add('align-right');
                break;
        }

        switch (that.column.verticalAlign) {
            case 'top':
                that.label.classList.add('align-top');
                break;
            case 'middle':
                that.label.classList.add('align-middle');
                break;
            case 'bottom':
                that.label.classList.add('align-bottom');
                break;
        }
    }

    _refresh() {
        const that = this;

        that.sortButton.classList.remove('filter');
        that.sortButton.classList.remove('action');

        that.label.className = 'jqx-label';

        if (that.column.dataField === '_checkBoxColumn') {
            const grid = that.column.grid;

            let visibleRows = grid.getVisibleRows();

            if (grid.paging.enabled && grid.selection.checkBoxes.selectAllMode === 'page') {
                visibleRows = visibleRows.slice(grid.paging.pageIndex * grid.paging.pageSize, (grid.paging.pageIndex + 1) * grid.paging.pageSize);
            }

            const selectedRows = grid.paging.enabled && grid.selection.checkBoxes.selectAllMode === 'page' ? grid._getSelectedRows(true, true) : grid._getSelectedRows(true, false);

            if (grid.selection.checkBoxes.autoShow) {
                that.setAttribute('auto-show', '');
            }
            else {
                that.removeAttribute('auto-show');
            }

            if (selectedRows.length === visibleRows.length) {
                that.setAttribute('selected', '');
            }
            else if (selectedRows.length > 0 && selectedRows.length < visibleRows.length) {
                that.setAttribute('selected', 'indeterminate');
            }
            else if (selectedRows.length === 0 || visibleRows.length === 0) {
                that.removeAttribute('selected');
            }

            that.removeAttribute('checkbox');
            that.label.classList.remove('jqx-input');

            if (grid.selection.checkBoxes.selectAllMode !== 'none') {
                that.setAttribute('checkbox', '');
                that.label.classList.add('jqx-input');
            }

            return;
        }

        if (that.column.dataField === '_commandColumn') {
            const grid = that.column.grid;
            const showLabel = grid.editing.commandColumn.displayMode !== 'icon';
            const showIcon = grid.editing.commandColumn.displayMode !== 'label';
            const properties = grid.editing.commandColumn.dataSource.commandColumnMenu;

            let commandColumnItem = '<div class="jqx-grid-command-item">';

            const label = properties.label === '{{messages}}' ?
                grid.localize('commandColumnMenu') :
                properties.label;

            const icon = properties.icon;

            if (showIcon && showLabel) {
                commandColumnItem += '<span class="jqx-grid-icon ' + icon + '"></span>';
                commandColumnItem += '<span class="jqx-grid-label">' + label + '</span>';
            }
            else if (showIcon && !showLabel) {
                commandColumnItem += '<span class="jqx-grid-icon ' + icon + '"></span>';
            }
            else if (showLabel && !showIcon) {
                commandColumnItem += '<span class="jqx-grid-label">' + label + '</span>';
            }

            commandColumnItem += '</div>';

            if (properties.visible) {
                that.label.innerHTML = commandColumnItem;
            }
        }

        const selected = that.column.getProperty('selected');

        if (selected === false && that.hasAttribute('selected')) {
            that.removeAttribute('selected');
        }
        else if (selected === true) {
            that.setAttribute('selected', '');
        }
        else if (selected === null) {
            that.setAttribute('selected', 'indeterminate');
        }

        if (that.column.allowSortButtonAnimation) {
            that.sortButton.classList.add('jqx-animate');
        }
        else {
            that.sortButton.classList.remove('jqx-animate');
        }

        if (!that.column.sorted) {
            that._hideSortButton(false);
        }
        else {
            that._showSortButton(false);
        }

        if (that.column.allowFilterButtonAnimation) {
            that.filterButton.classList.add('jqx-animate');
        }
        else {
            that.filterButton.classList.remove('jqx-animate');
        }

        if (that.column.allowActionButtonAnimation && that.allowAnimations !== false) {
            that.buttonsGroup.classList.add('jqx-animate');
        }
        else {
            that.buttonsGroup.classList.remove('jqx-animate');
        }

        if (that.column.allowLabelAnimation && that.allowAnimations !== false) {
            that.label.classList.add('jqx-animate');
        }
        else {
            that.label.classList.remove('jqx-animate');
        }

        that.buttonsGroup.classList.remove('action');

        if (that.actionButton.classList.contains('show')) {
            that.buttonsGroup.classList.add('action');
        }

        if (that.column.showIcon) {
            that.icon.classList.add('show');
        }
        else {
            that.icon.classList.remove('show');
        }

        if (that.icon.classList.contains('show')) {
            that.icon.classList.add(that.column.icon);
        }

        let buttonsCount = that.column.showIcon ? 1 : 0;


        for (let i = 0; i < that.buttonsGroup.children.length; i++) {
            if (that.buttonsGroup.children[i].classList.contains('show')) {
                buttonsCount++;
            }
        }

        switch (buttonsCount) {
            case 1:
                that.label.classList.add('one');
                break;
            case 2:
                that.label.classList.add('two');
                break;
            case 3:
                that.label.classList.add('three');
                break;
            case 4:
                that.label.classList.add('four');
                break;
            case 5:
                that.label.classList.add('five');
                break;
            case 6:
                that.label.classList.add('six');
                break;
        }

        that.classList.remove('jqx-visibility-hidden');

        if (that.column.adaptiveVisible || !that.column.visible) {
            that.classList.add('jqx-visibility-hidden');
        }

        if (that.column.grid._columnGap > 0) {
            that.classList.add('jqx-grid-column-border');
        }
        else {
            that.classList.remove('jqx-grid-column-border');
        }

        if (!that.column.grid.appearance.showColumnHeaderLines) {
            that.classList.add('jqx-grid-vertical-border-collapse');
        }
        else {
            that.classList.remove('jqx-grid-vertical-border-collapse');
        }

        if (that.column.rotationAngle) {
            const rotateResult = that._rotate();

            if (!rotateResult) {
                return;
            }
        }

        that._align();
    }

    _render() {
        const that = this;

        const columnDataField = that.column.dataField ? that.column.dataField : '';
        const isLastColumn = that.column === that.column.grid._lastVisibleColumn;

        if (that.label.firstChild) {
            if (that.label.firstChild.textContent !== that.column.label) {
                that.label.firstChild.textContent = that.column.label;
            }
        }
        else {
            that.label.innerHTML = '<span>' + that.column.label + '</span>';
        }

        that._refresh();

        if (that.column.autoGenerated || isLastColumn) {
            that.style.width = that.column.computedWidth + 'px';
        }
        else {
            that.style.width = that.column.computedWidth - that.column.grid._columnGap + 'px';
        }

        if (that.style.height !== that.column.computedHeight + 'px') {
            that.style.height = that.column.computedHeight + 'px';
        }

        if (that.style.lineHeight !== that.column.computedHeight + 'px') {
            that.style.lineHeight = that.column.computedHeight + 'px';
        }

        if (that.style.left !== that.column.left + 'px') {
            that.style.left = that.column.left + 'px';
        }

        if (that.style.top !== that.column.top + 'px') {
            that.style.top = that.column.top + 'px';
        }

        if (that.getAttribute('data-field') !== columnDataField) {
            that.setAttribute('data-field', columnDataField);
        }

        that.setAttribute('header', '');

        if (that.column.freeze) {
            that.setAttribute('freeze', '');
        }

        if (that.column.level > 0) {
            that.style.top = that.column.top + 'px';
        }
    }

    get hasStyleObserver() {
        return false;
    }

    get enableShadowDOM() {
        return false;
    }

    addThemeClass() {

    }

    addDefaultClass() {

    }

    get isUtilityElement() {
        return true;
    }


    _initialize(column) {
        const that = this;

        const label = document.createElement('div');
        const sortButton = document.createElement('div');
        const filterButton = document.createElement('div');
        const actionButton = document.createElement('div');
        const descriptionButton = document.createElement('div');
        const customButton = document.createElement('div');
        const icon = document.createElement('div');
        const buttonsGroup = document.createElement('div');

        that.column = column;
        that.classList.add('jqx-visibility-hidden');

        icon.classList.add('jqx-icon', 'jqx-grid-icon');
        label.classList.add('jqx-label');
        sortButton.classList.add('jqx-sort-button', 'jqx-grid-icon');
        filterButton.classList.add('jqx-filter-button', 'jqx-icon-filter', 'jqx-grid-icon');
        actionButton.classList.add('jqx-action-button', 'jqx-grid-icon');
        actionButton.setAttribute('aria-haspopup', '');
        descriptionButton.classList.add('jqx-description-button', 'jqx-icon-info-circled', 'jqx-grid-icon');
        customButton.classList.add('jqx-custom-button', column.customButtonIcon ? column.customButtonIcon : 'jqx-icon-tools', 'jqx-grid-icon');

        buttonsGroup.classList.add('jqx-buttons-group');
        actionButton.innerHTML = '<div></div>';
        that.style.width = that.column.computedWidth + 'px';

        that.appendChild(icon);
        that.appendChild(label);
        that.appendChild(buttonsGroup);

        buttonsGroup.appendChild(sortButton);
        buttonsGroup.appendChild(filterButton);
        buttonsGroup.appendChild(descriptionButton);
        buttonsGroup.appendChild(customButton);
        buttonsGroup.appendChild(actionButton);

        that.icon = icon;
        that.label = label;
        that.sortButton = sortButton;
        that.filterButton = filterButton;
        that.actionButton = actionButton;
        that.descriptionButton = descriptionButton;
        that.customButton = customButton;
        that.buttonsGroup = buttonsGroup;

        const downEvent = window.PointerEvent ? 'pointerdown' : 'mousedown';
        const upEvent = window.PointerEvent ? 'pointerup' : 'mouseup';


        that.filterButton.addEventListener(downEvent, function (event) {
            event.preventDefault();
            event.stopPropagation();

            if (that.column.onAction) {
                that.column.onAction(event);
            }
        }.bind(that));

        that.filterButton.addEventListener(upEvent, function (event) {
            event.preventDefault();
            event.stopPropagation();
        });

        that.actionButton.addEventListener(upEvent, function (event) {
            event.preventDefault();
            event.stopPropagation();
        });

        that.actionButton.addEventListener(downEvent, function (event) {
            event.preventDefault();
            event.stopPropagation();

            if (that.column.onAction) {
                that.column.onAction(event);
            }
        }.bind(that));

        if (!that.column.autoShowActionButton && that.column.showActionButton) {
            that._showActionButton();
        }

        if (!that.column.autoShowSortButton && that.column.showSortButton) {
            that._showSortButton();
        }

        if (!that.column.autoShowFilterButton && that.column.showFilterButton) {
            that._showFilterButton();
        }

        if (that.column.showDescriptionButton) {
            that._showDescriptionButton();
        }

        if (that.column.showCustomButton) {
            that._showCustomButton();
        }

        if (that.column.showIcon) {
            that._showIcon();
        }

        if (that.column.dataField === '_rowHeaderColumn') {
            that.classList.add('top-near-corner');
        }

        that.customButton.onclick = function (event) {
            if (that.column.onCustomButtonClick) {
                that.column.onCustomButtonClick(event);
            }
        }.bind(that);
    }

    template() {
        return '';
    }
});


JQX.Utilities.Assign('Grid.Row', class Row {
    constructor(row) {
        const that = this;

        if (!row) {
            row = {};
        }

        Object.assign(that, row);

        if (!row) {
            return;
        }

        if (that.data === undefined) {
            const itemObject = { $: {} };

            if (row.grid && row.grid.dataSource) {
                const dataSource = row.grid.dataSource;

                for (let j = 0; j < dataSource.dataFields.length; j++) {
                    const dataField = dataSource.dataFields ? dataSource.dataFields[j] : {};

                    itemObject[dataField.name] = '';
                }
            }

            if (row.id) {
                itemObject.$.id = row.id;
            }
            that.data = itemObject;
        }

        if (undefined === row.$ || (row.$ && undefined === row.$.id)) {
            if (row.data) {

                if (row.data.$ && row.data.$.id) {
                    that.id = row.data.$.id;
                }

                if (!that.id) {
                    that.id = row.index;
                }
            }
            else if (that.id === undefined) {
                that.id = row.index;
            }

            if (that.id === undefined) {
                that.id = JQX.Utilities.Core.createGUID();
            }
        }

        if (undefined === that.detailHeight) {
            if (that.grid) {
                that.detailHeight = that.grid.rowDetail.height;
            }
            else {
                that.detailHeight = 200;
            }
        }

        if (undefined === that.height && that.grid) {
            that.height = that.grid.rowMinHeight;

            if (that.grid.__autoRowHeight) {
                that.height = that.grid.__autoRowHeight;
            }


            if (that.grid.rowHeight) {
                that.height = that.grid.rowHeight;
            }
        }

        if (undefined === that.cellHeight) {
            that.cellHeight = that.height;
        }

        if (undefined === that.showDetail) {
            that.showDetail = false;
        }

        if (undefined === that.index) {
            that.index = -1;
        }

        if (undefined === that.visibleIndex) {
            that.visibleIndex = -1;
        }

        if (undefined === that.freeze) {
            that.freeze = false;
        }

        if (undefined === that.height) {
            that.height = null;
        }

        if (undefined === that.minHeight) {
            that.minHeight = 25;
        }

        if (undefined === that.selected) {
            that.selected = false;
            if (that.grid && that.grid._selection.rows[that.id]) {
                that.selected = true;
            }
        }
        else if (that.selected && that.grid) {
            that.grid._selection.rows[that.id] = true;
        }

        if (undefined === that.enabled) {
            that.enabled = true;
        }

        if (undefined === that.visible) {
            that.visible = true;
        }

        if (undefined === that.filtered) {
            that.filtered = true;
        }

        if (undefined === that.allowResize) {
            that.allowResize = true;
        }

        if (undefined === that.allowToggle) {
            that.allowToggle = true;
        }

        if (undefined === that.allowSelect) {
            that.allowSelect = true;
        }

        if (undefined === that.expanded) {
            if (row.data && row.data.expanded !== undefined) {
                that.expanded = row.data.expanded;
            }
            else {
                that.expanded = false;
            }
        }

        that.headerCell = null;
        that._cells = [];
    }

    get properties() {
        return ['allowToggle', 'allowResize', 'allowSelect', 'canNotify', 'cells', 'detailHeight', 'detailTemplate', 'cellHeight', 'expandHeight', 'data', 'enabled', 'expanded', 'filtered', 'freeze', 'grid', 'headerCell', 'height', 'index', 'id', 'minHeight', 'unbound', 'selected', 'showDetail', 'visible', 'visibleIndex']
    }

    createElement() {
        const that = this;
        const element = document.createElement('jqx-grid-row');

        that.element = element;

        element._initialize(that);

        return element;
    }

    getCell(column) {
        const that = this;
        const grid = that.grid;

        if (typeof column === 'string' || typeof column === 'number') {
            column = grid.columnByDataField[column];
        }

        if (!column) {
            return null;
        }

        if (!that['column_' + column.dataField]) {
            const cell = new JQX.Grid.Cell(that, column, grid);

            that['column_' + column.dataField] = cell;

            return cell;
        }
        else {
            const cell = that['column_' + column.dataField];

            cell.column = column;

            return cell;
        }
    }

    get cells() {
        const that = this;

        if (that._cells && that.grid && that._cells.length === that.grid.columns.length) {
            return that._cells;
        }

        that.createCells();

        return that._cells;
    }

    get viewCells() {
        const that = this;
        const cells = [];

        for (let i = 0; i < that.grid.viewColumns.length; i++) {
            const column = that.grid.viewColumns[i];

            if (!that['column_' + column.dataField]) {
                const cell = new JQX.Grid.Cell(that, column, that.grid);

                that['column_' + column.dataField] = cell;

                cells.push(cell);
            }
            else {
                const cell = that['column_' + column.dataField];

                cells.push(cell);
            }
        }

        that._viewCells = cells;

        return cells;
    }

    createCells() {
        const that = this;
        const grid = that.grid;

        that._cells = [];

        for (let i = 0; i < grid.viewColumns.length; i++) {
            const column = grid.viewColumns[i];

            if (column.autoGenerated) {
                continue;
            }

            if (!that['column_' + column.dataField]) {
                const cell = new JQX.Grid.Cell(that, column, grid);

                that['column_' + column.dataField] = cell;
                that._cells.push(cell);
            }
            else {
                const cell = that['column_' + column.dataField];

                that._cells.push(cell);
            }
        }
    }

    toggle() {
        const that = this;

        that.element._handleExpandCollapse(!that.expanded);
    }

    expand() {
        const that = this;

        that.element._handleExpandCollapse(true);
    }

    collapse() {
        const that = this;

        that.element._handleExpandCollapse(false);
    }

    render() {
        const that = this;

        that.element.row = that;

        that.element._render();
    }

    setProperty(propertyName, value) {
        const that = this;
        const oldValue = that.getProperty(propertyName);

        that[propertyName] = value;

        if (oldValue !== value) {
            that.canNotify = false;
            that.propertyChanged(propertyName, oldValue, value);
            that.canNotify = true;
        }
    }

    getProperty(propertyName) {
        const that = this;

        if (propertyName === 'selected') {
            let selected = false;

            if (that.grid._selection.cells['row' + that.id]) {
                selected = null;
            }

            if (that.grid && that.grid._selection.rows[that.id]) {
                selected = true;
            }

            that.grid.rows.canNotify = false;
            that[propertyName] = selected;
            that.grid.rows.canNotify = true;

            return selected;
        }

        return that[propertyName];
    }

    propertyChanged(propertyName, oldValue, newValue) {
        const that = this;

        if (propertyName === 'showDetail') {
            that.height = 0;

            const detail = that.element.rowDetail;

            if (that.grid.appearance.allowRowDetailToggleAnimation) {
                const toggleAnimation = function (event) {
                    const row = that.grid._toggledRow;

                    if (row && (event.propertyName === 'transform' || event.propertyName === 'height')) {
                        endAnimation(row);
                    }
                };

                const endAnimation = function (row) {
                    row.grid.$.content.style.transition = '';
                    row.element.rowDetail.removeEventListener('transitionend', toggleAnimation);
                    row.element.rowDetail.removeEventListener('transitioncancel', toggleAnimation);
                    row.grid._toggledRow = null;
                    row.element.removeAttribute('has-detail');

                    that.grid._refresh();
                }

                that.grid._toggledRow = that;

                detail.addEventListener('transitionend', toggleAnimation);
                detail.addEventListener('transitioncancel', toggleAnimation);

                if (newValue) {
                    that.element.setAttribute('has-detail', '');
                    that.element.toggleDetailButton.removeAttribute('toggled');
                    that.element.toggleDetailButton.classList.remove('jqx-animate');
                    setTimeout(() => {
                        that.element.toggleDetailButton.classList.add('jqx-animate');
                        that.element.toggleDetailButton.setAttribute('toggled', '');
                        that.element.setAttribute('show-detail', '');
                    });

                    that.element.style.height = that.cellHeight + that.detailHeight + 'px';

                    if (that.grid._autoHeight) {
                        that.grid.$.content.style.transition = '0.25s height ease-in-out';
                        that.grid.$.content.style.height = parseInt(that.grid.$.content.style.height) + that.detailHeight + 'px';
                        that.grid.$.scrollView.style.height = 'auto';
                    }


                    detail.classList.remove('jqx-hidden');
                    if (detail.style.height !== that.detailHeight + 'px') {
                        detail.style.height = that.detailHeight + 'px';
                    }

                    if (detail.style.lineHeight !== that.detailHeight + 'px') {
                        detail.style.lineHeight = that.detailHeight + 'px';
                    }

                    if (detail.style.top !== that.cellHeight + 'px') {
                        detail.style.top = that.cellHeight + 'px';
                    }
                }
                else {
                    that.element.setAttribute('has-detail', '');
                    that.element.toggleDetailButton.removeAttribute('toggled');
                    if (that.grid._autoHeight) {
                        that.grid.$.content.style.transition = '0.25s height ease-in-out';
                        that.grid.$.content.style.height = parseInt(that.grid.$.content.style.height) - that.detailHeight + 'px';
                        that.grid.$.scrollView.style.height = 'auto';
                    }

                    setTimeout(() => {
                        that.element.style.height = that.cellHeight + 'px';
                        that.element.removeAttribute('show-detail');
                    });
                }
            }
            else {
                that.grid._refresh();

            }
        }

        if (propertyName === 'selected') {

            if (newValue) {
                that.grid._selection.rows[that.id] = true;
            }
            else if (newValue === false) {
                if (that.grid._selection.rows[that.id]) {
                    delete that.grid._selection.rows[that.id];
                }
            }

            if (!that.element) {
                return;
            }

            that.grid._recycle();
        }

        if (propertyName === 'visible') {
            that.grid.refresh();
        }

        if (propertyName === 'expanded') {
            if (!that.expandHeight) {
                that.grid.refresh();
            }
        }
        if (propertyName === 'height') {
            if (!that.expandHeight) {
                if (that.cellHeight !== newValue) {
                    that.cellHeight = newValue;
                    that.grid.refresh();
                }
            }
        }

        if (propertyName === 'freeze') {
            if (newValue === true || newValue === 'near') {
                that.grid._frozenNearRows.push(that);
            }
            else if (newValue === 'far') {
                that.grid._frozenFarRows.push(that);
            }
            else {
                that.grid._frozenNearRows.splice(that.grid._frozenNearRows.indexOf(that), 1);
                that.grid._frozenFarRows.splice(that.grid._frozenFarRows.indexOf(that), 1);
            }

            that.grid._recycle();
        }
    }
});

JQX('jqx-grid-row', class Row extends JQX.BaseElement {
    static get properties() {
        return {
        }
    }

    get isUtilityElement() {
        return true;
    }

    get hasStyleObserver() {
        return false;
    }

    addThemeClass() {

    }

    addDefaultClass() {

    }

    _initialize(row) {
        const that = this;
        const grid = row.grid;
        const columnElements = grid._columnElements;
        const frozenNearColumns = grid._frozenNearColumns;
        const frozenFarColumns = grid._frozenFarColumns;

        const cellsContainerElement = document.createElement('div');
        const cellsNearContainerElement = document.createElement('div');
        const cellsFarContainerElement = document.createElement('div');
        const fragment = document.createDocumentFragment();
        const nearFragment = document.createDocumentFragment();
        const farFragment = document.createDocumentFragment();

        cellsNearContainerElement.classList.add('near', 'jqx-grid-cell-container');
        cellsContainerElement.classList.add('center', 'jqx-grid-cell-container');
        cellsFarContainerElement.classList.add('far', 'jqx-grid-cell-container');

        that.row = row;
        row.createCells();

        that.addEventListener('mouseenter', function () {
            if (grid.isScrolling || grid.editing.isEditing) {
                return;
            }

            if (that.commandBar) {
                that.commandBar.parentNode.removeChild(that.commandBar);
                that.commandBar = null;
            }

            if (grid.editing.enabled && grid.editing.commandColumn.visible && grid.editing.commandColumn.inline && !that.commandBar) {
                const commandBar = document.createElement('div');
                const template = grid._getCommandColumnCommandsTemplate();

                commandBar.classList.add('jqx-grid-command-bar');
                commandBar.innerHTML = template;

                cellsContainerElement.appendChild(commandBar);

                requestAnimationFrame(() => {
                    commandBar.classList.add('show');
                })

                grid._updateCommandColumnCommandsVisibility(commandBar, that.row);

                commandBar.onmousedown = function (event) {
                    const elements = event.path;
                    let commandItem = null;

                    for (let i = 0; i < elements.length; i++) {
                        if (elements[i].classList.contains('jqx-grid-command-item')) {
                            commandItem = elements[i];
                            break;
                        }
                    }

                    if (!commandItem) {
                        //    commandItem = that.querySelector('.jqx-grid-command-item');
                    }

                    if (commandItem) {
                        const command = commandItem.getAttribute('command');

                        grid._applyCommand(command, [that.row]);

                        if (that.commandBar) {
                            that.commandBar.parentNode.removeChild(that.commandBar);
                            that.commandBar = null;
                        }
                        that.removeAttribute('hover');

                        event.stopPropagation();
                        event.preventDefault();
                    }
                }

                that.commandBar = commandBar;
            }
        });

        that.addEventListener('mouseleave', function () {
            if (grid.isScrolling || grid.editing.isEditing) {
                return;
            }

            if (that.commandBar) {
                that.commandBar.classList.remove('show');
                that.commandBar.addEventListener('transitionend', function () {
                    if (that.commandBar) {
                        that.commandBar.parentNode.removeChild(that.commandBar);
                        that.commandBar = null;
                    }
                });

                that.commandBar.addEventListener('transitioncancel', function () {
                    if (that.commandBar) {
                        that.commandBar.parentNode.removeChild(that.commandBar);
                        that.commandBar = null;
                    }
                });
            }
        });

        for (let i = 0; i < frozenNearColumns.length; i++) {
            const column = frozenNearColumns[i];
            const cell = row.getCell(column);
            const cellElement = cell.createElement();

            nearFragment.appendChild(cellElement);
        }

        for (let i = 0; i < frozenFarColumns.length; i++) {
            const column = frozenFarColumns[i];
            const cell = row.getCell(column);
            const cellElement = cell.createElement();

            farFragment.appendChild(cellElement);
        }

        for (let i = 0; i < columnElements.length; i++) {
            const columnElement = columnElements[i];
            const column = columnElement.column;

            if (!columnElement.parentNode || !column) {
                break;
            }

            const cell = row.getCell(column);
            const cellElement = cell.createElement();

            if (column && column._treeColumn) {
                that.toggleButton = cellElement.toggleButton;
            }

            fragment.appendChild(cellElement);
        }

        cellsNearContainerElement.appendChild(nearFragment);
        cellsContainerElement.appendChild(fragment);
        cellsFarContainerElement.appendChild(farFragment);

        const rowDetailElement = document.createElement('div');
        rowDetailElement.classList.add('jqx-grid-row-detail', 'jqx-hidden', 'jqx-animate');

        const rowContainerElement = document.createElement('div');
        rowContainerElement.classList.add('jqx-grid-row-sub-container', 'jqx-hidden');

        if (grid._adaptiveLayout > 0) {
            cellsNearContainerElement.classList.add('jqx-visibility-hidden');
            cellsContainerElement.classList.add('jqx-visibility-hidden');
            cellsFarContainerElement.classList.add('jqx-visibility-hidden');
        }

        that._rowFragment = document.createDocumentFragment();

        that._rowFragment.appendChild(cellsNearContainerElement);
        that._rowFragment.appendChild(cellsContainerElement);
        that._rowFragment.appendChild(cellsFarContainerElement);
        that._rowFragment.appendChild(rowDetailElement);
        that._rowFragment.appendChild(rowContainerElement);

        that.appendChild(that._rowFragment);

        that.cellsNearContainerElement = that.children[0];
        that.cellsContainerElement = that.children[1];
        that.cellsFarContainerElement = that.children[2];
        that.rowDetail = that.children[3];
        that.rowContainer = that.children[4];

        if (grid.rowHeight && grid.rowHeight !== 'auto') {
            that.style.height = grid.rowHeight + 'px';
        }
    }

    get enableShadowDOM() {
        return false;
    }

    _handleExpandCollapse(expanded) {
        const that = this;
        const row = that.row;
        const grid = row.grid;

        if (!row.allowToggle) {
            return null;
        }

        grid._toggledRow = row;

        const setRowHeight = function () {
            const row = grid._toggledRow;

            grid._refresh();
            grid._refreshRowHierarchy();

            let expandHeight = 0;

            for (let i = 0; i < grid.rowHierarchy.length; i++) {
                const row = grid.rowHierarchy[i];

                let parent = row.parent;

                while (parent) {
                    if (parent.id === grid._toggledRow.id) {
                        expandHeight += row.height;
                    }

                    parent = parent.parent;
                }
            }

            const value = grid._scrollView.scrollTop;
            const remainingHeight = grid._contentHeight - (row.cellHeight + row.top - value);

            row.expandHeight = Math.min(remainingHeight, expandHeight);
            row.height = row.cellHeight + row.expandHeight;
        }

        const requestNewData = grid.dataSource.virtualDataSourceOnExpand && expanded && row.data._loaded !== true;

        if (!grid.appearance.allowRowToggleAnimation || requestNewData) {
            grid.rows.canNotify = false;
            row.expanded = expanded;
            grid.rows.canNotify = true;

            if (requestNewData) {
                row.data._loaded = true;
                row.data.expanded = expanded;
                grid._virtualDataRequest('expand');
            }

            grid._toggledRow = null;
            grid._refresh();

            if (requestNewData && grid.appearance.allowRowToggleAnimation) {
                that.toggleButton.removeAttribute('toggled');
                that.toggleButton.classList.remove('jqx-animate');
                setTimeout(() => {
                    that.toggleButton.classList.add('jqx-animate');
                    that.toggleButton.setAttribute('toggled', '');
                }, 50);
            }
        }
        else {
            const endAnimation = function (row) {
                row.height = row.cellHeight;
                grid.$.content.style.transition = '';
                row.element.rowContainer.innerHTML = '';
                row.element.rowContainer.classList.add('jqx-hidden');
                row.element.rowContainer.removeEventListener('transitionend', toggleAnimation);
                row.element.rowContainer.removeEventListener('transitioncancel', toggleAnimation);
                row.element.rowContainer.style.height = '';
                row.element.rowContainer.style.transform = '';
                row.element.rowContainer.style.transition = '';
                row.element.rowContainer.classList.remove('jqx-animate')
                row.element.toggleButton.classList.remove('jqx-animate');

                grid._refresh();
            }

            const toggleAnimation = function (event) {
                const row = grid._toggledRow;

                that._toggleTimer = null;
                grid._toggledRow = null;
                if (row && (event.propertyName === 'transform' || event.propertyName === 'height')) {
                    setTimeout(() => {
                        endAnimation(row);
                    }, 50);
                }
            };

            if (that._toggleTimer) {
                clearTimeout(that._toggleTimer);

                const row = grid._toggledRow;
                grid._toggledRow = null;

                endAnimation(row);
            }

            that._toggleTimer = setTimeout(() => {
                const updateHeightAndRefresh = function () {
                    setRowHeight();
                    grid._recycle(false);

                    that.style.overflow = 'hidden';
                    that.style.height = 'auto';
                    that.style.lineHeight = row.cellHeight + 'px';
                }

                if (expanded) {
                    row.expanded = true;

                    updateHeightAndRefresh();

                    that.rowContainer.style.transform = 'scaleY(0)';
                    that.rowContainer.style.height = '0px';
                    that.toggleButton.removeAttribute('toggled');

                    if (grid._autoHeight) {
                        grid.$.content.style.height = parseInt(grid.$.content.style.height) - row.expandHeight + 'px';
                    }

                    setTimeout(function () {
                        that.toggleButton.classList.add('jqx-animate');
                        that.toggleButton.setAttribute('toggled', '');
                        that.rowContainer.addEventListener('transitionend', toggleAnimation);
                        that.rowContainer.addEventListener('transitioncancel', toggleAnimation);

                        if (grid._autoHeight) {
                            grid.$.content.style.transition = '0.25s height ease-in-out';
                            grid.$.content.style.height = parseInt(grid.$.content.style.height) + row.expandHeight + 'px';
                        }

                        that.rowContainer.classList.add('jqx-animate')
                        that.rowContainer.style.height = row.expandHeight + 'px';
                        that.rowContainer.style.transform = 'scaleY(1)';
                    });
                }
                else {
                    updateHeightAndRefresh();
                    row.expanded = false;

                    that.rowContainer.style.transform = 'scaleY(0)';
                    that.rowContainer.style.height = '0px';

                    if (grid._autoHeight) {
                        grid.$.content.style.height = parseInt(grid.$.content.style.height) - row.expandHeight + 'px';
                        grid.$.content.style.transition = '';
                        grid.$.content.style.height = parseInt(grid.$.content.style.height) + row.expandHeight + 'px';
                    }

                    that.rowContainer.style.height = row.expandHeight + 'px';
                    that.rowContainer.style.transform = 'scaleY(1)';
                    that.toggleButton.setAttribute('toggled', '');
                    that.toggleButton.classList.add('jqx-animate');

                    setTimeout(function () {
                        that.toggleButton.removeAttribute('toggled', '');

                        if (grid._autoHeight) {
                            grid.$.content.style.transition = '0.25s height ease-in-out';
                            grid.$.content.style.height = parseInt(grid.$.content.style.height) - row.expandHeight + 'px';
                        }

                        that.rowContainer.addEventListener('transitionend', toggleAnimation);
                        that.rowContainer.addEventListener('transitioncancel', toggleAnimation);
                        that.rowContainer.classList.add('jqx-animate')
                        //     that.rowContainer.style.transition = 'transform .25s ease-in-out, height .25s ease-in-out';
                        that.rowContainer.style.transform = 'scaleY(0)';
                        that.rowContainer.style.height = '0px';
                    }, 0);
                }
            }, 50);
        }
    }

    _renderAddNewRow() {
        const that = this;

        const row = that.row;
        const grid = row.grid;
        const element = row.element;
        const cell = new JQX.Grid.Cell(row, grid.columns[0], grid);

        if (row.visible) {
            element.classList.remove('jqx-hidden');
        }
        else {
            element.classList.add('jqx-hidden');
        }

        element.innerHTML = '<jqx-grid-cell><div>' + grid.localize('addNewRow') + '</div></jqx-grid-cell>';
        element.firstChild.firstChild.classList.add('align-center');
        element.firstChild.classList.add('jqx-grid-column-border-collapse');
        element.firstChild.setAttribute('freeze', '');
        element.firstChild.setAttribute('addNewRow', '');

        element.firstChild.style.width = '100%';
        if (grid._scrollView.vScrollBar.offsetWidth > 0) {
            element.firstChild.style.width = 'calc(100% - ' + (-1 + grid._scrollView.vScrollBar.offsetWidth) + 'px)';
        }

        element.firstChild.cell = cell;

        if (grid._rowGap > 0 && row !== grid.rows[grid.rows.length - 1]) {
            that.style.marginBottom = grid._rowGap + 'px';

            if (parseInt(that.style.height) - grid._rowGap !== row.height) {
                that.style.height = row.height - grid._rowGap + 'px';
            }

            if (parseInt(that.style.lineHeight) - grid._rowGap !== row.height) {
                that.style.lineHeight = row.height - grid._rowGap + 'px';
            }
        }
        else {
            that.style.marginBottom = '';
            if (parseInt(that.style.height) !== row.height) {
                that.style.height = row.height + 'px';
            }

            if (parseInt(that.style.lineHeight) !== row.height) {
                that.style.lineHeight = row.height + 'px';
            }
        }
    }

    _renderEmpty() {
        const that = this;
        that.classList.add('jqx-hidden');
    }

    _renderAdaptive() {
        const that = this;
        const row = that.row;
        const grid = row.grid;

        let isChildRow = false;

        if (grid._toggledRow && grid.appearance.allowRowToggleAnimation && grid._toggledRow.expanded) {
            let parentRow = row.parent;

            while (parentRow) {
                if (parentRow.id === grid._toggledRow.id) {
                    const adaptiveDetail = parentRow.element.adaptiveDetail;

                    that.classList.add('jqx-hidden');
                    //   that = row.createElement();
                    that.toggleButton.classList.add('jqx-hidden');

                    isChildRow = true;
                    adaptiveDetail.appendChild(that);
                    break;

                }

                parentRow = parentRow.parent;
            }
        }

        const detail = that.adaptiveDetail;

        that.row = row;
        that.visible = row.visible;

        if (that.style.height !== row.height + 'px') {
            that.style.height = row.height + 'px';
        }

        if (that.style.lineHeight !== row.height + 'px') {
            that.style.lineHeight = row.height + 'px';
        }

        detail.classList.remove('jqx-hidden');
        if (detail.style.height !== row.adaptiveHeight + 'px') {
            detail.style.height = row.adaptiveHeight + 'px';
        }

        if (detail.style.lineHeight !== row.adaptiveHeight + 'px') {
            detail.style.lineHeight = row.adaptiveHeight + 'px';
        }

        if (row.expandHeight) {
            if (row.expanded) {
                const maxRowHeight = Math.min(grid._clientSize.height, row.height + row.expandHeight) + 'px';

                that.style.height = maxRowHeight;
                that.style.lineHeight = maxRowHeight;
            }

            const maxRowHeight = Math.min(grid._clientSize.height, row.height + row.expandHeight) + 'px';

            detail.style.height = maxRowHeight;
            detail.style.lineHeight = maxRowHeight;

        }
        else {
            detail.innerHTML = '';
        }

        if (!isChildRow) {
            detail.style.top = '0px';
        }
        else {
            detail.style.top = row.cellHeight + 'px';
        }

        const fragment = document.createDocumentFragment();

        let top = 0;
        let left = 0;

        for (let i = 0; i < grid.viewColumns.length; i++) {
            const column = grid.viewColumns[i];

            if (column.autoGenerated) {
                continue;
            }

            const header = column.createElement();
            const cell = row.getCell(column);
            const cellElement = cell.createElement();

            if (row.label !== undefined) {
                fragment.appendChild(cellElement);

                cellElement.classList.add('jqx-grid-adaptive-cell');
                cellElement.style.height = row.cellHeight + 'px';
                cellElement.style.lineHeight = row.cellHeight + 'px';
                cellElement.style.left = '0px';
                cellElement.style.top = '0px';
                cell.render();
                cellElement.style.width = '100%';

                break;
            }

            cellElement.classList.add('jqx-grid-adaptive-cell');
            header.classList.add('jqx-grid-adaptive-column');

            column.render();
            that._renderCell(row, column, cellElement);

            const columnWidth = grid._adaptiveLayout === 1 ? '100%' : '50%';

            header.style.width = columnWidth;
            header.style.height = row.cellHeight + 'px';
            header.style.lineHeight = row.cellHeight + 'px';
            header.style.top = top + 'px';
            header.classList.remove('jqx-visibility-hidden');

            cellElement.style.width = columnWidth;
            cellElement.style.height = row.cellHeight + 'px';
            cellElement.style.lineHeight = row.cellHeight + 'px';
            cellElement.style.top = top + row.cellHeight + 'px';

            if (columnWidth === '100%') {
                //          header.style.borderRightColor = 'transparent';
                //            cellElement.style.borderRightColor = 'transparent';
                header.style.left = '0px';
                cellElement.style.left = '0px';
            }
            else {
                if (left === 0) {
                    header.style.left = '0px';
                    cellElement.style.left = '0px';
                    left = '50%';
                }
                else {
                    header.style.left = '50%';
                    cellElement.style.left = '50%';
                }
            }


            if ((i + 1) % grid._adaptiveLayout === 0) {
                left = 0;
                top += 2 * row.cellHeight;
            }


            fragment.appendChild(header);
            fragment.appendChild(cellElement);
        }

        detail.appendChild(fragment);

        if (!that.visible) {
            that.classList.add('jqx-hidden');
        }
        else {
            that.classList.remove('jqx-hidden');
        }
    }

    _renderCell(row, column, element) {
        if (!column) {
            element.classList.add('jqx-hidden');
            return;
        }

        let cell = row.getCell(column);

        if (cell.element !== element) {
            cell._styleChanged = true;
        }

        if (element.cell !== cell) {
            if (element.cell.background !== cell.background ||
                element.cell.borderColor !== cell.borderColor ||
                element.cell.color !== cell.color ||
                element.cell.fontSize !== cell.fontSize ||
                element.cell.fontFamily !== cell.fontFamily ||
                element.cell.fontWeight !== cell.fontWeight ||
                element.cell.fontStyle !== cell.fontStyle) {
                cell._styleChanged = true;
            }
        }

        cell.element = element;
        element.cell = cell;

        cell.render();

        if (column && column.rowNumbersColumn) {
            row.header = element;
            element.setAttribute('data-id', row.id);
        }
    }

    _alternate() {
        const that = this;

        const row = that.row;
        const grid = row.grid;

        const start = grid.appearance.alternationStart;
        const end = grid.appearance.alternationEnd > 0 ? grid.appearance.alternationEnd : Infinity;

        if (grid.appearance.alternationCount <= 0) {
            return;
        }

        that.removeAttribute('alternation-index');

        if (row.visibleIndex >= start && row.visibleIndex <= end) {
            const alternationIndex = (row.visibleIndex - start) % grid.appearance.alternationCount;

            that.setAttribute('alternation-index', alternationIndex);
        }
    }

    _renderDetail(detail) {
        const that = this;
        const grid = that.row.grid;
        const row = that.row;
        let value = row.id;

        let template = row.detailTemplate || grid.rowDetail.template;

        if (template.startsWith('#')) {
            template = document.querySelector(template);
        }

        if (row._detail) {
            if (detail.firstChild === row._detail) {
                if (grid.onRowDetailUpdated) {
                    grid.onRowDetailUpdated(row.index, row, detail.firstChild);
                }

                return;
            }

            if (detail.firstChild) {
                detail.removeChild(detail.firstChild);
            }

            detail.appendChild(row._detail);

            if (grid.onRowDetailUpdated) {
                grid.onRowDetailUpdated(row.index, row, detail.firstChild);
            }

            return;
        }

        if (template instanceof HTMLTemplateElement) {
            const templateContent = template.content.cloneNode(true).firstElementChild;

            value = value.toString();
            value = value.replace(/'/ig, '\\\'');
            value = value.replace(/"/ig, '\\"');

            let html = templateContent.outerHTML.replace(/{{value}}/ig, value).replace(/{{id}}/ig, row.id);

            if (html.indexOf('{{value=') >= 0) {
                if (!value) {
                    html = html.replace(/{{value=/ig, '');
                    html = html.replace(/}}/ig, '');
                }
                else {
                    html = html.substring(0, html.indexOf('{{value=')) + value + html.substring(html.indexOf('}'));
                    html = html.replace(/}/ig, '');
                    html = html.replace(/{/ig, '');
                }
            }

            html = '<div>' + html + '</div>';

            for (let name in row.data) {
                html = html.replace('{{' + name + '}}', row.data[name])
            }

            if (detail.innerHTML !== html) {
                detail.innerHTML = html;
            }
        }
        else {
            let html = '<div>' + template.replace(/{{value}}/ig, value).replace(/{{id}}/ig, row.id) + '</div>';

            for (let name in row.data) {
                html = html.replace('{{' + name + '}}', row.data[name])
            }

            if (detail.innerHTML !== html) {
                detail.innerHTML = html;
            }
        }

        if (grid.onRowDetailInit) {
            grid.onRowDetailInit(row.index, row, detail.firstChild);
        }

        row._detail = detail.firstChild;
    }

    _render() {
        let that = this;
        const row = that.row;
        const grid = row.grid;

        const selected = row.getProperty('selected');

        if (selected === false && that.hasAttribute('selected')) {
            that.removeAttribute('selected');
        }
        else if (selected === true) {
            that.setAttribute('selected', '');
        }
        else if (selected === null) {
            that.setAttribute('selected', 'indeterminate');
        }

        if (that.hasAttribute('unbound')) {
            that.removeAttribute('unbound');
        }

        if (row.unbound) {
            that.setAttribute('unbound', '');
        }

        if (!grid._toggledRow && that.classList.contains('jqx-animate')) {
            that.classList.remove('jqx-animate');
            that.rowContainer.innerHTML = '';
            that.rowContainer.classList.add('jqx-hidden');
            grid._refreshLayout();
            grid._recycle();

            return;
        }

        if (row.adaptiveHeight && !grid._responsiveLayout) {
            that._renderAdaptive();
            return;
        }

        if (grid.columns.length === 0) {
            that._renderEmpty();
            return;
        }

        if (row.addNewRow) {
            that._renderAddNewRow();
            return;
        }

        if (grid._toggledRow) {
            if (row.id === grid._toggledRow.id) {
                that.setAttribute('toggle', '');
            }
            else if (that.hasAttribute('toggle')) {
                that.removeAttribute('toggle');
            }
        }

        if (grid._toggledRow && grid.appearance.allowRowToggleAnimation) {
            let parentRow = row.parent;

            if (!grid._toggledRow.expanded && grid._toggledRow.id === row.id) {
                const rowContainer = that.rowContainer;

                for (let i = 0; i < rowContainer.children.length; i++) {
                    const animatingRowElement = rowContainer.children[i];
                    const uid = animatingRowElement.getAttribute('data-id');
                    const animatingRow = grid.rowById[uid];

                    if (animatingRowElement.getAttribute('data-rendered')) {
                        continue;
                    }

                    animatingRowElement.setAttribute('data-rendered', true);
                    animatingRow.element = animatingRowElement;

                    animatingRow.render();
                }
            }

            while (parentRow) {
                if (parentRow.id === grid._toggledRow.id) {
                    const rowContainer = parentRow.element.rowContainer;

                    if (grid._toggledRow.expanded) {
                        that.classList.add('jqx-hidden');
                        let rowElement = row.createElement(grid);

                        for (let i = 0; i < rowContainer.children.length; i++) {
                            const animatingRowElement = rowContainer.children[i];

                            if (animatingRowElement.getAttribute('data-id') === row.id.toString()) {
                                rowElement = animatingRowElement;
                                return;
                            }
                        }

                        row.element = rowElement;
                        rowContainer.appendChild(rowElement);
                        rowContainer.classList.remove('jqx-hidden');

                        rowElement.row = row;

                        that = rowElement;
                    }
                    break;

                }

                parentRow = parentRow.parent;
            }
        }

        that._alternate();

        const nearWidth = parseFloat(grid.$.columnNearContainer.style.width);
        const centerWidth = parseFloat(grid.$.columnContainer.style.width);
        const farWidth = parseFloat(grid.$.columnFarContainer.style.width);
        const cellsCenterContainerElement = that.children[1];
        const cellsNearContainerElement = that.children[0];
        const cellsFarContainerElement = that.children[2];

        cellsFarContainerElement.classList.remove('vscroll');

        if (grid.computedVerticalScrollBarVisibility) {
            cellsFarContainerElement.classList.add('vscroll');
        }


        if (that.hasAttribute('group')) {
            that.removeAttribute('group');
        }

        if (that.hasAttribute('tree')) {
            that.removeAttribute('tree');
        }

        if (that.hasAttribute('level')) {
            that.removeAttribute('level');
        }

        if (that.hasAttribute('leaf')) {
            that.removeAttribute('leaf');
        }

        if (that.hasAttribute('expanded')) {
            that.removeAttribute('expanded');
        }

        if (that.hasAttribute('summary')) {
            that.removeAttribute('summary');
        }

        if (that.hasAttribute('filter')) {
            that.removeAttribute('filter');
        }

        if (row.filtered === null) {
            that.setAttribute('filter', 'indeterminate')
        }

        if (grid.dataSource.groupBy && grid.dataSource.groupBy.length > 0) {
            that.setAttribute('level', row.level);

            if (row.expanded) {
                that.setAttribute('expanded', '');
            }

            if (row.label !== undefined && row.level === grid.dataSource.groupBy.length - 1) {
                that.setAttribute('leaf', '');
            }

            if (row.label !== undefined) {
                that.setAttribute('group', '');
            }
            else {
                that.setAttribute('leaf', '');
            }

            if (row.summaryRow) {
                that.setAttribute('summary', '');
            }

            if (that.toggleButton) {
                that.toggleButton.classList.remove('jqx-hidden');
            }
        }
        else if (grid.dataSource.boundHierarchy) {
            that.setAttribute('level', row.level);

            if (row.expanded) {
                that.setAttribute('expanded', '');
            }

            if (row.leaf) {
                that.setAttribute('leaf', '');
            }

            if (row.summaryRow) {
                that.setAttribute('summary', '');
            }

            if (that.toggleButton) {
                that.toggleButton.classList.remove('jqx-hidden');
            }
        }
        else {
            row.canNotify = false;
            row.leaf = true;
            row.expanded = false;
            row.summaryRow = false;
            row.level = 0;
            if (that.toggleButton) {
                that.toggleButton.classList.add('jqx-hidden');
            }
            row.canNotify = true;
        }

        that.setAttribute('data-id', row.id);
        that.visible = row.visible;
        that.cellsNearContainerElement.classList.remove('jqx-visibility-hidden');
        that.cellsContainerElement.classList.remove('jqx-visibility-hidden');
        that.cellsFarContainerElement.classList.remove('jqx-visibility-hidden');
        that.removeAttribute('rowspan');

        if (grid._rowGap > 0 && row !== grid.rows[grid.rows.length - 1]) {
            that.style.marginBottom = grid._rowGap + 'px';

            if (parseInt(that.style.height) - grid._rowGap !== row.height) {
                that.style.height = row.height - grid._rowGap + 'px';
            }

            if (parseInt(that.style.lineHeight) - grid._rowGap !== row.height) {
                that.style.lineHeight = row.height - grid._rowGap + 'px';
            }
        }
        else {
            that.style.marginBottom = '';
            if (parseInt(that.style.height) !== row.height) {
                that.style.height = row.height + 'px';
            }

            if (parseInt(that.style.lineHeight) !== row.height) {
                that.style.lineHeight = row.height + 'px';
            }
        }

        if (cellsCenterContainerElement.style.left !== -grid._scrollView.scrollLeft + 'px') {
            cellsCenterContainerElement.style.left = -grid._scrollView.scrollLeft + 'px';
        }

        if (grid.rowDetail.enabled) {
            const detail = that.rowDetail;

            that.removeAttribute('show-detail');

            if (row.showDetail) {
                detail.classList.remove('jqx-hidden');

                that.setAttribute('show-detail', '');

                if (detail.style.height !== row.detailHeight + 'px') {
                    detail.style.height = row.detailHeight + 'px';
                }

                if (detail.style.lineHeight !== row.detailHeight + 'px') {
                    detail.style.lineHeight = row.detailHeight + 'px';
                }

                if (detail.style.top !== row.cellHeight + 'px') {
                    detail.style.top = row.cellHeight + 'px';
                }

                that._renderDetail(detail);
            }
            else {
                detail.classList.add('jqx-hidden');
            }
        }

        cellsNearContainerElement.classList.remove('jqx-hidden');
        cellsFarContainerElement.classList.remove('jqx-hidden');

        if (cellsNearContainerElement.style.width !== nearWidth + 'px') {
            cellsNearContainerElement.style.width = nearWidth + 'px';
        }

        if (cellsCenterContainerElement.style.width !== centerWidth + 'px') {
            cellsCenterContainerElement.style.width = centerWidth + 'px';
        }

        if (cellsFarContainerElement.style.width !== farWidth + 'px') {
            cellsFarContainerElement.style.width = farWidth + 'px';
        }

        cellsNearContainerElement.style.height = row.cellHeight + 'px';
        cellsCenterContainerElement.style.height = row.cellHeight + 'px';
        cellsFarContainerElement.style.height = row.cellHeight + 'px';

        if (farWidth === 0) {
            cellsFarContainerElement.classList.add('jqx-hidden');
        }

        if (nearWidth === 0) {
            cellsNearContainerElement.classList.add('jqx-hidden');
        }

        if (nearWidth > 0 && parseInt(nearWidth) === parseInt(grid._autoGeneratedColumnsNearWidth)) {
            //     cellsNearContainerElement.classList.add('border-collapse');
        }

        if (farWidth > 0 && parseInt(farWidth) === parseInt(grid._autoGeneratedColumnsFarWidth)) {
            cellsFarContainerElement.classList.add('border-collapse');
        }

        for (let j = 0; j < grid._frozenNearColumns.length; j++) {
            const column = grid._frozenNearColumns[j];

            let cellElement = that.children[0].children[j];

            if (!cellElement) {
                const cell = row.getCell(column);

                cellElement = cell.createElement();
                that.children[0].appendChild(cellElement);
            }

            that._renderCell(row, column, cellElement);
        }

        for (let j = 0; j < grid._frozenFarColumns.length; j++) {
            const column = grid._frozenFarColumns[j];
            let cellElement = that.children[2].children[j];

            if (!cellElement) {
                const cell = row.getCell(column);

                cellElement = cell.createElement();
                that.children[2].appendChild(cellElement);
            }

            if (column.adaptiveColumn) {
                if (!column.adaptiveVisible) {
                    cellElement.classList.add('jqx-hidden');
                }
                else {
                    cellElement.classList.remove('jqx-hidden');
                }

                continue;
            }

            that._renderCell(row, column, cellElement);
        }

        for (let j = 0; j < cellsCenterContainerElement.children.length; j++) {
            const columnElement = grid._columnElements[j + grid._frozenNearColumns.length];

            if (!columnElement) {
                let cellElement = that.children[1].children[j];

                that._renderCell(row, null, cellElement);
            }
        }


        for (let j = 0; j < grid._columnElements.length; j++) {
            const columnElement = grid._columnElements[j];
            const column = columnElement.column;

            if (!columnElement.parentNode || !column) {
                if (columnElement && !column) {
                    let cellElement = that.children[1].children[j];

                    if (cellElement) {
                        cellElement.classList.add('jqx-visibility-hidden');
                    }
                }

                continue;
            }

            let cellElement = that.children[1].children[j];

            if (!cellElement) {
                if (!columnElement.column) {
                    columnElement.column = column;
                }

                const cell = row.getCell(column);

                cellElement = cell.createElement();
                that.children[1].appendChild(cellElement);
            }

            if (columnElement.classList.contains('jqx-visibility-hidden')) {
                cellElement.classList.add('jqx-visibility-hidden');
                continue;
            }
            else {
                cellElement.classList.remove('jqx-visibility-hidden');
            }

            that._renderCell(row, column, cellElement);
        }

        if (!that.visible) {
            that.classList.add('jqx-hidden');
        }
        else {
            that.classList.remove('jqx-hidden');
        }
    }

    template() {
        return '';
    }
});

JQX.Utilities.Assign('Grid.Cell', class Cell {
    constructor(row, column) {
        const that = this;

        that.row = row;
        that.column = column;
        that.grid = row.grid;
        that.rowSpan = 1;
        that.colSpan = 1;
        that.value = undefined;
        that.fontSize = null;
        that.fontWeight = null;
        that.fontFamily = null;
        that.color = null;
        that.background = null;
        that.borderColor = null;
        that.tooltip = null;
        that.align = null;
        that.verticalAlign = null;
        that.readonly = false;
        that.oldValue = undefined;
        that._updating = false;
        that.styleChanged = true;
        that.editor = null;
        that.template = null;
        that.isEditing = false;
        that.canNotify = true;
        that.selected = false;
        that.focused = false;

        const proxy = new Proxy(that, {
            deleteProperty: function (target, property) {
                delete target[property];
                return true;
            },
    get: function (target, property) {
        if (property === 'value') {
            const cellValue = !that.column.displayField ? that.row.data[that.column.dataField] : that.row.data[that.column.displayField];

            return cellValue;
        }
        else if (property === 'editor' ||
            property === 'template') {
            return target[property] || that.column[property];
        }
        else if (property === 'focused') {
            if (that.grid.selection.allowCellSelection && that.grid._selection.focusedCell && that.grid._selection.focusedCell.row.id === that.row.id && that.grid._selection.focusedCell.column.dataField === that.column.dataField) {
                return true;
            }

            const parent = that.parent();

            if (parent && that.grid.selection.allowCellSelection && that.grid._selection.focusedCell && that.grid._selection.focusedCell.row.id === parent.row.id && that.grid._selection.focusedCell.column.dataField === parent.column.dataField) {
                return true;
            }

            return false;
        }
        if (property === 'selected') {
            if (that.row.getProperty('selected') === true) {
                return true;
            }

            if (that.column.getProperty('selected') === true) {
                return true;
            }

            return that.grid._selection.cells['row' + that.row.id] ? that.grid._selection.cells['row' + that.row.id][that.column.dataField] : false;
        }

        else if (property === 'modifiedValue') {
            const tempValue = that.grid._cellsUpdatedValues[that.row.id + '_' + that.column.dataField];

            if (tempValue !== undefined) {
                return tempValue;
            }

            return target['value'];
        }

        return target[property];
    },
    set: function (target, propertyName, value) {
        const oldValue = this.get(target, propertyName);

        if (oldValue === value) {
            return true;
        }

        target[propertyName] = value;

        if (propertyName === 'element' || propertyName === 'isEditing' || propertyName === 'oldValue' || propertyName === '_updating' || propertyName === 'notifyFn' || propertyName.startsWith('_') || propertyName === 'canNotify') {
            return true;
        }

        if (propertyName === 'focused') {
            that.grid._selection.focusedCell = that;
        }

        if (propertyName === 'colSpan' || propertyName === 'rowSpan') {
            if (value >= 0 && that.grid._cellsMerge.indexOf(that) === -1) {
                that.grid._cellsMerge.push(that);
            }
        }

        if (propertyName === 'row' || propertyName === 'column' || propertyName === 'grid' ||
           propertyName === 'styleChanged') {
            return true;
        }

        if (propertyName === 'background' ||
            propertyName === 'fontSize' ||
            propertyName === 'fontWeight' ||
            propertyName === 'fontFamily' ||
            propertyName === 'color' ||
            propertyName === 'borderColor' ||
            propertyName === 'fontStyle'
        ) {
            that._styleChanged = true;
        }

        if (propertyName === 'value') {
            if (that.oldValue === undefined) {
                that.oldValue = oldValue;
            }

            that.grid.dataSource.boundSource.canNotify = false;

            if (value !== null && value.label && value.value) {
                that.row.data[that.column.displayField] = value.label;
                that.row.data[that.column.dataField] = value.value;
            }
            else {
                if (that.column.valueField) {
                    that.row.data[that.column.valueField] = value;
                }

                that.row.data[that.column.dataField] = value;
            }

            const dataItem = that.grid.dataSource.dataItemById[that.row.id];

            if (dataItem) {
                const index = dataItem.$.index;

                if (value !== that.grid.dataSource[index][that.column.dataField]) {
                    that.grid.dataSource[index][that.column.dataField] = value;
                }
            }

            that.grid.dataSource.boundSource.canNotify = true;

        }

        if (propertyName === 'selected') {
            if (that.grid._selection.cells['row' + that.row.id]) {
                delete that.grid._selection.cells['row' + that.row.id][that.column.dataField];

                if (Object.getOwnPropertyNames(that.grid._selection.cells['row' + that.row.id]).length === 1) {
                    delete that.grid._selection.cells['row' + that.row.id];
                }
            }

            if (that.grid._selection.cells['column' + that.column.dataField]) {
                delete that.grid._selection.cells['column' + that.column.dataField][that.row.id];

                if (Object.getOwnPropertyNames(that.grid._selection.cells['column' + that.column.dataField]).length === 1) {
                    delete that.grid._selection.cells['column' + that.column.dataField];
                }
            }

            if (value) {
                if (!that.grid._selection.cells['row' + that.row.id]) {
                    that.grid._selection.cells['row' + that.row.id] = [];
                }

                if (!that.grid._selection.cells['column' + that.column.dataField]) {
                    that.grid._selection.cells['column' + that.column.dataField] = [];
                }

                that.grid._selection.cells['row' + that.row.id][that.column.dataField] = true;
                that.grid._selection.cells['column' + that.column.dataField][that.row.id] = true;
            }
        }

        if (that._updating || !that.canNotify) {
            return true;
        }

        if (!that.row.canNotify) {
            return true;
        }

        that.grid._recycle();

        if (that.propertyChanged) {
            that.propertyChanged(name.substring(1), oldValue/*, newValue*/);
        }


        return true;
    }
        });

        return proxy;
    }

    setStyle(element) {
        const that = this;

        if (that._styleChanged) {
            element.style.background = that.background;
            element.style.borderColor = that.borderColor;
            element.style.color = that.color;
            element.style.fontSize = that.fontSize;
            element.style.fontFamily = that.fontFamily;
            element.style.fontWeight = that.fontWeight;
            element.style.fontStyle = that.fontStyle;
            element.style.paddingBottom = '';

            that._styleChanged = false;
        }
    }

    getFormattedValue(value, format) {
        const that = this;

        if (value === undefined || value === null || value === '') {
            return value;
        }

        if (that.column.dataType === 'date' || that.column.dataType === 'datetime' || that.column.dataType === 'time') {
            return that.formatDate(value, format);
        }

        if (that.column.dataType === 'int' ||
        that.column.dataType === 'int64' ||
        that.column.dataType === 'float' ||
        that.column.dataType === 'number') {
            return that.formatNumber(value, format);
        }

        return value;
    }

    /**
   * Formats a date.
   */
    formatDate(value, format) {
        if (!JQX.Utilities.DateTime) {
            return value;
        }

        try {
            return new JQX.Utilities.DateTime(value).toString(format);
        }
        catch (e) {
            return value;
        }
    }

    /**
     * Formats a number.
     */
    formatNumber(value, format) {
        if (!JQX.Utilities.NumberRenderer) {
            return value;
        }

        const renderer = new JQX.Utilities.NumberRenderer(),
            result = renderer.formatNumber(value, format);

        if (result === undefined) {
            return value;
        }

        return result;
    }


    refresh() {
        const that = this;

        if (that.element) {
            const htmlCellContent = that.element.firstChild;

            that.setStyle(htmlCellContent);
        }
    }

    setProperties(properties) {
        const that = this;

        that._updating = true;

        for (let propertyName in properties) {
            that[propertyName] = properties[propertyName];
        }

        that._updating = false;

        that.grid._recycle();
    }

    createElement() {
        const that = this;
        const element = document.createElement('jqx-grid-cell');

        that.element = element;

        element._initialize(that);

        return element;
    }

    render() {
        const that = this;

        if (!that.element) {
            return;
        }

        that.element._render();
    }

    parent(getSiblingsData) {
        const that = this;
        const row = that.row;
        const dataField = that.column.dataField;
        const grid = that.grid;

        if (!grid._cellsMerge.length) {
            return null;
        }

        if (that.__parentCells) {
            if (that.__parentCells['row' + row.id + '_column_' + dataField] !== undefined) {
                return that.__parentCells['row' + row.id + '_column_' + dataField];
            }
        }

        let visibleRows = grid.getVisibleRows();

        if (grid.paging.enabled && grid.selection.selectAllMode === 'page') {
            visibleRows = visibleRows.slice(grid.paging.pageIndex * grid.paging.pageSize, (grid.paging.pageIndex + 1) * grid.paging.pageSize);
        }

        if (!that.__parentCells) {
            that.__parentCells = [];
        }

        for (let i = 0; i < grid._cellsMerge.length; i++) {
            const cell = grid._cellsMerge[i];

            let rows = [];
            let columns = [];

            rows.push(cell.row);

            if (cell.rowSpan > 1) {
                const startRowIndex = visibleRows.indexOf(cell.row);

                if (startRowIndex >= 0) {
                    for (let r = startRowIndex; r < startRowIndex + cell.rowSpan; r++) {
                        if (visibleRows[r] && rows.indexOf(visibleRows[r]) === -1) {
                            rows.push(visibleRows[r]);
                        }
                    }
                }
            }

            columns.push(cell.column.dataField);

            if (cell.colSpan > 1) {
                const startColumnIndex = grid.columns.indexOf(grid.columnByDataField[cell.column.dataField]);

                for (let r = startColumnIndex; r < startColumnIndex + cell.colSpan; r++) {
                    if (grid.columns[r] && columns.indexOf(grid.columns[r].dataField) === -1) {
                        columns.push(grid.columns[r].dataField);
                    }
                }
            }

            if (rows.indexOf(row) >= 0 && columns.indexOf(dataField) >= 0) {
                if (getSiblingsData) {
                    const parentCell = { cell: cell.row.getCell(cell.column.dataField), rows: rows, columns: columns, row: cell.row, column: cell.column, endRow: rows[rows.length - 1], endColumn: grid.columnByDataField[columns[columns.length - 1]] };

                    that.__parentCells['row' + row.id + '_column_' + dataField] = parentCell;

                    return parentCell;
                }

                const parentCell = cell.row.getCell(cell.column.dataField);

                that.__parentCells['row' + row.id + '_column_' + dataField] = parentCell;

                return parentCell;
            }
        }

        that.__parentCells['row' + row.id + '_column_' + dataField] = null;

        return null;
    }
});


JQX('jqx-grid-cell', class Cell extends JQX.BaseElement {
    static get properties() {
        return {
        }
    }

    get hasStyleObserver() {
        return false;
    }

    get enableShadowDOM() {
        return false;
    }

    addThemeClass() {

    }

    addDefaultClass() {

    }

    get isUtilityElement() {
        return true;
    }


    _initialize(cell) {
        const that = this;
        const content = document.createElement('div');
        const column = cell.column;
        const row = cell.row;
        const grid = cell.grid;

        that.cell = cell;
        that.appendChild(content);

        let shouldAddToggleButton = false;

        if (column && column._treeColumn && grid.dataSource.boundHierarchy) {
            shouldAddToggleButton = true;

            if (!grid.grouping.enabled && grid.dataSource.groupBy && grid.dataSource.groupBy.length > 0) {
                shouldAddToggleButton = false;
            }
        }

        if (shouldAddToggleButton) {
            const indent = document.createElement('div');
            const button = document.createElement('button');
            const label = document.createElement('div');
            const container = document.createElement('div');

            if (row.expanded) {
                button.setAttribute('toggled', '');
            }
            else {
                button.removeAttribute('toggled', '');
            }

            that.toggleButton = button;
            content.appendChild(indent);
            content.appendChild(container);

            container.setAttribute('content', '');
            indent.setAttribute('indent', '');
            label.setAttribute('label', '');
            button.setAttribute('toggle-button', '');

            that.setAttribute('has-toggle-button', '');
            container.appendChild(button);
            container.appendChild(label);
            that.content = label;
            return;
        }
        else {
            const label = document.createElement('div');

            content.appendChild(label);
        }

        that.content = content;
    }

    _renderCommands() {
        const that = this;

        const grid = that.cell.grid;

        if (grid.__cellsCommandTemplate) {
            that.firstChild.innerHTML = grid.__cellsCommandTemplate;

            grid._updateCommandColumnCommandsVisibility(that.firstChild, that.cell.row);
            return;
        }

        const commandHTML = grid._getCommandColumnCommandsTemplate();

        that.firstChild.innerHTML = commandHTML;
        grid._updateCommandColumnCommandsVisibility(that.firstChild, that.cell.row);
        grid.__cellsCommandTemplate = commandHTML;
    }

    _renderGroupCell() {
        const that = this;
        const grid = that.cell.grid;
        const column = that.cell.column;
        const row = that.cell.row;
        //const data = row.data;

        [...that.attributes].forEach(attr => that.removeAttribute(attr.name));

        if (that.style.width !== column.computedWidth + 'px') {
            that.style.width = column.computedWidth + 'px';
        }

        if (that.style.left !== column.left + 'px') {
            that.style.left = column.left + 'px';
        }

        if (that.classList.contains('jqx-hidden')) {
            that.classList.remove('jqx-hidden');
        }


        let cellValue = row.label;

        if (row.label !== undefined) {
            let summary = '';

            if (grid.grouping.summaryRow.visible) {
                const getAllSubRows = function (dataField, rows, subRows) {
                    for (let i = 0; i < rows.length; i++) {
                        const row = rows[i];

                        if (row[dataField] !== undefined) {
                            subRows.push(row);
                        }

                        if (row.summaryRow) {
                            continue;
                        }

                        if (row['children']) {
                            getAllSubRows(dataField, row['children'], subRows);
                        }
                        else if (row.data && row.data['children']) {
                            getAllSubRows(dataField, row['children'], subRows);
                        }
                    }

                    return subRows;
                }

                const subRows = getAllSubRows(column.dataField, row.summaryRow ? row.parent.data['children'] : row.data['children'], []);
                const summaryObject = {};
                const summaryFunctions = column._treeColumn ? (column.summary.length > 0 ? column.summary : ['count']) : column.summary;

                summaryObject[column.dataField] = summaryFunctions;

                const summaryResult = summaryFunctions.length > 0 ? grid.dataSource.summarize([summaryObject], subRows) : null;

                if (summaryResult) {
                    for (let i = 0; i < summaryFunctions.length; i++) {
                        const summaryFunction = summaryFunctions[i];

                        summary += '<span summary>' + grid.localize(summaryFunction, { value: summaryResult[column.dataField][summaryFunction] }); + '</span>';
                    }
                }
            }

            if (column._treeColumn) {
                if (!row.summaryRow) {
                    cellValue = '<div header><span group>' + grid.columnByDataField[row.groupDataField].label + '</span><span value>' + row.label + '</span></div>';
                }
                else {
                    cellValue = '<div header><span group></span><span value></span></div>';
                }

                if (summary) {
                    cellValue += '<div summary>';
                    cellValue += summary;
                    cellValue += '</div>';
                }

                that.setAttribute('has-toggle-button', '');
            }
            else {
                //let columnLabel = '';
                //let groupLabel = '';

                cellValue = '<div content><div label><div header><span group></span><span value></span></div>';

                if (summary) {
                    cellValue += '<div summary>';
                    cellValue += summary;
                    cellValue += '</div>';
                }

                cellValue += '</div></div>';
            }
        }

        const htmlCellContent = that.firstChild;

        if (grid.dataSource.boundHierarchy && that.toggleButton) {
            const indent = htmlCellContent.children[0];
            const toggleButton = htmlCellContent.children[1].children[0];
            const content = htmlCellContent.children[1].children[1];

            indent.setAttribute('indent', '');

            if (!row.leaf) {
                toggleButton.classList.remove('jqx-visibility-hidden');
                if (row.expanded) {
                    toggleButton.setAttribute('toggled', '');
                }
                else {
                    toggleButton.removeAttribute('toggled', '');
                }
            }
            else {
                toggleButton.classList.add('jqx-visibility-hidden');
            }

            let indentDiv = '';

            if (!column._treeColumn) {
                that.toggleButton.classList.add('jqx-hidden');
            }
            else {
                that.toggleButton.classList.remove('jqx-hidden');
            }

            if (column._treeColumn) {
                if (grid.grouping.enabled && grid.dataSource.groupBy.length > 0) {
                    let level = row.level;

                    if (undefined === row.label) {
                        level--;
                    }

                    indentDiv += '<div style="width: ' + (1 + level) * grid.grouping.groupIndent + 'px;"></div>';
                }
                else {
                    for (let i = 0; i < row.level; i++) {
                        indentDiv += '<div class=\'jqx-indent\'></div>';
                    }
                }
            }

            if (grid._adaptiveLayout > 0) {
                toggleButton.classList.add('jqx-hidden');
                indentDiv = '';
            }

            if (undefined === row.label) {
                toggleButton.classList.add('jqx-hidden');
            }
            else {
                toggleButton.classList.remove('jqx-hidden');
                toggleButton.style.marginLeft = '';

                if (column._treeColumn && grid.grouping.enabled && grid.grouping.toggleButtonIndent > 0) {
                    toggleButton.style.marginLeft = row.level * (grid.grouping.toggleButtonIndent - grid.grouping.groupIndent) + 'px';
                }
            }


            indent.innerHTML = indentDiv;
            content.innerHTML = cellValue;

            if (grid.appearance.showTooltips) {
                content.setAttribute('title', row.label ? row.label : cellValue);
            }
            else if (content.hasAttribute('title')) {
                content.removeAttribute('title');
            }
        }
        else if (row.label !== undefined && grid.grouping.enabled && !that.toggleButton) {
            htmlCellContent.innerHTML = cellValue;
        }

        if (grid.grouping.enabled && grid.dataSource.groupBy && grid.dataSource.groupBy.length > 0) {
            const indent = grid.grouping.groupIndent * (1 + row.level);

            if (column.dataField === grid.columns[grid.columns.length - 1].dataField) {
                that.style.width = column.computedWidth - indent + 'px';
                if (grid.appearance.showColumnLines) {
                    htmlCellContent.firstChild.classList.add('jqx-grid-column-border');
                }
            }
        }

        let cellContentClassName = 'jqx-label';

        if (htmlCellContent.className !== cellContentClassName) {
            htmlCellContent.className = cellContentClassName;
        }

        if (column.formatFunction) {
            const formatObject = {
                row: row,
                column: column,
                cell: that.cell,
                value: null,
                template: null,
                group: {
                    value: cellValue,
                    template: null
                }
            };

            column.formatFunction(formatObject);

            if (formatObject.group.value !== cellValue) {
                htmlCellContent.innerHTML = formatObject.group.value;
            }

            if (formatObject.group.template !== null) {
                htmlCellContent.innerHTML = formatObject.group.template;
            }
        }
    }

    _render() {
        const that = this;
        const grid = that.cell.grid;
        const column = that.cell.column;
        const row = that.cell.row;
        const data = row.data;

        if (grid.grouping.enabled && grid.dataSource.groupBy.length > 0 && row.label !== undefined) {
            that._renderGroupCell();
            return;
        }

        if (grid.grouping.enabled && grid.dataSource.groupBy.length > 0 && that.toggleButton) {
            that.toggleButton.classList.remove('jqx-hidden');
            that.toggleButton.classList.remove('jqx-visibility-hidden');
            that.toggleButton.style.marginLeft = '';

            if (column._treeColumn && grid.grouping.enabled && grid.grouping.toggleButtonIndent > 0) {
                that.toggleButton.style.marginLeft = row.level * (grid.grouping.toggleButtonIndent - grid.grouping.groupIndent) + 'px';
            }
        }

        if (!column.visible) {
            that.style.width = '0px';
            return;
        }

        if (grid.appearance.showSortColumnBackground) {
            column.sorted ? that.setAttribute('sort', '') : that.removeAttribute('sort');
        }
        else if (column.sorted && that.hasAttribute('sort')) {
            that.removeAttribute('sort');
        }

        if (grid.appearance.showFilterColumnBackground) {
            column.filtered ? that.setAttribute('filter', '') : that.removeAttribute('filter');
        }
        else if (column.filtered && that.hasAttribute('filter')) {
            that.removeAttribute('filter');
        }


        let cellValue = !column.displayField ? data[column.dataField] : data[column.displayField];

        if (grid.editing.batch) {
            if (grid._cellsUpdatedValues) {
                that.removeAttribute('update');

                const tempValue = grid._cellsUpdatedValues[row.id + '_' + column.dataField];

                if (tempValue !== undefined) {
                    that.setAttribute('update', '');
                    cellValue = tempValue;
                }
            }

            if (grid._rowsDeleted) {
                if (grid._rowsDeleted.indexOf(row) >= 0) {
                    that.setAttribute('delete', '');
                }
                else {
                    that.removeAttribute('delete');
                }
            }

            if (grid._rowsAdded) {
                if (grid._rowsAdded.indexOf(row.id) >= 0) {
                    that.setAttribute('add', '');
                }
                else {
                    that.removeAttribute('add');
                }
            }
        }

        if (grid.onCellValue && !(column.rowNumbersColumn || column.selectionColumn)) {
            that.cell._updating = true;
            grid.onCellValue(that.cell);
            that.cell._updating = false;

            cellValue = that.cell.value;
        }

        if (cellValue === undefined) {
            cellValue = '';
        }

        let formattedValue = cellValue;

        if (column.cellsFormat) {
            formattedValue = that.cell.getFormattedValue(cellValue, column.cellsFormat);
        }

        const htmlCellContent = that.firstChild;

        if (grid.onCellRender || column.onCellRender) {
            requestAnimationFrame(function () {
                if (!column._cellsCachedValues) {
                    column._cellsCachedValues = [];
                }

                if (column._cellsCachedValues[row.index]) {
                    const cellContent = column._cellsCachedValues[row.index];

                    if (htmlCellContent.firstChild) {
                        htmlCellContent.removeChild(htmlCellContent.firstChild);
                    }

                    htmlCellContent.appendChild(cellContent);
                }
                else {
                    grid.onCellRender ? grid.onCellRender(that.cell) : column.onCellRender(that.cell);

                    if (that.cell.template !== column.template) {
                        const cellContent = document.createElement('div');

                        if (htmlCellContent.firstChild) {
                            htmlCellContent.removeChild(htmlCellContent.firstChild);
                        }

                        if (that.cell.template instanceof HTMLTemplateElement) {
                            cellContent.appendChild(that.cell.template.cloneNode(true));
                        }
                        else {
                            cellContent.appendChild(that.cell.template);
                        }

                        htmlCellContent.appendChild(cellContent);

                        column._cellsCachedValues[row.index] = cellContent;

                        return;
                    }
                }
            });
        }

        if (!column.autoGenerated) {
            that.setAttribute('data-field', column.dataField);
        }

        if (that.cell.focused) {
            that.setAttribute('focus', '');
        }
        else {
            that.removeAttribute('focus');
        }

        if (that.cell.selected) {
            that.setAttribute('selected', '');
        }
        else {
            that.removeAttribute('selected');
        }

        if (grid.rowDetail.enabled && row.showDetail) {
            that.style.height = row.cellHeight + 'px';
            that.style.lineHeight = row.cellHeight + 'px';
        }

        if (row.adaptiveDetailExpanded || (grid.adaptivityMode.responsiveLayout.autoShowHiddenCells && row.adaptiveHeight)) {
            that.style.height = row.cellHeight + 'px';
            that.style.lineHeight = row.cellHeight + 'px';
        }

        if (row.expanded && row.expandHeight > 0) {
            that.style.height = row.cellHeight + 'px';
            that.style.lineHeight = row.cellHeight + 'px';
        }

        const alignment = that._getCellAlignment(row, column);
        const hasTemplate = that.cell.template !== '' && grid.isInitialized;

        let cellContentClassName = '';

        if (alignment.align) {
            cellContentClassName += alignment.align + ' ';
        }

        if (alignment.verticalAlign) {
            cellContentClassName += alignment.verticalAlign + ' ';
        }

        cellContentClassName += 'jqx-label';

        if (that.style.width !== column.computedWidth + 'px') {
            const isLastColumn = grid._isLastVisibleColumn(column);

            if (column.autoGenerated || isLastColumn) {
                that.style.width = column.computedWidth + 'px';
            }
            else {
                that.style.width = column.computedWidth - grid._columnGap + 'px';
            }
        }

        if (grid.grouping.enabled && grid.dataSource.groupBy && grid.dataSource.groupBy.length > 0) {
            const indent = grid.grouping.groupIndent * (1 + row.level);

            if (column.dataField === grid.columns[grid.columns.length - 1].dataField) {
                that.style.width = column.computedWidth - indent + grid.grouping.groupIndent + 'px';

                if (grid.appearance.showColumnLines) {
                    that.classList.add('jqx-grid-column-border');
                }
            }
        }

        if (column === grid._firstVisibleColumn) {
            that.classList.add('jqx-grid-column-border-collapse');
        }
        else {
            that.classList.remove('jqx-grid-column-border-collapse');
        }

        if (grid._columnGap > 0 && grid.appearance.showColumnLines) {
            that.classList.add('jqx-grid-column-border');
        }

        if (grid._rowGap > 0) {
            that.classList.add('jqx-grid-row-border');
        }

        if (!grid.appearance.showColumnLines) {
            that.classList.add('jqx-grid-vertical-border-collapse');
        }
        else {
            that.classList.remove('jqx-grid-vertical-border-collapse');
        }

        if (!grid.appearance.showRowLines) {
            that.classList.add('jqx-grid-horizontal-border-collapse');
        }
        else {
            that.classList.remove('jqx-grid-horizontal-border-collapse');
        }


        let left = column.left;

        if (that.style.left !== left + 'px') {
            that.style.left = left + 'px';
        }

        if (that.classList.contains('jqx-hidden')) {
            that.classList.remove('jqx-hidden');
        }

        if (that.hasAttribute('template')) {
            that.removeAttribute('template');
        }

        if (that.hasAttribute('freeze')) {
            that.removeAttribute('freeze');
        }

        if (that.hasAttribute('adaptive')) {
            that.removeAttribute('adaptive');
        }

        if (that.hasAttribute('detail')) {
            that.removeAttribute('detail');
        }

        if (row.filterRow) {
            that.classList.add('jqx-grid-filter-row-cell');
        }
        else if (row.summaryRow) {
            that.classList.add('jqx-grid-summary-row-cell');
        }
        else if (column.freeze || row.freeze) {
            if (column.selectionColumn) {
                that.setAttribute('checkbox', '');
                cellContentClassName += ' jqx-input';

                if (column.grid.selection.checkBoxes.enabled && column.grid.selection.checkBoxes.autoShow) {
                    that.setAttribute('auto-show', '');
                }
                else {
                    that.removeAttribute('auto-show');
                }
            }

            if (column.rowNumbersColumn || column.selectionColumn) {
                that.setAttribute('header', '');
            }

            if (column.rowDetailColumn) {
                that.setAttribute('header', '');
                that.setAttribute('detail', '');
                that.setAttribute('has-toggle-button', '');
            }

            if (column.commandColumn) {
                that.setAttribute('command', '');
            }

            if (grid.appearance.showFrozenColumnBackground && column.freeze) {
                that.setAttribute('freeze', '');
            }

            if (grid.appearance.showFrozenRowBackground && row.freeze) {
                that.setAttribute('freeze', '');
            }
        }

        if (column.cellsRotationAngle) {
            const rotateResult = that._rotateCellContent(htmlCellContent, column, cellValue);

            if (!rotateResult) {
                return;
            }
        }
        else {
            if (row.filterRow) {
                if (column.adaptiveColumn || column.toggleColumn || column.rowNumbersColumn) {
                    htmlCellContent.innerHTML = '';
                }
                else {
                    if (!column.filterEditorInitialized) {
                        column.filterEditorInitialized = true;
                    }
                }
            }
            else if (row.summaryRow) {
                if (column.adaptiveColumn || column.toggleColumn || column.rowNumbersColumn) {
                    htmlCellContent.innerHTML = '';
                }
                else {
                    if (column.summary.length > 0 && grid._summaryItems) {
                        const summaryItem = grid._summaryItems[column.dataField];

                        let index = 0;

                        for (let summaryItemFunction in summaryItem) {
                            if (index === row.summaryRowIndex) {
                                htmlCellContent.innerHTML = grid.localize(summaryItemFunction, { value: summaryItem[summaryItemFunction] });
                            }
                            index++;
                        }
                    }
                }
            }
            else {
                if (grid.rowDetail.enabled && column.rowDetailColumn) {
                    if (htmlCellContent.innerHTML !== '') {
                        if (row.showDetail) {
                            htmlCellContent.innerHTML = '<button class="jqx-animate" toggled toggle-button></button>';
                        }
                        else {
                            htmlCellContent.innerHTML = '<button class="jqx-animate" toggle-button></button>';
                        }

                        row.element.toggleDetailButton = that.querySelector('button');
                    }
                }
                else if (column.adaptiveColumn) {
                    that.removeAttribute('expanded');

                    if (row.adaptiveDetailExpanded) {
                        that.setAttribute('expanded', '');
                    }

                    if (new Date() - grid._lastPointerDownTime < 300) {
                        cellContentClassName += ' jqx-animate';
                    }
                }
                else if (column.commandColumn) {
                    that._renderCommands();
                }
                else if (grid.appearance.showRowNumber && column.rowNumbersColumn) {
                    if (row.addNewRow) {
                        htmlCellContent.textContent = '';
                    }
                    else {
                        if (grid._rowsAdded) {
                            if (grid._rowsAdded.indexOf(row.id) >= 0) {
                                htmlCellContent.textContent = '';
                            }
                            else {
                                htmlCellContent.textContent = row.visibleIndex + 1;
                            }
                        }
                        else {
                            htmlCellContent.textContent = row.visibleIndex + 1;
                        }
                    }
                }
                else if (hasTemplate) {

                    that.removeAttribute('readonly');

                    switch (that.cell.template) {
                        case 'checkBox':
                        case 'switchButton':
                        case 'radioButton':
                            if (htmlCellContent.textContent !== '') {
                                htmlCellContent.textContent = '';
                            }

                            if (!grid.editing.enabled || !column.allowEdit || that.cell.readonly || (grid.editing.enabled && grid.editing.commandColumn.visible && grid.editing.editRow !== that.cell.row)) {
                                that.setAttribute('readonly', '');
                            }

                            if (htmlCellContent.innerHTML !== '<span class="jqx-input"></span>') {
                                htmlCellContent.innerHTML = '<span class="jqx-input"></span>';
                            }

                            if (cellValue) {
                                htmlCellContent.firstChild.setAttribute('checked', '');
                            }
                            else if (cellValue === null) {
                                htmlCellContent.firstChild.setAttribute('checked', 'indeterminate');
                            }
                            else {
                                htmlCellContent.firstChild.removeAttribute('checked');
                            }

                            that.setAttribute('template', that.cell.template);
                            break;
                        default: {
                            let template = null;
                            that.setAttribute('template', '');

                            if (typeof that.cell.template === 'function') {
                                const formatObject = {
                                    row: row,
                                    column: column,
                                    cell: that.cell,
                                    oldValue: that.cell.oldValue,
                                    value: cellValue,
                                    template: null
                                };

                                const cellTemplate = htmlCellContent.querySelector('.jqx-grid-cell-template');

                                if (cellTemplate) {
                                    formatObject.template = cellTemplate.firstElementChild;
                                }

                                that.cell.template(formatObject);

                                if (!cellTemplate && formatObject.template) {
                                    if (formatObject.template instanceof HTMLElement) {
                                        const templateContainer = document.createElement('div');

                                        templateContainer.classList.add('jqx-grid-cell-template');

                                        htmlCellContent.appendChild(templateContainer);
                                        templateContainer.appendChild(formatObject.template);
                                    }
                                    else {
                                        htmlCellContent.innerHTML = '<div class="jqx-grid-cell-template">' + formatObject.template + '</div>';
                                    }
                                }
                                else if (!cellTemplate && formatObject.template === null) {
                                    htmlCellContent.innerHTML = cellValue;
                                }

                                if (that.cell._styleChanged) {
                                    that.cell.setStyle(htmlCellContent);
                                }
                            }
                            else {
                                if (htmlCellContent.textContent !== '') {
                                    htmlCellContent.textContent = '';
                                }

                                if (that.cell.template.startsWith('#')) {
                                    template = document.querySelector(that.cell.template);
                                }

                                if (template) {
                                    const templateContent = template.content.cloneNode(true).firstElementChild;

                                    cellValue = cellValue.toString();
                                    cellValue = cellValue.replace(/'/ig, '\\\'');
                                    cellValue = cellValue.replace(/"/ig, '\\"');

                                    let html = templateContent.outerHTML.replace(/{{value}}/ig, cellValue).replace(/{{id}}/ig, row.id);

                                    if (html.indexOf('{{value=') >= 0) {
                                        if (!cellValue) {
                                            html = html.replace(/{{value=/ig, '');
                                            html = html.replace(/}}/ig, '');
                                        }
                                        else {
                                            html = html.substring(0, html.indexOf('{{value=')) + cellValue + html.substring(html.indexOf('}'));
                                            html = html.replace(/}/ig, '');
                                            html = html.replace(/{/ig, '');
                                        }
                                    }

                                    if (htmlCellContent.innerHTML !== html) {
                                        htmlCellContent.innerHTML = html;
                                    }
                                }
                                else {
                                    const html = that.cell.template.replace(/{{value}}/ig, cellValue).replace(/{{id}}/ig, row.id);

                                    if (htmlCellContent.innerHTML !== html) {
                                        htmlCellContent.innerHTML = html;
                                    }
                                }
                            }
                        }
                    }
                }
                else if (column.selectionColumn) {
                    if (grid.selectionMode === 'checkBox') {

                        if (row.getProperty('selected')) {
                            that.setAttribute('selected', '');

                        }
                        else {
                            if (that.getAttribute('selected')) {
                                that.removeAttribute('selected');
                            }
                        }
                    }
                }

                else {
                    const firstChild = htmlCellContent.firstChild;

                    if (firstChild && firstChild.classList && that.toggleButton) {
                        const indent = htmlCellContent.children[0];
                        const toggleButton = htmlCellContent.children[1].children[0];
                        const content = htmlCellContent.children[1].children[1];

                        let indentDiv = '';

                        if (column._treeColumn) {
                            if (grid.grouping.enabled) {
                                let level = row.level - 1;

                                indentDiv += '<div style="width: ' + (1 + level) * grid.grouping.groupIndent + 'px;"></div>';
                            }
                            else {
                                for (let i = 0; i < row.level; i++) {
                                    indentDiv += '<div class=\'jqx-indent\'></div>';
                                }
                            }
                        }

                        indent.innerHTML = indentDiv;

                        toggleButton.classList.add('jqx-visibility-hidden');

                        if (!row.leaf) {
                            toggleButton.classList.remove('jqx-visibility-hidden');
                            if (row.expanded) {
                                toggleButton.setAttribute('toggled', '');
                            }
                            else {
                                toggleButton.removeAttribute('toggled', '');
                            }
                        }
                        else {
                            toggleButton.classList.add('jqx-visibility-hidden');
                        }


                        if (row.data.isEmpty) {
                            toggleButton.classList.add('jqx-visibility-hidden');
                        }

                        content.innerHTML = formattedValue;

                        if (grid.appearance.showTooltips) {
                            content.setAttribute('title', formattedValue);
                        }
                        else if (content.hasAttribute('title')) {
                            content.removeAttribute('title');
                        }
                    }
                    else {
                        const cell = row['column_' + column.dataField];

                        if (that.getAttribute('rowspan')) {
                            that.removeAttribute('rowspan');
                            that.style.height = '';
                        }

                        if (that.getAttribute('colspan')) {
                            that.removeAttribute('colspan');
                        }

                        if (cell) {
                            if (cell.colSpan > 1) {

                                const startColumnIndex = grid.columns.indexOf(column);
                                let width = 0;
                                for (let m = startColumnIndex; m < startColumnIndex + cell.colSpan; m++) {
                                    const viewColumn = grid.columns[m];

                                    if (viewColumn && viewColumn.visible) {
                                        width += viewColumn.computedWidth;
                                    }
                                }

                                that.style.width = width + 'px';

                                that.setAttribute('colspan', '');
                                cell._styleChanged = true;
                            }

                            if (cell.rowSpan > 1) {
                                const startRowIndex = grid.rows.indexOf(row);
                                let height = 0;

                                row.element.setAttribute('rowspan', '');

                                for (let m = startRowIndex; m <= startRowIndex + cell.rowSpan - 1; m++) {
                                    const viewRow = grid.rows[m];

                                    if (viewRow && viewRow.visible && viewRow.filtered) {
                                        height += viewRow.cellHeight;
                                    }
                                }

                                that.style.height = height + 'px';


                                that.setAttribute('rowspan', '');
                                cell._styleChanged = true;
                            }

                            if ((cell.colSpan === 1 && that.hasAttribute('colspan')) || (that.hasAttribute('rowspan') && cell.rowSpan === 1)) {
                                that.style.height = '';
                                that.style.width = '';
                                that.removeAttribute('colspan');
                                that.removeAttribute('rowspan');
                                cell._styleChanged = true;
                            }

                            if (htmlCellContent.textContent !== formattedValue && !column.formatFunction) {
                                htmlCellContent.textContent = formattedValue;
                            }

                            cell.setStyle(htmlCellContent);

                            if (grid.appearance.showTooltips) {
                                htmlCellContent.setAttribute('title', cell.tooltip || formattedValue);
                            }
                            else if (htmlCellContent.hasAttribute('title')) {
                                htmlCellContent.removeAttribute('title');
                            }
                        }
                        else {
                            htmlCellContent.textContent = formattedValue;
                        }
                    }
                }
            }
        }

        if (htmlCellContent.className !== cellContentClassName) {
            htmlCellContent.className = cellContentClassName;
        }

        if (column.formatFunction && !row.data.isEmpty && grid.isInitialized) {
            const formatObject = {
                row: row,
                column: column,
                cell: that.cell,
                oldValue: that.cell.oldValue,
                value: cellValue,
                formattedValue: formattedValue,
                template: null
            };

            that.cell.canNotify = false;
            row.canNotify = false;

            const cellStyle = Object.assign({}, {
                background: that.cell.background,
                borderColor: that.cell.borderColor,
                color: that.cell.color,
                fontSize: that.cell.fontSize,
                fontFamily: that.cell.fontFamily,
                fontWeight: that.cell.fontWeight,
                fontStyle: that.cell.fontStyle
            });

            column.formatFunction(formatObject);

            if (htmlCellContent.style.background !== cellStyle.background ||
                htmlCellContent.style.borderColor !== cellStyle.borderColor ||
                htmlCellContent.style.color !== cellStyle.color ||
                htmlCellContent.style.fontSize !== cellStyle.fontSize ||
                htmlCellContent.style.fontWeight !== cellStyle.fontWeight ||
                htmlCellContent.style.fontStyle !== cellStyle.fontStyle
            ) {
                that.cell._styleChanged = true;
                that.cell.setStyle(htmlCellContent);
            }

            let requiresUpdate = true;

            if (formatObject.value !== cellValue) {
                if (that.toggleButton) {
                    const content = htmlCellContent.children[1].children[1];

                    content.innerHTML = formatObject.value;
                }
                else {
                    htmlCellContent.innerHTML = formatObject.value;
                }

                requiresUpdate = false;
            }

            if (formatObject.template !== null) {
                if (that.toggleButton) {
                    const content = htmlCellContent.children[1].children[1];

                    if (content.innerHTML !== formatObject.template) {
                        content.innerHTML = formatObject.template;
                    }
                }
                else if (htmlCellContent.innerHTML !== formatObject.template) {
                    const checkTemplateElement = document.createElement('div');

                    checkTemplateElement.innerHTML = formatObject.template;

                    if (checkTemplateElement.innerHTML !== htmlCellContent.innerHTML) {
                        htmlCellContent.innerHTML = formatObject.template;
                    }
                }

                requiresUpdate = false;
            }

            if (requiresUpdate) {
                htmlCellContent.textContent = cellValue;
            }

            that.cell.canNotify = true;
            row.canNotify = true;
        }
    }

    _rotateCellContent(columnHeaderCellContentElement, column, cellValue) {
        const that = this;
        const textElement = document.createElement('span');

        columnHeaderCellContentElement.innerHTML = '';
        textElement.innerHTML = cellValue;
        columnHeaderCellContentElement.appendChild(textElement);

        textElement.className = 'rotate'
        textElement.style.transform = 'rotate(' + column.cellsRotationAngle + 'deg)';

        return that.grid._recycleRotate(columnHeaderCellContentElement, textElement, column.cellsAlign, column.cellsVerticalAlign, cellValue);
    }

    _getCellAlignment(row, column) {
        const cell = row['column_' + column.dataField];
        const align = cell ? cell.align || column.cellsAlign : column.cellsAlign;
        const verticalAlign = cell ? cell.verticalAlign || column.cellsVerticalAlign : column.cellsVerticalAlign;
        const alignment = { align: '', verticalAlign: '' };

        switch (align) {
            case 'left':
                alignment.align = 'align-left';
                break;
            case 'center':
            case 'middle':
                alignment.align = 'align-center';
                break;
            case 'right':
                alignment.align = 'align-right';
                break;
        }

        switch (verticalAlign) {
            case 'top':
                alignment.verticalAlign = 'align-top';
                break;
            case 'center':
            case 'middle':
                alignment.verticalAlign = 'align-middle';
                break;
            case 'bottom':
                alignment.verticalAlign = 'align-bottom';
                break;
        }

        return alignment;
    }

    template() {
        return '';
    }
});



JQX.Utilities.Assign('Grid.Menu', class Menu {
    openMenu(dataField) {
        const that = this;

        const column = that.columnByDataField[dataField];

        if (!column) {
            return;
        }

        that._openMenu(column);
    }

    _openColumnChooserMenu(column) {
        const that = this;

        if (!column) {
            column = that._commandColumn;
        }

        if (!column || (that.menu && that.menu.column === column && column.element.hasAttribute('aria-controls'))) {
            that.closeMenu();
            return;
        }

        if (!that.menu) {
            that.menu = document.createElement('div');
            that.menu.classList.add('jqx-grid-column-menu');
            that.menu.id = that.id + '_' + that.tagName.toLowerCase() + '_menu_' + Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
        }

        if (that.appearance.allowColumnMenuAnimation) {
            that.menu.classList.add('jqx-animate');
        }
        else {
            that.menu.classList.remove('jqx-animate');
        }

        that._createColumnChooserMenuItems(column);

        that.menu.style.height = that.columnMenu.height ? that.columnMenu.height + 'px' : 'auto';

        if (that.menu.column && that.menu.column !== column) {
            that.menu.column.setProperty('menu', null);
            that.menu.column = null;
        }

        document.body.appendChild(that.menu);

        column.setProperty('menu', that.menu);

        const columnRect = column.element.getBoundingClientRect();

        that.menu.column = column;

        let left = columnRect.right - column.element.actionButton.getBoundingClientRect().width + window.pageXOffset;
        let top = columnRect.bottom + window.pageYOffset;

        if (left + that.menu.offsetWidth > window.innerWidth) {
            left = columnRect.right + window.pageXOffset - that.menu.offsetWidth;

            if (left + that.menu.offsetWidth > window.innerWidth) {
                left = window.innerWidth - that.menu.offsetWidth;
            }
        }

        that.menu.style.left = left + 'px';
        that.menu.style.top = top + 'px';

        that.menu.classList.remove('jqx-hidden');
        that.menu.classList.add('open');
    }

    _openMenu(column) {
        const that = this;

        if (!column || (that.menu && that.menu.column === column && column.element.hasAttribute('aria-controls'))) {
            that.closeMenu();
            return;
        }

        if (!that.menu) {
            that.menu = document.createElement('div');
            that.menu.classList.add('jqx-grid-column-menu');
            that.menu.id = that.id + '_' + that.tagName.toLowerCase() + '_menu_' + Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
        }

        if (that.appearance.allowColumnMenuAnimation) {
            that.menu.classList.add('jqx-animate');
        }
        else {
            that.menu.classList.remove('jqx-animate');
        }

        that._createMenuItems(column);
        that._createFilterPanel(column);
        that._filterMenuItemsVisibility(column);

        that.menu.style.height = that.columnMenu.height ? that.columnMenu.height + 'px' : 'auto';

        if (that.menu.column && that.menu.column !== column) {
            that.menu.column.setProperty('menu', null);
            that.menu.column = null;
        }

        document.body.appendChild(that.menu);

        column.setProperty('menu', that.menu);

        const columnRect = column.element.getBoundingClientRect();

        that.menu.column = column;

        let left = columnRect.right - column.element.actionButton.getBoundingClientRect().width + window.pageXOffset;
        let top = columnRect.bottom + window.pageYOffset;

        if (left + that.menu.offsetWidth > window.innerWidth) {
            left = columnRect.right + window.pageXOffset - that.menu.offsetWidth;

            if (left + that.menu.offsetWidth > window.innerWidth) {
                left = window.innerWidth - that.menu.offsetWidth;
            }
        }

        that.menu.style.left = left + 'px';
        that.menu.style.top = top + 'px';

        if (!that.hasColumnMenu(column)) {
            that.closeMenu();
        }
        else {
            that.menu.classList.remove('jqx-hidden');
        }

        that.menu.classList.add('open');
    }

    _menuItemClick(event) {
        const that = this;
        const details = event.detail;
        const menuItem = details.value;

        if (menuItem && menuItem.properties) {
            const command = menuItem.properties.command;

            if (typeof command === 'function') {
                command.apply(that, [menuItem.column]);
            }
            else if (that[command]) {
                that[command].apply(that, [menuItem.column]);
            }

            if (menuItem.column.autoCloseMenu) {
                that.closeMenu();
            }
        }
    }

    removeGroupByCommand(column) {
        const that = this;

        that.removeGroup(column.dataField);
    }

    groupByCommand(column) {
        const that = this;

        if (!that.dataSource) {
            return;
        }

        that.addGroup(column.dataField);
    }

    sortAscCommand(column) {
        const that = this;

        that.sortBy(column.dataField, 'asc');
    }

    sortDescCommand(column) {
        const that = this;

        that.sortBy(column.dataField, 'desc');
    }

    removeSortCommand(column) {
        const that = this;

        that.sortBy(column.dataField, null);
    }

    /*
    { 'columnMenuCustomizeType': {command: 'customizeTypeCommand', enabled: true, visible: false, icon: 'jqx-icon-customize', label: '{{messages}}'}},
{ 'columnMenuItemRename': { command: 'renameCommand', enabled: true, visible: false, icon: 'jqx-icon-rename', label: '{{messages}}' } },
{ 'columnMenuItemEditDescription': { command: 'editDescriptionCommand', enabled: true, visible: false, icon: 'jqx-icon-description', label: '{{messages}}' } },
{ 'columnMenuItemDuplicate': { command: 'duplicateCommand', visible: false, enabled: true, icon: 'jqx-icon-duplicate', label: '{{messages}}' } },
{ 'columnMenuItemInsertLeft': { command: 'insertLeftCommand', visible: false, enabled: true, icon: 'jqx-icon-insert-left', label: '{{messages}}' } },
{ 'columnMenuItemInsertRight': { command: 'insertRightCommand', visible: false, enabled: true, icon: 'jqx-icon-insert-right', label: '{{messages}}' } },
{ 'columnMenuItemSortAsc': { command: 'sortAscCommand', visible: 'auto', enabled: true, icon: 'jqx-icon-sort-a-z', label: '{{messages}}' } },
{ 'columnMenuItemSortDesc': { command: 'sortDescCommand', visible: 'auto', enabled: true, icon: 'jqx-icon-sort-z-a', label: '{{messages}}' } },
{ 'columnMenuItemRemoveSort': { command: 'removeSortCommand', visible: 'auto', enabled: true, icon: 'jqx-icon-cancel-circled', label: '{{messages}}' } },
{ 'columnMenuItemFilter': { command: 'addFilterCommand', visible: 'auto', enabled: true, icon: 'jqx-icon-add-filter', label: '{{messages}}' } },
{ 'columnMenuItemRemoveFilter': { command: 'removeFilterCommand', enabled: true, visible: 'auto', icon: 'jqx-icon-cancel-circled-outline', label: '{{messages}}' } },
{ 'columnMenuItemGroupBy': { command: 'groupByCommand', enabled: true, visible: 'auto', icon: 'jqx-icon-group-by', label: '{{messages}}' } },
{ 'columnMenuItemHide': { command: 'hideColumnCommand', enabled: true, visible: false, icon: 'jqx-icon-hide', label: '{{messages}}' } },
{ 'columnMenuItemDelete': { command: 'deleteColumnCommand', enabled: true, visible: false, icon: 'jqx-icon-delete', label: '{{messages}}' } }
*/

    _removeMenu() {
        const that = this;
        const verticalMenu = that.menu.querySelector('jqx-menu');

        if (verticalMenu) {
            that.menu.removeChild(verticalMenu);
        }
    }

    _createColumnChooserMenuItems(/*column*/) {
        const that = this;

        that._removeMenu();

        const verticalMenu = document.createElement('jqx-menu');
        const menuContent = document.createDocumentFragment();

        verticalMenu.mode = 'vertical';
        verticalMenu.dropDownAppendTo = 'body';
        verticalMenu.checkboxes = true;
        verticalMenu.checkable = true;
        verticalMenu.classList.add('jqx-grid-column-chooser-menu');

        for (let i = 0; i < that.columns.length; i++) {
            const column = that.columns[i];
            const menuItem = document.createElement('jqx-menu-item');
            const icon = column.showIcon ? column.icon : (column.visible ? 'jqx-icon-eye' : 'jqx-icon-eye-off');

            menuItem.checked = column.visible;

            if (!column.allowHide) {
                continue;
            }

            column.command = function (column) {
                column.visible = !column.visible;
            }

            menuItem.label = that.localize(column.label) || column.label || column.dataField;
            menuItem.value = { column: column, properties: column };

            if (icon) {
                menuItem.label = '<span class="jqx-grid-icon ' + icon + '"></span>' + menuItem.label;
            }

            menuContent.appendChild(menuItem);
        }

        verticalMenu.appendChild(menuContent);
        that.menu.appendChild(verticalMenu);

        that.menu.itemCheckChange = that._menuItemClick.bind(that);

        that.menu.addEventListener('itemCheckChange', that.menu.itemCheckChange);
        that.menu.addEventListener('keydown', that._keyDownHandler.bind(that));
    }

    _createMenuItems(column) {
        const that = this;

        that._removeMenu();

        const verticalMenu = document.createElement('jqx-menu');
        const menuContent = document.createDocumentFragment();
        const dataSource = column.menuItems || that.columnMenu.dataSource;

        verticalMenu.mode = 'vertical';
        verticalMenu.dropDownAppendTo = 'body';

        for (let item in dataSource) {
            const properties = dataSource[item];
            const menuItem = document.createElement('jqx-menu-item');
            let icon = properties.icon;

            menuItem.label = that.localize(item);
            menuItem.value = { column: column, properties: properties };

            const sortString = (asc) => {
                if (asc) {
                    if (column.dataType === 'string') {
                        return 'A  Z';
                    }
                    else if (column.dataType === 'number' || column.dataType === 'date' || column.dataType === 'time') {
                        return '1  9';
                    }
                    else if (column.dataType === 'bool' || column.dataType === 'boolean') {
                        return '0  1';
                    }
                }
                else {
                    if (column.dataType === 'string') {
                        return 'Z  A';
                    }
                    else if (column.dataType === 'number' || column.dataType === 'date' || column.dataType === 'time') {
                        return '9  1';
                    }
                    else if (column.dataType === 'bool' || column.dataType === 'boolean') {
                        return '1  0';
                    }
                }
            }

            if (item === 'columnMenuItemSortAsc') {
                menuItem.label = that.localize(item, { mode: sortString(true) });

                if (column.dataType !== 'string') {
                    if (properties.iconAlt) {
                        icon = properties.iconAlt;
                    }
                }
            }
            else if (item === 'columnMenuItemSortDesc') {
                menuItem.label = that.localize(item, { mode: sortString(false) });

                if (column.dataType !== 'string') {
                    if (properties.iconAlt) {
                        icon = properties.iconAlt;
                    }
                }
            }

            if (icon) {
                menuItem.label = '<span class="jqx-grid-icon ' + icon + '"></span>' + menuItem.label;
            }

            menuContent.appendChild(menuItem);
        }

        verticalMenu.appendChild(menuContent);

        if (that._filterContainer) {
            that.menu.insertBefore(verticalMenu, that._filterContainer);
        }
        else {
            that.menu.appendChild(verticalMenu);
        }

        that.menu.itemClick = that._menuItemClick.bind(that);

        that.menu.addEventListener('itemClick', that.menu.itemClick);
        that.menu.addEventListener('keydown', that._keyDownHandler.bind(that));
    }

    _getFilterType(column) {
        const dataType = column.dataType.endsWith('?') ? column.dataType.substring(0, column.dataType.length - 1) : column.dataType;

        let filterType = 'string';

        switch (dataType) {
            case 'number':
            case 'int':
            case 'float':
            case 'int64':
                filterType = 'numeric';
                break;
            case 'bool':
            case 'boolean':
                filterType = 'bool';
                break;
            case 'date':
            case 'time':
            case 'datetime':
                filterType = 'date';
                break;
            case 'any':
                filterType = 'any';
                break;
        }

        return filterType;
    }

    _createFilterPanel(column) {
        const that = this;

        if (!JQX.FilterPanel) {
            return;
        }

        if (that.filtering.enabled && that.filtering.filterMenu.visible && column.allowFilter) {
            const filterType = that._getFilterType(column);

            if (that._filterPanel) {
                that._filterPanel.parentNode.removeChild(that._filterPanel);
            }

            that._filterPanel = that._filterPanels[filterType];
            that._filterPanel.dataField = column.dataField;


            if (!that._filterContainer) {
                const filterContainer = document.createElement('div');

                filterContainer.classList.add('jqx-filter-container');
                that._filterContainer = filterContainer;

                requestAnimationFrame(function () {
                    that.menu.appendChild(filterContainer);
                });

                that._applyFilterHandler = function () {
                    that.addFilter(that._filterPanel.dataField, that._filterPanel.getFilter());

                    const column = that.columnByDataField[that._filterPanel.dataField];
                    column._filterState = that._filterPanel.getState();
                };

                that._clearFilterHandler = function () {
                    requestAnimationFrame(() => {
                        that.removeFilter(that._filterPanel.dataField);

                        const column = that.columnByDataField[that._filterPanel.dataField];
                        column._filterState = null;
                    });
                };
            }

            that._filterContainer.appendChild(that._filterPanel);

            that._filterPanel.classList.remove('jqx-hidden');
            that._filterPanel.removeEventListener('filter', that._applyFilterHandler);
            that._filterPanel.removeEventListener('clear', that._clearFilterHandler);

            that._filterPanel.addEventListener('filter', that._applyFilterHandler);
            that._filterPanel.addEventListener('clear', that._clearFilterHandler);


            if (column.filterMenuMode === 'none' || !that.filtering.filterMenu.visible || !JQX.FilterPanel) {
                that._filterContainer.classList.add('jqx-hidden');
            }
            else {
                that._filterContainer.classList.remove('jqx-hidden');
            }

            that._filterPanel.reset();

            if (column._filterState) {
                that._filterPanel.loadState(column._filterState);
            }
            else if (column.filter) {
                const columnFilterGroup = column.filter;
                const filterType = that._getFilterType(column);
                let filters = columnFilterGroup.getFilters();

                while (filters.length > 0 && filters[0].type === 'FilterGroup') {
                    filters = filters[0].value;
                }

                const conditions = columnFilterGroup.getConditions(filterType);

                const firstFilterComparison = filters.length > 0 ? conditions.indexOf(filters[0].condition) : -1;
                const secondFilterComparison = filters.length > 1 ? conditions.indexOf(filters[1].condition) : -1;
                const firstFilterValue = filters.length > 0 ? filters[0].value : '';
                const secondFilterValue = filters.length > 1 ? filters[1].value : '';
                const logicalOperator = filters.length > 1 ? ['and', 'or'].indexOf(filters[1].logicalOperator) : 0;

                column._filterState = {
                    firstFilterComparison: firstFilterComparison,
                    firstFilterValue: firstFilterValue,
                    logicalOperator: logicalOperator,
                    secondFilterComparison: secondFilterComparison,
                    secondFilterValue: secondFilterValue
                };

                that._filterPanel.loadState(column._filterState);

            }
        }
        else if (that._filterPanel) {
            that._filterPanel.parentNode.removeChild(that._filterPanel);
            column._filterState = null;
        }
    }

    hasColumnMenu(column) {
        const that = this;

        const dataSource = column.menuItems || that.columnMenu.dataSource;

        let hiddenMenuItemsCount = 0;
        let length = 0;

        for (let item in dataSource) {
            const properties = dataSource[item];

            length++;

            if (properties.visible === false) {
                hiddenMenuItemsCount++;
            }
            else if (properties.visible === 'auto') {
                if (item === 'columnMenuItemFilter' || item === 'columnMenuItemRemoveFilter') {
                    if (that.filtering.filterMenu.visible || that.filtering.filterBuilder.visible) {
                        hiddenMenuItemsCount++;
                    }
                }

                if (item === 'columnMenuItemGroupBy' || item === 'columnMenuItemRemoveGroupBy') {
                    if (!column.allowGroup || !that.grouping.enabled) {
                        hiddenMenuItemsCount++;
                    }
                }

                if (item === 'columnMenuItemFilter' && !column.allowFilter) {
                    hiddenMenuItemsCount++;
                }

                if (item === 'columnMenuItemRemoveFilter' && !column.allowFilter) {
                    hiddenMenuItemsCount++;
                }

                if (item === 'columnMenuItemGroupBy' && !column.allowGroup) {
                    hiddenMenuItemsCount++;
                }

                if (item === 'columnMenuItemSortAsc' ||
                    item === 'columnMenuItemSortDesc' ||
                    item === 'columnMenuItemRemoveSort') {

                    if (!column.allowSort || !that.sorting.enabled) {
                        hiddenMenuItemsCount++;
                    }
                }
            }
        }

        const hasFilter = that.filtering.enabled && that.filtering.filterMenu.visible && column.filterMenuMode !== 'none';

        if ((!hasFilter || !JQX.FilterPanel) && (!JQX.Menu || hiddenMenuItemsCount >= length)) {
            return false;
        }

        return true;
    }

    _filterMenuItemsVisibility(column) {
        const that = this;
        const menuItems = that.menu.querySelectorAll('jqx-menu-item');
        const dataSource = column.menuItems || that.columnMenu.dataSource;
        let index = 0;
        for (let item in dataSource) {
            const menuItem = menuItems[index++];
            const properties = dataSource[item];

            menuItem.disabled = !properties.enabled;
            menuItem.classList.remove('jqx-hidden');

            if (item === 'columnMenuItemRemoveSort') {
                if (column.sortOrder) {
                    menuItem.disabled = false;
                }
                else {
                    menuItem.disabled = true;
                }
            }

            if (item === 'columnMenuItemSortAsc' && column.sortOrder === 'asc') {
                menuItem.disabled = true;
            }
            else if (item === 'columnMenuItemSortDesc' && column.sortOrder === 'desc') {
                menuItem.disabled = true;
            }

            if (properties.visible === true) {
                menuItem.classList.remove('jqx-hidden');
            }
            else if (properties.visible === false) {
                menuItem.classList.add('jqx-hidden');
            }
            else if (properties.visible === 'auto') {
                if (item === 'columnMenuItemFilter' || item === 'columnMenuItemRemoveFilter') {
                    if (that.filtering.enabled === false) {
                        menuItem.classList.add('jqx-hidden');
                    }
                    else {
                        if (that.filtering.filterMenu.visible || that.filtering.filterBuilder.visible) {
                            menuItem.classList.add('jqx-hidden');
                        }
                        else if (that.filtering.filterBuilder.visible) {
                            menuItem.classList.remove('jqx-hidden');
                        }
                    }
                }

                if (item === 'columnMenuItemGroupBy') {
                    if (that.grouping.enabled && column.allowGroup) {
                        menuItem.classList.remove('jqx-hidden');
                    }
                    else {
                        menuItem.classList.add('jqx-hidden');
                    }

                    const groupIndex = that.dataSource.groupBy.indexOf(column.dataField);

                    if (groupIndex >= 0) {
                        menuItem.disabled = true;
                    }
                    else {
                        menuItem.disabled = false;
                    }
                }

                if (item === 'columnMenuItemRemoveGroupBy') {
                    if (that.grouping.enabled && column.allowGroup) {
                        menuItem.classList.remove('jqx-hidden');
                    }
                    else {
                        menuItem.classList.add('jqx-hidden');
                    }

                    const groupIndex = that.dataSource.groupBy.indexOf(column.dataField);

                    if (groupIndex < 0) {
                        menuItem.disabled = true;
                    }
                    else {
                        menuItem.disabled = false;
                    }
                }

                if (item === 'columnMenuItemFilter' && !column.allowFilter) {
                    menuItem.classList.add('jqx-hidden');
                }

                if (item === 'columnMenuItemRemoveFilter' && !column.allowFilter) {
                    menuItem.classList.add('jqx-hidden');
                }

                if (item === 'columnMenuItemSortAsc' ||
                    item === 'columnMenuItemSortDesc' ||
                    item === 'columnMenuItemRemoveSort') {

                    if (column.allowSort && that.sorting.enabled) {
                        menuItem.classList.remove('jqx-hidden');
                    }
                    else {
                        menuItem.classList.add('jqx-hidden');
                    }
                }
            }
        }
    }

    hasMenu() {
        const that = this;

        if (that.menu && that.menu.column) {
            if (that.menu.parentNode) {
                return true;
            }
        }

        return false;
    }

    closeMenu() {
        const that = this;

        if (that.menu && that.menu.column) {
            if (that.menu.column) {
                that.menu.column.setProperty('menu', null);
                that.menu.column = null;
            }

            if (that.menu.parentNode) {
                that.menu.classList.remove('open');

                if (!that.appearance.allowColumnMenuAnimation) {
                    that.menu.parentNode.removeChild(that.menu);
                }
            }

            that.menu.removeEventListener('keydown', that._keyDownHandler.bind(that));
            that.menu.removeEventListener('itemClick', that.menu.itemClick);
            that.menu.removeEventListener('itemCheckChange', that.menu.itemCheckChange);

            that.focus();
        }
    }
});

JQX.Utilities.Assign('Grid.Filter', class Filter {
    addFilter(dataField, filter, refreshFilters) {
        const that = this;
        const column = that.columnByDataField[dataField];

        if (column && column.canNotify) {
            column.setProperty('filter', filter);

            if (refreshFilters !== false) {
                that.refreshFilters();
            }
        }
    }

    removeFilter(dataField, refreshFilters) {
        const that = this;
        const column = that.columnByDataField[dataField];

        if (column && column.canNotify) {
            column.setProperty('filter', null);

            if (refreshFilters !== false) {
                that.refreshFilters();
            }
        }
    }

    clearFilter() {
        const that = this;

        for (let i = 0; i < that.columns.length; i++) {
            const column = that.columns[i];

            column.setProperty('filter', null);
        }

        that.refreshFilters();
    }

    getFilteredColumns() {
        const that = this;

        if (that._filters) {
            const columns = [];

            for (let i = 0; i < that._filters.length; i++) {
                const filter = that._filters[i];

                columns[filter[0]] = filter[1];

                columns.length++;
            }

            return columns;
        }

        return [];
    }

    getVisibleRows() {
        const that = this;

        if (that._visibleRows) {
            return that._visibleRows;
        }

        const visibleRows = [];
        const viewRows = that._viewRows;
        const offset = that.editing.addNewRow.visible && that.editing.addNewRow.position !== 'far' ? 1 : 0;

        for (let i = 0; i < viewRows.length; i++) {
            const row = viewRows[i];

            row.canNotify = false;
            row.visibleIndex = -1;

            if (row.visible && (row.filtered !== false || row.filtered === undefined)) {
                row.visibleIndex = visibleRows.length - offset;
                visibleRows.push(row);
            }

            row.canNotify = true;
        }

        that._visibleRows = visibleRows;

        return visibleRows;
    }

    refreshFilters() {
        const that = this;

        const filters = [];
        //const viewRows = that._viewRows;

        for (let i = 0; i < that.columns.length; i++) {
            const column = that.columns[i];

            if (column.filter) {
                filters.push([column.dataField, column.filter]);
            }
        }

        that.scrollTop = 0;
        that.closeMenu();

        if (that.dataSource && !that.dataSource.onFilter) {
            that.dataSource.onFilter = function () {
                const viewRows = that._viewRows;

                for (let i = 0; i < viewRows.length; i++) {
                    const row = viewRows[i];

                    if (row.data && !row.addNewRow) {
                        row.filtered = row.data.$.filtered !== undefined ? row.data.$.filtered : true;
                    }
                }

                that.refresh();
            }
        }

        that._filters = filters;
        that._visibleRows = null;

        if (that.dataSource && that.dataSource.virtualDataSource) {
            that.closeMenu();
            that._virtualDataRequest('filter');
        }
        else {
            that.dataSource._filter(filters);
        }

        if (that.paging.enabled && that.dataSource && !that.dataSource.virtualDataSource) {
            that._refreshPagesCount();
        }

        that.$.fireEvent('filter', {
            'data': that.getFilteredColumns()
        });
    }
});

JQX.Utilities.Assign('Grid.Sort', class Sort {
    clearSort() {
        const that = this;

        if (that._isSorting) {
            return;
        }

        that._isSorting = true;

        that.dataSource.clearSort();

        for (let i = 0; i < that._sortedColumns.length; i++) {
            const sortColumn = that._sortedColumns[i];
            const column = that.columnByDataField[sortColumn.dataField];

            column.setProperty('sortOrder', null);
            column.setProperty('sortIndex', null);
        }

        that._sortedColumns = [];

        for (let i = 0; i < that.dataSource.length; i++) {
            const row = that.rows[i];
            const data = that.dataSource[i];

            row.data = data;
            row.boundIndex = data.boundIndex;
        }

        that._recycle();

        that._isSorting = false;
    }

    getSortedColumns() {
        const that = this;
        const sortedColumns = [];

        if (that._sortedColumns) {
            for (let i = 0; i < that._sortedColumns.length; i++) {
                const sortColumn = that._sortedColumns[i];

                sortedColumns[sortColumn.dataField] = { sortOrder: sortColumn.sortOrder, sortIndex: sortColumn.sortIndex };
                sortedColumns.length++;
            }
        }

        return sortedColumns;
    }

    addSort(dataField, sortOrder) {
        const that = this;

        that.sortBy(dataField, sortOrder);
    }

    removeSort(dataField) {
        const that = this;

        that.sortBy(dataField, null);
    }

    sortBy(columnDataField, sortOrder) {
        const that = this;
        const column = that.columnByDataField[columnDataField];
        const sortDataFields = [];
        const sortOrders = [];
        const sortDataTypes = [];
        const toggleSort = sortOrder === undefined ? true : false;

        if (that._isSorting || !column) {
            return;
        }

        that._isSorting = true;

        if (undefined === sortOrder) {
            sortOrder = 'asc';
        }

        const clearSortColumn = function (column) {
            column.setProperty('sortOrder', null);
        }

        const clearSortColumns = function () {
            if (that._sortedColumns.length > 0) {
                for (let i = 0; i < that._sortedColumns.length; i++) {
                    const sortColumn = that._sortedColumns[i];
                    const column = that.columnByDataField[sortColumn.dataField];

                    clearSortColumn(column);
                }
            }

            that._sortedColumns = [];
        }

        if (column === null) {
            clearSortColumns();
            that._isSorting = false;
            return;
        }

        if (!that.sorting.enabled || !that.dataSource || !column.allowSort || that._sortAnimation) {
            that._isSorting = false;
            return;
        }


        clearSortColumn(column);

        if (!that._sortedColumns) {
            that._sortedColumns = [];
        }

        let dataType = 'string';

        for (let i = 0; i < that.dataSource.dataFields.length; i++) {
            const field = that.dataSource.dataFields[i];

            if (field.name === columnDataField) {
                dataType = field.dataType;
                break;
            }
        }

        let addNewSortColumn = true;

        for (let i = 0; i < that._sortedColumns.length; i++) {
            const sortColumn = that._sortedColumns[i];

            if (sortColumn.dataField === columnDataField) {
                addNewSortColumn = false;

                sortColumn.sortIndex = column.sortIndex;

                if (toggleSort) {
                    if (sortColumn.sortOrder === 'asc') {
                        sortColumn.sortOrder = 'desc';
                        sortOrder = 'desc';
                    }
                    else if (sortColumn.sortOrder === 'desc') {
                        if (that.sorting.sortToggleThreeStates) {
                            that._sortedColumns.splice(i, 1);
                            clearSortColumn(column);
                            sortOrder = null;
                        }
                        else {
                            sortColumn.sortOrder = 'asc';
                            sortOrder = 'asc';
                        }
                        break;
                    }
                }
                else {
                    sortColumn.sortOrder = sortOrder;

                    if (sortOrder === null) {
                        that._sortedColumns.splice(i, 1);
                        clearSortColumn(column);
                    }
                }
            }
        }

        if (addNewSortColumn) {
            if (that.sorting.mode === 'one') {
                clearSortColumns();
            }

            if (sortOrder !== null) {
                that._sortedColumns.push({ dataField: columnDataField, sortOrder: sortOrder, sortIndex: column.sortIndex, dataType: dataType });
            }
        }

        column.setProperty('sortOrder', sortOrder);

        that._sortedColumns.sort((a, b) => {
            if (typeof a.sortIndex === 'string' && typeof b.sortIndex === 'string') {
                return 0;
            }

            if (typeof a.sortIndex === 'number' && typeof b.sortIndex === 'string') {
                return -1;
            }

            if (typeof a.sortIndex === 'string' && typeof b.sortIndex === 'number') {
                return 1;
            }

            if (typeof a.sortIndex === 'number' && typeof b.sortIndex === 'number') {
                return a.sortIndex - b.sortIndex;
            }
        });

        for (let i = 0; i < that._sortedColumns.length; i++) {
            const sortColumn = that._sortedColumns[i];

            sortDataFields.push(sortColumn.dataField);
            sortOrders.push(sortColumn.sortOrder);
            sortDataTypes.push(sortColumn.dataType);
        }

        const sort = function () {
            if (that.dataSource && that.dataSource.virtualDataSource) {
                that._virtualDataRequest('sort');
            }
            else {
                that.dataSource.sortBy(sortDataFields, sortDataTypes, sortOrders);

                if (that.dataSource.boundHierarchy) {
                    that._refreshRowHierarchy();
                }
                else {
                    for (let i = 0; i < that.dataSource.length; i++) {
                        const row = that.rows[i];
                        const data = that.dataSource[i];

                        row.data = data;
                        row.boundIndex = data.boundIndex;
                    }
                }

                that._recycle();
            }

            that.$.fireEvent('sort', {
                'data': that.getSortedColumns()
            });
        }

        if (that.appearance.allowSortAnimation) {
            let positions = [];
            let takenPositions = [];

            that.rows.canNotify = false;
            that._sortAnimation = true;

            const refreshRows = function () {
                for (let i = 0; i < that._rowElements.length; i++) {
                    const rowElement = that._rowElements[i];

                    rowElement.classList.remove('jqx-grid-sort-animation');
                    that.removeTransformMoveStyle(rowElement);

                    if (rowElement.offsetHeight > 0) {
                        positions.push(rowElement.offsetTop);
                    }
                }
            }

            refreshRows();

            that._sortTimer = setTimeout(function () {
                refreshRows();
                that._sortAnimation = false;
                that.rows.canNotify = true;
            }, that.appearance.sortAnimationDuration);

            that._sortTimer2 = setTimeout(function () {
                sort();
            }, that.appearance.sortAnimationDuration / 2);

            for (let i = 0; i < positions.length; i++) {
                const rowElement = that._rowElements[i];

                rowElement.classList.remove('jqx-grid-sort-animation');

                that.removeTransformMoveStyle(rowElement);
                let randomIndex = Math.floor((Math.random() * positions.length - 1) + 1);

                while (takenPositions[randomIndex]) {
                    randomIndex = Math.floor((Math.random() * positions.length - 1) + 1);
                }

                takenPositions[randomIndex] = true;

                that.addTransformMoveStyle(rowElement, '0ms', 0, -rowElement.offsetTop + positions[randomIndex], 0, 0.5);
                rowElement.classList.add('jqx-grid-sort-animation');

                setTimeout(function () {
                    that.addTransformMoveStyle(rowElement, that.appearance.sortAnimationDuration + 'ms', 0, 0, 0, 1);
                });

                setTimeout(function () {
                    rowElement.classList.remove('jqx-grid-sort-animation');
                }, that.appearance.sortAnimationDuration);
            }
        }
        else {
            sort();
        }

        that._isSorting = false;
    }
});

JQX('jqx-grid', class Grid extends JQX.ScrollViewer {
    // Grid's properties.
    /*

    */
    static get properties() {
        return {
            //When the adaptivityMode property is set to responsiveLayout, 
            //the grid automatically hides columns one by one when the browser window is resized  
            //When a grid has hidden columns, an ellipsis button is displayed for every row. 
            //Clicking this button expands an adaptive detail row containing the hidden data.

            //When the adaptivityMode property is set to adaptiveLayout, 
            //the grid automatically switches its layout at certain point.
            'adaptivityMode': {
                value: {
                    'responsiveLayout': {
                        value: {
                            'enabled': {
                                value: false,
                                type: 'boolean'
                            },
                            'autoShowHiddenCells': {
                                value: true,
                                type: 'boolean'
                            },
                            'width': {
                                value: 900,
                                type: 'number'
                            }
                        },
                        type: 'object'
                    },
                    'adaptiveLayout': {
                        value: {
                            'enabled': {
                                value: false,
                                type: 'boolean'
                            },
                            'width': {
                                value: 450,
                                type: 'number'
                            }
                        },
                        type: 'object'
                    }
                },
                type: 'object'
            },
            'allowColumnReorder': {
                value: false,
                type: 'boolean'
            },
            'allowRowReorder': {
                value: false,
                type: 'boolean'
            },
            // context menu option.
            'allowColumnFixing': {
                value: false,
                type: 'boolean'
            },
            'appearance': {
                value: {
                    'alternationStart': {
                        value: 0,
                        type: 'int'
                    },
                    'alternationEnd': {
                        value: 0,
                        type: 'int'
                    },
                    'alternationCount': {
                        value: 0,
                        type: 'int'
                    },
                    'allowHover': {
                        value: false,
                        type: 'boolean',
                        defaultReflectToAttribute: true
                    },
                    'allowHeaderHover': {
                        value: true,
                        type: 'boolean',
                        defaultReflectToAttribute: true
                    },
                    'allowRowToggleAnimation': {
                        value: false,
                        type: 'boolean'
                    },
                    'allowRowDetailToggleAnimation': {
                        value: false,
                        type: 'boolean'
                    },
                    'allowSortAnimation': {
                        value: false,
                        type: 'boolean'
                    },
                    'allowColumnLabelAnimation': {
                        value: true,
                        type: 'boolean'
                    },
                    'allowCheckBoxesSelectionAnimation': {
                        value: true,
                        type: 'boolean'
                    },
                    'allowColumnMenuAnimation': {
                        value: true,
                        type: 'boolean'
                    },
                    'allowColumnSortButtonAnimation': {
                        value: true,
                        type: 'boolean'
                    },
                    'allowColumnActionButtonAnimation': {
                        value: true,
                        type: 'boolean'
                    },
                    'allowColumnFilterButtonAnimation': {
                        value: true,
                        type: 'boolean'
                    },
                    'allowColumnStickyPosition': {
                        value: false,
                        type: 'boolean'
                    },
                    'autoShowColumnSortButton': {
                        value: true,
                        type: 'boolean'
                    },
                    'autoShowColumnActionButton': {
                        value: true,
                        type: 'boolean'
                    },
                    'autoShowColumnFilterButton': {
                        value: true,
                        type: 'boolean'
                    },
                    'sortAnimationDuration': {
                        value: 500,
                        type: 'number'
                    },
                    'showRowHeader': {
                        value: false,
                        type: 'boolean'
                    },
                    'showRowNumber': {
                        value: false,
                        type: 'boolean'
                    },
                    'showColumnHeaderLines': {
                        value: true,
                        type: 'boolean',
                        defaultReflectToAttribute: true
                    },
                    'showColumnLines': {
                        value: true,
                        type: 'boolean',
                        defaultReflectToAttribute: true
                    },
                    'showRowLines': {
                        value: true,
                        type: 'boolean',
                        defaultReflectToAttribute: true
                    },
                    'showFilterColumnBackground': {
                        value: true,
                        type: 'boolean'
                    },
                    'showSortColumnBackground': {
                        value: true,
                        type: 'boolean'
                    },
                    'showFrozenColumnBackground': {
                        value: true,
                        type: 'boolean'
                    },
                    'showFrozenRowBackground': {
                        value: true,
                        type: 'boolean'
                    },
                    'showColumnSortButton': {
                        value: true,
                        type: 'boolean'
                    },
                    'showColumnFilterButton': {
                        value: true,
                        type: 'boolean'
                    },
                    'showColumnDescriptionButton': {
                        value: false,
                        type: 'boolean'
                    },
                    'showColumnIcon': {
                        value: false,
                        type: 'boolean'
                    },
                    'showColumnCustomButton': {
                        value: false,
                        type: 'boolean'
                    },
                    'showColumnActionButton': {
                        value: true,
                        type: 'boolean'
                    },
                    'showTooltips': {
                        value: false,
                        type: 'boolean'
                    },
                    'showResizeTooltips': {
                        value: true,
                        type: 'boolean'
                    },
                    'showHorizontalScrollBarOnFixedColumns': {
                        value: false,
                        type: 'boolean'
                    },
                    'showVerticalScrollBarOnFixedColumns': {
                        value: false,
                        type: 'boolean'
                    }
                },
                type: 'object'
            },
            'dataExport': {
                value: {
                    'header': {
                        value: true,
                        type: 'boolean'
                    },
                    'filterBy': {
                        value: null,
                        type: 'object',
                    },
                    'groupBy': {
                        value: null,
                        type: 'object',
                    },
                    'style': {
                        value: null,
                        type: 'object'
                    },
                    'fileName': {
                        value: 'jqxGrid',
                        type: 'string'
                    },
                    'pageOrientation': {
                        value: 'portrait',
                        type: 'string'
                    },
                    'expandChar': {
                        value: '+',
                        type: 'string'
                    },
                    'collapseChar': {
                        value: '-',
                        type: 'string'
                    }
                },
                type: 'object'
            },
            'clipboard': {
                value: {
                    'enabled': {
                        value: true,
                        type: 'boolean'
                    },
                    'autoFillMode': {
                        value: 'copy',
                        allowedValues: ['none', 'copy', 'fillSeries'],
                        type: 'string'
                    },
                    'onPasteValue': {
                        value: null,
                        type: 'any'
                    }
                },
                type: 'object'
            },
            'columns': {
                value: [],
                type: 'any',
                reflectToAttribute: false
            },
            'columnWidth': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'columnChooser': {
                value: {
                    'allowSearch': {
                        value: false,
                        type: 'boolean'
                    },
                    'visible': {
                        value: false,
                        type: 'boolean'
                    },
                    'label': {
                        value: 'Column Chooser',
                        type: 'string'
                    },
                    'mode': {
                        value: 'dragAndDrop',
                        type: 'string',
                        allowedValues: ['select', 'dragAndDrop']
                    },
                    'placeholder': {
                        value: 'Drag a column here to hide it',
                        type: 'string'
                    },
                    'width': {
                        value: 250,
                        type: 'number'
                    },
                    'height': {
                        value: 200,
                        type: 'number'
                    }
                },
                type: 'object'
            },
            'columnMenu': {
                value: {
                    'autoClose': {
                        value: true,
                        type: 'boolean'
                    },
                    'dataSource': {
                        value: {
                            'columnMenuCustomizeType': { command: 'customizeTypeCommand', enabled: true, visible: false, icon: 'jqx-icon-customize', label: '{{messages}}' },
                            'columnMenuItemRename': { command: 'renameCommand', enabled: true, visible: false, icon: 'jqx-icon-rename', label: '{{messages}}' },
                            'columnMenuItemEditDescription': { command: 'editDescriptionCommand', enabled: true, visible: false, icon: 'jqx-icon-info-circled', label: '{{messages}}' },
                            'columnMenuItemDuplicate': { command: 'duplicateCommand', visible: false, enabled: true, icon: 'jqx-icon-duplicate', label: '{{messages}}' },
                            'columnMenuItemInsertLeft': { command: 'insertLeftCommand', visible: false, enabled: true, icon: 'jqx-icon-insert-left', label: '{{messages}}' },
                            'columnMenuItemInsertRight': { command: 'insertRightCommand', visible: false, enabled: true, icon: 'jqx-icon-insert-right', label: '{{messages}}' },
                            'columnMenuItemSortAsc': { command: 'sortAscCommand', visible: 'auto', enabled: true, iconAlt: 'jqx-icon-sort-number-up', icon: 'jqx-icon-sort-name-up', label: '{{messages}}' },
                            'columnMenuItemSortDesc': { command: 'sortDescCommand', visible: 'auto', enabled: true, iconAlt: 'jqx-icon-sort-number-down', icon: 'jqx-icon-sort-name-down', label: '{{messages}}' },
                            'columnMenuItemRemoveSort': { command: 'removeSortCommand', visible: 'auto', enabled: true, icon: 'jqx-icon-cancel-circled', label: '{{messages}}' },
                            'columnMenuItemFilter': { command: 'addFilterCommand', visible: 'auto', enabled: true, icon: 'jqx-icon-add-filter', label: '{{messages}}' },
                            'columnMenuItemRemoveFilter': { command: 'removeFilterCommand', enabled: true, visible: 'auto', icon: 'jqx-icon-cancel-circled-outline', label: '{{messages}}' },
                            'columnMenuItemGroupBy': { command: 'groupByCommand', enabled: true, visible: 'auto', icon: 'jqx-icon-object-group', label: '{{messages}}' },
                            'columnMenuItemRemoveGroupBy': { command: 'removeGroupByCommand', visible: 'auto', enabled: true, icon: 'jqx-icon-object-ungroup', label: '{{messages}}' },
                            'columnMenuItemHide': { command: 'hideColumnCommand', enabled: true, visible: false, icon: 'jqx-icon-hide', label: '{{messages}}' },
                            'columnMenuItemDelete': { command: 'deleteColumnCommand', enabled: true, visible: false, icon: 'jqx-icon-delete', label: '{{messages}}' }
                        },
                        type: 'object'
                    },
                    'visible': {
                        value: false,
                        type: 'boolean'
                    },
                    'width': {
                        value: 250,
                        type: 'number'
                    },
                    'height': {
                        value: null,
                        type: 'number?'
                    }
                },
                type: 'object'
            },
            'columnGroups': {
                value: [],
                type: 'array',
                reflectToAttribute: false
            },
            'columnHeight': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'columnMinHeight': {
                value: 30,
                type: 'any',
                reflectToAttribute: false
            },
            'columnResizeMode': {
                value: 'none',
                type: 'string',
                allowedValues: ['none', 'split', 'growAndShrink']
            },
            'dataSource': {
                value: null,
                type: 'object',
                reflectToAttribute: false
            },
            'displayLoadingIndicator': {
                value: false,
                type: 'boolean'
            },
            'grouping': {
                value: {
                    'enabled': {
                        value: false,
                        type: 'boolean',
                        reflectToAttribute: false
                    },
                    'allowCollapse': {
                        value: false,
                        type: 'boolean',
                        reflectToAttribute: false
                    },
                    'autoExpandAll': {
                        value: false,
                        type: 'boolean',
                        reflectToAttribute: false
                    },
                    'expandMode': {
                        value: 'buttonClick',
                        type: 'string',
                        allowedValues: ['buttonClick', 'rowClick'],
                        reflectToAttribute: false
                    },
                    'groupRowHeight': {
                        value: 50,
                        type: 'any',
                        reflectToAttribute: false
                    },
                    'toggleButtonIndent': {
                        value: 16,
                        type: 'number',
                        reflectToAttribute: false
                    },
                    'groupIndent': {
                        value: 16,
                        type: 'number',
                        reflectToAttribute: false
                    },
                    'groupBar': {
                        value: {
                            'visible': {
                                value: false,
                                type: 'boolean',
                                reflectToAttribute: false
                            },
                            'allowColumnDragDrop': {
                                value: false,
                                type: 'boolean',
                                reflectToAttribute: false
                            },
                            'allowColumnCloseButtons': {
                                value: true,
                                type: 'boolean',
                                reflectToAttribute: false
                            }
                        },
                        type: 'object'
                    },
                    'groupPanel': {
                        value: {
                            'visible': {
                                value: false,
                                type: 'boolean',
                                reflectToAttribute: false
                            }
                        },
                        type: 'object'
                    },
                    'summaryRow': {
                        value: {
                            'inline': {
                                value: true,
                                type: 'boolean'
                            },
                            'visible': {
                                value: true,
                                type: 'boolean'
                            }
                        },
                        type: 'object'
                    }
                },
                type: 'object'
            },
            'messages': {
                extend: true,
                value: {
                    'en': {
                        'invalidColumnProperty': '{{elementType}}: Invalid property name "{{propertyName}}" set for Column: "{{type}}"',
                        'invalidRowProperty': '{{elementType}}: Invalid property name "{{propertyName}}" set for Row"',
                        'frozenColumns': '{{elementType}}: To Pin/Freeze a column group, all columns within it should be frozen.',
                        'frozenRows': '{{elementType}}: To Pin/Freeze a special cell, all rows within it should be frozen.',
                        'columnGroups': '{{elementType}}: Please, check the initialization of the jqxGrid\'s columns array. The columns in a column group are expected to be siblings in the columns array.',
                        'min': 'Min: {{value}}',
                        'max': 'Max: {{value}} ',
                        'sum': 'Sum: {{value}} ',
                        'avg': 'Avg: {{value}} ',
                        'count': 'Count: {{value}} ',
                        'pagerFirstButton': 'First',
                        'pagerLastButton': 'Last',
                        'pagerPreviousButton': 'Previous',
                        'pagerNextButton': 'Next',
                        'pagerNavigateToLabel': 'Go to:',
                        'pagerPageSizeLabel': 'Show:',
                        'pagerNavigateToInputPlaceholder': '',
                        'pagerEllipsis': '...',
                        'pagerSummaryString': 'of',
                        'pagerSummaryPrefix': 'of',
                        'pagerSummarySuffix': '',
                        'columnMenuCustomizeType': 'Customize type',
                        'columnMenuItemRename': 'Rename',
                        'columnMenuItemEditDescription': 'Edit description',
                        'columnMenuItemDuplicate': 'Duplicate',
                        'columnMenuItemInsertLeft': 'Insert left',
                        'columnMenuItemInsertRight': 'Insert right',
                        'columnMenuItemSortAsc': 'Sort {{mode}}',
                        'columnMenuItemSortDesc': 'Sort {{mode}}', //Sort A  Z
                        'columnMenuItemRemoveSort': 'Remove Sort',
                        'columnMenuItemFilter': 'Filter',
                        'columnMenuItemRemoveFilter': 'Remove Filter',
                        'columnMenuItemGroupBy': 'Group by this column',
                        'columnMenuItemRemoveGroupBy': 'Remove Group',
                        'columnMenuItemHide': 'Hide',
                        'columnMenuItemDelete': 'Delete',
                        'commandBarAddRow': 'Add',
                        'commandBarDeleteRow': 'Delete',
                        'commandBarBatchRevert': 'Revert',
                        'commandBarBatchSave': 'Save',
                        'commandColumnEdit': 'Edit',
                        'commandColumnDelete': 'Delete',
                        'commandColumnCancel': 'Cancel',
                        'commandColumnUpdate': 'Update',
                        'commandColumnMenu': '',
                        'addNewRow': 'Click here to add a new row',
                        'dialogEditHeader': 'Edit {{value}}',
                        'dialogAddButtonConfirm': 'ADD',
                        'dialogAddButtonCancel': 'CANCEL',
                        'dialogEditButtonConfirm': 'OK',
                        'dialogEditButtonCancel': 'CANCEL',
                        'dialogDeleteButtonConfirm': 'DELETE',
                        'dialogDeleteButtonCancel': 'CANCEL',
                        'dialogAddHeader': 'Add Row',
                        'dialogDeleteHeader': 'Delete Row',
                        'dialogDeleteContent': 'Are you sure you want to delete this row?'
                    }
                },
                type: 'object'
            },
            'onCellValue': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'onBeforeInit': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'onInit': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'onKey': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'onRender': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'onRowInit': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'onRowDetailInit': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'onRowDetailUpdated': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'onRowInserted': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'onRowRemoved': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'onRowUpdated': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'onColumnInit': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'onColumnInserted': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'onColumnRemoved': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'onColumnUpdated': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'onCommand': {
                value: null,
                reflectToAttribute: false,
                type: 'any'
            },
            'filtering': {
                value: {
                    'enabled': {
                        value: false,
                        type: 'boolean'
                    },
                    'filter': {
                        value: [],
                        type: 'array',
                        reflectToAttribute: false
                    },
                    'filterRow': {
                        value: {
                            'visible': {
                                value: false,
                                type: 'boolean'
                            },
                            'menuVisible': {
                                value: false,
                                type: 'boolean'
                            },
                            'applyMode': {
                                value: 'auto',
                                type: 'string',
                                allowedValues: ['auto', 'click']
                            },
                            'autoApplyModeDelay': {
                                value: 300,
                                type: 'number'
                            }
                        },
                        type: 'object'
                    },
                    'filterMenu': {
                        value: {
                            'visible': {
                                value: true,
                                type: 'boolean'
                            },
                            'buttons': {
                                value: ['cancel', 'clear', 'filter'],
                                type: 'array'
                            },
                            'dataSource': {
                                value: null,
                                type: 'any'
                            },
                            'width': {
                                value: 250,
                                type: 'number'
                            },
                            'height': {
                                value: 200,
                                type: 'number'
                            }
                        },
                        type: 'object'
                    },
                    'filterBuilder': {
                        value: {
                            'visible': {
                                value: false,
                                type: 'boolean'
                            },
                            'height': {
                                value: null,
                                type: 'number?'
                            }
                        },
                        type: 'object'
                    }
                },
                type: 'object'
            },
            'editing': {
                value: {
                    'active': {
                        value: false,
                        readonly: true,
                        type: 'boolean'
                    },
                    'enabled': {
                        value: false,
                        type: 'boolean'
                    },
                    'batch': {
                        value: false,
                        type: 'any'
                    },
                    'action': {
                        value: 'click',
                        type: 'string',
                        allowedValues: ['none', 'click', 'doubleClick']
                    },
                    'commandKeys': {
                        value: {
                            'commandKeyEdit': {
                                value: {
                                    command: 'commandKeyEditCommand',
                                    key: 'F2'
                                },
                                type: 'object'
                            },
                            'commandKeyCancel': {
                                value: {
                                    command: 'commandKeyCancelCommand',
                                    key: 'Escape'
                                },
                                type: 'object'
                            },
                            'commandKeyUpdate': {
                                value: {
                                    command: 'commandKeyUpdateCommand',
                                    key: 'Enter | Tab'
                                },
                                type: 'object'
                            }
                        },
                        type: 'object'
                    },
                    'commandBar': {
                        value: {
                            'visible': {
                                value: false,
                                type: 'boolean'
                            },
                            'position': {
                                value: 'near',
                                allowedValues: ['near', 'far', 'both'],
                                type: 'string'
                            },
                            'displayMode': {
                                value: 'labelAndIcon',
                                allowedValues: ['label', 'icon', 'labelAndIcon'],
                                type: 'string'
                            },
                            'dataSource': {
                                value: {
                                    'commandBarAddRow':
                                    {
                                        value: {
                                            'command': {
                                                value: 'commandBarAddRowCommand',
                                                type: 'any'
                                            },
                                            'icon': {
                                                value: 'jqx-icon-plus',
                                                type: 'string'
                                            },
                                            'label': {
                                                value: '{{messages}}',
                                                type: 'string'
                                            },
                                            'visible': {
                                                value: false,
                                                type: 'any'
                                            }
                                        },
                                        type: 'object'
                                    },
                                    'commandBarDeleteRow':
                                    {
                                        value: {
                                            'command': {
                                                value: 'commandBarDeleteRowCommand',
                                                type: 'any'
                                            },
                                            'icon': {
                                                value: 'jqx-icon-delete',
                                                type: 'string'
                                            },
                                            'label': {
                                                value: '{{messages}}',
                                                type: 'string'
                                            },
                                            'visible': {
                                                value: false,
                                                type: 'any'
                                            }
                                        },
                                        type: 'object'
                                    },
                                    'commandBarBatchSave':
                                    {
                                        value: {
                                            'command': {
                                                value: 'commandBarBatchSaveCommand',
                                                type: 'any'
                                            },
                                            'icon': {
                                                value: 'jqx-icon-ok-squared',
                                                type: 'string'
                                            },
                                            'label': {
                                                value: '{{messages}}',
                                                type: 'string'
                                            },
                                            'visible': {
                                                value: true,
                                                type: 'any'
                                            }
                                        },
                                        type: 'object'
                                    },
                                    'commandBarBatchRevert':
                                    {
                                        value: {
                                            'command': {
                                                value: 'commandBarBatchRevertCommand',
                                                type: 'any'
                                            },
                                            'icon': {
                                                value: 'jqx-icon-ccw',
                                                type: 'string'
                                            },
                                            'label': {
                                                value: '{{messages}}',
                                                type: 'string'
                                            },
                                            'visible': {
                                                value: true,
                                                type: 'any'
                                            }
                                        },
                                        type: 'object'
                                    }
                                },
                                type: 'object'
                            }
                        },
                        type: 'object'
                    },
                    'commandColumn': {
                        value: {
                            'visible': {
                                value: false,
                                type: 'boolean'
                            },
                            'inline': {
                                value: false,
                                type: 'boolean'
                            },
                            'position': {
                                value: 'far',
                                allowedValues: ['near', 'far'],
                                type: 'string'
                            },
                            'displayMode': {
                                value: 'icon',
                                allowedValues: ['label', 'icon', 'labelAndIcon'],
                                type: 'string'
                            },
                            'dataSource': {
                                value: {
                                    'commandColumnMenu':
                                    {
                                        value: {
                                            'command': {
                                                value: 'commandColumnMenuCommand',
                                                type: 'any'
                                            },
                                            'icon': {
                                                value: 'jqx-icon-menu',
                                                type: 'string'
                                            },
                                            'label': {
                                                value: '{{messages}}',
                                                type: 'string'
                                            },
                                            'visible': {
                                                value: false,
                                                type: 'any'
                                            }
                                        },
                                        type: 'object'
                                    },
                                    'commandColumnEdit':
                                    {
                                        value: {
                                            'command': {
                                                value: 'commandColumnEditCommand',
                                                type: 'any'
                                            },
                                            'icon': {
                                                value: 'jqx-icon-rename',
                                                type: 'string'
                                            },
                                            'label': {
                                                value: '{{messages}}',
                                                type: 'string'
                                            },
                                            'visible': {
                                                value: 'auto',
                                                type: 'any'
                                            }
                                        },
                                        type: 'object'
                                    },
                                    'commandColumnDelete':
                                    {
                                        value: {
                                            'command': {
                                                value: 'commandColumnDeleteCommand',
                                                type: 'any'
                                            },
                                            'icon': {
                                                value: 'jqx-icon-delete',
                                                type: 'string'
                                            },
                                            'label': {
                                                value: '{{messages}}',
                                                type: 'string'
                                            },
                                            'visible': {
                                                value: true,
                                                type: 'any'
                                            }
                                        },
                                        type: 'object'
                                    },
                                    'commandColumnUpdate':
                                    {
                                        value: {
                                            'command': {
                                                value: 'commandColumnUpdateCommand',
                                                type: 'any'
                                            },
                                            'icon': {
                                                value: 'jqx-icon-ok-squared',
                                                type: 'string'
                                            },
                                            'label': {
                                                value: '{{messages}}',
                                                type: 'string'
                                            },
                                            'visible': {
                                                value: 'auto',
                                                type: 'any'
                                            }
                                        },
                                        type: 'object'
                                    },
                                    'commandColumnCancel':
                                    {
                                        value: {
                                            'command': {
                                                value: 'commandColumnCancelCommand',
                                                type: 'any'
                                            },
                                            'icon': {
                                                value: 'jqx-icon-cancel-circled',
                                                type: 'string'
                                            },
                                            'label': {
                                                value: '{{messages}}',
                                                type: 'string'
                                            },
                                            'visible': {
                                                value: 'auto',
                                                type: 'any'
                                            }
                                        },

                                        type: 'object'
                                    },
                                    'commandColumnRowMenu':
                                    {
                                        value: {
                                            'command': {
                                                value: 'commandColumnRowMenuCommand',
                                                type: 'any',
                                                reflectToAttribute: false
                                            },
                                            'icon': {
                                                value: 'jqx-icon-ellipsis-vert',
                                                type: 'string'
                                            },
                                            'label': {
                                                value: '{{messages}}',
                                                type: 'string'
                                            },
                                            'visible': {
                                                value: false,
                                                type: 'any'
                                            }
                                        },
                                        type: 'object'
                                    },
                                    'commandColumnCustom':
                                    {
                                        value: {
                                            'command': {
                                                value: '',
                                                type: 'any'
                                            },
                                            'icon': {
                                                value: 'jqx-icon-ellipsis-vert',
                                                type: 'string'
                                            },
                                            'label': {
                                                value: '',
                                                type: 'string'
                                            },
                                            'visible': {
                                                value: false,
                                                type: 'any'
                                            }
                                        },
                                        type: 'object'
                                    }
                                },
                                type: 'object'
                            },
                            'width': {
                                value: null,
                                type: 'number?'
                            }
                        },
                        reflectToAttribute: false,
                        type: 'object'
                    },
                    'mode': {
                        value: 'cell',
                        allowedValues: ['cell', 'row'],
                        type: 'string'
                    },
                    'addNewRow': {
                        value: {
                            'position': {
                                value: 'both',
                                allowedValues: ['near', 'far', 'both'],
                                type: 'string'
                            },
                            'visible': {
                                value: false,
                                type: 'boolean'
                            },
                            'autoCreate': {
                                value: false,
                                type: 'boolean'
                            },
                            'autoSave': {
                                value: true,
                                type: 'boolean'
                            },
                            'label': {
                                value: '{{message}}',
                                type: 'string'
                            },
                            'displayMode': {
                                value: 'row',
                                allowedValues: ['row', 'button'],
                                type: 'string'
                            }
                        },
                        type: 'object'
                    },
                    'dialog': {
                        value: {
                            'header': {
                                value: '{{message}}',
                                type: 'string'
                            },
                            'height': {
                                value: 'auto',
                                type: 'any'
                            },
                            'width': {
                                value: 'auto',
                                type: 'any'
                            },
                            'left': {
                                value: 'center',
                                type: 'any'
                            },
                            'top': {
                                value: 'center',
                                type: 'any'
                            },
                            'enabled': {
                                value: false,
                                type: 'boolean'
                            },
                            'visible': {
                                value: false,
                                type: 'boolean'
                            }
                        },
                        type: 'object'
                    },
                    'addDialog': {
                        value: {
                            'header': {
                                value: '{{message}}',
                                type: 'string'
                            },
                            'height': {
                                value: 'auto',
                                type: 'any'
                            },
                            'width': {
                                value: 'auto',
                                type: 'any'
                            },
                            'left': {
                                value: 'center',
                                type: 'any'
                            },
                            'top': {
                                value: 'center',
                                type: 'any'
                            },
                            'enabled': {
                                value: false,
                                type: 'boolean'
                            },
                            'visible': {
                                value: false,
                                type: 'boolean'
                            }
                        },
                        type: 'object'
                    },
                    'deleteDialog': {
                        value: {
                            'header': {
                                value: '{{message}}',
                                type: 'string'
                            },
                            'height': {
                                value: 'auto',
                                type: 'any'
                            },
                            'width': {
                                value: 'auto',
                                type: 'any'
                            },
                            'left': {
                                value: 'center',
                                type: 'any'
                            },
                            'top': {
                                value: 'center',
                                type: 'any'
                            },
                            'enabled': {
                                value: false,
                                type: 'boolean'
                            },
                            'visible': {
                                value: false,
                                type: 'boolean'
                            }
                        },
                        type: 'object'
                    }
                },
                type: 'object'
            },
            'loadingIndicatorPlaceholder': {
                value: 'Loading...',
                type: 'string'
            },
            'loadingIndicatorPosition': {
                value: 'center',
                allowedValues: ['bottom', 'center', 'top'],
                type: 'string'
            },
            'paging': {
                value: {
                    'enabled': {
                        value: false,
                        type: 'boolean'
                    },
                    'spinner': {
                        value: {
                            'enabled': {
                                value: false,
                                type: 'boolean'
                            },
                            'step': {
                                value: 1,
                                type: 'number'
                            }
                        },
                        type: 'object'
                    },
                    'pageSize': {
                        value: 10,
                        type: 'int',
                        validator: 'pageSizeValidator'
                    },
                    'pageIndex': {
                        value: 0,
                        type: 'int',
                        validator: 'pageIndexValidator'
                    }
                },
                type: 'object'
            },
            'pager': {
                value: {
                    'autoEllipsis': {
                        value: 'both',
                        allowedValues: ['none', 'before', 'after', 'both'],
                        type: 'string'
                    },
                    'position': {
                        value: 'far',
                        allowedValues: ['near', 'far', 'both'],
                        type: 'string'
                    },
                    'template': {
                        value: '',
                        type: 'string'
                    },
                    'pageSizeSelector': {
                        value: {
                            'visible': {
                                value: false,
                                type: 'boolean'
                            },
                            'dataSource': {
                                value: [10, 20, 50],
                                type: 'object'
                            },
                            'position': {
                                value: 'far',
                                allowedValues: ['near', 'far'],
                                type: 'string'
                            }
                        },
                        type: 'object'
                    },
                    'summary': {
                        value: {
                            'position': {
                                value: 'far',
                                allowedValues: ['near', 'far'],
                                type: 'string'
                            },
                            'visible': {
                                value: false,
                                type: 'boolean'
                            }
                        },
                        type: 'object'
                    },
                    'navigationButtons': {
                        value: {
                            'position': {
                                value: 'both',
                                allowedValues: ['near', 'far', 'both'],
                                type: 'string'
                            },
                            'prevNextButtons': {
                                value: {
                                    'visible': {
                                        value: true,
                                        type: 'boolean'
                                    }
                                },
                                type: 'object'
                            },
                            'firstLastButtons': {
                                value: {
                                    'visible': {
                                        value: true,
                                        type: 'boolean'
                                    }
                                },
                                type: 'object'
                            },
                            'labels': {
                                value: {
                                    'visible': {
                                        value: false,
                                        type: 'boolean'
                                    }
                                },
                                type: 'object'
                            }
                        },
                        type: 'object'
                    },
                    'navigationInput': {
                        value: {
                            'position': {
                                value: 'far',
                                allowedValues: ['near', 'far'],
                                type: 'string'
                            },
                            'visible': {
                                value: false,
                                type: 'boolean'
                            }
                        },
                        type: 'object'
                    },
                    'pageIndexSelectors': {
                        value: {
                            'visible': {
                                value: true,
                                type: 'boolean'
                            },
                            'dataSource': {
                                value: 10,
                                type: 'any'
                            },
                        },
                        type: 'object'
                    },
                    'visible': {
                        value: false,
                        type: 'boolean'
                    }
                },
                type: 'object',
                reflectToAttribute: false
            },
            'placeholder': {
                value: 'No Rows',
                type: 'string'
            },
            'rowDetail': {
                value: {
                    'enabled': {
                        value: false,
                        type: 'boolean'
                    },
                    'height': {
                        value: 200,
                        type: 'number'
                    },
                    'position': {
                        value: 'near',
                        allowedValues: ['near', 'far'],
                        type: 'string'
                    },
                    'template': {
                        value: '',
                        type: 'any',
                        reflectToAttribute: false
                    },
                    'visible': {
                        value: true,
                        type: 'boolean'
                    },
                    'dialog': {
                        value: {
                            'header': {
                                value: '{{message}}',
                                type: 'string'
                            },
                            'height': {
                                value: 'auto',
                                type: 'any'
                            },
                            'width': {
                                value: 'auto',
                                type: 'any'
                            },
                            'left': {
                                value: 'center',
                                type: 'any'
                            },
                            'top': {
                                value: 'center',
                                type: 'any'
                            },
                            'enabled': {
                                value: false,
                                type: 'boolean'
                            },
                            'visible': {
                                value: false,
                                type: 'boolean'
                            }
                        },
                        type: 'object'
                    }
                },
                type: 'object'
            },
            'rowMinHeight': {
                value: 30,
                type: 'number'
            },
            'rowHeight': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'rowResizeMode': {
                value: 'none',
                type: 'string',
                allowedValues: ['none', 'split', 'growAndShrink']
            },
            'summaryRow': {
                value: {
                    'position': {
                        value: 'far',
                        allowedValues: ['near', 'far'],
                        type: 'string'
                    },
                    'visible': {
                        value: false,
                        type: 'boolean'
                    },
                    'template': {
                        value: '',
                        type: 'string'
                    }
                },
                type: 'object'
            },
            'scrollMode': {
                value: 'physical',
                allowedValues: ['physical', 'virtual', 'infinite', 'deferred'],
                type: 'string'
            },
            'columnHeader': {
                value: {
                    'visible': {
                        value: true,
                        type: 'boolean'
                    }
                },
                type: 'object'
            },
            'groupHeader': {
                value: {
                    'visible': {
                        value: false,
                        type: 'boolean'
                    },
                    'template': {
                        value: '',
                        type: 'string'
                    }
                },
                type: 'object'
            },
            'header': {
                value: {
                    'visible': {
                        value: false,
                        type: 'boolean'
                    },
                    'template': {
                        value: '',
                        type: 'string'
                    }
                },
                type: 'object'
            },
            'footer': {
                value: {
                    'visible': {
                        value: false,
                        type: 'boolean'
                    },
                    'template': {
                        value: '',
                        type: 'string'
                    }
                },
                type: 'object'
            },
            'selection': {
                value: {
                    'enabled': {
                        value: false,
                        type: 'boolean'
                    },
                    'allowRowHeaderSelection': {
                        value: false,
                        type: 'boolean'
                    },
                    'allowColumnHeaderSelection': {
                        value: false,
                        type: 'boolean'
                    },
                    'allowRowSelection': {
                        value: true,
                        type: 'boolean'
                    },
                    'allowCellSelection': {
                        value: false,
                        type: 'boolean'
                    },
                    'allowDragSelection': {
                        value: true,
                        type: 'boolean'
                    },
                    'allowDragSelectionAutoScroll': {
                        value: true,
                        type: 'boolean'
                    },
                    'allowCellDragSelectionHandle': {
                        value: true,
                        type: 'boolean'
                    },
                    'allowCellDragDropSelectionHandle': {
                        value: true,
                        type: 'boolean'
                    },
                    'allowCellDragSelectionAutoFill': {
                        value: true,
                        type: 'boolean'
                    },
                    'selectAllMode': {
                        value: 'page',
                        allowedValues: ['none', 'page', 'all'],
                        type: 'string'
                    },
                    'mode': {
                        value: 'many',
                        type: 'string',
                        allowedValues: ['one', 'many', 'extended']
                    },
                    'action': {
                        value: 'click',
                        type: 'string',
                        allowedValues: ['none', 'click', 'doubleClick']
                    },
                    'checkBoxes': {
                        value: {
                            'enabled': {
                                value: false,
                                type: 'boolean'
                            },
                            'autoShow': {
                                value: false,
                                type: 'boolean'
                            },
                            'action': {
                                value: 'click',
                                type: 'string',
                                allowedValues: ['none', 'click', 'doubleClick']
                            },
                            'selectAllMode': {
                                value: 'page',
                                allowedValues: ['none', 'page', 'all'],
                                type: 'string'
                            },

                            'position': {
                                value: 'near',
                                allowedValues: ['near', 'far'],
                                type: 'string'
                            }
                        },
                        type: 'object'
                    },
                    'selected': {
                        value: '',
                        type: 'string'
                    }
                },
                type: 'object'
            },
            'sorting': {
                value: {
                    'enabled': {
                        value: false,
                        type: 'boolean'
                    },
                    'sort': {
                        value: [],
                        type: 'array'
                    },
                    'mode': {
                        value: 'one',
                        allowedValues: ['one', 'many'],
                        type: 'string'
                    },
                    'sortToggleThreeStates': {
                        value: true,
                        type: 'boolean'
                    }
                },
                type: 'object'
            }
        }
    }

    static get requires() {
        return {/*
                'JQX.Button': 'jqxbutton.js',
                'JQX.ScrollBar': 'jqxscrollbar.js',
                'JQX.Menu': 'jqxmenu.js',
                'JQX.Calendar': 'jqxcalendar.js',
                'JQX.TimePicker': 'jqxtimepicker.js',
                'JQX.DateTimePicker': 'jqxdatetimepicker.js',
                'JQX.Tree': 'jqxtree.js',
                'JQX.Utilities.Complex': 'jqxcomplex.js',
                'JQX.Utilities.BigNumber': 'jqxmath.js',
                'JQX.Utilities.NumericProcessor': 'jqxnumeric.js',    
                'JQX.NumericTextBox': 'jqxnumerictextbox.js',    
                'JQX.Pager': 'jqxpager.js',    
                'JQX.ListBox': 'jqxlistbox.js',    
                'JQX.DropDownList': 'jqxdropdownlist.js',    
                'JQX.ComboBox': 'jqxcombobox.js',    
                'JQX.Utilities.DateTime': 'jqxdate.js',    
                'JQX.FilterBuilder': 'jqxfilterbuilder.js',              
                'JQX.FilterPanel': 'jqxfilterpanel.js'      */
        }
    }

    static get styleUrls() {
        return [
            'jqx.grid.css'
        ]
    }

    /** Button's template. */
    template() {
        return `<div class=\'jqx-container\'id=\'container\' disabled=\'[[disabled]]\' role=\'grid\'>
                <div id=\'header\' class=\'jqx-grid-header jqx-hidden\' ></div>
                <div id=\'groupHeader\' class=\'jqx-grid-group-header jqx-hidden\'></div>
                <div id=\'headerPager\' top class=\'jqx-grid-pager jqx-hidden\'></div>
                <div id=\'headerCommandBar\' header top class=\'jqx-grid-header jqx-grid-command-bar jqx-hidden\'></div>
                 <div id=\'content\' class=\'jqx-grid-content\'>
                    <div id=\'placeholder\' class =\'jqx-hidden jqx-placeholder jqx-grid-placeholder\'>[[placeholder]]</div>
                    <div id=\'columnHeader\' class=\'jqx-grid-column-header\'>
                        <div id=\'columnNearContainer\' class=\'near jqx-hidden jqx-grid-column-header-cell-container\'>
                       </div>
                       <div id=\'columnContainer\' class=\'center jqx-grid-column-header-cell-container\'>
                       </div>
                        <div id=\'columnFarContainer\' class=\'far jqx-hidden jqx-grid-column-header-cell-container\'>
                       </div>
                    </div>
                    <div id=\'scrollView' class =\'jqx-grid-scroll-view\'>
                        <div id=\'rowNearContainer\' class=\'near jqx-hidden jqx-grid-row-container\'>
                        </div>
                         <div id=\'rowContainer\' class=\'center jqx-grid-row-container\'>
                        </div>
                        <div id=\'rowFarContainer\' class=\'far jqx-hidden jqx-grid-row-container\'>
                        </div>
                        <jqx-scroll-bar id=\'verticalScrollBar\' class=\'jqx-grid-scroll-bar\' wait disabled=\'[[disabled]]\' orientation=\'vertical\'></jqx-scroll-bar>
                        <jqx-scroll-bar id=\'horizontalScrollBar\' class=\'jqx-grid-scroll-bar\' wait disabled=\'[[disabled]]\'></jqx-scroll-bar>
                    </div>
                  <div id=\'filterFooter\' class=\'jqx-grid-filter-footer jqx-hidden\'></div>
                </div>
                <div id=\'loadingIndicatorContainer\' class=\'jqx-loader-container\'>
                    <span id=\'loadingIndicator\' class=\'jqx-grid-loader jqx-loader\'></span>
                    <span id=\'loadingIndicatorPlaceHolder\' class =\'jqx-loader-label jqx-hidden\'>[[loadingIndicatorPlaceholder]]</span>
                </div>
                <div id=\'footerCommandBar\' footer class=\'jqx-grid-footer jqx-grid-command-bar jqx-hidden\'></div>
                <div id=\'footerPager\' class=\'jqx-grid-pager jqx-hidden\'></div>
                <div id=\'footer\' class=\'jqx-grid-footer jqx-hidden\'></div>
            </div>`;
    }

    /**
        * Grid's event listeners.
        */
    static get listeners() {
        return {
            'focus': '_focusHandler',
            'blur': '_blurHandler',
            'wheel': '_mouseWheelHandler',
            'document.up': '_upHandler',
            'document.move': '_moveHandler',
            'document.down': '_downHandler',
            'document.scroll': '_scrollHandler',
            'keydown': '_keyDownHandler',
            'keyup': '_keyUpHandler',
            'resize': '_resizeHandler',
            'columnHeader.down': '_columnDownHandler',
            'columnHeader.move': '_columnMoveHandler',
            'columnHeader.mouseleave': '_columnMouseLeaveHandler',
            'rowNearContainer.down': '_rowDownHandler',
            'rowContainer.down': '_rowDownHandler',
            'rowFarContainer.down': '_rowDownHandler',
            'selectstart': '_selectStartHandler',
            'styleChanged': '_styleChangedHandler',
            'swipeleft': '_swipeLeftHandler',
            'swiperight': '_swipeRightHandler'
        };
    }

    pageSizeValidator(oldValue, newValue) {
        const that = this;

        if (newValue < 0) {
            return 0;
        }

        if (that.dataSource && newValue > that.dataSource.length) {
            return that.dataSource.length;
        }
    }

    pageIndexValidator(oldValue, newValue) {
        const that = this;

        if (newValue < 0) {
            return 0;
        }


        if (that.dataSource) {
            const maxPageIndex = Math.ceil(that.dataSource.length / that.paging.pageSize);

            if (newValue > maxPageIndex - 1) {
                return maxPageIndex - 1;
            }
        }
    }

    _offsetTop(element) {
        const that = this;

        if (!element) {
            return 0;
        }

        return element.offsetTop + that._offsetTop(element.offsetParent);
    }

    _offsetLeft(element) {
        const that = this;

        if (!element) {
            return 0;
        }

        return element.offsetLeft + that._offsetLeft(element.offsetParent);
    }

    offset(element) {
        return { left: this._offsetLeft(element), top: this._offsetTop(element) }
    }

    getBoundingRect(element) {
        let offsetX = window.pageXOffset,
            offsetY = window.pageYOffset,
            rect = element.getBoundingClientRect();

        if (element !== document.body) {
            let parent = element.parentNode;

            while (parent !== document.body) {
                offsetX += parent.scrollLeft;
                offsetY += parent.scrollTop;
                parent = parent.parentNode;
            }
        }

        return {
            bottom: rect.bottom + offsetY,
            height: rect.height,
            left: rect.left + offsetX,
            right: rect.right + offsetX,
            top: rect.top + offsetY,
            width: rect.width
        };
    }

    _downHandler() {


    }

    _upHandler(event) {
        const that = this;

        const boundingRect = that.getBoundingRect(that);

        if (that._tapTimer) {
            clearTimeout(that._tapTimer);
        }

        if (event.pageX < boundingRect.left || event.pageX > boundingRect.right || event.pageY < boundingRect.top || event.pageY > boundingRect.bottom) {
            if (that._inputOverlay) {
                that._inputOverlay.classList.remove('jqx-input-overlay-on');
                setTimeout(() => {
                    if (that._inputOverlay) {
                        if (that._inputOverlay.parentNode) {
                            that._inputOverlay.parentNode.removeChild(that._inputOverlay);
                        }

                        that._inputOverlay = null;
                    }
                }, 300);
            }

            if (that.editing.isEditing && !that.editing.dialog.enabled) {
                setTimeout(() => {
                    if (event.defaultPrevented) {
                        return;
                    }

                    if (that.editing.editCell && that.editing.editCell.editor.instance) {
                        that.editing.editCell.editor.instance.blur(event);

                        if (event.defaultPrevented) {
                            return;
                        }
                    }

                    that.endEdit();
                }, 50);
            }

            if (that.menu) {
                const target = event.originalEvent.target;

                if (!that.contains(target) && !that.menu.contains(target)) {
                    const dropDownLists = that.menu.querySelectorAll('jqx-drop-down-list');
                    const dateTimePickers = that.menu.querySelectorAll('jqx-date-time-picker');

                    for (let i = 0; i < dropDownLists.length; i++) {
                        const dropDownList = dropDownLists[i];
                        const dropDown = dropDownList.$.dropDownContainer;

                        if (dropDown.contains(target)) {
                            return;
                        }
                    }

                    for (let i = 0; i < dateTimePickers.length; i++) {
                        const dateTimePicker = dateTimePickers[i];
                        const dropDown = dateTimePicker.$.dropDownContainer;

                        if (dropDown.contains(target)) {
                            return;
                        }
                    }

                    that.closeMenu();

                    return;
                }
            }
        }

        that._dragSelectionEnd();

        that.classList.remove('jqx-grid-resize-mode');
        that.$.root.classList.remove('jqx-grid-resize-mode');

        if (that._rowToResize && that._rowResizeStartLine && that._rowResizeLine) {
            const row = that.rowById[that._rowToResizeId];

            const newRowHeight = row.cellHeight + parseFloat(that._rowResizeLine.style.top) - parseFloat(that._rowResizeStartLine.style.top)


            that.rows.canNotify = false;
            row.height = null;

            if (that.rowResizeMode === 'split') {
                const nextRow = that._nextRow(row);
                const offset = parseInt(row.height - newRowHeight + row.cellHeight);

                row.computedHeight = newRowHeight;
                nextRow.computedHeight = parseInt(nextRow.height) + offset;
                nextRow.height = null;
            }
            else {
                row.computedHeight = newRowHeight;
            }

            that.rows.canNotify = true;

            that._rowResizeStartLine.parentNode.removeChild(that._rowResizeStartLine);
            that._rowResizeLine.parentNode.removeChild(that._rowResizeLine);
            if (that.appearance.showResizeTooltips) {
                that._rowResizeTooltip.parentNode.removeChild(that._rowResizeTooltip);
            }
            that._rowResizeLine = null;
            that._rowToResize = null;
            that._rowToResizeId = null;

            that.refresh();

            return;
        }

        if (!that._columnToResizeElement || !that._columnResizeLine) {
            return;
        }

        const column = that.columnByDataField[that._columnToResizeDataField];
        const columnRect = that._columnToResizeRect;

        const newColumnWidth = boundingRect.left + parseInt(that._columnResizeLine.style.left) - columnRect.left + that.scrollLeft;

        that.columns.canNotify = false;
        if (that.columnResizeMode === 'split') {
            const nextColumn = that._nextColumn(column);
            const offset = parseInt(column.computedWidth - newColumnWidth);

            column.width = newColumnWidth;
            nextColumn.width = parseInt(nextColumn.computedWidth) + offset;
        }
        else {
            column.width = newColumnWidth;
        }
        that.columns.canNotify = true;
        that._columnResizeLine.parentNode.removeChild(that._columnResizeLine);
        that._columnResizeLine = null;
        that._columnResizeStartLine.parentNode.removeChild(that._columnResizeStartLine);
        if (that._columnResizeTooltip.parentNode) {
            that._columnResizeTooltip.parentNode.removeChild(that._columnResizeTooltip);
        }
        that._columnResizeStartLine = null;
        that._columnToResizeElement = null;
        that._columnToResizeRect = null;
        that._columnToResizeDataField = null;
        that._columnResizeTooltip = null;

        that.refresh();
    }

    _nextColumn(column) {
        const that = this;

        for (let i = 0; i < that.viewColumns.length; i++) {
            const currentColumn = that.viewColumns[i];

            if (currentColumn.visibleIndex === column.visibleIndex + 1) {
                return currentColumn;
            }
        }

        return null;
    }

    _nextRow(row) {
        const that = this;

        const rows = that._recyclingRows;
        const rowIndex = rows.indexOf(row);

        if (rowIndex >= 0) {
            return rows[rowIndex + 1];
        }

        return null;
    }

    _columnMoveResizeHandler(event) {
        const that = this;
        const columnResizeBreakpoint = 5;

        const updateTooltip = function (boundingRect) {
            const columnRect = that._columnToResizeRect;
            const newColumnWidth = boundingRect.left + parseFloat(that._columnResizeLine.style.left) - columnRect.left + that.scrollLeft;

            if (that.appearance.showResizeTooltips) {
                that._columnResizeTooltip.innerHTML = 'w: ' + parseInt(newColumnWidth) + 'px';
            }
        }

        if (that._columnResizeLine) {
            const column = that.columnByDataField[that._columnToResizeDataField];
            const columnRect = that._columnToResizeRect;
            const minWidth = column.minWidth;
            const maxWidth = column.maxWidth;
            const nextColumn = that._nextColumn(column);
            const boundingRect = that.getBoundingRect(that);

            if (event.pageX < boundingRect.left) {
                return;
            }

            if (that.columnResizeMode === 'split' && nextColumn) {
                if (event.pageX >= boundingRect.left + nextColumn.left + nextColumn.width - nextColumn.minWidth - that.scrollLeft) {
                    that._columnResizeLine.style.left = -boundingRect.left + boundingRect.left + nextColumn.width + nextColumn.left - nextColumn.minWidth - that.scrollLeft + 'px';
                    updateTooltip(boundingRect);
                    return;
                }
            }


            if (columnRect.left + minWidth - that.scrollLeft >= event.pageX) {
                that._columnResizeLine.style.left = -boundingRect.left + columnRect.left + minWidth - that.scrollLeft + 'px';

                updateTooltip(boundingRect);
                return;
            }

            if (columnRect.left + maxWidth - that.scrollLeft <= event.pageX) {
                that._columnResizeLine.style.left = -boundingRect.left + columnRect.left + maxWidth - that.scrollLeft + 'px';
                updateTooltip(boundingRect);
                return;
            }

            that._columnResizeLine.style.left = -boundingRect.left + event.pageX + 'px';
            updateTooltip(boundingRect);
        }
        else {
            const that = this;

            const elements = document.elementsFromPoint(event.clientX, event.clientY);

            let columnDataField = null;
            let columnElement = null;

            if (that._columnResizeLine) {
                return;
            }

            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];

                if (element.hasAttribute('data-field') && element.hasAttribute('header')) {
                    columnDataField = element.getAttribute('data-field');
                    columnElement = element;
                    break;
                }
            }

            if (that._columnToResizeElement) {
                that._columnToResizeElement.style.cursor = '';
                that._columnToResizeElement = null;
            }

            if (columnDataField) {
                const columnRight = columnElement.getBoundingClientRect().right;

                columnElement.style.cursor = ''

                if (columnRight - columnResizeBreakpoint <= event.clientX && event.clientX <= columnRight + columnResizeBreakpoint) {
                    const column = that.columnByDataField[columnDataField];

                    if (!column || (column && !column.allowResize)) {
                        return;
                    }

                    const isLastColumn = that._isLastVisibleColumn(column);

                    if (that.columnResizeMode === 'split' && isLastColumn) {
                        return;
                    }

                    columnElement.style.cursor = 'col-resize';

                    that._columnToResizeRect = that.getBoundingRect(columnElement);
                    that._columnToResizeElement = columnElement;
                    that._columnToResizeDataField = columnDataField;
                }
            }
        }
    }

    _moveHandler(event) {
        const that = this;

        if (that.selection.enabled && that.selection.allowDragSelection && !that.editing.isEditing) {
            if (!that._selection.selectionRect || (that._selection.selectionRect && !that._selection.selectionRect.captured)) {
                that._dragSelection(event);
                if (JQX.Utilities.Core.isMobile) {
                    event.originalEvent.preventDefault();
                }
            }
        }

        if (that.columnResizeMode !== 'none') {
            that._columnMoveResizeHandler(event);
        }

        if (that.rowResizeMode !== 'none') {
            that._rowMoveResizeHandler(event);
        }
    }

    _rowMoveResizeHandler(event) {
        const that = this;

        const elements = document.elementsFromPoint(event.clientX, event.clientY);
        const rowResizeBreakpoint = 5;
        const resizeLineHeight = 1;

        let rowId = null;
        let rowElement = null;

        if (that._rowResizeLine) {
            const scrollViewTop = that._offsetTop(that.$.scrollView);
            const scrollViewBounds = {
                top: scrollViewTop, bottom: that.$.scrollView.offsetHeight + scrollViewTop
            };

            if (event.pageY <= scrollViewBounds.top) {
                return;
            }

            if (event.pageY >= scrollViewBounds.bottom) {
                return;
            }

            const updateTooltip = function () {
                const newRowHeight = row.cellHeight + parseFloat(that._rowResizeLine.style.top) - parseFloat(that._rowResizeStartLine.style.top);

                if (that.appearance.showResizeTooltips) {
                    that._rowResizeTooltip.innerHTML = 'h: ' + parseInt(newRowHeight) + 'px';
                }
            }


            const row = that.rowById[that._rowToResizeId];
            const nextRow = that._nextRow(row);
            const rowBounds = that._rowToResizeBounds;

            const minHeight = row.minHeight;
            const maxHeight = row.maxHeight;


            if (that.rowResizeMode === 'split' && nextRow) {
                if (rowBounds.bottom + nextRow.height - nextRow.minHeight <= event.pageY) {
                    that._rowResizeLine.style.top = rowBounds.bottom + nextRow.height - nextRow.minHeight - scrollViewTop + 'px';
                    updateTooltip();
                    return;
                }
            }

            if (rowBounds.top + minHeight + rowResizeBreakpoint >= event.pageY) {
                that._rowResizeLine.style.top = rowBounds.top + minHeight + rowResizeBreakpoint - scrollViewTop + 'px';
                updateTooltip();
                return;
            }

            if (rowBounds.top + maxHeight >= event.pageY - scrollViewTop) {
                that._rowResizeLine.style.top = rowBounds.top + maxHeight + rowResizeBreakpoint - scrollViewTop + 'px';
                updateTooltip();
                return;
            }

            that._rowResizeLine.style.top = -scrollViewTop + event.pageY - resizeLineHeight + 'px';
            updateTooltip();
            return;
        }
        else {
            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];

                if (element.hasAttribute('data-id') && element.hasAttribute('header')) {
                    rowElement = element;
                    rowId = element.getAttribute('data-id');
                    break;
                }
            }

            if (that._rowToResize) {
                that._rowToResize.style.cursor = '';
                that._rowToResize = null;
            }

            if (rowId !== null) {
                const rowBottom = that._offsetTop(rowElement) + rowElement.offsetHeight;

                rowElement.style.cursor = '';

                if (rowBottom - rowResizeBreakpoint <= event.clientY && event.clientY <= rowBottom + rowResizeBreakpoint) {
                    const row = that.rowById[rowId];

                    if (!row || (row && !row.allowResize)) {
                        return;
                    }

                    if (row.header) {
                        row.header.style.cursor = 'row-resize';
                    }

                    const top = that._offsetTop(rowElement);

                    that._rowToResizeBounds = {
                        top: top, bottom: rowElement.offsetHeight + top, height: rowElement.offsetHeight
                    };
                    that._rowToResize = rowElement;
                    that._rowToResizeId = rowId;
                }
            }
        }
    }

    _rowDownResizeHandler() {
        const that = this;

        const rowBounds = that._rowToResizeBounds;

        const createLine = function () {
            const resizeLine = document.createElement('div');

            resizeLine.classList.add('jqx-grid-resize-line', 'row');

            resizeLine.style.width = that.$.scrollView.offsetWidth - that._rowToResize.offsetLeft + 'px';
            resizeLine.style.left = '0px';
            resizeLine.style.top = -that._offsetTop(that.$.scrollView) + rowBounds.bottom + 'px';

            return resizeLine;
        }

        const resizeTooltip = document.createElement('div');

        resizeTooltip.classList.add('jqx-grid-resize-tooltip');

        that._rowResizeTooltip = resizeTooltip;
        that._rowResizeTooltip.style.top = -that._offsetTop(that.$.scrollView) + rowBounds.bottom + 'px';
        that._rowResizeTooltip.innerHTML = 'h: ' + parseInt(rowBounds.height) + 'px';
        that._rowResizeTooltip.style.right = '20px';
        that._rowResizeTooltip.style.bottom = 'initial';

        if (that.rowResizeMode === 'growAndShrink') {
            that.classList.add('jqx-grid-resize-mode');
            that.$.root.classList.add('jqx-grid-resize-mode');
        }

        that._rowResizeLine = createLine();
        that._rowResizeStartLine = createLine();

        that.$.scrollView.appendChild(that._rowResizeLine);
        that.$.scrollView.appendChild(that._rowResizeStartLine);
        if (that.appearance.showResizeTooltips) {
            that.$.scrollView.appendChild(that._rowResizeTooltip);
        }
    }

    _rowResizeHandler(event) {
        const that = this;

        let clientX = event.clientX;
        let clientY = event.clientY;

        if (clientX === undefined || clientY === undefined) {
            clientX = event.touches[0].clientX;
            clientY = event.touches[0].clientY;
        }

        const elements = document.elementsFromPoint(clientX, clientY);
        let rowId = null;

        for (let i = 0; i < elements.length; i++) {
            const element = elements[i];

            if (element.getAttribute('data-id')) {
                rowId = element.getAttribute('data-id');
            }
        }

        if (rowId !== null) {
            if (that._rowToResize && !that._rowResizeLine) {
                that._rowDownResizeHandler(event);

                return;
            }
        }
    }

    _columnMouseLeaveHandler() {
        const that = this;

        for (let i = 0; i < that._columnElements.length; i++) {
            const element = that._columnElements[i];
            const column = element.column;

            if (column && column.autoShowActionButton) {
                element._hideActionButton();
            }
        }
    }

    _columnMoveHandler(event) {
        const that = this;

        if (that._columnResizeStartLine || that._rowResizeStartLine) {
            return;
        }

        for (let i = 0; i < that._columnElements.length; i++) {
            const element = that._columnElements[i];
            const column = element.column;

            if (column && column.autoShowActionButton) {
                const rect = element.getBoundingClientRect();
                const offset = that.offset(element);


                if (offset.left <= event.pageX && offset.left + rect.width - 6 >= event.pageX) {
                    if (offset.top <= event.pageY && offset.top + rect.height >= event.pageY) {
                        if (!that.hasColumnMenu(column)) {
                            continue;
                        }

                        element._showActionButton();
                    }
                    else {
                        element._hideActionButton();
                    }
                }
                else {
                    element._hideActionButton();
                }
            }
        }
    }

    _columnDownResizeHandler() {
        const that = this;

        const columnRect = that._columnToResizeRect;
        const columnHeaderRect = that.getBoundingRect(that.$.columnHeader);

        const createLine = function () {
            const resizeLine = document.createElement('div');

            resizeLine.classList.add('jqx-grid-resize-line');

            resizeLine.style.left = -columnHeaderRect.left + columnRect.right + 'px';
            resizeLine.style.top = -columnHeaderRect.top + columnRect.top + 'px';
            resizeLine.style.height = 'calc(100% - ' + resizeLine.style.top + ')';

            return resizeLine;
        }

        const resizeTooltip = document.createElement('div');

        resizeTooltip.classList.add('jqx-grid-resize-tooltip');

        that._columnResizeTooltip = resizeTooltip;
        that._columnResizeTooltip.style.left = -columnHeaderRect.left + columnRect.right + 'px';
        that._columnResizeTooltip.innerHTML = 'w: ' + parseInt(columnRect.width) + 'px';

        that._columnResizeLine = createLine();
        that._columnResizeStartLine = createLine();

        if (that.columnResizeMode === 'growAndShrink') {
            that.classList.add('jqx-grid-resize-mode');
            that.$.root.classList.add('jqx-grid-resize-mode');
        }

        if (that.appearance.showResizeTooltips) {
            that.$.root.appendChild(that._columnResizeTooltip);
        }

        that.$.root.appendChild(that._columnResizeLine);
        that.$.root.appendChild(that._columnResizeStartLine);
    }

    _columnDownHandler(event) {
        const that = this;

        const elements = document.elementsFromPoint(event.clientX, event.clientY);

        let columnDataField = null;
        let columnElement = null;

        for (let i = 0; i < elements.length; i++) {
            const element = elements[i];

            if (element.classList.contains('jqx-action-button')) {
                return;
            }

            if (element.getAttribute('data-field')) {
                columnDataField = element.getAttribute('data-field');
                columnElement = element;
                break;
            }
        }

        if (columnDataField) {
            const column = columnElement.column;

            if (!column) {
                return;
            }

            if (columnDataField === '_commandColumn') {
                that._applyCommand(that.editing.commandColumn.dataSource.commandColumnMenu.command);
                return
            }

            const selectColumn = function (action) {
                const canSelect = column.selectionColumn ? that.selection.checkBoxes.action === action && that.selection.enabled : that.selection.action === action && that.selection.enabled;

                if (canSelect) {
                    if (!event.shiftKey && !event.ctrlKey) {
                        that._dragSelectionStartDataField = columnDataField;
                    }
                    else {
                        that._dragSelectionStartDataField = null;
                    }

                    if (columnDataField === '_checkBoxColumn') {
                        that._toggleColumnSelection(column);
                        return;
                    }

                    that._setSelection(null, column.dataField, event);

                    that.$.fireEvent('change');
                }
            }

            that.$.fireEvent('columnClick', {
                'column': column
            });

            if (new Date() - that._clickTime < 300) {
                that.$.fireEvent('columnDoubleClick', {
                    'column': column
                });

                selectColumn('doubleClick');
            }

            selectColumn('click');

            if (that._columnToResizeElement && !that._columnResizeLine) {
                that._columnDownResizeHandler(event);

                return;
            }

            if (JQX.Utilities.Core.isMobile) {
                if (new Date() - that._clickTime < 300) {
                    if (column.allowSortToggleOnClick && that.sorting.enabled) {
                        that.sortBy(columnDataField);
                    }
                }

                that._columnMoveHandler(event);
                event.originalEvent.preventDefault();
            }
            else {
                if (column.allowSortToggleOnClick && that.sorting.enabled) {
                    that.sortBy(columnDataField);
                }
            }

            that._clickTime = new Date();
        }

        that.closeMenu();
    }

    addTransformMoveStyle(element, duration, x, y, z, opacity) {
        element.style['opacity'] = opacity;
        element.style['transition-duration'] = duration;
        element.style['transform'] = 'translate3d(' + x + 'px,' + y + 'px,' + z + 'px)';
    }

    removeTransformMoveStyle(element) {
        element.style['opacity'] = '';
        element.style['transition-duration'] = '';
        element.style['transform'] = '';
    }


    _rowDownHandler(event) {
        const that = this;

        if (that._inputOverlay) {
            that._inputOverlay.classList.remove('jqx-input-overlay-on');
        }

        that.closeMenu();
        that._rowResizeHandler(event);

        if (that._toggledRow && that.appearance.allowRowToggleAnimation) {
            return;
        }

        let clientX = event.clientX;
        let clientY = event.clientY;

        if (event.touches) {
            clientX = event.touches[0].clientX;
            clientY = event.touches[0].clientY;
        }

        const elements = document.elementsFromPoint(clientX, clientY);
        let rowElement = null;
        let toggleButton = null;
        let cellElement = null;

        //const refresh = function () {
        //    const scrollLeft = that._scrollView.scrollLeft;

        //    that._refreshLayout();
        //    that._recycle();
        //    that._scrollView.scrollLeft = scrollLeft;
        //}

        that._lastPointerDownTime = new Date();

        for (let i = 0; i < elements.length; i++) {
            const element = elements[i];

            if (element.hasAttribute('toggle-button')) {
                toggleButton = element;
            }

            if (!cellElement && element.nodeName.toLowerCase() === 'jqx-grid-cell') {
                cellElement = element;
            }

            if (!rowElement && element.nodeName.toLowerCase() === 'jqx-grid-row') {
                rowElement = element;
                break;
            }
        }

        if (rowElement && cellElement) {
            const cell = cellElement ? cellElement.cell : null;

            if (toggleButton && cell && !cell.column.rowDetailColumn || (that._adaptiveLayout > 0 && false === rowElement.row.leaf)) {
                const row = rowElement.row;

                row.toggle();
            }
            else if (that.rowDetail.enabled && that.rowDetail.visible && toggleButton && cell && cell.column.rowDetailColumn) {
                const row = rowElement.row;

                if (row.showDetail) {
                    that.hideDetail(row.id);
                }
                else {
                    that.showDetail(row.id);
                }
            }
            else {
                const row = rowElement.row;
                const cell = cellElement ? cellElement.cell : null;

                that.$.fireEvent('rowClick', {
                    'row': row,
                    originalEvent: event.originalEvent
                });

                that.$.fireEvent('cellClick', {
                    'cell': cell,
                    originalEvent: event.originalEvent
                });

                if (that._tapTimer) {
                    clearTimeout(that._tapTimer);
                }

                that._tapTimer = setTimeout(function () {
                    if (that._clickedRow === rowElement) {
                        that.$.fireEvent('rowTap', {
                            'row': row,
                            originalEvent: event.originalEvent
                        });
                    }

                    if (that._clickedCell === cellElement) {

                        that.$.fireEvent('cellTap', {
                            'cell': cell,
                            originalEvent: event.originalEvent
                        });
                    }
                }, 300);

                //const isEditing = that.editing.isEditing;

                const selectRow = function (action) {
                    if (!that.selection.enabled || row.autoGenerated) {
                        return;
                    }

                    const isEditing = that.editing.isEditing;

                    if (isEditing && that.editing.editCell.row.id === row.id && that.editing.editCell.column.dataField === cell.column.dataField) {
                        return;
                    }

                    if (that.selection.action === action) {
                        if (!event.shiftKey && !event.ctrlKey) {
                            if (!that.selection.allowRowHeaderSelection && cell.column.autoGenerated) {
                                that._dragSelectionStartRow = null;
                            }
                            else {
                                that._dragSelectionStartRow = rowElement.row;
                            }
                        }
                        else {
                            that._dragSelectionStartRow = null;
                        }

                        if (!event.shiftKey && !event.ctrlKey) {
                            that._dragSelectionStartDataField = cell.column.dataField;
                        }
                        else {
                            that._dragSelectionStartDataField = null;
                        }

                        that._setSelection(row.id, cell.column.dataField, event);
                        that.$.fireEvent('change');
                    }
                    else if (cell.column.selectionColumn && that.selection.checkBoxes.enabled && that.selection.checkBoxes.action === action) {
                        that._setSelection(row.id, cell.column.dataField, event);
                        that.$.fireEvent('change');
                    }

                }

                const isSelected = cell.selected;
                //const focusedCell = that._selection.focusedCell;

                selectRow('click');

                if (row.autoGenerated || (cell.column.autoGenerated || cell.template)) {
                    that._onRowClick(row.index, row, event);
                    that._onCellClick(cell, event);
                }
                else {
                    if (that.selection.enabled) {
                        if (that.selection.allowCellSelection) {
                            if (isSelected === true && isSelected === cell.selected && !that.selection.isDragging
                                && that._clickedCell === cellElement && new Date() - that._clickTime < 300) {
                                that._onRowClick(row.index, row, event);
                                that._onCellClick(cell, event);
                            }
                        }
                        else if (that.selection.allowRowSelection) {
                            if (isSelected === true && isSelected === cell.selected && !that.selection.isDragging
                                && that._clickedCell === cellElement && new Date() - that._clickTime < 300) {
                                that._onRowClick(row.index, row, event);
                                that._onCellClick(cell, event);
                            }
                        }
                        else {
                            that._onRowClick(row.index, row, event);
                            that._onCellClick(cell, event);
                        }
                    }
                    else {
                        that._onRowClick(row.index, row, event);
                        that._onCellClick(cell, event);
                    }
                }

                if (new Date() - that._clickTime < 300) {
                    if (that._clickedRow === rowElement) {
                        that._onRowDoubleClick(row.index, row, event, event);

                        that.$.fireEvent('rowDoubleClick', {
                            'row': row,
                            originalEvent: event.originalEvent
                        });

                        selectRow('doubleClick');
                    }

                    if (that._clickedCell === cellElement) {
                        that._onCellDoubleClick(cell, event);

                        that.$.fireEvent('cellDoubleClick', {
                            'cell': cell,
                            originalEvent: event.originalEvent
                        });
                    }
                }

                that._clickedRow = rowElement;
                that._clickedCell = cellElement;
                that._clickTime = new Date();
            }
        }
    }

    showDetail(id) {
        const that = this;

        const row = that.rowById[id];

        if (!row) {
            return;
        }

        row.showDetail = true;
    }

    hideDetail(id) {
        const that = this;

        const row = that.rowById[id];

        if (!row) {
            return;
        }

        row.showDetail = false;
    }

    _focusHandler() {
        const that = this;
        that._focused = true;
    }

    _blurHandler() {
        const that = this;
        that._focused = false;
    }


    _notify(propertyName, oldValue, newValue) {
        const that = this;

        if (that.notifyFn) {
            for (let i = 0; i < that.notifyFn.length; i++) {
                that.notifyFn[i](propertyName, oldValue, newValue);
            }
        }
    }

    notify(notifyFn) {
        const that = this;

        if (notifyFn) {
            if (!that.notifyFn) {
                that.notifyFn = [];
            }

            that.notifyFn.push(notifyFn);
        }
    }

    _applyTemplate(selector, element) {
        //const that = this;
        let template = null;

        if (selector === null || selector === '') {
            element.innerHTML = '';
            return;
        }

        if (selector.startsWith('#') || selector.startsWith('.')) {
            template = document.querySelector(selector);
        }

        if (template) {
            element.innerHTML = '';
            element.appendChild(template.content.cloneNode(true).firstElementChild);
        }
        else {
            const htmlToElement = function (html) {
                const template = document.createElement('template');

                html = html.trim(); // Never return a text node of whitespace as the result
                template.innerHTML = html;
                return template.content.firstChild;
            }

            const templateElement = htmlToElement(selector);

            if (templateElement) {
                element.innerHTML = '';
                element.appendChild(templateElement);
            }
        }
    }
    /**
    * Updates the listbox when a property is changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
    * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        if (!that.isInitialized) {
            return;
        }


        that._notify(propertyName, oldValue, newValue);

        switch (propertyName) {
            case 'appearance_showColumnHeaderLines':
            case 'appearance_showColumnLines':
            case 'appearance_showRowLines': {
                that._recycle();
                return;
            }
            case 'appearance_allowColumnStickyPosition': {
                if (newValue) {
                    that._stickHeader();
                }
                else {
                    that._unstickHeader();
                }

                break;
            }
            case 'appearance_showColumnIcon': {
                for (let i = 0; i < that.columns.length; i++) {
                    const column = that.columns[i];

                    column.setProperty('showIcon', that.appearance.showColumnIcon);
                }

                that._recycle();


                break;
            }
                /*
            case 'appearance_showColumnSortButton': {
                for (let i = 0; i < that.columns.length; i++) {
                    const column = that.columns[i];

                    column.setProperty('showSortButton', that.appearance.showColumnSortButton);
                }

                that._recycle();

                break;
            }
            case 'appearance_showColumnFilterButton': {
                for (let i = 0; i < that.columns.length; i++) {
                    const column = that.columns[i];

                    column.setProperty('showFilterButton', that.appearance.showColumnFilterButton);
                }

                that._recycle();

                break;
            }
            case 'appearance_showColumnDescriptionButton': {
                for (let i = 0; i < that.columns.length; i++) {
                    const column = that.columns[i];

                    column.setProperty('showDescriptionButton', that.appearance.showColumnDescriptionButton);
                }

                that._recycle();
                break;
            }*/
            case 'appearance_showRowNumber':
            case 'appearance_showRowHeader': {
                that._initializeRowNumberColumn();

                const column = that._frozenNearColumns[0];

                if (column.rowNumbersColumn && column.element && !column.element.parentNode) {
                    that.$.columnNearContainer.appendChild(column.element);
                }

                that.refresh();
                break;
            }

            case 'header_template': {
                that._applyTemplate(newValue, that.$.header);
                break;
            }
            case 'footer_template': {
                that._applyTemplate(newValue, that.$.footer);
                break;
            }
            case 'columnWidth': {
                that.columns.canNotify = false;

                let width = parseInt(newValue);

                if (isNaN(width)) {
                    width = 'auto';
                }

                if (width >= 30 || width === 'auto') {
                    for (let i = 0; i < that.columns.length; i++) {
                        const column = that.columns[i];

                        column.width = width;
                    }
                }

                that.columns.canNotify = true;
                that.refresh();
                break;
            }
            case 'columnHeader_visible': {
                that.__columnHeaderHeight = null;
                that.refresh();
                break;
            }
            case 'selection_checkBoxes_enabled': {
                that._selectionColumn.visible = newValue;
                break;
            }

            case 'selection_checkBoxes_autoShow': {
                if (that._selectionColumn.element) {
                    if (newValue) {
                        that._selectionColumn.element.setAttribute('auto-show', '');
                    }
                    else {
                        that._selectionColumn.element.removeAttribute('auto-show');
                    }
                }
                break;
            }

            case 'selection_checkBoxes_position': {
                let index = that.viewColumns.indexOf(that._selectionColumn);

                that.viewColumns.canNotify = false;

                that.viewColumns.splice(index, 1);

                const nearIndex = that._frozenNearColumns.indexOf(that._selectionColumn);
                const farIndex = that._frozenFarColumns.indexOf(that._selectionColumn);

                if (nearIndex >= 0) {
                    that._frozenNearColumns.splice(nearIndex, 1);
                }

                if (farIndex >= 0) {
                    that._frozenFarColumns.splice(farIndex, 1);
                }

                if (newValue === 'far') {
                    that._selectionColumn.canNotify = false;
                    that._selectionColumn.freeze = 'far';
                    that._selectionColumn.canNotify = true;
                    that._frozenFarColumns.splice(0, 0, that._selectionColumn);
                    that.viewColumns.push(that._selectionColumn);
                    that.$.columnFarContainer.appendChild(that._selectionColumn.element);
                }
                else {
                    let autoGeneratedNearColumns = 0;
                    let index = 0;

                    for (let i = 0; i < that.viewColumns.length; i++) {
                        if (!that.viewColumns[i].autoGenerated && that.viewColumns[i].dataField === that.columns[index++].dataField) {
                            break;
                        }

                        if (that.viewColumns[i].autoGenerated) {
                            autoGeneratedNearColumns++;
                        }
                    }

                    that._selectionColumn.canNotify = false;
                    that._selectionColumn.freeze = 'near';
                    that._selectionColumn.canNotify = true;

                    that._frozenNearColumns.splice(autoGeneratedNearColumns, 0, that._selectionColumn);
                    that.viewColumns.splice(autoGeneratedNearColumns, 0, that._selectionColumn);
                    that.$.columnNearContainer.appendChild(that._selectionColumn.element);

                }

                that.viewColumns.canNotify = true;

                break;
            }
            case 'filtering_enabled':
                if (newValue) {
                    that._createFilterPanels();
                }
                return;
            case 'filtering_filter':
                for (let i = 0; i < that.columns.length; i++) {
                    const column = that.columns[i];

                    column.canNotify = false;
                    column.setProperty('filter', null);
                    column.canNotify = true;
                }

                for (let j = 0; j < that.filtering.filter.length; j++) {
                    const filter = that.filtering.filter[j];

                    if (filter) {
                        const dataField = filter[0];
                        const filterExpression = filter.splice(1);
                        let filterGroup = null;

                        if (filterExpression instanceof JQX.FilterGroup) {
                            filterGroup = filterExpression;
                        }
                        else {
                            const column = that.columnByDataField[dataField];

                            if (column) {
                                filterGroup = that.dataSource._createFilter(column.dataType, filterExpression);
                            }
                        }

                        if (filterGroup) {
                            that.addFilter(dataField, filterGroup, false);
                        }
                    }
                }

                that.refreshFilters();
                return;
            case 'paging_spinner_enabled': {
                that._refresh();
                break;
            }
            case 'pager_visible':
                that._renderPagers();
                that._refreshPaging(false);
                return;
            case 'paging_pageIndex':
            case 'pager_position':
            case 'paging_enabled':
                that._refreshPaging(true);
                return;
            case 'paging_pageSize':
                that._refreshPaging(false);
                return;
            case 'columns': {
                that._renderColumns();
                return;
            }
            case 'dataSource': {
                that.dataBind();
                return;
            }
            case 'displayLoadingIndicator': {
                that._setLoadingIndicatorVisibility();
                return;
            }
            case 'filterable': {
                that._refreshLayout();
                return;
            }

            case 'selectionMode': {
                return;
            }

            case 'editing_addNewRow_position': {
                that._renderAddNewRow();
                that.refresh();
                return;
            }

            case 'editing_dialog_visible': {
                return;
            }
        }

        that.refresh();
    }

    /**
      * Unselects all rows.
      */
    clearSelection() {
        const that = this;

        if (!that.dataSource || that.dataSource.length === 0) {
            return;
        }

        that._recycle();
    }

    /**
    * ListBox ready method.
    */
    ready() {
        super.ready();
        const that = this;

        const vScrollBar = that._scrollView.vScrollBar;
        const hScrollBar = that._scrollView.hScrollBar;

        vScrollBar.hasStyleObserver = false;
        hScrollBar.hasStyleObserver = false;
        vScrollBar.hasResizeObserver = false;
        hScrollBar.hasResizeObserver = false;
        vScrollBar.wait = false;
        hScrollBar.wait = false;
        vScrollBar.onChange = that._verticalScrollbarHandler.bind(that);
        hScrollBar.onChange = that._horizontalScrollbarHandler.bind(that);

        that.setFocusable(true);
        that._setLoadingIndicatorVisibility();
        that._cellsMerge = [];
        that.checkLicense();

        that._render();
    }

    checkLicense(log) {
        const that = this;

        if (
            (that.grouping.enabled) ||
            (that.selection.enabled && that.selection.allowCellSelection) ||
            (that.rowDetail.enabled) ||
            (that.editing.enabled && that.editing.batch) ||
            (that.editing.enabled && that.editing.mode === 'row') ||
            (that.editing.enabled && that.editing.addNewRow.visible) ||
            (that.editing.enabled && that.editing.commandColumn.visible) ||
            (that.scrollMode === 'virtual') ||
            (that.sorting.enabled && that.sorting.mode === 'many') ||
            log === true
           ) {
            super.checkLicense();
        }
    }

    _createFilterPanels() {
        const that = this;

        if (!that._filterPanels) {
            that._filterPanels = [];
        }
        else if (that._filterPanels.length > 0) {
            return;
        }

        if (that.filtering.enabled && that._filterPanels.length === 0) {
            requestAnimationFrame(() => {
                const stringPanel = document.createElement('jqx-filter-panel');
                const boolPanel = document.createElement('jqx-filter-panel');
                const numericPanel = document.createElement('jqx-filter-panel');
                const datePanel = document.createElement('jqx-filter-panel');

                boolPanel.filterType = 'boolean';
                numericPanel.filterType = 'numeric';
                datePanel.filterType = 'date';

                that._filterPanels['bool'] = boolPanel;
                that._filterPanels['date'] = datePanel;
                that._filterPanels['numeric'] = numericPanel;

                that._filterPanels['string'] = stringPanel;

                for (let filterType in that._filterPanels) {
                    const filterPanel = that._filterPanels[filterType];

                    filterPanel.classList.add('jqx-hidden');
                    that.$.content.appendChild(filterPanel);
                    filterPanel.parentNode.removeChild(filterPanel);
                }
            });
        }
    }

    _applyScrollMode() {
        const that = this;
        const vScrollBar = that._scrollView.vScrollBar;

        requestAnimationFrame(() => {
            vScrollBar.largeStep = that.$.scrollView.offsetHeight;

            switch (that.scrollMode) {
                case 'physical':
                case 'infinite':
                case 'virtual':
                    vScrollBar.step = 10;
                    vScrollBar.mechanicalAction = 'switchWhileDragging';
                    break;
                case 'deferred':
                    vScrollBar.step = 10;
                    vScrollBar.mechanicalAction = 'switchWhenReleased';
                    break;
                case 'logical':
                    vScrollBar.step = that.rowMinHeight;
                    vScrollBar.mechanicalAction = 'switchWhileDragging';
                    break;
            }
        });
    }

    beginUpdate() {
        const that = this;

        if (!that._isUpdating) {
            that._isUpdating = 0;
        }

        that._isUpdating++;
    }

    endUpdate(refresh) {
        const that = this;

        that._isUpdating--;

        if (that._isUpdating < 0) {
            that._isUpdating = 0;
        }

        if (refresh !== false) {
            that.refresh();
        }
    }

    suspendLayout() {
        const that = this;

        that._layoutSuspended = true;
    }

    resumeLayout(reRender) {
        const that = this;

        that._layoutSuspended = false;

        if (reRender) {
            that.refresh();
        }
        else {
            that._recycle(false);
        }
    }

    get _autoRowHeight() {
        const that = this;

        if (that.__autoRowHeight) {
            return that.__autoRowHeight;
        }

        const row = new JQX.Grid.Row({ adaptiveHeight: 0, index: 0, grid: that });
        const measureRowElement = row.createElement();

        let measuredHeight = that.rowMinHeight;

        that.$.scrollView.appendChild(measureRowElement);

        const data = {
        };

        for (let i = 0; i < that.dataSource.dataFields.length; i++) {
            const dataField = that.dataSource.dataFields[i];

            data[dataField.name] = 'ABCDEFHIJLMNOPQRSTUVWXYZ1234567910|';
        }

        row.data = data;
        row.render();
        measureRowElement.style.height = '';
        measureRowElement.style.lineHeight = '';

        measuredHeight = Math.max(measureRowElement.offsetHeight, measuredHeight);

        for (let i = 0; i < measureRowElement.children.length; i++) {
            measureRowElement.children[i].style.height = '';
        }

        for (let i = 0; i < measureRowElement.children[1].children.length; i++) {
            measureRowElement.children[1].children[i].style.height = 'auto';

            const cell = row.getCell(that.columns[0].dataField);

            cell.render();

            measuredHeight = Math.max(measuredHeight, 8 + measureRowElement.children[1].children[i].offsetHeight);
            break;
        }

        that.$.scrollView.removeChild(measureRowElement);

        that.__autoRowHeight = measuredHeight;

        return measuredHeight;
    }


    get _scrollHeight() {
        const that = this;

        let rows = that._recyclingRows;

        let scrollHeight = 0;
        let measuredHeight = that._autoRowHeight;
        let nearHeight = 0;
        let farHeight = 0;

        if (that.__scrollHeight) {
            return that.__scrollHeight;
        }

        if (rows.length === 0 || that.columns.length === 0) {
            return 0;
        }

        that.rows.canNotify = false;

        // calculate adaptive columns count;

        let adaptiveColumnsCount = 0;
        let normalColumnsCount = 0;

        if (that._responsiveLayout) {
            for (let i = 0; i < that.viewColumns.length; i++) {
                const column = that.viewColumns[i];

                if (column.autoGenerated) {
                    continue;
                }

                if (column.adaptiveVisible) {
                    adaptiveColumnsCount++;
                }
                else {
                    normalColumnsCount++;
                }
            }
        }
        else if (that._adaptiveLayout > 0) {
            for (let i = 0; i < that.viewColumns.length; i++) {
                const column = that.viewColumns[i];

                if (column.autoGenerated) {
                    continue;
                }

                adaptiveColumnsCount++;
            }
        }


        //const columnAdaptiveWidth = that._adaptiveLayout === 2 ? '50%' : that._adaptiveLayout === 1 ? '100%' : 0;
        const length = rows.length;

        for (let i = 0; i < length; i++) {
            let row = rows[i];

            if (!row.visible || row.filtered === false) {
                row.height = 0;
                row.cellHeight = 0;
                row.top = scrollHeight;
                continue;
            }

            let recalculateRowHeight = !row.height || !row.cellHeight || row.showDetail;

            if (recalculateRowHeight && !row.expandHeight) {
                if (!row.detailHeight) {
                    row.detailHeight = 200;
                }

                if (!that.rowHeight) {
                    row.height = measuredHeight;
                    row.adaptiveHeight = 0;

                    if (row.label !== undefined && !row.summaryRow) {
                        row.height = that.grouping.groupRowHeight;
                    }

                    if (row.computedHeight) {
                        row.height = row.computedHeight;
                    }

                    row.cellHeight = row.height;

                    if (that._responsiveLayout) {
                        const rowsCount = Math.ceil(adaptiveColumnsCount / normalColumnsCount);

                        if (undefined === row.label) {
                            row.adaptiveHeight = rowsCount * measuredHeight;
                        }
                        else {
                            row.adaptiveHeight = row.height;
                        }

                        row.adaptiveHeight += 50;
                    }


                    if (that.rowDetail.enabled && row.showDetail) {
                        row.height += row.detailHeight;
                    }
                }
                else if (that.rowHeight) {
                    if (typeof that.rowHeight === 'number') {
                        if (that.rowHeight < that.rowMinHeight) {
                            that.rowHeight = that.rowMinHeight;
                        }

                        row.height = that.rowHeight;

                        if (row.computedHeight) {
                            row.height = row.computedHeight;
                        }

                        if (row.label !== undefined) {
                            row.height = that.grouping.groupRowHeight;
                        }

                        row.cellHeight = row.height;

                        if (that.rowDetail.enabled && row.showDetail) {
                            row.height += row.detailHeight;
                        }
                    }
                    else {
                        that.rowHeight(i, row);
                        if (!row.height) {
                            row.height = measuredHeight;

                        }

                        row.cellHeight = row.height;

                        if (that.rowDetail.enabled && row.showDetail) {
                            row.height += row.detailHeight;
                        }
                    }
                }

                if (that._rowGap && i < that.rows.length - 1) {
                    row.height += that._rowGap;
                }
            }

            if (row.freeze === true || row.freeze === 'near') {
                nearHeight += row.height;
            }
            else if (row.freeze === 'far') {
                farHeight += row.height;
            }

            if (row.freeze) {
                row.top = scrollHeight;
                continue;
            }

            if (row.top !== scrollHeight) {
                row.top = scrollHeight;
            }

            if (row.expandHeight) {
                scrollHeight += row.cellHeight;
            }
            else {
                scrollHeight += row.height;
            }
        }

        that.__scrollHeight = scrollHeight;
        that.__frozenNearHeight = nearHeight;
        that.__frozenFarHeight = farHeight;

        that._scrollView.scrollHeight = scrollHeight - that.$.scrollView.offsetHeight + nearHeight + farHeight;

        scrollHeight = that.__scrollHeight + nearHeight + farHeight;

        if (that.grouping.enabled && that.dataSource.groupBy.length > 0 && that.grouping.groupIndent > 0) {
            scrollHeight += parseInt(that.grouping.groupIndent / 2);
        }

        that.__scrollHeight = scrollHeight;


        that.rows.canNotify = true;

        return scrollHeight;
    }

    _measureColumnHeight() {
        const that = this;

        if (that.__measuredColumnHeight) {
            return that.__measuredColumnHeight;
        }

        const header = document.createElement('jqx-grid-column');
        header.style.height = 'auto';
        header.style.position = 'static';

        const columnHeaderCellContentElement = document.createElement('div');

        columnHeaderCellContentElement.classList.add('jqx-label');
        columnHeaderCellContentElement.innerHTML = 'aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRwWxXyYzZ1234567890';

        header.appendChild(columnHeaderCellContentElement);
        that.$.columnHeader.appendChild(header);

        let height = that.$.columnHeader.offsetHeight;

        that.$.columnHeader.removeChild(header);

        if (that._columnHeights && that._columnHeights.length > 1) {
            height = that._columnHeights[0];
        }

        if (height < that.columnMinHeight) {
            height = that.columnMinHeight;
        }

        that.__measuredColumnHeight = height;

        return height;
    }

    _initializeColumnGroupsHierarchy() {
        const that = this;
        let totalMaxLevel = 0;

        that.$.columnContainer.innerHTML = '';

        if (that.columnGroups.length > 0) {
            for (let i = 0; i < that.columnGroups.length; i++) {
                that.columnGroups[i].parent = null;
                that.columnGroups[i].groups = null;
            }

            for (let i = 0; i < that.viewColumns.length; i++) {
                that.viewColumns[i].parent = null;
                that.viewColumns[i].groups = null;
            }

            const getParentGroup = function (name) {
                for (let i = 0; i < that.columnGroups.length; i++) {
                    let group = that.columnGroups[i];
                    if (group.name === name)
                        return group;
                }
                return null;
            }

            const getColumns = function (group) {
                let columns = new Array();
                if (group.columnGroup) {
                    columns.push(group);
                }
                if (group.groups) {
                    for (let i = 0; i < group.groups.length; i++) {
                        if (group.groups[i].columnGroup) {
                            columns.push(group.groups[i]);
                        }
                        else {
                            if (group.groups[i].groups) {
                                let tmpcolumns = getColumns(group.groups[i]);
                                for (let j = 0; j < tmpcolumns.length; j++) {
                                    columns.push(tmpcolumns[j]);
                                }
                            }
                        }
                    }
                }
                return columns;
            }

            for (let i = 0; i < that.columnGroups.length; i++) {
                let group = that.columnGroups[i];
                if (!group.groups) {
                    group.groups = null;
                }
                if (group.parentGroup) {
                    let parentGroup = getParentGroup(group.parentGroup);
                    if (parentGroup) {
                        group.parent = parentGroup;
                        if (!parentGroup.groups) {
                            parentGroup.groups = new Array();
                        }
                        if (parentGroup.groups.indexOf(group) === -1) {
                            parentGroup.groups.push(group);
                        }
                    }
                }
            }
            for (let i = 0; i < that.viewColumns.length; i++) {
                let group = that.viewColumns[i];

                if (group.columnGroup) {
                    let parentGroup = getParentGroup(group.columnGroup);

                    if (parentGroup) {
                        if (!parentGroup.groups) {
                            parentGroup.groups = new Array();
                        }

                        group.parent = parentGroup;

                        if (parentGroup.groups.indexOf(group) === -1) {
                            parentGroup.groups.push(group);
                        }
                    }
                }
            }
            for (let i = 0; i < that.viewColumns.length; i++) {
                const group = that.viewColumns[i];
                let initialgroup = group;

                group.level = 0;
                while (initialgroup.parent) {
                    initialgroup = initialgroup.parent;
                    group.level++;
                }

                initialgroup = group;
                let maxlevel = group.level;
                totalMaxLevel = Math.max(totalMaxLevel, group.level);

                while (initialgroup.parent) {
                    initialgroup = initialgroup.parent;
                    if (initialgroup) {
                        initialgroup.level = --maxlevel;
                    }
                }
            }

            for (let i = 0; i < that.columnGroups.length; i++) {
                const group = that.columnGroups[i];
                const columns = getColumns(group);

                group.columns = columns;

                let indexes = new Array();
                let frozen = 0;
                let freezePosition = 'near';

                if (columns.length === 0) {
                    frozen = -1;
                    group.visible = false;
                }

                for (let j = 0; j < columns.length; j++) {
                    indexes.push(that.viewColumns.indexOf(columns[j]));
                    if (columns[j].freeze) {
                        if (columns[j].freeze === 'far') {
                            freezePosition = 'far';
                        }
                        frozen++;
                    }
                }

                if (frozen === columns.length) {
                    group.freeze = freezePosition;
                }
                else if (frozen > 0 && frozen < columns.length) {
                    that.error(that.localize('frozenColumns', { elementType: 'Grid' }));
                }

                indexes.sort(function (value1, value2) {
                    value1 = parseInt(value1);
                    value2 = parseInt(value2);

                    if (value1 < value2) {
                        return -1;
                    }

                    if (value1 > value2) {
                        return 1;
                    }
                    return 0;
                });

                for (let index = 1; index < indexes.length; index++) {
                    if (indexes[index] !== indexes[index - 1] + 1) {
                        that.error(that.localize('columnGroups', { elementType: 'Grid' }));
                    }
                }
            }
        }

        that._columnGroupsLevel = 1 + totalMaxLevel;
    }

    _refreshColumnHeights() {
        const that = this;

        that._viewColumnsHeight = that._measureColumnHeight();
        that._columnHeights = [];
        let height = 0;

        for (let i = 0; i < that._columnGroupsLevel; i++) {
            let currentHeight = that._viewColumnsHeight;

            if (that.columnHeight) {
                if (typeof that.columnHeight === 'number') {
                    currentHeight = that.columnHeight ? that.columnHeight : that._viewColumnsHeight;
                }
                else {
                    currentHeight = that.columnHeight ? that.columnHeight(i) : that._viewColumnsHeight;
                }
            }

            if (currentHeight < that.columnMinHeight) {
                currentHeight = that.columnMinHeight;
            }

            if (!currentHeight) {
                height += that._viewColumnsHeight;
                that._columnHeights.push(that._viewColumnsHeight);
            }
            else {
                that._columnHeights.push(currentHeight);
                height += currentHeight;
            }
        }

        that._columnHeaderHeight = that._columnGroupsLevel * that._viewColumnsHeight;
        that._columnHeaderHeight = height;
        that.$.columnHeader.style.height = that._columnHeaderHeight + 'px';

        const getColumnTop = function (column) {
            let top = 0;

            for (let i = 0; i < column.level; i++) {
                top += that._columnHeights[i];
            }

            return top;
        }

        const getColumnHeight = function (column) {
            let top = getColumnTop(column);
            let totalHeight = that._columnHeaderHeight - top;

            for (let i = column.level + 1; i < that._columnHeights.length; i++) {
                const level = i;

                for (let j = 0; j < that.viewColumns.length; j++) {
                    const currentColumn = that.viewColumns[j];
                    let breakLoop = false;

                    if (currentColumn.level === level) {
                        let col = currentColumn;

                        while (col.parent) {
                            if (col.parent === column) {
                                totalHeight -= that._columnHeights[level];
                                breakLoop = true;
                                break;
                            }
                            col = col.parent;
                        }

                        if (breakLoop) {
                            break;
                        }
                    }
                }
            }

            return totalHeight;
        }

        for (let i = 0; i < that.viewColumns.length; i++) {
            const column = that.viewColumns[i];

            const height = getColumnHeight(column);

            column.computedHeight = height;
            column.top = getColumnTop(column);
        }

        for (let j = 0; j < that._columnGroupsLevel - 1; j++) {
            for (let i = 0; i < that.columnGroups.length; i++) {
                const group = that.columnGroups[i];
                const level = group.level;

                if (level !== j) {
                    continue;
                }

                if (group.groups) {
                    const height = getColumnHeight(group);
                    const top = getColumnTop(group);

                    group.top = top;
                    group.computedHeight = height;
                }

                const header = group.element;

                if (!header) {
                    continue;
                }

                header.style.width = group.computedWidth + 'px';
                header.style.left = group.left + 'px';
                header.style.top = group.top + 'px';
                header.style.height = group.computedHeight + 'px';
                header.style.lineHeight = group.computedHeight + 'px';

            }
        }
    }

    _refreshColumnWidths() {
        const that = this;

        that.__clientSize = null;

        const vScrollWidth = (that.$.verticalScrollBar.offsetWidth > 0 ? that.$.verticalScrollBar.offsetWidth : 0);
        const groupByDataSource = that.dataSource.groupBy || [];

        let indent = that.grouping.enabled ? that.grouping.groupIndent * (1 + groupByDataSource.length) : 0;
        let checkBoxesIndent = 0;

        if (that.selection.checkBoxes.enabled) {
            checkBoxesIndent = that._selectionColumn.computedWidth ? that._selectionColumn.computedWidth : that._selectionColumn.minWidth;
        }

        const gridWidth = that._clientSize.width - vScrollWidth - indent;

        const adaptiveWidth = that.adaptivityMode.adaptiveLayout.width;
        const responsiveWidth = that.adaptivityMode.responsiveLayout.width;
        // 375 is default for iPhone 6, 7, & 8, X. Switches to 1 column layout instead of 2 columns layout when this point is reached.
        const phoneMinWidth = 375;
        const columnAdaptiveWidth = that.adaptivityMode.adaptiveLayout.enabled && gridWidth <= adaptiveWidth ? (gridWidth >= phoneMinWidth ? '50%' : '100%') : null;

        let columnsComputedWidth = 0;
        let columnsWithAutoWidth = [];
        let nearWidth = 0;
        let farWidth = 0;
        let columnsWidth = 0;

        that._adaptiveLayout = 0;

        if (columnAdaptiveWidth) {
            if (columnAdaptiveWidth === '50%') {
                that._adaptiveLayout = 2;
            }
            else {
                that._adaptiveLayout = 1;
            }
        }

        that._responsiveLayout = false;

        for (let i = that.viewColumns.length - 1; i >= 0; i--) {
            const column = that.viewColumns[i];

            if (column.adaptiveVisible) {
                that._responsiveLayout = that.adaptivityMode.responsiveLayout.enabled && gridWidth <= responsiveWidth && that._adaptiveLayout === 0;
                break;
            }
        }

        if (that.editing.enabled && that.editing.commandColumn.visible && !that.editing.commandColumn.inline) {
            const measureColumnWidth = function () {
                const header = document.createElement('div');
                const columnHeaderCellContentElement = document.createElement('div');
                const dataSource = that.editing.commandColumn.dataSource;

                let width = 0;
                let commandsHTML = '';
                let visibleColumnsLength = 0;

                columnHeaderCellContentElement.classList.add('jqx-label');

                for (let item in dataSource) {
                    const properties = dataSource[item];

                    let checkedVisibility = false;

                    if (item === 'commandColumnMenu') {
                        continue;
                    }

                    let visible = false;

                    if (!checkedVisibility) {
                        if (properties.visible === true) {
                            visibleColumnsLength++;
                            visible = true;
                        }
                        else if (properties.visible === 'auto') {
                            if (((!that.editing.editRow && !that.editing.editCell) || that.editing.dialog.enabled) && item === 'commandColumnEdit') {
                                visibleColumnsLength++;
                                visible = true;
                            }
                            else if ((that.editing.editRow || that.editing.editCell) && !that.editing.dialog.enabled) {
                                if (item === 'commandColumnUpdate') {
                                    visibleColumnsLength++;
                                    visible = true;
                                }
                                else if (item === 'commandColumnCancel') {
                                    visibleColumnsLength++;
                                    visible = true;
                                }
                            }
                        }

                        checkedVisibility = true;
                    }

                    if (visible && that.editing.commandColumn.displayMode !== 'icon') {
                        const label = properties.label === '{{messages}}' ? that.localize(item) : properties.label;

                        commandsHTML += '<span>' + label + '</span>';
                    }
                }

                columnHeaderCellContentElement.innerHTML = '<span>' + commandsHTML + '</span>';
                header.appendChild(columnHeaderCellContentElement);
                header.style.width = 'auto';
                header.style.position = 'static';
                that.$.columnHeader.appendChild(header);
                width = 10 + columnHeaderCellContentElement.firstChild.offsetWidth;
                that.$.columnHeader.removeChild(header);

                if (that.editing.commandColumn.displayMode === 'icon') {
                    width = 20 + (visibleColumnsLength * 20);
                }
                else if (that.editing.commandColumn.displayMode === 'labelAndIcon') {
                    width += (visibleColumnsLength * 25)
                }
                else {
                    width += visibleColumnsLength * 10;
                }

                return width;
            }

            const width = that.editing.commandColumn.width ? that.editing.commandColumn.width : measureColumnWidth();

            that.columns.canNotify = false;
            that._commandColumn.width = width;
            that.columns.canNotify = true;
        }

        for (let i = 0; i < that.viewColumns.length; i++) {
            const viewColumn = that.viewColumns[i];
            const column = viewColumn;
            //     const columnByDataField = that.columnByDataField[viewColumn.dataField];
            //     const column = columnByDataField ? columnByDataField : viewColumn;

            let width;

            if (columnAdaptiveWidth) {
                width = parseFloat(columnAdaptiveWidth) / 100;
                width *= gridWidth;
                column.computedWidth = width;
                continue;
            }

            if (typeof column.width === 'number') {
                width = column.width;
            }
            else if (column.width && column.width.toString().indexOf('%') >= 0) {
                width = parseFloat(column.width) / 100;
                width *= (gridWidth - checkBoxesIndent);
            }
            else if (column.visible) {
                columnsWithAutoWidth.push(column);
                width = 0;
            }

            if (column.overflowWidth) {
                width -= column.overflowWidth;
            }

            if (column.visible && !column.adaptiveVisible) {
                columnsComputedWidth += width;
            }

            if (width < column.minWidth) {
                width = column.minWidth;
            }

            column.computedWidth = width;
        }

        if (columnsWithAutoWidth) {
            let autoWidth = gridWidth - columnsComputedWidth;
            let computedAutoWidth = 0;

            if (autoWidth < 0) {
                autoWidth = columnsWithAutoWidth.length * 60;
            }

            for (let i = 0; i < columnsWithAutoWidth.length; i++) {
                const column = columnsWithAutoWidth[i];
                let width;

                width = autoWidth / columnsWithAutoWidth.length;

                if (i === columnsWithAutoWidth.length - 1) {
                    width = autoWidth - computedAutoWidth;
                }

                if (column.overflowWidth) {
                    width -= column.overflowWidth;
                }

                if (width < column.minWidth) {
                    width = column.minWidth;
                }

                column.computedWidth = width;
                computedAutoWidth += width;
            }
        }

        for (let i = 0; i < that.viewColumns.length; i++) {
            const viewColumn = that.viewColumns[i];
            let column = viewColumn; //viewColumn.autoGenerated ? viewColumn : that.columnByDataField[viewColumn.dataField];

            if (!column.visible || column.adaptiveVisible) {
                continue;
            }

            if (indent > 0 && !column.autoGenerated) {
                column.computedWidth += indent;
                indent = 0;
            }

            if (column.freeze) {
                if (column.freeze === true || column.freeze === 'near') {
                    column.left = nearWidth;
                    columnsWidth += column.computedWidth;
                    nearWidth += column.computedWidth;
                }
                else if (column.freeze === 'far') {
                    column.left = farWidth;
                    farWidth += column.computedWidth;
                }
            }
            else {
                column.left = columnsWidth;
                columnsWidth += column.computedWidth;
            }
        }

        for (let j = 0; j < that._columnGroupsLevel - 1; j++) {
            for (let i = 0; i < that.columnGroups.length; i++) {
                const group = that.columnGroups[i];
                const level = group.level;

                if (level !== j) {
                    continue;
                }

                let left = 99999;

                if (group.groups) {
                    const getWidth = function (group) {
                        let width = 0;
                        for (let j = 0; j < group.groups.length; j++) {
                            let currentGroup = group.groups[j];
                            if (!currentGroup.groups) {
                                if (!currentGroup.hidden) {
                                    left = Math.min(currentGroup.left, left);
                                    width += currentGroup.computedWidth;
                                }
                            }
                            else {
                                width += getWidth(currentGroup);
                            }
                        }
                        return width;
                    }

                    group.computedWidth = getWidth(group);
                    group.left = left;
                }
            }
        }
    }


    _createColumnHeaderCellElements() {
        const that = this;
        const columnContainer = that.$.columnContainer;
        const fragment = document.createDocumentFragment();

        let columnsWidth = 0;
        that._columnElements = [];
        that.$.columnContainer.innerHTML = '';
        that.$.columnNearContainer.innerHTML = '';
        that.$.columnFarContainer.innerHTML = '';

        for (let i = 0; i < that._frozenNearColumns.length; i++) {
            const column = that._frozenNearColumns[i];

            column.createElement();
        }

        for (let i = 0; i < that._frozenFarColumns.length; i++) {
            const column = that._frozenFarColumns[i];

            column.createElement();
        }

        for (let i = 0; i < that.viewColumns.length; i++) {
            const column = that.viewColumns[i];

            if (column.freeze) {
                continue;
            }

            const header = column.createElement();

            if (column.computedWidth === undefined) {
                that._columnElements.push(header);
                fragment.appendChild(header);
                continue;
            }

            columnsWidth += column.computedWidth;

            that._columnElements.push(header);

            if (columnsWidth < 2 * that._clientSize.width) {
                fragment.appendChild(header);
            }
        }

        for (let i = 0; i < that.columnGroups.length; i++) {
            const group = that.columnGroups[i];
            const groupColumn = new JQX.Grid.Column({ visible: group.visible !== undefined ? group.visible : true, allowSelect: false, grid: that, dataField: group.name, label: group.label, align: group.align, verticalAlign: group.verticalAlign });

            group.column = groupColumn;

            const header = groupColumn.createElement();

            header.style.width = group.computedWidth + 'px';
            header.style.left = group.left + 'px';
            header.style.top = group.top + 'px';
            header.style.height = group.computedHeight + 'px';
            header.style.lineHeight = group.computedHeight + 'px';

            fragment.appendChild(header);

            group.element = header;
            group.grid = this;
        }

        if (!that.htmlColumnLastChild) {
            that.htmlColumnLastChild = document.createElement('jqx-grid-column');
            that.htmlColumnLastChild.classList.add('top-far-corner');
            that.$.columnHeader.appendChild(that.htmlColumnLastChild);
        }

        columnContainer.appendChild(fragment);
        columnContainer.style.width = that._computedColumnsWidth + 'px';

        that._refreshFrozenColumns();
    }

    _refreshFrozenColumns() {
        const that = this;

        that.$.columnNearContainer.style.width = that._frozenColumnsNearWidth + 'px';
        that.$.columnFarContainer.style.width = that._frozenColumnsFarWidth + 'px';

        for (let i = 0; i < that.columnGroups.length; i++) {
            const columnGroup = that.columnGroups[i];

            if (columnGroup.freeze && columnGroup.element) {
                if (columnGroup.freeze === true || columnGroup.freeze === 'near') {
                    that.$.columnNearContainer.appendChild(columnGroup.element);
                }
                else if (columnGroup.freeze === 'far') {
                    that.$.columnFarContainer.appendChild(columnGroup.element);
                }
            }
        }

        for (let i = 0; i < that.viewColumns.length; i++) {
            const column = that.viewColumns[i];

            if (column.freeze && column.element) {
                if (column.freeze === true || column.freeze === 'near') {
                    that.$.columnNearContainer.appendChild(column.element);
                }
                else if (column.freeze === 'far') {
                    that.$.columnFarContainer.appendChild(column.element);
                }
            }
        }
    }

    get _clientSize() {
        const that = this;

        if (that.__clientSize) {
            return that.__clientSize;
        }

        const computedStyle = getComputedStyle(that.$.container);

        const paddingX = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
        const paddingY = parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);

        const borderX = parseFloat(computedStyle.borderLeftWidth) + parseFloat(computedStyle.borderRightWidth);
        const borderY = parseFloat(computedStyle.borderTopWidth) + parseFloat(computedStyle.borderBottomWidth);

        that.__clientSize = {
            width: that.$.container.offsetWidth - paddingX - borderX, height: that.$.container.offsetHeight - paddingY - borderY
        };

        return that.__clientSize;
    }

    _initializeRowElements() {
        const that = this;

        if (!that.rows) {
            return;
        }

        that.rows.canNotify = false;

        let rowsHeight = 0;
        let height = that._clientSize.height;

        that.$.rowNearContainer.innerHTML = '';
        that.$.rowFarContainer.innerHTML = '';
        that.$.rowContainer.innerHTML = '';
        that._rowElements = [];
        that._overflowOffset = Math.max(height, 300);

        const offsetHeight = that.offsetHeight;
        that.$.container.classList.add('jqx-hidden');

        const newOffsetHeight = that.offsetHeight;
        that.$.container.classList.remove('jqx-hidden');

        if (that.verticalScrollBarVisibility === 'hidden' || (offsetHeight !== newOffsetHeight)) {
            height = that._scrollHeight;
        }

        const createRecyclingRows = function () {
            const documentFragment = document.createDocumentFragment();

            if ((that.rows && that.rows.length === 0)) {
                return;
            }

            for (let i = 0; i < that.rows.length; i++) {
                const row = that.rows[i];

                if (row.freeze) {
                    continue;
                }

                const rowElement = row.createElement();

                documentFragment.appendChild(rowElement);
                rowsHeight += that.rowMinHeight;

                if (rowsHeight > that._overflowOffset + height) {
                    break;
                }
            }

            that.$.rowContainer.appendChild(documentFragment);

            const rowElements = that.$.rowContainer.children;

            for (let i = 0; i < rowElements.length; i++) {
                const rowElement = rowElements[i];

                if (that.rows[i]) {
                    that.rows[i].element = rowElement;
                }

                that._rowElements[i] = rowElement;
            }
        }

        for (let i = 0; i < that._frozenNearRows.length; i++) {
            const row = that._frozenNearRows[i];
            const element = row.createElement();

            row.element = element;
            that.$.rowNearContainer.appendChild(element);
        }

        for (let i = 0; i < that._frozenFarRows.length; i++) {
            const row = that._frozenFarRows[i];
            const element = row.createElement();

            row.element = element;
            that.$.rowFarContainer.appendChild(element);
        }

        createRecyclingRows();

        let maxIterations = 0;

        while (rowsHeight < 1.5 * height && ++maxIterations < 50) {
            createRecyclingRows();
        }

        that.rows.canNotify = true;
    }

    _initializeRows() {
        const that = this;

        let frozenIndex = 0;
        that._frozenNearDefaultRows = [];
        that._frozenFarDefaultRows = [];
        that.rows = [];
        that.rowById = [];

        that._frozenFarRows = [];
        that._frozenNearRows = [];

        const calculateSummary = function () {
            let summaryObject = [];
            let hasSummary = false;

            for (let i = 0; i < that.columns.length; i++) {
                const column = that.columns[i];
                let columnSummary = {
                };

                if (column.summary && column.summary.length > 0) {
                    hasSummary = true;
                }

                columnSummary[column.dataField] = column.summary;
                summaryObject.push(columnSummary);

            }

            if (!hasSummary) {
                that._summaryItems = [];
                return;
            }

            that._summaryItems = that.dataSource.summarize(summaryObject);
        }

        const addNewRow = function (data, index) {
            const row = data.grid ? data : new JQX.Grid.Row({ data: data, index: index, grid: that });

            if (that.onRowInit) {
                that.onRowInit(index, row);
                for (let propertyName in row) {
                    if (row.properties.indexOf(propertyName) === -1 && !propertyName.startsWith('_')) {
                        that.error(that.localize('invalidRowProperty', { elementType: 'Grid', propertyName: propertyName }));
                    }
                }
            }

            if (row.selected) {
                that._selection.rows[row.id] = true;
            }

            if (row.freeze) {
                if (row.freeze === true || row.freeze === 'near') {
                    that.rows.splice(frozenIndex++, 0, row);
                    that._frozenNearRows.push(row);
                }
                else if (row.freeze === 'far') {
                    that._frozenFarRows.push(row);
                    that.rows.push(row);
                }
            }
            else {
                if (that.rows[index]) {
                    that.rows.splice(index, 0, row);
                }
                else {
                    that.rows.push(row);
                }
            }

            if (that.scrollMode === 'virtual' || (that.paging.enabled && that.dataSource && that.dataSource.virtualDataSource)) {
                return;
            }

            if (that.onRowInserted) {
                that.onRowInserted(index, row);
            }
        }

        const removeLastRow = function () {
            const lastRow = that.rows[that.rows.length - 1];

            that.rows.pop();

            if (that.onRowRemoved) {
                that.onRowRemoved(that.rows.length, lastRow);
            }
        }

        const removeAt = function (index) {
            const row = that.rows[index];

            that.rows.splice(index, 1);

            if (that.onRowRemoved) {
                that.onRowRemoved(index, row);
            }
        }

        that._add = addNewRow;
        that._removeLastRow = removeLastRow;
        that._removeAt = removeAt;

        that._rowHeight = that._autoRowHeight;

        const dataSourceLength = that.dataSource.length;

        for (let i = 0; i < that.dataSource.length; i++) {
            const data = that.dataSource[i];

            addNewRow(data, i);
        }

        for (let i = 0; i < that._frozenFarRows.length; i++) {
            const row = that._frozenFarRows[i];

            that.rows.splice(that.rows.indexOf(row), 1);
            that.rows.push(row);
        }

        calculateSummary();

        that.dataSource.notify(function (changes) {
            if (that.dataSource._updating) {
                return;
            }

            const data = changes.data;

            that.rows.canNotify = false;

            switch (changes.action) {
                case 'add':
                    if (data.length) {
                        for (let i = 0; i < data.length; i++) {
                            addNewRow(data[i], that.dataSource.length - data.length + i);
                        }
                    }
                    else {
                        addNewRow(data, that.dataSource.length - 1);
                    }

                    break;
                case 'update':
                    if (data.length) {
                        for (let i = 0; i < data.length; i++) {
                            const index = changes.index[i];

                            if (!that.rows[index]) {
                                addNewRow(data[i], that.dataSource.length - 1);
                                continue;
                            }

                            that.rows[index].data = data[i];

                            if (that.onRowUpdated) {
                                that.onRowUpdated(index, that.rows[index]);
                            }
                        }
                    }
                    else {
                        const index = changes.index;

                        if (!that.rows[index]) {
                            addNewRow(data, that.dataSource.length - 1);
                        }
                        else {
                            that.rows[index].data = data;
                        }

                        if (that.onRowUpdated) {
                            that.onRowUpdated(index, that.rows[index]);
                        }
                    }
                    break;
                case 'insert':
                    addNewRow(data, changes.index);

                    for (let i = 0; i < that.rows.length; i++) {
                        const row = that.rows[i];

                        row.index = i;
                    }
                    break;
                case 'remove':
                    removeAt(changes.index);
                    break;
                case 'removeLast':
                    removeLastRow();
                    break;
                case 'bindingComplete':
                    if (that.dataSource && that.dataSource.url) {
                        that.displayLoadingIndicator = false;
                        that._setLoadingIndicatorVisibility();
                        that._toggledRow = null;

                        if (that.dataSource.length !== dataSourceLength) {
                            if (that.paging.enabled) {
                                that.$.headerPager.querySelector('jqx-pager').pagesCount = Math.ceil(that.dataSource.length / that.paging.pageSize);
                                that.$.footerPager.querySelector('jqx-pager').pagesCount = Math.ceil(that.dataSource.length / that.paging.pageSize);
                            }

                            that._initializeRows();
                            that._initializeRowElements();

                            that.refresh();
                        }

                        that._recycle();
                    }
                    break;
            }

            calculateSummary();

            if (changes.action !== 'update') {
                that._refreshLayout();
            }

            that._recycle();

            that.rows.canNotify = true;
        });


        that._observeRows();

        if (that.summaryRow.visible) {
            for (let i = 0; i < that._summaryRowCount; i++) {
                const summaryNearRow = new JQX.Grid.Row({ freeze: 'near', visible: that.summaryRow.position === 'near', summaryRowIndex: i, summaryRow: true });
                const summaryFarRow = new JQX.Grid.Row({ freeze: 'far', visible: that.summaryRow.position === 'far', summaryRowIndex: i, summaryRow: true });

                that._frozenNearRows.splice(0, 0, summaryNearRow);
                that._frozenFarRows.push(summaryFarRow);
            }
        }

        if (that.filtering.enabled && that.filtering.filterRow.visible) {
            const row = new JQX.Grid.Row({ freeze: 'near', filterRow: true });

            that._frozenNearRows.splice(0, 0, row);
        }

        that._renderAddNewRow();
    }

    _observeRows() {
        const that = this;

        const observables = {
            'allowToggle': true, 'allowResize': true, 'expanded': true, 'selected': true, 'visible': true, 'enabled': true, 'minHeight': true, 'height': true, 'freeze': true, 'showDetail': true, 'data': true, 'visibleIndex': true, 'index': true
        }

        that._frozenNearRows = [];
        that._frozenFarRows = [];

        that.rows = new JQX.ObservableArray(that.rows, null, observables);

        for (let i = 0; i < that.rows.length; i++) {
            const row = that.rows[i];

            if (row.freeze === true || row.freeze === 'near') {
                that._frozenNearRows.push(row);
            }
            else if (row.freeze === 'far') {
                that._frozenFarRows.push(row);
            }

            that.rowById[that.rows[i].id] = row;
        }

        const rowPropertyChanged = function (row, propertyName, oldValue, newValue) {
            row.propertyChanged(propertyName, oldValue, newValue);
        }

        that.rows.notify(function (changes) {
            if (!that.rows.canNotify) {
                return;
            }

            const changeType = changes.action;

            if (changeType === 'length') {
                return;
            }

            if (changes.path) {
                that.rows.canNotify = false;
                rowPropertyChanged(changes.target, changes.propertyName, changes.oldValue, changes.newValue);
                that.rows.canNotify = true;
                return;
            }

            that.rows.canNotify = false;

            if (!that.dataSource) {
                return;
            }

            that.dataSource.canNotify = false;

            switch (changeType) {
                case 'add': {
                    const addRow = function (index) {
                        let row = that.rows[index];

                        if (row instanceof JQX.Grid.Row === false) {
                            row = new JQX.Grid.Row(row);

                            const notify = that.rows.canNotify;
                            that.rows.canNotify = false;
                            changes.object[index] = row;
                            row = changes.object[index];
                            that.rows.canNotify = notify;
                        }

                        if (index < that.dataSource.length) {
                            that.dataSource.insert(index, that.rows[index].data);

                        }
                        else {
                            that.dataSource.add(that.rows[index].data);
                        }

                        row.grid = that;
                        row.data = that.dataSource[index];

                        that.rowById[row.id] = row;


                        if (row.selected) {
                            that._selection.rows[row.id] = true;
                        }

                        if (row.freeze) {
                            if (row.freeze === true || row.freeze === 'near') {
                                that._frozenNearRows.push(row);
                            }
                            else if (row.freeze === 'far') {
                                that._frozenFarRows.push(row);
                            }
                        }
                    }

                    for (let i = 0; i < changes.addedCount; i++) {
                        addRow(changes.index + i);
                    }

                    break;
                }
                case 'update': {
                    that.dataSource.update(changes.index, that.rows[changes.index]);
                    break;
                }
                case 'remove': {
                    const row = changes.removed;

                    delete that.rowById[row.id];

                    that.dataSource.remove(changes.index);
                    break;
                }
            }



            that.dataSource.canNotify = true;
            that.rows.canNotify = true;

            if (!changeType) {
                return;
            }

            const fullRefresh = that.isInitialized && that._rowElements && that._rowElements.length < that.rows.length;

            if (fullRefresh) {
                that._initializeRowElements();
            }

            that.refresh();
            that._refreshPagesCount();
        });
    }

    render() {
        const that = this;

        that._render();
    }

    _renderColumns(refresh) {
        const that = this;

        that._initializeColumns();
        that._initializeColumnGroupsHierarchy();
        that._refreshColumnsResponsiveVisibility();
        that._createColumnHeaderCellElements();
        that._renderColumnGroupHeaders();

        if (refresh !== false) {
            that._refresh();
        }
    }

    _renderRows(refresh) {
        const that = this;

        that._initializeRows();
        that._initializeRowElements();

        if (refresh !== false) {
            that._refresh();
        }
    }

    _render() {
        const that = this;


        if (!that.isInitialized) {
            if (that.onBeforeInit) {
                that.onBeforeInit();
            }

            that.$.fireEvent('beforeInit', {
                'grid': that
            });
        }

        if (that.dataSource === null) {
            that.dataSource = new JQX.DataAdapter();
        }

        that._selection = {
            rows: [],
            columns: [],
            cells: []
        };

        if (that.dataSource && that.dataSource.url) {
            that.displayLoadingIndicator = true;
            that._setLoadingIndicatorVisibility();

            that.dataSource.data = {
                sorting: that.getSortedColumns(),
                filtering: that.getFilteredColumns(),
                grouping: []
            }
        }

        that._renderColumns(false);
        that._renderRows(false);
        that._renderPagers();
        that._renderCommandBar();

        if (that.appearance.allowColumnStickyPosition) {
            that._stickHeader();
        }

        if (!that.isInitialized) {
            for (let i = 0; i < that.viewColumns.length; i++) {
                const column = that.viewColumns[i];

                if (!column.allowSort || !column.sortOrder) {
                    continue;
                }

                const sortAnimation = that.appearance.allowSortAnimation;

                that.appearance.allowSortAnimation = false;
                that.sortBy(column.dataField, column.sortOrder);
                that.appearance.allowSortAnimation = sortAnimation;
            }

            if (that.filtering.filter.length > 0) {
                for (let j = 0; j < that.filtering.filter.length; j++) {
                    const filter = that.filtering.filter[j];

                    if (filter) {
                        const dataField = filter[0];
                        const filterExpression = filter.splice(1);
                        let filterGroup = null;

                        if (filterExpression instanceof JQX.FilterGroup) {
                            filterGroup = filterExpression;
                        }
                        else {
                            const column = that.columnByDataField[dataField];

                            if (column) {
                                filterGroup = that.dataSource._createFilter(column.dataType, filterExpression);
                            }
                        }

                        if (filterGroup) {
                            that.addFilter(dataField, filterGroup, false);
                        }
                    }
                }

                that.refreshFilters();
            }
        }
        else {
            that.refreshFilters();
        }

        that.viewColumns.canNotify = true;


        if (!that.isInitialized) {
            if (that.onInit) {
                that.onInit();
            }

            that.$.fireEvent('init', {
                'grid': that
            });
        }

        that.isInitialized = true;

        if (that.scrollMode === 'virtual' || (that.paging.enabled && that.dataSource && that.dataSource.virtualDataSource)) {
            that._virtualDataRequest('dataBind');
        }
        else if (that.dataSource && that.dataSource.virtualDataSource) {
            that._virtualDataRequest('dataBind');
        }

        if (that.header.template !== '') {
            that._applyTemplate(that.header.template, that.$.header);
        }

        if (that.footer.template !== '') {
            that._applyTemplate(that.footer.template, that.$.footer);
        }

        that._createFilterPanels();
        that._refresh();
        that._applyScrollMode();


        if (that.onRender) {
            that.onRender();
        }
    }

    _refreshPagesCount() {
        const that = this;

        const getPagesCount = function () {
            const visibleRows = that.getVisibleRows();

            let rowsCount = visibleRows.length;

            if (that.rowHierarchy) {
                rowsCount = 0;

                for (let i = 0; i < visibleRows.length; i++) {
                    const row = visibleRows[i];

                    if (row.level === 0 && !row.parent) {
                        rowsCount++;
                    }
                }

                if (that.dataSource.virtualDataSourceLength) {
                    rowsCount = that.dataSource.virtualDataSourceLength;
                }
            }

            return Math.ceil(rowsCount / that.paging.pageSize);
        }

        const headerPager = that.$.headerPager.querySelector('jqx-pager');
        const pagesCount = getPagesCount();

        if (headerPager) {
            headerPager.pagesCount = pagesCount;
        }

        const footerPager = that.$.footerPager.querySelector('jqx-pager');

        if (headerPager) {
            footerPager.pagesCount = pagesCount;
        }

        if (that.paging.pageIndex > pagesCount) {
            that.paging.pageIndex = pagesCount - 1;
            that._refreshPaging(that.paging.pageIndex);
        }
    }

    get _viewRows() {
        const that = this;

        if (that.__viewRows) {
            return that.__viewRows;
        }

        if (!that._nearRowsAdded) {
            that._nearRowsAdded = [];
            that._farRowsAdded = [];
        }

        const viewRows = !that.rowHierarchy ? that.rows.toArray() : that.rowHierarchy;

        const rows = [].concat(that._frozenNearDefaultRows, that._nearRowsAdded, viewRows, that._farRowsAdded, that._frozenFarDefaultRows);

        that.__viewRows = rows;

        return rows;
    }

    _stickHeader() {
        const that = this;

        const handler = function () {
            that._handleStickyHeader();
        }

        that.$.columnHeader.style.top = '';
        that.$.columnHeader.classList.remove('jqx-columns-sticky');

        let parent = that.parentNode;

        while (parent !== document) {
            parent.addEventListener('scroll', handler);

            parent = parent.parentNode;
        }

        try {
            if (window.top !== null && window.top !== window.self) {
                window.top.document.addEventListener('scroll', handler);
            }
        }
        catch (error) {
            //
        }

        that._handleStickyHeader();
    }

    _unstickHeader() {
        const that = this;

        that.$.columnHeader.style.top = '';
        that.$.columnHeader.classList.remove('jqx-columns-sticky');

        const handler = function () {
            that._scrollHandler();
        }

        let parent = that.parentNode;

        while (parent !== document.body) {
            parent.removeEventListener('scroll', handler);

            parent = parent.parentNode;
        }

        try {
            if (document.referrer !== '' || window.frameElement) {
                if (window.top !== null && window.top !== window.self) {
                    window.top.document.removeEventListener('scroll', handler);
                }
            }
        }
        catch (error) {
            //
        }
    }
    _handleStickyHeader() {
        const that = this;

        if (!that.appearance.allowColumnStickyPosition) {
            return;
        }

        that.$.columnHeader.classList.add('jqx-columns-sticky');

        if (document.scrollTop === 0 && that.parentElement.scrollTop === 0) {
            that.$.columnHeader.style.top = '';
        }
        else {
            let parent = that.parentNode;

            let top = 0;

            while (parent !== document.body) {
                top += parseInt(parent.scrollTop);

                parent = parent.parentNode;
            }

            const headerTop = parseInt(that.clientTop + top);

            that.$.columnHeader.style.top = headerTop + 'px';

            let frameTop = 0;

            if (window.top !== window.self) {
                if (parseInt(window.top.scrollY) > parseInt(that._offsetTop(window.frameElement))) {
                    frameTop = parseInt(window.top.scrollY) - parseInt(that._offsetTop(window.frameElement));
                }
            }

            if (window.scrollY + frameTop > that.offsetTop) {
                that.$.columnHeader.style.top = parseInt(window.scrollY) - parseInt(that.offsetTop) + headerTop + frameTop + 'px';
            }
        }
    }

    _scrollHandler() {
        const that = this;

        that._handleStickyHeader();
    }

    _initializeRowNumberColumn() {
        const that = this;

        if (that._frozenNearColumns && that._frozenNearColumns.length > 0 && that._frozenNearColumns[0].rowNumbersColumn) {
            that._frozenNearColumns[0].visible = that.appearance.showRowNumber || that.appearance.showRowHeader;
            return;
        }

        const measureColumnWidth = function () {
            const header = document.createElement('div');
            const columnHeaderCellContentElement = document.createElement('div');
            const rowsLength = that.rows ? that.rows.length : that.dataSource ? that.dataSource.length : 0;

            let width = 0;

            columnHeaderCellContentElement.classList.add('jqx-label');
            columnHeaderCellContentElement.innerHTML = '<span>' + rowsLength + '</span>';
            header.appendChild(columnHeaderCellContentElement);
            header.style.width = 'auto';
            header.style.position = 'static';
            that.$.columnHeader.appendChild(header);
            width = 20 + columnHeaderCellContentElement.firstChild.offsetWidth;
            that.$.columnHeader.removeChild(header);

            return Math.max(30, width);
        }

        const width = that.appearance.showRowNumber ? measureColumnWidth() : 30;
        const column = new JQX.Grid.Column({ dataField: '_rowHeaderColumn', label: '', allowSelect: false, freeze: true, visible: true, grid: that, autoGenerated: true, rowNumbersColumn: true, cellsAlign: 'center', width: width });

        column.createElement();

        const observableColumn = new JQX.Observable(column, column.observables);

        that.viewColumns.splice(0, 0, observableColumn);
        that._frozenNearColumns.splice(0, 0, observableColumn);

    }

    _initializeColumns() {
        const that = this;

        if (typeof that.columns === 'number') {
            const boundColumns = [];

            const charCode = 'A'.charCodeAt(0);
            let prefix = '';
            let index = 0;

            for (let i = 0; i < that.columns; i++) {
                const letter = String.fromCharCode(charCode + index);

                index++;

                const label = prefix + letter;

                boundColumns.push({ align: 'center', label: label, dataField: label, width: 100 })

                if (index >= 26) {
                    index = 0;
                    prefix += 'A';
                }
            }

            that._boundColumns = boundColumns;
        }
        else {
            that._boundColumns = Array.isArray(that.columns) ? that.columns.splice(0) : that.columns.toArray().splice(0);
        }

        that.columnByDataField = [];
        that.viewColumns = [];
        that.columns = new JQX.ObservableArray();

        that._frozenFarColumns = [];
        that._frozenNearColumns = [];
        that._summaryRowCount = 0;
        let frozenIndex = 0;

        const _applyBoundColumnDataType = function (column) {
            if (that.dataSource.dataFields) {
                const field = that.dataSource.dataFields.find(field => {
                    if (field.name === column.dataField) {
                        return field;
                    }
                });

                const dataType = field ? field.dataType || 'string' : 'string';

                column.dataType = dataType;
            }
        }

        if (that._boundColumns.length === 0 && that.dataSource && that.dataSource[0]) {
            const row = that.dataSource[0];

            for (let dataField in row) {
                if (dataField.startsWith('_') || dataField === '$') {
                    continue;
                }

                const index = that._boundColumns.length;
                const column = {
                    index: index, visibleIndex: index, label: dataField, dataField: dataField
                };

                _applyBoundColumnDataType(column);

                that._boundColumns.push(column);
            }
        }

        for (let i = 0; i < that._boundColumns.length; i++) {
            let boundColumn = that._boundColumns[i];

            if (typeof boundColumn === 'string') {
                if (that.dataSource.dataFields) {
                    const field = that.dataSource.dataFields.find(field => {
                        if (field.name === boundColumn) {
                            return field;
                        }
                    });

                    boundColumn = {
                        label: boundColumn, dataField: boundColumn, dataType: field ? field.dataType || 'string' : 'string'
                    };
                }
            }
            else {
                _applyBoundColumnDataType(boundColumn);
            }

            boundColumn.visibleIndex = i;
            boundColumn.index = i;
            boundColumn.grid = that;

            const column = new JQX.Grid.Column(boundColumn);

            if (that.onColumnInit) {
                that.onColumnInit(i, column);
            }

            for (let propertyName in column) {
                if (column.properties.indexOf(propertyName) === -1 && !propertyName.startsWith('_')) {
                    that.error(that.localize('invalidColumnProperty', { elementType: 'Grid', propertyName: propertyName, type: column.dataField || 'Column' }));
                }
            }
            column.grid = that;

            that.columns.push(column);

            const observableColumn = that.columns[that.columns.length - 1];

            that._summaryRowCount = Math.max(that._summaryRowCount, column.summary.length);

            if (column.freeze) {
                if (column.freeze === true || column.freeze === 'near') {
                    that.viewColumns.splice(frozenIndex++, 0, observableColumn);
                    that._frozenNearColumns.push(observableColumn);
                }
                else if (column.freeze === 'far') {
                    that._frozenFarColumns.push(observableColumn);
                }
            }
            else {
                that.viewColumns.push(observableColumn);
            }

            if (!that.columnByDataField[column.dataField]) {
                that.columnByDataField[column.dataField] = observableColumn;
            }
            else {
                observableColumn.parent = that.columnByDataField[column.dataField];
                if (!that.columnByDataField[column.dataField].children) {
                    that.columnByDataField[column.dataField].children = [];
                }

                that.columnByDataField[column.dataField].children.push(observableColumn);
            }

            if (that.onColumnInserted) {
                that.onColumnInserted(i, column);
            }
        }

        that.viewColumns = that.viewColumns.concat(that._frozenFarColumns);

        let autoGeneratedNearColumns = 0;

        if (that.appearance.showRowNumber || that.appearance.showRowHeader) {
            that._initializeRowNumberColumn();
            autoGeneratedNearColumns++;
        }

        if (that.rowDetail.enabled) {
            const column = new JQX.Grid.Column({ dataField: '_rowDetailColumn', allowSelect: false, visible: that.rowDetail.visible, label: '', grid: that, freeze: true, rowDetailColumn: true, autoGenerated: true, cellsAlign: 'center', width: 30 });
            const observableColumn = new JQX.Observable(column, column.observables);

            if (that.rowDetail.position === 'near') {
                column.freeze = 'near';
                observableColumn.freeze = 'near';

                that.viewColumns.splice(autoGeneratedNearColumns, 0, observableColumn);
                that._frozenNearColumns.splice(autoGeneratedNearColumns, 0, observableColumn);
            }
            else {
                that.viewColumns.push(observableColumn);
                that._frozenFarColumns.splice(0, 0, observableColumn);
            }

            autoGeneratedNearColumns++;
        }

        const column = new JQX.Grid.Column({ dataField: '_adaptiveColumn', allowSelect: false, visible: !that.adaptivityMode.responsiveLayout.autoShowHiddenCells, label: '', grid: that, freeze: 'far', adaptiveColumn: true, autoGenerated: true, cellsAlign: 'center', width: 30 });
        const observableColumn = new JQX.Observable(column, column.observables);

        observableColumn.canNotify = false;

        that.viewColumns.push(observableColumn);
        that._frozenFarColumns.splice(0, 0, observableColumn);

        const commandColumn = new JQX.Grid.Column({ dataField: '_commandColumn', allowSelect: false, visible: that.editing.enabled && that.editing.commandColumn.visible && !that.editing.commandColumn.inline, label: '', grid: that, freeze: 'far', commandColumn: true, autoGenerated: true, align: 'center', cellsAlign: 'center', width: '' });
        const observableCommandColumn = new JQX.Observable(commandColumn, commandColumn.observables);

        observableCommandColumn.canNotify = false;

        if (that.editing.commandColumn.position === 'near') {
            commandColumn.freeze = 'near';
            observableCommandColumn.freeze = 'near';

            that.viewColumns.splice(autoGeneratedNearColumns, 0, observableCommandColumn);
            that._frozenNearColumns.splice(autoGeneratedNearColumns, 0, observableCommandColumn);
        }
        else {
            that.viewColumns.push(observableCommandColumn);
            that._frozenFarColumns.splice(0, 0, observableCommandColumn);
        }

        that._commandColumn = observableCommandColumn;

        const selectionColumn = new JQX.Grid.Column({ allowSelect: false, visible: that.selection.enabled && that.selection.checkBoxes.enabled, dataField: '_checkBoxColumn', label: '', freeze: that.selection.checkBoxes.position, grid: that, selectionColumn: true, autoGenerated: true, cellsAlign: 'center', width: 32 });
        const observableSelectionColumn = new JQX.Observable(selectionColumn, selectionColumn.observables);

        if (selectionColumn.freeze === 'near') {
            that.viewColumns.splice(autoGeneratedNearColumns, 0, observableSelectionColumn);
            that._frozenNearColumns.splice(autoGeneratedNearColumns, 0, observableSelectionColumn);
        }
        else {
            that.viewColumns.push(observableSelectionColumn);
            that._frozenFarColumns.splice(0, 0, observableSelectionColumn);
        }

        that._selectionColumn = observableSelectionColumn;
        that._selectionColumn.canNotify = false;
        that._observeColumns();
        that._templateColumns();
    }

    get styleProperties() {
        return ['grid-template-columns'];
    }

    _templateColumns() {
        const that = this;

        const computedStyle = getComputedStyle(that);
        const templateColumns = computedStyle.getPropertyValue('--jqx-grid-template-columns').trim();
        const columnGap = computedStyle.getPropertyValue('--jqx-grid-column-gap').trim();
        const rowGap = computedStyle.getPropertyValue('--jqx-grid-row-gap').trim();

        that._rowGap = parseInt(rowGap);
        that._columnGap = parseInt(columnGap);
        that._maxHeight = parseInt(computedStyle.maxHeight);
        that._minHeight = parseInt(computedStyle.minHeight);

        if (templateColumns !== 'none') {

            let unboundColumnWidths = 0;

            for (let i = 0; i < that.viewColumns.length; i++) {
                if (that.viewColumns[i].autoGenerated) {
                    unboundColumnWidths += that.viewColumns[i].visible ? that.viewColumns[i].width : 0;
                }
            }

            let boundColumnWidths = [];
            const templateColumnsContainer = document.createElement('div');

            templateColumnsContainer.style.display = 'grid';
            templateColumnsContainer.style.gridTemplateColumns = templateColumns;

            for (let i = 0; i < that.columns.length; i++) {
                templateColumnsContainer.innerHTML += '<div></div>';
            }

            templateColumnsContainer.style.width = that.clientWidth - unboundColumnWidths + 'px';

            that.$.root.appendChild(templateColumnsContainer);

            const templateColumnsArray = templateColumns.split(' ');

            for (let i = 0; i < that.columns.length; i++) {
                boundColumnWidths[i] = templateColumnsContainer.children[i].offsetWidth;

                if (templateColumnsArray[i] === 'auto') {
                    boundColumnWidths[i] = 'auto';
                }
            }

            templateColumnsContainer.parentNode.removeChild(templateColumnsContainer);


            let j = 0;

            for (let i = 0; i < that.viewColumns.length; i++) {
                const column = that.viewColumns[i];

                if (column.autoGenerated) {
                    continue;
                }

                if (boundColumnWidths[j]) {
                    column.width = column.templateWidth = boundColumnWidths[j++];
                }
            }
        }
        else {
            for (let i = 0; i < that.viewColumns.length; i++) {
                const column = that.viewColumns[i];

                if (column.autoGenerated) {
                    continue;
                }

                if (column.templateWidth) {
                    column.width = column.templateWidth = 'auto';
                }
            }
        }
    }


    _observeColumns() {
        const that = this;

        const columnPropertyChanged = function (column, propertyName, oldValue, newValue) {
            column.propertyChanged(propertyName, oldValue, newValue);
        }

        for (let i = 0; i < that.viewColumns.length; i++) {
            const column = that.viewColumns[i];

            column.onAction = function () {
                that._openMenu(this);
            }

            if (column.autoGenerated) {
                column.notify(function (changes) {
                    column.canNotify = false;
                    columnPropertyChanged(column, changes.propertyName, changes.oldValue, changes.newValue);
                    column.canNotify = true;
                });
            }
        }

        that.columns.notify(function (changes) {
            let column = null;

            if (changes.path) {
                that.columns.canNotify = false;
                columnPropertyChanged(changes.target, changes.propertyName, changes.oldValue, changes.newValue);
                that.columns.canNotify = true;
                return;
            }

            that.columns.canNotify = false;

            const changeType = changes.action;


            let unboundColumnsCount = 0;

            switch (changeType) {
                case 'length': {
                    that.columns.canNotify = true;
                    return;
                }
                case 'add': {
                    const addColumn = function (columnIndex) {
                        column = changes.object[columnIndex];

                        if (column instanceof JQX.Grid.Column === false) {
                            column = new JQX.Grid.Column(column);

                            const notify = that.columns.canNotify;
                            that.columns.canNotify = false;
                            changes.object[columnIndex] = column;
                            column = changes.object[columnIndex];
                            that.columns.canNotify = notify;
                        }

                        column.grid = that;

                        if (column.freeze) {
                            that._frozenNearColumns.push(column);
                        }
                        else if (column.freeze === 'far') {
                            that._frozenFarColumns.push(column);
                        }

                        let index = that.viewColumns.length - that._frozenFarColumns.length;

                        if (columnIndex < that.columns.length) {
                            that.viewColumns.splice(columnIndex + that._frozenNearColumns.length, 0, column);
                        }
                        else {
                            that.viewColumns.splice(index, 0, column);
                        }

                        if (!that.columnByDataField[column.dataField]) {
                            that.columnByDataField[column.dataField] = column;
                        }
                        else {
                            that.columnByDataField[column.dataField].children.push(column);
                            column.parent = that.columnByDataField[column.dataField];

                            column.valueField = column.dataField;

                            const dataField = column.dataField + '_' + column.parent.children.length;

                            that.columnByDataField[dataField] = column;
                            column.dataField = dataField;
                        }

                        if (that.onColumnInserted) {
                            that.onColumnInserted(columnIndex, column);
                        }
                    }

                    for (let i = 0; i < changes.addedCount; i++) {
                        addColumn(changes.index + i);
                    }

                    break;
                }
                case 'update': {
                    column = changes.object[changes.index];
                    column.grid = that;

                    for (let i = 0; i < changes.index; i++) {
                        if (that.viewColumns[i].autoGenerated) {
                            unboundColumnsCount++;
                        }
                    }

                    that.viewColumns[unboundColumnsCount + changes.index] = column;
                    that.columnByDataField[column.dataField] = column;

                    if (that.onColumnUpdated) {
                        that.onColumnUpdated(changes.index, column);
                    }
                    break;
                }
                case 'remove': {
                    column = changes.removed[0];
                    let index = changes.index;

                    for (let i = 0; i <= index; i++) {
                        if (that.viewColumns[i].autoGenerated) {
                            unboundColumnsCount++;
                        }
                    }

                    that.viewColumns.splice(unboundColumnsCount + index, 1);
                    delete that.columnByDataField[column.dataField];

                    if (that.onColumnRemoved) {
                        that.onColumnRemoved(changes.index, column);
                    }

                    break;
                }
            }

            that._initializeColumnGroupsHierarchy();
            that._refreshColumnsResponsiveVisibility();
            that._createColumnHeaderCellElements();
            that._templateColumns();
            that.refresh();
            that.columns.canNotify = true;
        });
    }

    /**
    * Calculates the width/height of the rows.
    */
    get _scrollWidth() {
        const that = this;

        if (that.__scrollWidth) {
            return that.__scrollWidth;
        }

        let width = 0;

        for (let i = 0; i < that.viewColumns.length; i++) {
            const column = that.viewColumns[i];

            if (!column.visible || column.adaptiveVisible) {
                continue;
            }

            width += column.computedWidth;
        }

        if (that.adaptivityMode.responsiveLayout.enabled) {
            const responsiveWidth = that.adaptivityMode.responsiveLayout.width;
            const scrollViewWidth = 1 + that.$.scrollView.offsetWidth;

            if (scrollViewWidth <= responsiveWidth) {
                return 0;
            }
        }

        if (that.adaptivityMode.adaptiveLayout.enabled) {
            const adaptiveWidth = that.adaptivityMode.adaptiveLayout.width;
            const scrollViewWidth = 1 + that.$.scrollView.offsetWidth;

            if (scrollViewWidth <= adaptiveWidth) {
                return 0;
            }
        }

        width = parseInt(width);
        that.__scrollWidth = width;
        that._scrollView.scrollWidth = width - that._clientSize.width;

        return that.__scrollWidth;
    }



    /**
    * Handles pressed keys.
    
    _handleKeyStrokes(key) {
        const that = this;
        const toFocus = that.selectionMode === 'radioButton' || that.selectionMode === 'checkBox' || that.selectionMode === 'zeroOrMany' || that.selectionMode === 'oneOrMany';
        let rows = that.rows;
    
    
        if (that.disabled || that.readonly) {
            return;
        }
    
        switch (key) {
            case 'ArrowLeft':
            case 'ArrowUp':
                break;
            case 'ArrowRight':
            case 'ArrowDown':
                break;
            case ' ': {
                break;
            }
            case 'Home': {
                break;
            }
            case 'End': {
                break;
            }
            case 'PageUp': {
                break;
            }
            case 'PageDown': {
                break;
            }
        }
    
        that._recycle();
    }
    /**
    * Horizontal Scroll Bar handler
    */
    _horizontalScrollbarHandler() {
        const that = this;

        that.closeMenu();
        that.isScrolling = true;

        requestAnimationFrame(() => {
            that._recycle();
            that.isScrolling = false;
        });
    }

    /**
    * Container mousewheel event handler.
    */
    _mouseWheelHandler(event) {
        const that = this;

        if (that._scrollView.hScrollBar.$.hasClass('jqx-hidden') && that._scrollView.vScrollBar.$.hasClass('jqx-hidden')) {
            return;
        }

        if (!that.disabled && !that._scrollView.vScrollBar.$.hasClass('jqx-hidden')) {
            event.stopPropagation();
            event.preventDefault();
            that._scrollView.scrollTo(that._scrollView.scrollTop + that._getScrollCoefficient(event, that._clientSize.height));
            //            that._scrollView.scrollTop += event.deltaY < 0 ? -100 : 100;

        }
    }

    /**
    * Removes all rows from DOM. 
    */
    clearRows() {
        const that = this;

        that.dataSource = [];
        that.clearSelection();
    }

    dataBind() {
        const that = this;

        that._renderRows();
        if (that.scrollMode === 'virtual' || (that.paging.enabled && that.dataSource && that.dataSource.virtualDataSource)) {
            that._virtualDataRequest('dataBind');
        }
        else if (that.dataSource && that.dataSource.virtualDataSource) {
            that._virtualDataRequest('dataBind');
        }
    }

    refresh(fullRefresh) {
        const that = this;

        if (!that.isInitialized) {
            return;
        }

        if (fullRefresh) {
            that._initializeRows();
            that._initializeRowElements();
        }

        that._refresh();
    }

    _refresh() {
        const that = this;

        if (that._isUpdating) {
            return;
        }

        const vScrollWidth = that.$.verticalScrollBar.offsetWidth;

        that.removeAttribute('grouped');
        that.removeAttribute('tree');

        if (that.grouping.enabled && that.dataSource.groupBy && that.dataSource.groupBy.length > 0) {
            that.setAttribute('grouped', '');
        }
        else if (that.dataSource.boundHierarchy) {
            that.setAttribute('tree', '');
        }

        if (that.isInitialized) {
            // resize columns first, becase we have columns with auto or percentage width depending on the Grid's width.
            that._refreshColumnsResponsiveVisibility();
        }

        // refresh layout and show or hide horizontal/vertical scrollbars..
        that._refreshLayout();

        if (vScrollWidth !== that.$.verticalScrollBar.offsetWidth) {
            that.__scrollWidth = null;
            that._refreshColumnsResponsiveVisibility();
            that._refreshScrollBars();
        }

        that._refreshSelection();
        that._recycle();

        requestAnimationFrame(() => {
            that._width = that.offsetWidth;
            that._height = that.offsetHeight;
        });
    }
    /**
    * Grid resize handler.
    */
    _resizeHandler(event) {
        const that = this;

        if (event.target === that && !that._isUpdatingScrollBars) {
            that._isUpdatingScrollBars = true;

            that._autoHeight = false;
            if (that.$.content) {
                that.$.content.classList.remove('auto-height');
            }

            that.refresh();
            that._isUpdatingScrollBars = false;
        }
    }

    _refreshColumnsResponsiveVisibility() {
        const that = this;

        const responsiveWidth = that.adaptivityMode.responsiveLayout.width;
        const adaptiveWidth = that.adaptivityMode.adaptiveLayout.width;
        const gridWidth = 1 + that.$.scrollView.offsetWidth;
        const columnContainer = that.$.columnContainer;
        const columnNearContainer = that.$.columnNearContainer;
        const columnFarContainer = that.$.columnFarContainer;

        let nearWidth = 0;
        let farWidth = 0;
        let computedColumnsWidth = 0;
        let isTreeColumnSet = false;

        for (let i = 0; i < that.viewColumns.length; i++) {
            const column = that.viewColumns[i];

            column._treeColumn = false;

            if (column.visible && !column.autoGenerated && !isTreeColumnSet) {
                column._treeColumn = true;
                isTreeColumnSet = true;
            }

            column.overflowWidth = undefined;
            column.adaptiveVisible = false;
        }


        that._refreshColumnWidths();

        let autoGeneratedNearWidth = 0;
        let autoGeneratedFarWidth = 0;

        for (let i = 0; i < that.viewColumns.length; i++) {
            const column = that.viewColumns[i];

            if (!column.visible || column.adaptiveVisible) {
                continue;
            }

            if (column.freeze) {
                if (column.freeze === true || column.freeze === 'near') {
                    nearWidth += column.computedWidth;

                    if (column.autoGenerated) {
                        autoGeneratedNearWidth += column.computedWidth;
                    }
                }
                else if (column.freeze === 'far') {
                    farWidth += column.computedWidth;

                    if (column.autoGenerated) {
                        autoGeneratedFarWidth += column.computedWidth;
                    }
                }

            }

            computedColumnsWidth += column.computedWidth;
        }

        columnContainer.style.width = computedColumnsWidth + 'px';
        columnNearContainer.style.width = nearWidth + 'px';
        columnFarContainer.style.width = farWidth + 'px';

        columnFarContainer.classList.remove('jqx-hidden');
        columnNearContainer.classList.remove('jqx-hidden');

        if (farWidth === 0) {
            columnFarContainer.classList.add('jqx-hidden');
        }

        if (nearWidth === 0) {
            columnNearContainer.classList.add('jqx-hidden');
        }

        columnFarContainer.classList.remove('border-collapse');

        if (farWidth === autoGeneratedFarWidth) {
            columnFarContainer.classList.add('border-collapse');
        }

        that._autoGeneratedColumnsNearWidth = autoGeneratedNearWidth;
        that._autoGeneratedColumnsFarWidth = autoGeneratedFarWidth;

        if (that.adaptivityMode.responsiveLayout.enabled || that.adaptivityMode.adaptiveLayout.enabled) {
            const responsiveMode = gridWidth <= responsiveWidth && that.adaptivityMode.responsiveLayout.enabled;
            const adaptiveMode = gridWidth <= adaptiveWidth && that.adaptivityMode.adaptiveLayout.enabled;

            if (responsiveMode || adaptiveMode) {
                for (let i = that.viewColumns.length - 1; i >= 0; i--) {
                    const column = that.viewColumns[i];

                    if (!column.visible || column.freeze) {
                        continue;
                    }

                    if (computedColumnsWidth - column.computedWidth <= gridWidth) {
                        break;
                    }

                    computedColumnsWidth -= column.computedWidth;
                    column.adaptiveVisible = true;
                }

                if (computedColumnsWidth > gridWidth) {
                    let overflowWidth = computedColumnsWidth - gridWidth;

                    let columnIndex = -1;

                    const calculateOverflowWidth = function (overflowWidth) {
                        for (let i = that.viewColumns.length - 1; i >= 0; i--) {
                            const column = that.viewColumns[i];

                            if (!column.visible || column.freeze) {
                                continue;
                            }

                            if (column.adaptiveVisible) {
                                continue;
                            }

                            if (columnIndex === -1) {
                                columnIndex = i;
                            }

                            const width = column.computedWidth - overflowWidth;

                            if (width < column.minWidth) {
                                const maxOverflowColumnWidth = column.computedWidth - column.minWidth;

                                column.overflowWidth = maxOverflowColumnWidth;
                                overflowWidth -= maxOverflowColumnWidth;
                            }
                            else {
                                column.overflowWidth = overflowWidth;

                                return 0;
                            }
                        }

                        return overflowWidth;
                    }

                    overflowWidth = calculateOverflowWidth(overflowWidth);

                    if (overflowWidth > 0 && columnIndex !== -1) {
                        const column = that.viewColumns[columnIndex];

                        computedColumnsWidth -= column.computedWidth;
                        column.adaptiveVisible = true;

                        overflowWidth = computedColumnsWidth - gridWidth;
                        calculateOverflowWidth(overflowWidth);

                    }

                    that._refreshColumnWidths();
                    computedColumnsWidth = gridWidth;
                }
            }
        }

        that._computedColumnsWidth = computedColumnsWidth;
        that._frozenColumnsNearWidth = nearWidth;
        that._frozenColumnsFarWidth = farWidth;
    }

    /**
    * Document select start handler.
    */
    _selectStartHandler(event) {
        const that = this;

        if (that.isScrolling || that.editing.isEditing) {
            return;
        }

        event.preventDefault();
    }

    /**
    * Set tabIndex.
    */
    setFocusable(focusable) {
        const that = this;

        if (that.disabled || !focusable) {
            that.removeAttribute('tabindex');
            return;
        }

        that.tabIndex = 0;
    }

    /**
    * Set Loading Indicator Visibility
    */
    _setLoadingIndicatorVisibility() {
        const that = this;

        if (that.displayLoadingIndicator) {
            that.$.loadingIndicatorContainer.classList.remove('jqx-visibility-hidden');
            return;
        }

        that.$.loadingIndicatorContainer.classList.add('jqx-visibility-hidden');
    }

    _refreshElementsVisibility() {
        const that = this;

        const setVisibility = function (element, visible) {
            visible ? element.classList.remove('jqx-hidden') : element.classList.add('jqx-hidden');
        }

        setVisibility(that.$.placeholder, (!that.rows) || (that.rows && that.rows.length === 0) || (that.columns.length === 0));
        setVisibility(that.$.footer, that.footer.visible);
        setVisibility(that.$.header, that.header.visible);
        setVisibility(that.$.groupHeader, that.groupHeader.visible);
        setVisibility(that.$.columnHeader, that.columnHeader.visible && !that._adaptiveLayout && that.columns.length > 0);
        setVisibility(that.$.headerCommandBar, that.editing.commandBar.visible && that.editing.enabled && that.editing.commandBar.position !== 'far');
        setVisibility(that.$.footerCommandBar, that.editing.commandBar.visible && that.editing.enabled && that.editing.commandBar.position !== 'near');

        that.htmlColumnLastChild.classList.add('jqx-visibility-hidden');

        if (that.pager && that.pager.visible && that.paging.enabled) {
            switch (that.pager.position) {
                case 'near':
                    setVisibility(that.$.headerPager, true);
                    setVisibility(that.$.footerPager, false);
                    break;
                case 'far':
                    setVisibility(that.$.headerPager, false);
                    setVisibility(that.$.footerPager, true);
                    break;
                case 'both':
                    setVisibility(that.$.headerPager, true);
                    setVisibility(that.$.footerPager, true);
                    break;
            }
        }
        else {
            setVisibility(that.$.footerPager, false);
            setVisibility(that.$.headerPager, false);
        }

        that._refreshRowHierarchy();
    }

    _refreshRowHierarchy() {
        const that = this;

        that.rowHierarchy = null;

        if (!that.grouping.enabled && that.dataSource.groupBy && that.dataSource.groupBy.length > 0) {
            return;
        }

        if (that.dataSource.boundHierarchy) {
            const reservedNames = that.dataSource.reservedNames;

            const addRow = function (data) {
                const row = new JQX.Grid.Row({ data: data, index: that.rows.length })

                that.rowById[row.id] = row;

                return row;
            }

            const refreshRowsVisibility = function (boundSource, hierarchy) {
                for (let i = 0; i < boundSource.length; i++) {
                    const dataItem = boundSource[i];

                    let row = that.rowById[dataItem.$.id];

                    if (!row) {
                        row = addRow(dataItem);
                    }

                    row.data = dataItem;
                    row.leaf = dataItem[reservedNames.leaf] || false;
                    row.level = dataItem[reservedNames.level];
                    row.groupDataField = dataItem.groupDataField;
                    row.label = dataItem.label;

                    if (row.data) {
                        row.filtered = row.data.$.filtered !== undefined ? row.data.$.filtered : true;
                    }

                    if (dataItem.summaryRow) {
                        row.summaryRow = true;
                    }

                    if (that._toggledRow === null || (that._toggledRow && that._toggledRow.id !== row.id)) {
                        row.expandHeight = 0;
                    }

                    if (dataItem.parent) {
                        row.parent = that.rowById[dataItem.parent.$.id];
                        row.parentId = dataItem.parent.$.id;
                    }
                    else {
                        row.parent = null;
                        row.parentId = null;
                    }

                    const expanded = row.expanded;

                    if (row.visible === true && row.filtered !== false) {
                        if (expanded || dataItem[reservedNames.leaf]) {
                            hierarchy.push(row);

                            if (dataItem.children && dataItem.children.length > 0) {
                                const children = refreshRowsVisibility(dataItem.children, new Array());

                                if (children.length === 0) {
                                    row.leaf = true;
                                }

                                for (let t = 0; t < children.length; t++) {
                                    hierarchy.push(children[t]);
                                }
                            }
                        }
                        else {
                            hierarchy.push(row);

                            if (dataItem.children && dataItem.children.length > 0) {
                                const children = refreshRowsVisibility(dataItem.children, new Array());

                                if (children.length === 0) {
                                    row.leaf = true;
                                }
                            }
                        }
                    }
                }

                return hierarchy;
            };

            let hierarchy = that.dataSource.boundHierarchy;

            if (that.paging.enabled) {
                hierarchy = hierarchy.slice(that.paging.pageIndex * that.paging.pageSize, (that.paging.pageIndex + 1) * that.paging.pageSize);
            }

            that.rowHierarchy = refreshRowsVisibility(hierarchy, new Array());

            if (that._rowElements.length < that.rowHierarchy.length && !that._toggledRow) {
                that._initializeRowElements();
            }

            if (that.grouping.summaryRow.visible && !that.grouping.summaryRow.inline) {
                const addHierarchySummaryRow = function (level, hierarchy, parent, index) {
                    if (level !== 0) {
                        if (hierarchy.length > 0 && hierarchy[hierarchy.length - 1] && !hierarchy[hierarchy.length - 1].summaryRow) {
                            let dataItem = {
                                label: ' ', boundSource: [], groupDataField: parent.data.groupDataField, $: {
                                }, summaryRow: true, leaf: true, level: level, expandHeight: 0, siblings: hierarchy
                            };


                            dataItem.$.id = 'SubRow' + index + '_' + parent.data.$.id;

                            if (parent) {
                                dataItem.parent = parent.data;
                                dataItem.parentId = parent.data.$.id;
                            }

                            dataItem.data = Object.assign(dataItem);

                            hierarchy.push(dataItem);
                        }
                    }

                    for (let i = 0; i < hierarchy.length; i++) {
                        if (hierarchy[i] && hierarchy[i].data && hierarchy[i].data.children) {
                            addHierarchySummaryRow(level + 1, hierarchy[i].data.children, hierarchy[i], i);
                        }
                    }
                }

                addHierarchySummaryRow(0, that.rowHierarchy, null, 0);
            }
        }
    }

    applyContent() {

    }


    _refreshContentHeight() {
        const that = this;

        let contentHeight = that._clientSize.height;

        const offsetHeight = that.offsetHeight;
        that.$.container.classList.add('jqx-hidden');

        const newOffsetHeight = that.offsetHeight;
        that.$.container.classList.remove('jqx-hidden');

        if (that.verticalScrollBarVisibility === 'hidden' || (offsetHeight !== newOffsetHeight)
        || (that._minHeight && that._minHeight === offsetHeight)) {
            contentHeight = that._scrollHeight + that.$.columnHeader.offsetHeight + that.$.filterFooter.offsetHeight;

            that.$.content.style.height = contentHeight + 'px';

            that._contentHeight = contentHeight;

            if (that._maxHeight < contentHeight) {
                that._autoHeight = false;
                that.$.content.classList.remove('auto-height');
                that.$.content.style.height = that._maxHeight + 'px';
                that._contentHeight = that._maxHeight;
            }
            else {
                that._autoHeight = true;
                that.$.content.classList.add('auto-height');
            }
            return;
        }

        if (that.header.visible) {
            contentHeight -= that.$.header.offsetHeight;
        }

        if (that.groupHeader.visible) {
            contentHeight -= that.$.groupHeader.offsetHeight;
        }

        if (that.footer.visible) {
            contentHeight -= that.$.footer.offsetHeight;
        }

        if (that.pager.visible) {
            contentHeight -= that.$.headerPager.offsetHeight;
            contentHeight -= that.$.footerPager.offsetHeight;
        }

        if (that.editing.enabled && that.editing.commandBar.visible) {
            contentHeight -= that.$.headerCommandBar.offsetHeight;
            contentHeight -= that.$.footerCommandBar.offsetHeight;
        }

        that.$.content.style.height = contentHeight + 'px';
        that._contentHeight = contentHeight;
    }

    appendChild() {
        const args = Array.prototype.slice.call(arguments, 2);
        return HTMLElement.prototype.appendChild.apply(this, args.concat(Array.prototype.slice.call(arguments)));
    }

    removeChild() {
        const args = Array.prototype.slice.call(arguments, 2);
        return HTMLElement.prototype.removeChild.apply(this, args.concat(Array.prototype.slice.call(arguments)));
    }

    get enableShadowDOM() {
        return true;
    }

    get _contentBorder() {
        const that = this;

        if (that.__contentBorder) {
            return that.__contentBorder;
        }

        const contentComputedStyle = getComputedStyle(that.$.content);
        const contentBorderX = parseFloat(contentComputedStyle.borderLeftWidth) + parseFloat(contentComputedStyle.borderRightWidth);
        const contentBorderY = parseFloat(contentComputedStyle.borderTopWidth) + parseFloat(contentComputedStyle.borderBottomWidth);

        const border = {
            left: contentBorderX, top: contentBorderY
        };

        that.__contentBorder = border;

        return border;
    }
    /**
    * Sets the initial scroll bar sizes.
    */
    _refreshLayout() {
        const that = this;
        const source = that.rows;

        if (that._layoutSuspended) {
            return;
        }

        that._visibleRows = null;
        that.__viewRows = null;
        that.__clientSize = null;
        that.__scrollHeight = null;
        that.__scrollWidth = null;
        that.__parentCells = null;

        that.$.columnFarContainer.classList.remove('vscroll');
        that.$.scrollView.classList.remove('hscroll');
        that.$.scrollView.classList.remove('vscroll');

        that._refreshElementsVisibility();
        that._refreshColumnHeights();
        that._refreshContentHeight();

        if (!(source && source.url)) {
            if (!source || source === null || source.length === 0 || that.columns.length === 0) {
                that.$.placeholder.classList.remove('jqx-hidden');

                that.scrollWidth = 0;
                that.scrollHeight = 0;

                return;
            }
        }

        if (!that.__columnHeaderHeight) {
            that.__columnHeaderHeight = that.$.columnHeader.offsetHeight;
        }

        if (!that.__filterFooterOffsetHeight) {
            that.__filterFooterOffsetHeight = that.$.filterFooter.classList.contains('jqx-hidden') ? 0 : that.$.filterFooter.offsetHeight;
        }

        const scrollViewOffsetHeight = that._contentHeight - that.__filterFooterOffsetHeight - that.__columnHeaderHeight;

        that.$.scrollView.style.height = scrollViewOffsetHeight + 'px';
        that.htmlColumnLastChild.style.height = that.__columnHeaderHeight + 'px';


        if (that.paging.spinner.enabled && that.paging.enabled) {
            if (!that.pageScroll) {
                const pageScroll = document.createElement('jqx-scroll-bar');

                pageScroll.orientation = 'vertical';
                pageScroll.style.height = '100%';
                pageScroll.style.width = '100%';
                pageScroll.max = Math.ceil(that.dataSource.length / that.paging.pageSize);
                pageScroll.step = that.paging.spinner.step;
                pageScroll.largeStep = that.paging.spinner.step;
                pageScroll.setAttribute('spinner', '');
                pageScroll.setAttribute('jqx-id', 'spinner');
                pageScroll.ownerElement = that;

                that.addPropertyBinding('[[paging_spinner_step]]', 'step', pageScroll, that.$.columnHeader);

                pageScroll.addEventListener('change', function (event) {
                    that.paging.pageIndex = event.detail.value;
                });

                that.pageScroll = pageScroll;
            }

            that.htmlColumnLastChild.appendChild(that.pageScroll);
        }
        else {
            that.htmlColumnLastChild.innerHTML = '';
        }

        that._refreshScrollBars();

    }

    _refreshScrollBars() {
        const that = this;
        const vScrollBar = that._scrollView.vScrollBar;
        const hScrollBar = that._scrollView.hScrollBar;

        const scrollViewOffsetHeight = that._contentHeight - that.__filterFooterOffsetHeight - that.__columnHeaderHeight;
        const scrollViewOffsetWidth = that.$.scrollView.offsetWidth;

        const hScrollWidth = that._scrollWidth - scrollViewOffsetWidth - that._contentBorder.left;
        const vScrollHeight = that._scrollHeight - scrollViewOffsetHeight - that._contentBorder.top;

        const columnNearContainerComputedStyle = that._columnNearContainerComputedStyle ? that._columnNearContainerComputedStyle : getComputedStyle(that.$.columnNearContainer);
        const columnFarContainerComputedStyle = that._columnFarContainerComputedStyle ? that._columnFarContainerComputedStyle : getComputedStyle(that.$.columnFarContainer);

        const nearWidth = parseInt(that.$.columnNearContainer.style.width) + parseInt(columnNearContainerComputedStyle.borderRightWidth);
        const farWidth = parseInt(that.$.columnFarContainer.style.width) + parseInt(columnFarContainerComputedStyle.borderLeftWidth);

        that.__frozenNearWidth = nearWidth;
        that.__frozenFarWidth = farWidth;

        that._columnNearContainerComputedStyle = columnNearContainerComputedStyle;
        that._columnFarContainerComputedStyle = columnFarContainerComputedStyle;

        that._refreshHorizontalScrollBarVisibility(hScrollWidth);
        that._refreshVerticalScrollBarVisibility(vScrollHeight);

        vScrollBar.style.height = scrollViewOffsetHeight + 'px';

        if (that.computedVerticalScrollBarVisibility) {
            if (!that.__scrollBarSize) {
                that.__scrollBarSize = vScrollBar.offsetWidth;
            }

            that.__scrollWidth += that.__scrollBarSize;
            that._refreshHorizontalScrollBarVisibility(that._scrollWidth - scrollViewOffsetWidth - 1);

            that.$.columnFarContainer.classList.add('vscroll');
            that.htmlColumnLastChild.classList.remove('jqx-visibility-hidden');
        }

        hScrollBar.style.width = scrollViewOffsetWidth + 'px';
        hScrollBar.style.left = '0px';

        if (that.computedVerticalScrollBarVisibility && that.computedHorizontalScrollBarVisibility) {
            hScrollBar.style.width = scrollViewOffsetWidth - vScrollBar.offsetWidth + 'px';
            vScrollBar.style.height = scrollViewOffsetHeight - hScrollBar.offsetHeight + 'px';
        }

        if (that.computedHorizontalScrollBarVisibility) {
            that.$.scrollView.classList.add('hscroll');

            if (that._autoHeight) {
                that.$.content.style.height = 'auto';
                that.$.scrollView.style.height = 'auto';
                that.$.scrollView.style.paddingBottom = hScrollBar.offsetHeight + 'px';
            }
            else {
                that.$.scrollView.style.paddingBottom = '';
            }
        }
        else {
            that.$.scrollView.classList.remove('hscroll');
        }

        if ((that.__frozenNearHeight > 0 || (that._frozenNearRows && that._frozenNearRows.length > 0)) && !that.appearance.showVerticalScrollBarOnFixedColumns) {
            const rowNearContainerComputedStyle = getComputedStyle(that.$.rowNearContainer);
            const nearHeight = that.__frozenNearHeight + parseInt(rowNearContainerComputedStyle.borderBottomWidth);

            vScrollBar.style.height = parseInt(vScrollBar.style.height) - nearHeight + 'px';
            vScrollBar.style.top = nearHeight + 'px';
            vScrollBar.style.setProperty('--jqx-scroll-bar-near-size', nearHeight + 'px');
        }
        else if (that.appearance.showVerticalScrollBarOnFixedColumns) {
            vScrollBar.style.top = '0px';

        }

        if ((that.__frozenFarHeight > 0 || (that._frozenFarRows && that._frozenFarRows.length > 0)) && !that.appearance.showVerticalScrollBarOnFixedColumns) {
            const rowFarContainerComputedStyle = getComputedStyle(that.$.rowFarContainer);
            const farHeight = -2 + that.__frozenFarHeight + parseInt(rowFarContainerComputedStyle.borderTopWidth);

            vScrollBar.style.height = parseInt(vScrollBar.style.height) - farHeight + 'px';
            vScrollBar.style.setProperty('--jqx-scroll-bar-far-size', farHeight + 'px');

            if (that.__frozenNearHeight === 0) {
                vScrollBar.style.top = '0px';
            }
        }

        if ((nearWidth > 0 || farWidth > 0) && !that.appearance.showHorizontalScrollBarOnFixedColumns) {
            hScrollBar.style.width = parseInt(hScrollBar.style.width) - nearWidth - farWidth + 'px';
            hScrollBar.style.left = nearWidth + 'px';
            hScrollBar.style.setProperty('--jqx-scroll-bar-near-size', nearWidth + parseInt(columnNearContainerComputedStyle.borderRightWidth) + 'px');
            hScrollBar.style.setProperty('--jqx-scroll-bar-far-size', farWidth + parseInt(columnNearContainerComputedStyle.borderLeftWidth) + 'px');

            if (that.computedVerticalScrollBarVisibility) {
                if (!that.__scrollBarSize) {
                    that.__scrollBarSize = vScrollBar.offsetWidth;
                }

                hScrollBar.style.setProperty('--jqx-scroll-bar-far-size', farWidth + that.__scrollBarSize + 'px');
            }
        }

        vScrollBar.refresh();
        hScrollBar.refresh();
    }

    /**
    * Enable/Disable Horizontal Scroll bar.
    */
    _refreshHorizontalScrollBarVisibility(scrollWidth) {
        const that = this;

        that.scrollWidth = scrollWidth;

        if (!that.computedHorizontalScrollBarVisibility) {
            that.scrollLeft = 0;
        }
    }

    /**
    * Enable/Disable Vertical Scroll bar.
    */
    _refreshVerticalScrollBarVisibility(scrollHeight) {
        const that = this;

        if (that._autoHeight) {
            that.scrollTop = 0;
            that.scrollHeight = 0;
            return;
        }

        if (that.computedHorizontalScrollBarVisibility) {
            scrollHeight += that.$.horizontalScrollBar.offsetHeight;
        }

        that.scrollHeight = scrollHeight;

        if (that.paging.enabled && that.paging.spinner.visible) {
            that.$.verticalScrollBarVisibility.classList.remove('jqx-hidden');
        }

        if (!that.computedVerticalScrollBarVisibility) {
            that.scrollTop = 0;
        }
    }

    /**
    * Style change event.
    */
    _styleChangedHandler(event) {
        const that = this;

        if (event.detail.styleProperties['overflow'] || that.classList.contains('jqx-grid-resize-mode')) {
            return;
        }

        if (event.detail.styleProperties['grid-template-columns']) {
            that._templateColumns();
            that.refresh();

            return;
        }


        that._resetCachedLayout();
        that._refreshLayout();
        that._recycle();
    }

    _resetCachedLayout() {
        const that = this;

        that.__cellsCommandTemplate = null;
        that.__autoRowHeight = null;
        that.__measuredColumnHeight = null;
        that.__columnHeaderHeight = null;
        that.__filterFooterOffsetHeight = null;
    }
    /**
    * SwipeLeft event handler.
    **/
    _swipeLeftHandler() {
    }

    /**
    * SwipeRight event handler.
    */
    _swipeRightHandler() {
    }

    _getRowIndexByPosition(position) {
        const that = this;

        const getRowIndex = (rows) => {
            let bottomPointer = 0;
            let topPointer = rows.length - 1;

            if (position <= 0) {
                return 0;
            }

            const lastNode = rows[rows.length - 1];

            if (lastNode.top !== -1 && lastNode.top <= position) {
                return rows.length - 1;
            }

            const condition = true;

            while (condition) {
                const midPointer = Math.floor((bottomPointer + topPointer) / 2);
                const currentrow = rows[midPointer];
                if (that._isRowInPosition(currentrow, position)) {
                    return midPointer;
                }
                else if (currentrow.top < position) {
                    bottomPointer = midPointer + 1;
                }
                else if (currentrow.top > position) {
                    topPointer = midPointer - 1;
                }
                else {
                    bottomPointer = midPointer + 1;
                }
            }
        };

        const index = getRowIndex(that._recyclingRows);

        return index;
    }

    get _recyclingRows() {
        const that = this;

        if (that.rowHierarchy) {
            return that.rowHierarchy;
        }

        let rows = that.getVisibleRows();

        if (that.paging.enabled) {
            rows = rows.slice(that.paging.pageIndex * that.paging.pageSize, (that.paging.pageIndex + 1) * that.paging.pageSize);
        }

        return rows;
    }

    _isRowInPosition(row, position) {
        const topPixel = row.top;
        const bottomPixel = row.top + row.height;
        const pixelInRow = topPixel <= position && bottomPixel > position;

        if (row.height === 0) {
            return false;
        }

        return pixelInRow;
    }

    _renderColumnGroupHeaders() {
        const that = this;

        for (let i = 0; i < that.columnGroups.length; i++) {
            const columnGroup = that.columnGroups[i];
            columnGroup.column.render();
        }
    }



    _isLastVisibleColumn(column) {
        const that = this;

        for (let i = that.viewColumns.length - 1; i >= 0; i--) {
            const currentColumn = that.viewColumns[i];

            if (!currentColumn.visible) {
                continue;
            }

            if (currentColumn === column) {
                return true;
            }

            return false;
        }

        return false;
    }

    _recycle(recycleColumns, recycleRows) {
        const that = this;

        if (that._layoutSuspended) {
            return;
        }

        if (that._isUpdating) {
            return;
        }



        if (that.editing.isEditing) {
            that.endEdit();
        }

        if (that._inputOverlay) {
            if (that._inputOverlay.parentNode) {
                that._inputOverlay.parentNode.removeChild(that._inputOverlay);
            }

            that._inputOverlay = null;
        }

        if (that._selection.selectionRect) {
            that._refreshCellSelectionRect();
        }

        const value = that._scrollView.scrollTop;
        let rowIndex = that._getRowIndexByPosition(value);
        let rows = that._recyclingRows;

        let row = rows[rowIndex];

        let rowTop = row ? row.top : 0;
        let columnLeft = undefined;

        let nearWidth = 0;
        let j = 0;

        let rowSpanOffset = 0;
        let colSpanOffset = 0;

        for (let i = 0; i < that._cellsMerge.length; i++) {
            const cell = that._cellsMerge[i];

            const startRowIndex = rows.indexOf(cell.row);

            if (rowIndex > startRowIndex && rowIndex <= startRowIndex + cell.rowSpan) {
                rowIndex = startRowIndex;
                row = cell.row;
                rowSpanOffset = Math.max(rowSpanOffset, rowTop - row.top);
                rowTop = row.top;
                that.$.rowContainer.style.top = that.__frozenNearHeight - value + rowTop + 'px';
            }

            if (cell.colSpan > 1) {
                for (let j = 0; j < that.viewColumns.length; j++) {
                    const viewColumn = that.viewColumns[j];
                    let column = viewColumn.autoGenerated ? viewColumn : that.columnByDataField[viewColumn.dataField];
                    if (!column.visible || column.adaptiveVisible) {
                        continue;
                    }

                    if (column.left + column.computedWidth - that._scrollView.scrollLeft >= nearWidth && column.left - column.computedWidth - that._scrollView.scrollLeft < that._clientSize.width) {
                        let cellColumn = that.columnByDataField[cell.column.dataField]


                        colSpanOffset = Math.max(colSpanOffset, column.left - cellColumn.left + column.computedWidth);
                        break;
                    }
                }
            }
        }


        if (recycleColumns !== false || that._cellsMerge.length > 0) {
            for (let i = 0; i < that._columnElements.length; i++) {
                const columnElement = that._columnElements[i];

                if (!columnElement.parentNode) {
                    break;
                }

                columnElement.set('column', null, false);
                columnElement.classList.add('jqx-visibility-hidden');
            }

            for (let i = 0; i < that.columnGroups.length; i++) {
                const column = that.columnGroups[i];
                const header = column.element;

                header.style.left = column.left + 'px';
                header.style.width = column.computedWidth + 'px';
            }

            that._firstVisibleColumn = null;
            that._lastVisibleColumn = null;

            for (let i = 0; i < that.viewColumns.length; i++) {
                const viewColumn = that.viewColumns[i];
                //      let column = viewColumn.autoGenerated ? viewColumn : that.columnByDataField[viewColumn.dataField];
                let column = viewColumn;

                if (column.visible || column.adaptiveVisible) {
                    if (!that._firstVisibleColumn) {
                        that._firstVisibleColumn = column;
                    }

                    that._lastVisibleColumn = column;
                }

                if (column.element) {
                    if (column === that._firstVisibleColumn) {
                        column.element.classList.add('jqx-grid-column-border-collapse');
                    }
                    else {
                        column.element.classList.remove('jqx-grid-column-border-collapse');
                    }
                }

                if (column.freeze) {
                    if (column.freeze === true || column.freeze === 'near') {
                        if (column.visible) {
                            nearWidth += column.computedWidth;
                        }
                    }

                    if (!column.visible || column.adaptiveVisible) {
                        column.element.classList.add('jqx-visibility-hidden');
                    }
                    else {
                        column.element.classList.remove('jqx-visibility-hidden');
                        column.render();
                    }


                    continue;
                }

                if (!column.visible || column.adaptiveVisible) {
                    continue;
                }

                if (that._adaptiveLayout > 0) {
                    column.element.classList.add('jqx-visibility-hidden');
                }
                else {
                    if (column.left + column.computedWidth - that._scrollView.scrollLeft >= nearWidth - colSpanOffset && column.left - column.computedWidth - that._scrollView.scrollLeft < that._clientSize.width) {
                        const columnElement = that._columnElements[j++];

                        columnElement.set('column', column, false);

                        if (!columnElement.parentNode) {
                            that.$.columnContainer.appendChild(columnElement);
                        }

                        column.element = columnElement;
                        column.render();

                        if (columnLeft === undefined) {
                            columnLeft = column.left;
                        }
                    }
                }
            }
        }

        if (columnLeft === undefined) {
            columnLeft = 0;
        }

        that.$.columnContainer.style.left = -that._scrollView.scrollLeft + 'px';
        that.$.rowContainer.style.top = that.__frozenNearHeight - value + rowTop + 'px';

        if (recycleRows === false) {
            return;
        }

        if (!that._rowElements) {
            return;
        }

        if (rowIndex >= 0) {
            j = 0;
            let offsetHeight = Math.max(that._clientSize.height, that._overflowOffset);

            for (let i = rowIndex; i < rows.length; i++) {
                const row = rows[i];

                if (row.height === 0 || !row.visible || (row.filtered === false) || row.freeze) {
                    continue;
                }

                const rowHeight = row.height;

                if (row.expandHeight) {
                    offsetHeight += that.offsetHeight + row.expandHeight;
                }

                if ((rowTop + rowHeight >= value - rowSpanOffset && rowTop <= value + offsetHeight) || that._autoHeight) {
                    const rowElement = that._rowElements[j++];

                    if (!rowElement) {
                        break;
                    }

                    row.element = rowElement;
                    row.grid = that;
                    row.render();
                }
                else {
                    break;
                }

                rowTop += rowHeight;
            }
        }

        that._renderFrozenRows();

        if (j < that._rowElements.length) {
            for (let i = j; i < that._rowElements.length; i++) {
                const scrollRow = that._rowElements[j++];

                scrollRow.classList.add('jqx-hidden');
            }
        }
    }

    _renderFrozenRows() {
        const that = this;
        let anyFrozenNearRowVisible = false;
        let anyFrozenFarRowVisible = false;

        if (that._frozenNearRows.length === 0) {
            that.$.rowNearContainer.classList.add('jqx-hidden');
        }
        else {
            that.$.rowNearContainer.classList.remove('jqx-hidden');
        }

        for (let i = 0; i < that._frozenNearRows.length; i++) {
            const row = that._frozenNearRows[i];

            if (row.visible && row.filtered) {
                anyFrozenNearRowVisible = true;

                row.element = that.$.rowNearContainer.children[i];
                row.render();
            }
        }

        if (!anyFrozenNearRowVisible) {
            that.$.rowNearContainer.classList.add('jqx-hidden');
        }

        if (that._frozenFarRows.length === 0) {
            that.$.rowFarContainer.classList.add('jqx-hidden');
        }
        else {
            that.$.rowFarContainer.classList.remove('jqx-hidden');
        }

        for (let i = 0; i < that._frozenFarRows.length; i++) {
            const row = that._frozenFarRows[i];

            if (row.visible) {
                anyFrozenFarRowVisible = true;
            }

            row.element = that.$.rowFarContainer.children[i];
            row.render();
        }

        if (!anyFrozenFarRowVisible) {
            that.$.rowFarContainer.classList.add('jqx-hidden');
        }
    }

    _recycleRotate(columnHeaderCellContentElement, textElement, halign, valign, value) {
        const textRectangle = textElement.getBoundingClientRect();
        const boundingRectangle = columnHeaderCellContentElement.getBoundingClientRect();

        const padding = 4;
        let left = 0;
        let top = 0;

        if (boundingRectangle.width === 0) {
            columnHeaderCellContentElement.innerHTML = value;
            return false;
        }

        if (textRectangle.left > boundingRectangle.left) {
            left = boundingRectangle.left - textRectangle.left;
        }

        if (textRectangle.top < boundingRectangle.top) {
            top = boundingRectangle.top - textRectangle.top;
        }

        if (halign === 'left' || halign === '') {
            left = padding;
        }

        if (halign === 'center') {
            left += boundingRectangle.width / 2 - textRectangle.width / 2;
        }

        if (halign === 'right') {
            left += boundingRectangle.width - textRectangle.width - padding;
        }

        if (valign === 'top' || valign === '') {
            top = padding;
        }

        if (valign === 'center' || valign === 'middle') {
            top += boundingRectangle.height / 2 - textRectangle.height / 2;
        }

        if (valign === 'bottom') {
            top += boundingRectangle.height - textRectangle.height - padding;
        }

        textElement.style.left = left + 'px';
        textElement.style.top = top + 'px';

        return true;
    }

    _virtualDataRequest(action) {
        const that = this;

        let first = -1;
        let last = -1;

        if (!that._rowElements && that.scrollMode !== 'infinite') {
            return;
        }

        if (that.scrollMode === 'virtual') {
            for (let i = 0; i < that._rowElements.length; i++) {
                const rowElement = that._rowElements[i];
                const row = rowElement.row;
                const visibleIndex = i === 0 ? row.visibleIndex : first + i;

                if (rowElement.classList.contains('jqx-hidden')) {
                    continue;
                }

                if (first === -1) {
                    first = visibleIndex;
                }

                if (visibleIndex === -1) {
                    continue;
                }

                last = 1 + visibleIndex;
            }
        }
        else if (that.scrollMode === 'infinite') {
            first = Infinity;
            last = Infinity;
        }
        else {
            first = 0;
            last = that.dataSource.length;
        }


        if (that.paging.enabled) {
            first = that.paging.pageIndex * that.paging.pageSize;
            last = first + that.paging.pageSize;
        }

        if (last !== Infinity) {
            last = Math.min(last, that.dataSource.length);
        }

        that.displayLoadingIndicator = true;
        that._setLoadingIndicatorVisibility();

        const details = {
            first: first,
            last: last,
            sorting: that.getSortedColumns(),
            filtering: that.getFilteredColumns(),
            grouping: [],
            row: that._toggledRow ? that._toggledRow.data : null,
            action: action
        }

        const dataSourceLength = that.dataSource.length;

        that.dataSource.onVirtualDataSourceRequested(function () {
            that.displayLoadingIndicator = false;
            that._setLoadingIndicatorVisibility();
            that._toggledRow = null;

            if (that.dataSource.length !== dataSourceLength) {
                if (that.paging.enabled) {
                    that.$.headerPager.querySelector('jqx-pager').pagesCount = Math.ceil(that.dataSource.length / that.paging.pageSize);
                    that.$.footerPager.querySelector('jqx-pager').pagesCount = Math.ceil(that.dataSource.length / that.paging.pageSize);
                }

                that._initializeRows();
                that._initializeRowElements();

                that.refresh();
            }
            else if (that.dataSource.virtualDataSourceOnExpand) {
                that.refresh();
            }

            that._recycle();
        }, details);
    }

    /**
    * Vertical Scroll Bar handler
    */
    _verticalScrollbarHandler(data) {
        const that = this;

        that.closeMenu();
        that.isScrolling = true;

        if (that._scrollTimer) {
            clearTimeout(that._scrollTimer);
        }

        that._scrollTimer = setTimeout(() => {
            that._recycle(false);
            that.isScrolling = false;

            if (data.max === data.value) {
                that.$.fireEvent('scrollBottomReached');

                if (that.scrollMode === 'infinite') {
                    that._virtualDataRequest('scroll');
                    return;
                }
            }

            if (that.scrollMode === 'virtual') {
                that._virtualDataRequest('scroll');
            }

            if (data.min === data.value) {
                that.$.fireEvent('scrollTopReached');
            }
        });

    }
});

(function () {
    'use strict';

    JQX.Grid.Extend = function (module) {
        const methodNames = Object.getOwnPropertyNames(module.prototype);

        for (let index in methodNames) {
            const methodName = methodNames[index];

            if (methodName === 'constructor') {
                continue;
            }

            JQX.Grid.prototype[methodName] = module.prototype[methodName];
        }
    };

    JQX.Grid.Extend(JQX.Utilities.Grid.Pager);
    JQX.Grid.Extend(JQX.Utilities.Grid.Filter);
    JQX.Grid.Extend(JQX.Utilities.Grid.Sort);
    JQX.Grid.Extend(JQX.Utilities.Grid.Menu);
    JQX.Grid.Extend(JQX.Utilities.Grid.Select);
    JQX.Grid.Extend(JQX.Utilities.Grid.Edit);
    JQX.Grid.Extend(JQX.Utilities.Grid.Group);
    JQX.Grid.Extend(JQX.Utilities.Grid.Tree);
    JQX.Grid.Extend(JQX.Utilities.Grid.Export);

    JQX.Grid.Cell = JQX.Utilities.Grid.Cell;
    JQX.Grid.Row = JQX.Utilities.Grid.Row;
    JQX.Grid.Column = JQX.Utilities.Grid.Column;
})();
/**
 * Menu Item custom element.
 */
JQX('jqx-menu-item', class MenuItem extends JQX.BaseElement {
    // Menu Item's properties.
    static get properties() {
        return {
            'checked': {
                value: false,
                type: 'boolean'
            },
            'label': {
                value: '',
                type: 'any'
            },
            'level': {
                value: null,
                type: 'number?'
            },
            'separator': {
                value: false,
                type: 'boolean'
            },
            'shortcut': {
                value: '',
                type: 'string'
            },
            'value': {
                value: null,
                type: 'any'
            }
        };
    }

    get enableShadowDOM() {
        return false;
    }

    /**
     * Menu Items Group's HTML template.
     */
    template() {
        return '';
    }

    ready() {
        super.ready();
        this.$.addClass('jqx-unselectable');
    }

    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        if (propertyName !== 'disabled' || newValue === false || !that.checked) {
            return;
        }

        const parentMenu = that.menu;

        if (!parentMenu) {
            return;
        }

        super.propertyChangedHandler(propertyName, oldValue, newValue);

        that.checked = false;

        const parentItem = that.parentItem,
            checkMode = parentItem ? parentItem.checkMode : parentMenu.checkMode;

        if (checkMode === 'radioButton') {
            parentMenu._validateRadioButtonSelection(parentItem, that.level, []);
        }
    }
});

/**
 * Menu Items Group custom element.
 */
JQX('jqx-menu-items-group', class MenuItemsGroup extends JQX.BaseElement {
    // Menu Items Group's properties.
    static get properties() {
        return {
            'checkable': {
                value: false,
                type: 'boolean'
            },
            'checked': {
                value: false,
                type: 'boolean'
            },
            'checkMode': {
                value: 'checkbox',
                allowedValues: ['checkbox', 'radioButton'],
                type: 'string'
            },
            'dropDownHeight': {
                value: null,
                type: 'number?'
            },
            'expanded': {
                value: false,
                type: 'boolean'
            },
            'label': {
                value: '',
                type: 'any'
            },
            'level': {
                value: null,
                type: 'number?'
            },
            'separator': {
                value: false,
                type: 'boolean'
            },
            'value': {
                value: null,
                type: 'any'
            }
        };
    }

    get enableShadowDOM() {
        return false;
    }

    /**
     * Menu Items Group's HTML template.
     */
    template() {
        return '';
    }

    ready() {
        super.ready();
        this.$.addClass('jqx-unselectable');
    }

    propertyChangedHandler(propertyName, oldValue, newValue) {
        if (['checkable', 'checkMode', 'disabled'].indexOf(propertyName) === -1) {
            return;
        }

        const that = this,
            parentMenu = that.menu;

        if (!parentMenu) {
            return;
        }

        super.propertyChangedHandler(propertyName, oldValue, newValue);

        switch (propertyName) {
            case 'checkable':
                if (newValue) {
                    that.itemContainer.setAttribute('checkable', '');
                }
                else {
                    that.itemContainer.removeAttribute('checkable');
                }

                if (parentMenu._isContainerOpened(that.container.level, that.container) &&
                    parentMenu.mode !== 'tree' && !parentMenu._minimized) {
                    parentMenu._closeSubContainers(that.level + 2);
                }
                break;
            case 'checkMode':
                that.itemContainer.setAttribute('check-mode', newValue);
                parentMenu._changeToRadioButtonMode(newValue, that.itemContainer, that);
                break;
            case 'disabled': {
                if (JQX.ListMenu && parentMenu instanceof JQX.ListMenu) {
                    if (parentMenu._view) {
                        while (that.contains(parentMenu._view)) {
                            parentMenu._backButtonClickHandler();
                        }
                    }
                }
                else if (parentMenu._isContainerOpened(that.container.level, that.container)) {
                    parentMenu._closeSubContainers(that.level + 1, that.container);
                }

                if (!that.checked) {
                    return;
                }

                that.checked = false;

                const parentItem = that.parentItem,
                    checkMode = parentItem ? parentItem.checkMode : parentMenu.checkMode;

                if (checkMode === 'radioButton') {
                    parentMenu._validateRadioButtonSelection(parentItem, that.level, []);
                }

                break;
            }
        }
    }
});

/**
 * Menu custom element.
 */
JQX('jqx-menu', class Menu extends JQX.BaseElement {
    // Menu's properties.
    static get properties() {
        return {
            'autoCloseDelay': {
                value: 100,
                type: 'number'
            },
            'autoFocusOnMouseenter': {
                value: false,
                type: 'boolean'
            },
            'checkable': {
                value: false,
                type: 'boolean'
            },
            'checkboxes': {
                value: false,
                type: 'boolean'
            },
            'checkMode': {
                value: 'checkbox',
                allowedValues: ['checkbox', 'radioButton'],
                type: 'string'
            },
            'closeAction': {
                value: 'up',
                allowedValues: ['up', 'down', 'none'],
                type: 'string'
            },
            'dataSource': {
                value: null,
                type: 'array?',
                reflectToAttribute: false
            },
            'displayMember': {
                value: 'label',
                type: 'string'
            },
            'dropDownAppendTo': {
                value: null,
                type: 'any?'
            },
            'dropDownOverlay': {
                value: false,
                type: 'boolean'
            },
            'dropDownPosition': {
                value: 'auto',
                allowedValues: ['top-left', 'top-right', 'bottom-left', 'bottom-right', 'overlay-left', 'overlay-right', 'auto'],
                type: 'string'
            },
            'enableMouseWheelAction': {
                value: false,
                type: 'boolean'
            },
            'itemsMember': {
                value: 'items',
                type: 'string'
            },
            'minimizeIconTemplate': {
                value: null,
                type: 'string?'
            },
            'minimizeWidth': {
                value: null,
                type: 'number?'
            },
            'mode': {
                value: 'horizontal',
                allowedValues: ['horizontal', 'vertical', 'dropDown', 'tree'],
                type: 'string'
            },
            'opened': {
                value: false,
                type: 'boolean'
            },
            'overflow': {
                value: 'auto',
                allowedValues: ['auto', 'hidden', 'scroll'],
                type: 'string'
            },
            'selectionMode': {
                value: 'click',
                allowedValues: ['click', 'mouseenter'],
                type: 'string'
            },
            'valueMember': {
                value: 'value',
                type: 'string'
            }
        };
    }

    /**
     * Menu's event listeners.
     */
    static get listeners() {
        return {
            'container.click': '_selectionHandler',
            'keydown': '_keydownHandler',
            'mouseenter': '_mouseenterHandler',
            'mouseleave': '_mouseleaveHandler',
            'container.mouseout': '_mouseoutMouseoverHandler',
            'container.mouseover': '_mouseoutMouseoverHandler',
            'resize': '_resizeHandler',
            'transitionend': '_transitionendHandler',
            'hamburgerIcon.click': '_hamburgerIconClickHandler',
            'mainContainer.click': '_mainContainerHandler',
            'mainContainer.mouseleave': '_mainContainerHandler',
            'mainContainer.mouseout': '_mainContainerHandler',
            'mainContainer.mouseover': '_mainContainerHandler',
            'document.down': '_documentDownHandler',
            'document.up': '_documentUpHandler'
        };
    }

    /**
     * Menu's required files.
     */
    static get requires() {
        return {
            'JQX.RepeatButton': 'jqxbutton.js'
        }
    }

    /**
     * CSS files needed for the element (ShadowDOM)
     */
    static get styleUrls() {
        return [
            'jqx.button.css',
            'jqx.menu.css'
        ]
    }

    /**
     * Menu's items.
     */
    get items() {
        return this._menuItems;
    }

    /**
     * Menu's HTML template.
     */
    template() {
        return `<div id="container">
                    <div id="minimizedHeader" class ="jqx-header jqx-minimized-header jqx-hidden">
                        <div id="hamburgerIcon" class ="jqx-hamburger-icon jqx-hidden">
                            <div id="hamburgerIconLineTop" class ="jqx-hamburger-icon-line jqx-hamburger-icon-line-top"></div>
                            <div id="hamburgerIconLineCenter" class ="jqx-hamburger-icon-line jqx-hamburger-icon-line-center"></div>
                            <div id="hamburgerIconLineBottom" class ="jqx-hamburger-icon-line jqx-hamburger-icon-line-bottom"></div>
                            <div id="customIconContainer" class ="jqx-hamburger-icon-custom-container jqx-hidden"></div>
                        </div>
                    </div>
                    <jqx-repeat-button id="scrollButtonNear" class="jqx-menu-scroll-button jqx-spin-button jqx-scroll-button-near jqx-hidden" animation="[[animation]]" unfocusable>
                        <div id="arrowNear" class="jqx-arrow"></div>
                    </jqx-repeat-button>
                    <div id="mainContainer" class="jqx-menu-main-container">
                        <content></content>
                    </div>
                    <jqx-repeat-button id="scrollButtonFar" class="jqx-menu-scroll-button jqx-spin-button jqx-scroll-button-far jqx-hidden" animation="[[animation]]" unfocusable>
                        <div id="arrowFar" class="jqx-arrow"></div>
                    </jqx-repeat-button>
                </div>`;
    }

    /**
     * Called when the element is attached to the DOM.
     */
    attached() {
        const that = this;

        super.attached();

        if (that._element === 'tree' || JQX.ListMenu && that instanceof JQX.ListMenu) {
            return;
        }

        if (that.isCompleted && that.dropDownAppendTo !== null) {
            if (that._minimized) {
                that._dropDownParent.appendChild(that.$.mainContainer);
            }
            else {
                for (let i = 0; i < that._containersInBody.length; i++) {
                    that._dropDownParent.appendChild(that._containersInBody[i]);
                }
            }

            if (that.mode === 'dropDown') {
                if (that._dropDownParent === that.parentElement) {
                    if (that._dynamicallyReparented) {
                        delete that._dynamicallyReparented;
                    }
                    else {
                        that._positionRelativeTo = null;
                    }
                }
                else {
                    that._positionRelativeTo = that.parentElement;
                    that._dynamicallyReparented = true;
                    setTimeout(function () {
                        that._dropDownParent.appendChild(that);
                    }, 0);
                }
            }
        }
    }

    /**
     * Called when the element is detached from the DOM.
     */
    detached() {
        const that = this;

        super.detached();

        if (that._element === 'tree' || JQX.ListMenu && that instanceof JQX.ListMenu) {
            return;
        }

        that._close();

        if (that.dropDownAppendTo !== null) {
            if (that._minimized) {
                that._dropDownParent.removeChild(that.$.mainContainer);
            }
            else {
                that._removeContainersInBody();
            }
        }
    }

    /**
     * Called when the element is ready. Used for one-time configuration of the Menu.
     */
    ready() {
        super.ready();

        const that = this;

        that._element = 'menu';
        that._edgeMacFF = JQX.Utilities.Core.Browser.Edge ||
            JQX.Utilities.Core.Browser.Firefox && navigator.platform.toLowerCase().indexOf('mac') !== -1;
        that._containers = [];
        that._containersInBody = [];
        that._openedContainers = [];
        that._containersFixedHeight = [];
        that._menuItemsGroupsToExpand = [];
        that._additionalScrollButtons = [];

        that._createElement();
    }

    /**
     * Adds an item.
     *
     * @param {HTMLElement} item A jqx-menu-item to add to the Menu.
     * @param {HTMLElement/String} parent Optional The jqx-menu-items-group (or its id or numeric path) to add the item to.
     */
    addItem(item, parent) {
        const that = this;

        if (!(item instanceof JQX.MenuItem || item instanceof JQX.MenuItemsGroup)) {
            return;
        }

        let level, container;

        if (parent === undefined) {
            parent = that.$.mainContainer;
            level = 1;
            container = parent;
        }
        else {
            parent = that.getItem(parent);

            if (parent instanceof JQX.MenuItemsGroup === false) {
                return;
            }

            level = parent.level + 1;
            container = parent.itemContainer;
        }

        that._createItemHTMLStructure(item, level, parent, container.childElementCount, 0);

        if (item instanceof JQX.MenuItemsGroup) {
            that._processHTML(item, level + 1);
            that._checkContainersLength();
        }

        container.appendChild(item);
        that._checkOverflowAddRemove(item.level, container);

        if (item instanceof JQX.MenuItemsGroup && (that.mode === 'tree' || that._minimized)) {
            const arrows = item.getElementsByClassName('jqx-menu-items-group-arrow');

            for (let i = 0; i < arrows.length; i++) {
                arrows[i].className = 'jqx-menu-items-group-arrow down jqx-arrow-down';
            }

            that._expandItemsByDefault();
        }
    }

    /**
     * Checks an item.
     *
     * @param {HTMLElement/String} item jqx-menu-item/jqx-menu-items-group (or its id or numeric path).
     */
    checkItem(item) {
        const that = this;

        item = that.getItem(item);

        if (item === undefined || item.checked || item.disabled || item.templateApplied) {
            return;
        }

        that._toggleItem(item);
    }

    /**
     * Clears all Menu items.
     */
    clear() {
        const that = this;

        that.$.mainContainer.innerHTML = '';
        that._removeContainersInBody();
        that._menuItems = {};
        that._containers = [];
        that._containersInBody = [];
        that._openedContainers = [];
        that._containersFixedHeight = [];
        that._menuItemsGroupsToExpand = [];
        that._additionalScrollButtons = [];
    }

    /**
     * Closes the Menu when "mode" is 'dropDown'.
     */
    close() {
        const that = this;

        if (that.mode !== 'dropDown' || that.opened === false && that.$.hasClass('jqx-visibility-hidden')) {
            return;
        }

        const closingEvent = that.$.fireEvent('closing', arguments[0] || { trigger: 'programmatic' });

        if (!closingEvent.defaultPrevented) {
            that.opened = false;
            that.$.addClass('jqx-visibility-hidden');
            that._close();
            that.$.fireEvent('close');
        }
        else {
            that.opened = true;
        }
    }

    /**
     * Collapses an item.
     *
     * @param {HTMLElement/String} item Optional jqx-menu-item/jqx-menu-items-group (or its id or numeric path).
     * @param {Boolean} animation Optional If set to false, disables collapse animation even if animation is enabled for the element.
     */
    collapseItem(item, animation) {
        const that = this,
            animationType = that.animation,
            restoreAnimation = animation === false && that.hasAnimation;

        if (item !== undefined) {
            item = that.getItem(item);

            if (item === undefined || item instanceof JQX.MenuItem) {
                return;
            }
        }
        else {
            // collapse all
            if (restoreAnimation) {
                that.animation = 'none';
            }

            that._close();

            if (restoreAnimation) {
                setTimeout(function () {
                    that.animation = animationType;
                }, 0);
            }

            return;
        }

        const level = item.level;

        if (that._openedContainers[level + 1] && that._isContainerOpened(level + 1, item.container)) {
            const mode = that.mode;

            if (restoreAnimation) {
                that.animation = 'none';
            }

            that._closeSubContainers(level + 1, item.container, undefined, arguments[2] !== false);

            if (level === 1 || mode === 'tree') {
                that._checkOverflow(that.$.mainContainer, mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]);
            }

            if (restoreAnimation) {
                that.animation = animationType;
            }
        }
    }

    /**
     * Expands an item.
     *
     * @param {HTMLElement/String} item jqx-menu-item/jqx-menu-items-group (or its id or numeric path).
     * @param {Boolean} animation Optional If set to false, disables expand animation even if animation is enabled for the element.
     */
    expandItem(item, animation) {
        const that = this;

        item = that.getItem(item);

        if (item === undefined ||
            (item instanceof JQX.MenuItemsGroup &&
                that._isContainerOpened(item.level + 1, item.container) &&
                that._isBranchExpanded(item))) {
            return;
        }

        const stack = [item],
            animationType = that.animation,
            restoreAnimation = animation === false && that.hasAnimation;
        let stackItem = item.parentItem;

        if (restoreAnimation) {
            that.animation = 'none';
        }

        that._discardKeyboardHover();

        while (stackItem) {
            stack.unshift(stackItem);
            stackItem = stackItem.parentItem;
        }

        for (let i = 0; i < stack.length; i++) {
            const currentStackItem = stack[i];

            if (i === stack.length - 1 && currentStackItem instanceof JQX.MenuItem) {
                if (!(currentStackItem.disabled || currentStackItem.templateApplied)) {
                    that._hoverViaKeyboard(currentStackItem);
                }

                break;
            }

            if (!that._isContainerOpened(currentStackItem.container.level, currentStackItem.container)) {
                that._menuItemsGroupSelectionHandler(currentStackItem, { target: currentStackItem, type: 'expand', isTrusted: true }, arguments[2]);
            }
        }

        if (restoreAnimation) {
            that.animation = animationType;
        }
    }

    /**
     * Gets an item by its id or numeric path.
     *
     * @param {String} id The id or numeric path of an item.
     */
    getItem(id) {
        const that = this;
        let item;

        if (typeof id === 'string') {
            item = that.shadowRoot ? that.shadowRoot.getElementById(id) : document.getElementById(id);

            if (item === null) {
                return that._menuItems[id];
            }
        }
        else if (!isNaN(id)) {
            return that._menuItems[id.toString()];
        }
        else {
            item = id;
        }

        if (!(item instanceof JQX.MenuItem || item instanceof JQX.MenuItemsGroup) ||
            !(that.contains(item) || that.$.mainContainer.contains(item) || item.parentElement.parentElement.ownerElement === that)) {
            return;
        }

        return item;
    }

    /**
     * Maximizes the Menu.
     */
    maximize() {
        const that = this;

        if (!that._minimized) {
            return;
        }

        const animationType = that.animation;

        that.$.mainContainer.style.marginTop = '';
        that.$.mainContainer.style.marginLeft = '';

        if (that.enableShadowDOM && !that.$.mainContainer.id) {
            that.$.mainContainer.id = that.$.mainContainer.getAttribute('jqx-id');
        }

        if (animationType !== 'none') {
            that.animation = 'none';
        }

        that._positionDetection.removeOverlay();
        that._closeSubContainers(2);
        that.$minimizedHeader.addClass('jqx-hidden');

        that._minimized = false;

        if (that._minimizedDropDownOpened) {
            that.$hamburgerIcon.removeClass('jqx-close-button');
            that._minimizedDropDownOpened = false;
        }

        if (that.dropDownAppendTo !== null) {
            that._appendMinimizedContainerToMenu(that.$.mainContainer, that.$.scrollButtonFar);
        }

        if (that.mode !== 'tree') {
            that.$mainContainer.addClass('jqx-menu-main-container');
            that.$mainContainer.removeClass('jqx-menu-minimized-items-container');

            const arrows = that.getElementsByClassName('jqx-menu-items-group-arrow');

            for (let i = 0; i < arrows.length; i++) {
                that._setArrowDirection(arrows[i], arrows[i].parentElement.parentElement.level + 1);
            }

            if (that.dropDownAppendTo !== null) {
                that._moveDropDownsToExternalContainer();
            }

            that._applyContainerFixedHeight();
        }

        that.$mainContainer.removeClass('jqx-visibility-hidden');
        that.$hamburgerIcon.addClass('jqx-hidden');

        that.removeAttribute('minimized');

        that._checkOverflow(that.$.mainContainer, that.mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]);

        if (animationType !== 'none') {
            setTimeout(function () {
                that.animation = animationType;
            }, 0);
        }
    }

    /**
     * Minimizes the Menu.
     */
    minimize() {
        const that = this;

        if (that._minimized || that.mode === 'dropDown') {
            return;
        }

        that.$minimizedHeader.removeClass('jqx-hidden');

        const differentDropDownParent = that.dropDownAppendTo !== null,
            animationType = that.animation,
            restoreAnimation = that.hasAnimation;

        if (restoreAnimation) {
            that.animation = 'none';
        }

        that._positionDetection.removeOverlay();
        that._closeSubContainers(2);

        if (restoreAnimation && differentDropDownParent) {
            that.animation = animationType;
        }

        if (that.mode !== 'tree') {
            if (differentDropDownParent) {
                that._moveDropDownsToMenu();
            }

            that._removeContainerFixedHeight();
        }

        that._hideMainContainerScrollButtons();

        that.$mainContainer.removeClass('jqx-menu-main-container');
        that.$mainContainer.addClass('jqx-visibility-hidden');

        if (that.enableShadowDOM) {
            that.$.mainContainer.removeAttribute('id');
        }

        if (that._edgeMacFF) {
            that.$.mainContainer.style.left = '';
            that.$.mainContainer.style.top = '';
            that.$mainContainer.addClass('not-in-view');
        }

        that.$hamburgerIcon.removeClass('jqx-hidden');

        if (differentDropDownParent) {
            that._appendMinimizedContainerToExternalElement(that.$.mainContainer);
        }

        setTimeout(function () {
            that.$mainContainer.addClass('jqx-menu-minimized-items-container');

            if (restoreAnimation && !differentDropDownParent) {
                that.animation = animationType;
            }
        }, 0);

        that._minimized = true;
        that.setAttribute('minimized', '');

        if (that.mode !== 'tree') {
            const arrows = that.$.mainContainer.getElementsByClassName('jqx-menu-items-group-arrow');

            for (let i = 0; i < arrows.length; i++) {
                that._setArrowDirection(arrows[i], arrows[i].parentElement.parentElement.level + 1);
            }
        }
    }

    /**
     * Opens the Menu when "mode" is 'dropDown'.
     *
     * @param {Number} left Horizontal position.
     * @param {Number} top Vertical position.
     */
    open(left, top) {
        const that = this;

        if (that.mode !== 'dropDown') {
            return;
        }

        const openingEvent = that.$.fireEvent('opening');

        if (openingEvent.defaultPrevented) {
            that.opened = false;
            return;
        }

        let actualParentRect;

        that.opened = true;

        if (that._positionRelativeTo) {
            const targetRect = that._positionRelativeTo.getBoundingClientRect();

            left += targetRect.left;
            top += targetRect.top;

            if (that._positionedParent) {
                actualParentRect = that._positionedParent.getBoundingClientRect();

                left -= actualParentRect.left;
                top -= actualParentRect.top;
            }
            else {
                left += window.pageXOffset;
                top += window.pageYOffset;
            }
        }

        // browser bounds detection
        let overflowLeft = left + that.offsetWidth - document.documentElement.clientWidth,
            overflowTop = top + that.offsetHeight - document.documentElement.clientHeight;

        if (actualParentRect) {
            overflowLeft += actualParentRect.left;
            overflowTop += actualParentRect.top;
        }
        else {
            overflowLeft -= window.pageXOffset;
            overflowTop -= window.pageYOffset;
        }

        if (overflowLeft > 0) {
            left -= overflowLeft;
        }
        else if (actualParentRect) {
            left = Math.max(left, -actualParentRect.left);
        }
        else {
            left = Math.max(left, window.pageXOffset);
        }

        if (overflowTop > 0) {
            top -= overflowTop;
        }
        else if (actualParentRect) {
            top = Math.max(top, -actualParentRect.top);
        }
        else {
            top = Math.max(top, window.pageYOffset);
        }
        // browser bounds detection end

        if (!isNaN(left)) {
            that.style.left = left + 'px';
        }

        if (!isNaN(top)) {
            that.style.top = top + 'px';
        }

        that.$.removeClass('jqx-visibility-hidden');
        that.$.fireEvent('open');

        if (!that.hasAnimation && !that._noAutoFocus) {
            that.focus();
        }
    }

    /**
     * Removes an item.
     *
     * @param {HTMLElement/String} item The jqx-menu-item/jqx-menu-items-group (or its id or numeric path) to remove.
     */
    removeItem(item) {
        const that = this;

        item = that.getItem(item);

        if (item === undefined) {
            return;
        }

        const itemParent = item.parentElement;

        if (item instanceof JQX.MenuItemsGroup) {
            const container = item.container;

            if (that._isContainerOpened(container.level, container)) {
                that._closeSubContainers(container.level, container);
            }

            if (item.level === 1) {
                const index = that._containersInBody.indexOf(container);

                if (index !== -1) {
                    that._containersInBody.splice(index, 1);

                    if (that.dropDownAppendTo !== null && that.mode !== 'tree' && !that._minimized) {
                        that._dropDownParent.removeChild(container);
                    }
                }
            }
        }

        itemParent.removeChild(item);
        that._refreshContainersArrays();
        that._menuItems = {};
        that._refreshItemPaths(that.$.mainContainer, true);
        that._checkOverflowAddRemove(item.level, itemParent);
    }

    /**
     * Unchecks an item.
     *
     * @param {HTMLElement/String} item jqx-menu-item/jqx-menu-items-group (or its id or numeric path).
     */
    uncheckItem(item) {
        const that = this;

        item = that.getItem(item);

        if (item === undefined || !item.checked || item.disabled || item.templateApplied) {
            return;
        }

        that._toggleItem(item);
    }

    /**
     * Called when a property is changed.
     */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this;

        function checkOverflow() {
            if (that.dropDownAppendTo !== null || that.mode === 'tree') {
                that._checkOverflow(that.$.mainContainer, that.mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]);
            }
        }

        function updateAttribute(attribute, container, setAttribute) {
            if (setAttribute) {
                container.setAttribute(attribute, '');
            }
            else {
                container.removeAttribute(attribute);
            }
        }

        switch (propertyName) {
            case 'animation':
                that.$.mainContainer.setAttribute('animation', newValue);
                that._additionalScrollButtons.forEach(function (element) {
                    element[0].animation = newValue;
                    element[1].animation = newValue;
                });

                if (that._dropDownParent !== null) {
                    that._containers.forEach(function (element) {
                        element.setAttribute('animation', newValue);
                    });
                }

                break;
            case 'checkable':
                if (that.mode !== 'tree' && !that._minimized) {
                    that._closeSubContainers(2);
                }
                else if (that._minimized && that.dropDownAppendTo !== null) {
                    updateAttribute('checkable', that.$.mainContainer, newValue);
                }

                break;
            case 'checkboxes':
                that._close();

                if (that.dropDownAppendTo !== null) {
                    for (let i = 0; i < that._containers.length; i++) {
                        const container = that._containers[i];

                        updateAttribute('checkboxes', container, newValue);
                    }

                    if (that._minimized) {
                        updateAttribute('checkboxes', that.$.mainContainer, newValue);
                    }
                }

                break;
            case 'checkMode':
                that._changeToRadioButtonMode(newValue, that.$.mainContainer);

                if (that._minimized && that.dropDownAppendTo !== null) {
                    that.$.mainContainer.setAttribute('check-mode', newValue);
                }

                break;
            case 'dataSource': {
                let toMinimize = false;

                if (that._minimized) {
                    that.maximize();
                    toMinimize = true;
                }

                that._removeContainersInBody();
                that._containersInBody = [];
                that._menuItems = {};
                that._processDataSource();
                that._checkContainersLength();

                if (toMinimize) {
                    that.minimize();
                }
                else {
                    checkOverflow();
                }

                that._expandItemsByDefault();

                that._suppressResizeHandler = true;
                setTimeout(() => delete that._suppressResizeHandler, 500);
                break;
            }
            case 'dropDownAppendTo': {
                const oldDropDownParent = that._dropDownParent;

                that._positionDetection.getDropDownParent();

                if (that._dropDownParent === oldDropDownParent || (that.mode === 'tree' && !that._minimized)) {
                    return;
                }

                that._close();

                if (that._minimized) {
                    if (newValue === null) {
                        that._appendMinimizedContainerToMenu(that.$.mainContainer, that.$.scrollButtonFar);
                    }
                    else {
                        that._appendMinimizedContainerToExternalElement(that.$.mainContainer);
                    }

                    return;
                }

                if (that._dropDownParent !== null && oldDropDownParent === null) {
                    that._moveDropDownsToExternalContainer();
                }
                else if (that._dropDownParent === null && oldDropDownParent !== null) {
                    that._moveDropDownsToMenu();
                }
                else if (that._dropDownParent !== null && oldDropDownParent !== null) {
                    for (let i = 0; i < that._containersInBody.length; i++) {
                        that._dropDownParent.appendChild(that._containersInBody[i]);
                    }
                }

                if (newValue === null && !that.$mainContainer.hasClass('simple')) {
                    that._hideMainContainerScrollButtons();
                }
                else {
                    that._checkOverflow(that.$.mainContainer, that.mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]);
                }

                for (let i = 0; i < that._containersFixedHeight.length; i++) {
                    that._containersFixedHeight[i].itemContainer.checkOverflow = true;
                }

                if (that.mode === 'dropDown') {
                    that.close({ trigger: 'internal' });
                    that._reparentMenu(true, oldDropDownParent);
                }

                break;
            }
            case 'dropDownOverlay':
                if (!newValue) {
                    that._positionDetection.removeOverlay();
                }

                break;
            case 'disabled':
                if (newValue) {
                    that._close();
                }

                that._setFocusable();
                that.$.scrollButtonNear.disabled = newValue;
                that.$.scrollButtonFar.disabled = newValue;

                if (!newValue && (that.dropDownAppendTo !== null || that.$mainContainer.hasClass('simple') || that.mode === 'tree')) {
                    that._updateScrollButtonVisibility(that.$.mainContainer, that.mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]);
                }

                break;
            case 'dropDownPosition':
            case 'mode': {
                if (propertyName === 'mode') {
                    delete that._dynamicallyReparented;

                    if (oldValue === 'tree' || that._minimized) {
                        that._closeSubContainersTreeMode(2, undefined, undefined, undefined, true);
                        that._openedContainers = [];
                    }
                    else {
                        that._closeSubContainersDefaultMode(2);
                    }

                    that._discardKeyboardHover(true);

                    if (that._minimized && that._minimizedDropDownOpened) {
                        that.$mainContainer.addClass('jqx-visibility-hidden');
                        that.$hamburgerIcon.removeClass('jqx-close-button');
                        that._minimizedDropDownOpened = false;
                    }

                    if (newValue === 'horizontal' || oldValue === 'horizontal') {
                        that._changeScrollButtonsArrows();
                    }

                    if (that._minimized) {
                        if (newValue === 'dropDown') {
                            that.mode = oldValue;
                        }

                        return;
                    }

                    if (that.opened === false) {
                        if (newValue === 'dropDown') {
                            that.$.addClass('jqx-visibility-hidden');
                        }
                        else if (oldValue === 'dropDown') {
                            that.$.removeClass('jqx-visibility-hidden');
                        }
                    }

                    if (oldValue === 'tree') {
                        if (that.dropDownAppendTo !== null) {
                            that._moveDropDownsToExternalContainer();
                        }

                        that.$mainContainer.addClass('jqx-menu-main-container');
                        that.$mainContainer.removeClass('jqx-menu-minimized-items-container');

                        that._applyContainerFixedHeight();
                    }
                    else if (newValue === 'tree') {
                        if (that.dropDownAppendTo !== null) {
                            that._moveDropDownsToMenu();
                        }

                        that._applyTreeMode();
                    }

                    if (that.overflow === 'auto') {
                        that._hideMainContainerScrollButtons();
                    }

                    checkOverflow();
                }

                if (that.mode === 'tree' || that._minimized) {
                    if (that._minimizedDropDownOpened) {
                        that._close();
                    }

                    if (that._minimized && that.dropDownAppendTo !== null) {
                        that.$.mainContainer.setAttribute(that.properties[propertyName].attributeName, newValue);
                    }

                    return;
                }
                else if (propertyName === 'dropDownPosition') {
                    that._close();
                }

                const menuItemsGroups = that.enableShadowDOM ? that.shadowRoot.querySelectorAll('jqx-menu-items-group') : that.getElementsByTagName('jqx-menu-items-group');

                for (let i = 0; i < menuItemsGroups.length; i++) {
                    const currentMenuItemsGroup = menuItemsGroups[i];

                    that._setArrowDirection(currentMenuItemsGroup.children[0].children[1], currentMenuItemsGroup.level + 1);
                }

                if (that.dropDownAppendTo !== null) {
                    for (let i = 0; i < that._containers.length; i++) {
                        const container = that._containers[i];

                        container.setAttribute(JQX.Utilities.Core.toDash(propertyName), newValue);

                        if (container.level > 2) {
                            that._setArrowDirection(container.menuItemsGroup.children[0].children[1], container.level);
                        }
                    }
                }

                break;
            }
            case 'minimizeIconTemplate':
                that._applyMinimizeIconTemplate(newValue, oldValue);
                break;
            case 'minimizeWidth':
                that._resizeHandler();
                break;
            case 'opened':
                if (newValue) {
                    that.open();
                }
                else {
                    that.close({ trigger: 'internal' });
                }

                break;
            case 'overflow':
                that._handleOverflowChange();
                break;
            case 'theme':
                if (that.dropDownAppendTo === null || JQX.ListMenu && that instanceof JQX.ListMenu) {
                    return;
                }

                if (that._minimized) {
                    if (oldValue !== '') {
                        that.$mainContainer.removeClass(oldValue);
                    }

                    if (newValue !== '') {
                        that.$mainContainer.addClass(newValue);
                    }
                }
                else {
                    for (let i = 0; i < that._containers.length; i++) {
                        const container = that._containers[i];

                        if (oldValue !== '') {
                            container.classList.remove(oldValue);
                        }

                        if (newValue !== '') {
                            container.classList.add(newValue);
                        }
                    }
                }

                break;
            case 'unfocusable':
                that._setFocusable();
                break;
        }
    }

    /**
     * Adds a container to the "_openedContainers" array.
     */
    _addOpenedContainer(level, container) {
        const that = this;

        if (that.mode === 'tree' || that._minimized) {
            if (!that._openedContainers[level]) {
                that._openedContainers[level] = [];
            }

            const menuItemsGroup = container.menuItemsGroup;

            menuItemsGroup.set('expanded', true);

            if (that._updateState) {
                that._updateState('expanded', menuItemsGroup.id, true);
            }

            return that._openedContainers[level].push(container);
        }
        else {
            that._openedContainers[level] = container;
        }
    }

    /**
     * Appends the minimized items container to external element.
     */
    _appendMinimizedContainerToExternalElement(itemsContainer) {
        const that = this;

        itemsContainer.ownerElement = that;
        that._dropDownParent.appendChild(itemsContainer);
        itemsContainer.setAttribute('animation', that.animation);

        if (that.theme !== '') {
            itemsContainer.$.addClass(that.theme);
        }

        itemsContainer.$.addClass('jqx-menu-drop-down jqx-drop-down');
        itemsContainer.$.addClass('jqx-drop-down-repositioned');
        itemsContainer.setAttribute('check-mode', that.checkMode);
        itemsContainer.setAttribute('drop-down-position', that.dropDownPosition);
        itemsContainer.setAttribute('mode', that.mode);
        itemsContainer.setAttribute('loading-indicator-position', that.loadingIndicatorPosition);

        if (that.checkable) {
            itemsContainer.setAttribute('checkable', '');
        }

        if (that.checkboxes) {
            itemsContainer.setAttribute('checkboxes', '');
        }

        if (that.$.view && that.detachedChildren.indexOf(that.$.view)) {
            that.detachedChildren.push(that.$.view);
        }
    }

    /**
     * Appends the minimized items container to Menu.
     */
    _appendMinimizedContainerToMenu(itemsContainer, sibling) {
        const that = this;

        delete itemsContainer.ownerElement;
        that.$.container.insertBefore(itemsContainer, sibling);

        itemsContainer.removeAttribute('animation');

        if (that.theme !== '') {
            itemsContainer.$.removeClass(that.theme);
        }

        itemsContainer.$.removeClass('jqx-menu-drop-down jqx-drop-down');
        itemsContainer.$.removeClass('jqx-drop-down-repositioned');
        itemsContainer.removeAttribute('checkable');
        itemsContainer.removeAttribute('checkboxes');
        itemsContainer.removeAttribute('check-mode');
        itemsContainer.removeAttribute('drop-down-position');
        itemsContainer.removeAttribute('mode');
        itemsContainer.removeAttribute('loading-indicator-position');
        itemsContainer.removeAttribute('style');
    }

    /**
     * Applies fixed heights to containers.
     */
    _applyContainerFixedHeight() {
        const that = this;

        for (let i = 0; i < that._containers.length; i++) {
            const container = that._containers[i];

            if (that._containersFixedHeight.indexOf(container) !== -1) {
                container.style.height = container.menuItemsGroup.dropDownHeight + 'px';
                container.itemContainer.checkOverflow = true;
            }
            else {
                container.style.height = '';
            }
        }
    }

    /**
     * Applies grouping.
     */
    _applyGrouping(item, noRecursion) {
        const that = this;
        let itemChildren;

        if (item === that.$.mainContainer) {
            itemChildren = Array.from(item.children);
        }
        else {
            itemChildren = Array.from(item.container.firstElementChild.children);
        }

        for (let i = 0; i < itemChildren.length; i++) {
            const currentItem = itemChildren[i];

            currentItem.originalIndex = i;

            if (currentItem instanceof JQX.MenuItemsGroup && noRecursion === undefined) {
                that._applyGrouping(currentItem);
            }
        }

        that._sortItems(item);
    }

    /**
     * Applies minimize icon template.
     */
    _applyMinimizeIconTemplate(newValue, oldValue) {
        const that = this;

        if (newValue === null) {
            if (oldValue === null) {
                return;
            }

            that.$customIconContainer.addClass('jqx-hidden');
            that.$.customIconContainer.innerHTML = '';

            that.$hamburgerIconLineTop.removeClass('jqx-hidden');
            that.$hamburgerIconLineCenter.removeClass('jqx-hidden');
            that.$hamburgerIconLineBottom.removeClass('jqx-hidden');
        }
        else {
            const potentialHTMLTemplate = document.getElementById(newValue);

            if (potentialHTMLTemplate !== null && potentialHTMLTemplate.tagName.toLowerCase() === 'template') {
                // label is the id of an HTML template
                const templateContent = document.importNode(potentialHTMLTemplate.content, true);

                that.$hamburgerIconLineTop.addClass('jqx-hidden');
                that.$hamburgerIconLineCenter.addClass('jqx-hidden');
                that.$hamburgerIconLineBottom.addClass('jqx-hidden');

                that.$.customIconContainer.innerHTML = '';
                that.$.customIconContainer.appendChild(templateContent);
                that.$customIconContainer.removeClass('jqx-hidden');
            }
            else {
                that.minimizeIconTemplate = oldValue;
            }
        }
    }

    /**
     * Applies mode: 'tree'.
     */
    _applyTreeMode() {
        const that = this,
            arrows = that.getElementsByClassName('jqx-menu-items-group-arrow');

        that.$mainContainer.removeClass('jqx-menu-main-container');
        that.$mainContainer.addClass('jqx-menu-minimized-items-container');

        if (that.isCompleted) {
            for (let i = 0; i < arrows.length; i++) {
                arrows[i].className = 'jqx-menu-items-group-arrow down';
            }
        }

        that._removeContainerFixedHeight();
    }

    /**
     * Default left arrow handler.
     */
    _arrowLeftHandler(level, mode, focusedItem, lastOpenedContainer) {
        const that = this;

        if (level === 1) {
            if (mode === 'horizontal') {
                that._levelOneNavigate('_getLastEnabledChild', focusedItem, lastOpenedContainer);
            }
        }
        else if (level === 2) {
            that._levelOneNavigateFromLowerLevel('_getPreviousEnabledChild', focusedItem);
        }
        else {
            that._escapeHandler(focusedItem, level, lastOpenedContainer);
        }
    }

    /**
     * Default right arrow handler.
     */
    _arrowRightHandler(level, mode, focusedItem, lastOpenedContainer) {
        const that = this;

        if (level === 1) {
            if (mode === 'horizontal') {
                that._levelOneNavigate('_getFirstEnabledChild', focusedItem, lastOpenedContainer);
            }
            else {
                that._levelOneOpenDropDown(focusedItem);
            }
        }
        else {
            if (focusedItem instanceof JQX.MenuItemsGroup) {
                that._selectionHandler({ target: focusedItem, isTrusted: true });
            }
            else {
                that._levelOneNavigateFromLowerLevel('_getNextEnabledChild', focusedItem);
            }
        }
    }

    /**
     * Repositions container if it intersects with browser bounds.
     */
    _browserBoundsDetection(container) {
        const that = this;

        if (that.mode === 'tree' && !that._minimized) {
            return;
        }

        container.style.marginTop = '';
        container.style.marginLeft = '';

        if (that.dropDownPosition !== 'auto') {
            return;
        }

        const windowWidth = window.devicePixelRatio === 1 ? document.documentElement.clientWidth : window.innerWidth,
            windowHeight = window.devicePixelRatio === 1 ? document.documentElement.clientHeight : window.innerHeight,
            containerBoundingRect = container.getBoundingClientRect(),
            horizontalCorrection = windowWidth - containerBoundingRect.left - container.offsetWidth,
            verticalCorrection = windowHeight - containerBoundingRect.top - container.offsetHeight;

        if (horizontalCorrection < 10) {
            container.style.marginLeft = Math.min(horizontalCorrection - 10, -10) + 'px';
        }

        if (verticalCorrection < 10) {
            container.style.marginTop = Math.min(verticalCorrection - 10, -10) + 'px';
        }
    }

    /**
     * Changes the direction of scroll button arrows.
     */
    _changeScrollButtonsArrows() {
        const that = this;

        if (that.mode === 'horizontal') {
            that.$arrowNear.removeClass('jqx-arrow-up');
            that.$arrowNear.addClass('jqx-arrow-left');
            that.$arrowFar.removeClass('jqx-arrow-down');
            that.$arrowFar.addClass('jqx-arrow-right');
        }
        else {
            that.$arrowNear.removeClass('jqx-arrow-left');
            that.$arrowNear.addClass('jqx-arrow-up');
            that.$arrowFar.removeClass('jqx-arrow-right');
            that.$arrowFar.addClass('jqx-arrow-down');
        }
    }

    /**
     * Changes to checkMode: 'radioButton'.
     */
    _changeToRadioButtonMode(newValue, container, item) {
        if (newValue === 'radioButton') {
            const checkedChildren = [];

            for (let i = 0; i < container.childElementCount; i++) {
                const currentItem = container.children[i];

                if (currentItem.checked && !currentItem.disabled && !currentItem.templateApplied) {
                    checkedChildren.push(currentItem);
                }
            }

            this._validateRadioButtonSelection(item, item ? item.level + 1 : 1, checkedChildren);
        }
    }

    /**
     * Checks the number of dropdowns.
     */
    _checkContainersLength(initialization) {
        const that = this;

        if (that._containers.length === 0) {
            that.$mainContainer.addClass('simple');

            if (!initialization) {
                that._checkOverflow(that.$.mainContainer, that.mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]);
            }
        }
        else if (!initialization) {
            that.$mainContainer.removeClass('simple');

            if (that.dropDownAppendTo === null && that.mode !== 'tree') {
                that.$mainContainer.removeClass('scroll-buttons-shown one-button-shown');
            }
        }
    }

    /**
     * Checks if items overflow and shows/hides scroll buttons.
     */
    _checkOverflow(element, horizontal, scrollButtons) {
        const that = this,
            overflow = element === that.$.mainContainer ? that.overflow : 'auto';

        if (that._minimized || overflow === 'hidden' ||
            (that.dropDownAppendTo === null && that.mode !== 'tree' && element === that.$.mainContainer && !that.$mainContainer.hasClass('simple'))) {
            return;
        }

        const oldScrollTop = element.scrollTop;

        if (overflow === 'auto') {
            element.classList.remove('scroll-buttons-shown');
            element.classList.remove('one-button-shown');
            scrollButtons[0].$.addClass('jqx-hidden');
            scrollButtons[1].$.addClass('jqx-hidden');
        }

        let overflowing, showNear, showFar;

        if (horizontal) {
            overflowing = Math.round(element.scrollWidth) > Math.round(element.offsetWidth);
            showNear = Math.round(element.scrollLeft) > 0;
            showFar = Math.round(element.offsetWidth + element.scrollLeft) < Math.round(element.scrollWidth);
        }
        else {
            overflowing = Math.round(element.scrollHeight) > Math.round(element.offsetHeight);
            showNear = Math.round(element.scrollTop) > 0;
            showFar = Math.round(element.offsetHeight + element.scrollTop) < Math.round(element.scrollHeight);
        }

        if (overflowing) {
            if (overflow === 'auto') {
                element.classList.add('scroll-buttons-shown');

                if (showNear) {
                    scrollButtons[0].$.removeClass('jqx-hidden');
                }

                if (showFar) {
                    scrollButtons[1].$.removeClass('jqx-hidden');
                }

                if ((showNear && showFar) === false) {
                    element.classList.add('one-button-shown');
                }

                if (!that.disabled) {
                    scrollButtons[0].disabled = false;
                    scrollButtons[1].disabled = false;
                }

                element.scrollTop = oldScrollTop;
            }
            else {
                scrollButtons[0].$.removeClass('jqx-hidden');
                scrollButtons[1].$.removeClass('jqx-hidden');

                if (that.disabled) {
                    scrollButtons[0].disabled = true;
                    scrollButtons[1].disabled = true;
                }
                else {
                    scrollButtons[0].disabled = !showNear;
                    scrollButtons[1].disabled = !showFar;
                }
            }
        }
        else if (overflow === 'scroll') {
            scrollButtons[0].disabled = true;
            scrollButtons[1].disabled = true;
        }

        if (element === that.$.mainContainer && that.mode !== 'tree') {
            that._close();
        }
    }

    /**
     * Checks overflow after "addItem" or "removeItem" has been called.
     */
    _checkOverflowAddRemove(level, itemParent) {
        const that = this;

        if (level === 1 && that.dropDownAppendTo !== null || that.mode === 'tree') {
            that._checkOverflow(that.$.mainContainer, that.mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]);
        }
        else if (level > 1 && itemParent.dropDownHeightSet) {
            if (that._isContainerOpened(level, itemParent.container)) {
                that._checkOverflow(itemParent, false, [itemParent.container.children[0], itemParent.container.children[2]]);
            }
            else {
                itemParent.checkOverflow = true;
            }
        }
    }

    /**
     * Closes any open dropdown containers.
     */
    _close() {
        const that = this;

        that._positionDetection.removeOverlay();
        that._closeSubContainers(2);
        that._discardKeyboardHover(true);

        if (that._minimized && that._minimizedDropDownOpened) {
            that.$mainContainer.addClass('jqx-visibility-hidden');

            if (that._edgeMacFF) {
                that.$.mainContainer.style.left = '';
                that.$.mainContainer.style.top = '';
                that.$mainContainer.addClass('not-in-view');
            }

            that.$hamburgerIcon.removeClass('jqx-close-button');
            that._minimizedDropDownOpened = false;
        }
    }

    /**
     * Closes sub-containers.
     */
    _closeSubContainers(level, container, preserveClass, fireEvent) {
        const that = this;

        if (that.mode !== 'tree' && !that._minimized) {
            that._closeSubContainersDefaultMode(level, container, preserveClass);
        }
        else {
            that._closeSubContainersTreeMode(level, container, preserveClass, fireEvent);
        }
    }

    /**
     * Closes sub-containers (in horizontal/vertical/dropDown mode).
     */
    _closeSubContainersDefaultMode(level, container, preserveClass) {
        const that = this,
            openedContainers = that._openedContainers;

        function applyClasses(i) {
            const menuItemsGroup = openedContainers[i].menuItemsGroup;

            if (!(preserveClass && i === level)) {
                menuItemsGroup.$.removeClass('focus');
                menuItemsGroup.removeAttribute('focus');
                menuItemsGroup.$.removeClass('hover');
                menuItemsGroup.removeAttribute('hover');

            }

            menuItemsGroup.$.removeClass('jqx-menu-items-group-opened');
            openedContainers[i].$.addClass('jqx-visibility-hidden');

            if (that._edgeMacFF && i === 2 && !that.hasAnimation) {
                openedContainers[i].style.left = '';
                openedContainers[i].style.top = '';
                openedContainers[i].$.addClass('not-in-view');
            }

            if (that._minimized) {
                that._browserBoundsDetection(that.$.mainContainer);
            }

            that.$.fireEvent('collapse', {
                'item': menuItemsGroup,
                'label': menuItemsGroup.label,
                'path': menuItemsGroup.path,
                'value': menuItemsGroup.value,
                'children': menuItemsGroup.itemContainer.children
            });

            openedContainers[i] = undefined;
        }

        for (let i = openedContainers.length - 1; i >= level; i--) {
            if (openedContainers[i] === undefined) {
                continue;
            }

            applyClasses(i, true);
        }
    }

    /**
     * Closes sub-containers (in tree/minimized mode).
     */
    _closeSubContainersTreeMode(level, container, preserveClass, fireEvent, modeChanged) {
        const that = this;

        if (fireEvent) {
            const menuItemsGroup = container.menuItemsGroup,
                collapsingEvent = that.$.fireEvent('collapsing', {
                    'item': menuItemsGroup,
                    'label': menuItemsGroup.label,
                    'path': menuItemsGroup.path,
                    'value': menuItemsGroup.value,
                    'children': container.itemContainer.children
                });

            if (collapsingEvent.defaultPrevented) {
                return;
            }
        }

        if (container === undefined) {
            that._collapseAll(false, modeChanged);
            return;
        }

        const menuItemsGroup = container.menuItemsGroup;

        menuItemsGroup.set('expanded', false);

        if (that._element === 'menu') {
            if (preserveClass) {
                const currentFocus = that.$.mainContainer.getElementsByClassName('focus')[0];

                if (currentFocus) {
                    currentFocus.$.removeClass('focus');
                    currentFocus.removeAttribute('focus');
                }

                menuItemsGroup.$.addClass('focus');
                menuItemsGroup.setAttribute('focus', '');
                that._focusedViaKeyboard = menuItemsGroup;
            }
            else {
                menuItemsGroup.$.removeClass('focus');
                menuItemsGroup.removeAttribute('focus');
            }
        }
        else {
            that._updateState('expanded', menuItemsGroup.id, false);
        }

        menuItemsGroup.$.removeClass('jqx-' + that._element + '-items-group-opened');

        if (modeChanged || !that.hasAnimation) {
            menuItemsGroup.$.removeClass('jqx-' + that._element + '-items-group-expanded');
            container.$.addClass('jqx-visibility-hidden');

            if (that._minimized) {
                that._browserBoundsDetection(that.$.mainContainer);
            }
        }
        else {
            that._collapseSection(container);
        }

        if (fireEvent) {
            const eventDetail = {
                'item': menuItemsGroup,
                'label': menuItemsGroup.label,
                'path': menuItemsGroup.path,
                'value': menuItemsGroup.value,
                'children': menuItemsGroup.itemContainer.children
            };

            if (that.toggleCallback) {
                eventDetail.type = 'collapse';
                that.toggleCallback(eventDetail);
            }
            else {
                that.$.fireEvent('collapse', eventDetail);
            }
        }

        if (!that._openedContainers[level]) {
            return;
        }

        const index = that._openedContainers[level].indexOf(container);

        if (index !== -1) {
            that._openedContainers[level].splice(index, 1);
        }
    }

    /**
     * Collapses all items (in tree/minimized mode).
     */
    _collapseAll(fireEvent, modeChanged) {
        const that = this;

        for (let i = that._openedContainers.length - 1; i >= 2; i--) {
            if (that._openedContainers[i] === undefined) {
                break;
            }

            for (let j = that._openedContainers[i].length - 1; j >= 0; j--) {
                that._closeSubContainersTreeMode(i, that._openedContainers[i][j], undefined, fireEvent, modeChanged);
            }
        }

        if (!that.hasAnimation) {
            that._checkOverflow(that.$.mainContainer, false, [that.$.scrollButtonNear, that.$.scrollButtonFar]);
        }

        for (let i = that._openedContainers.length - 1; i >= 2; i--) {
            const currentSet = that._openedContainers[i];

            if (currentSet === undefined || currentSet.length === 0) {
                that._openedContainers.splice(i, 1);
            }
            else {
                break;
            }
        }

        if (that._openedContainers.length === 2) {
            that._openedContainers = [];
        }
    }

    /**
     * Collapses a section (in tree/minimized mode).
     */
    _collapseSection(element) {
        const that = this,
            sectionHeight = element.scrollHeight + 'px';

        that._treeAnimationInProgress = element;
        element.style.transition = 'none';

        requestAnimationFrame(function () {
            if (that.mode !== 'tree' && !that._minimized) {
                element.style.transition = '';
                return;
            }

            element.style.height = sectionHeight;
            element.style.transition = '';

            requestAnimationFrame(function () {
                element.style.height = '0px';

                if (that.tagName.toLowerCase() === 'jqx-tree') {
                    element.$.addClass('jqx-visibility-hidden');
                }

                if (sectionHeight === '0px') {
                    that._transitionendHandlerCollapse(that, element);
                }
            });
        });

        element.addEventListener('transitionend', that._transitionendHandlerCollapse);
    }

    /**
     * Applies initial settings to the Menu element.
     */
    _createElement() {
        const that = this,
            mode = that.mode;

        that._positionDetection = new JQX.Utilities.PositionDetection(that);
        that._positionDetection.getDropDownParent();
        that._reparentMenu();

        if (that.disabled) {
            that.$.scrollButtonNear.disabled = true;
            that.$.scrollButtonFar.disabled = true;
        }

        if (that.dataSource === null && that.$.mainContainer.firstElementChild instanceof HTMLUListElement) {
            that._processUList();
        }

        const items = that.getElementsByTagName('jqx-menu-item');

        const itemsReady = function () {
            const animationType = that.animation;

            that._changeScrollButtonsArrows();

            that._setFocusable();

            if (mode === 'dropDown' && that.opened === false) {
                if (that.hasAnimation) {
                    that.animation = 'none';
                    that.$.addClass('jqx-visibility-hidden');
                    that.animation = animationType;
                }
                else {
                    that.$.addClass('jqx-visibility-hidden');
                }
            }

            that._menuItems = {};

            that.$.mainContainer.setAttribute('animation', animationType);

            if (that.dataSource === null) {
                that._processHTML(that.$.mainContainer, 1);
            }
            else {
                that._processDataSource();
            }

            that._checkContainersLength(true);

            if ((that.dropDownAppendTo !== null || that.$mainContainer.hasClass('simple') || that.mode === 'tree') && that.overflow === 'scroll') {
                that.$mainContainer.addClass('scroll-buttons-shown');
                that.$scrollButtonNear.removeClass('jqx-hidden');
                that.$scrollButtonFar.removeClass('jqx-hidden');
                that._updateScrollButtonVisibility(that.$.mainContainer, mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]);
            }

            that._applyMinimizeIconTemplate(that.minimizeIconTemplate, null);

            if (mode === 'tree') {
                that._applyTreeMode();
            }

            if (that.minimizeWidth !== null && that.offsetWidth <= that.minimizeWidth) {
                that.minimize();
            }
            else {
                that._checkOverflow(that.$.mainContainer, mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]);
            }

            that._expandItemsByDefault();

            if (that.__onCompleted) {
                that._onCompleted = that.__onCompleted;
                that.__onCompleted = null;
                that._onCompleted();
            }
        }

        if (items.length === 0) {
            itemsReady();
        }
        else {
            if (that._onCompleted) {
                that.__onCompleted = that._onCompleted;
                that._onCompleted = null;
            }
            that._ensureItemsReady(items, itemsReady);
        }
    }

    _ensureItemsReady(nodes, callback) {
        const that = this;

        const contextCallback = function () {
            const setContext = function (context) {
                for (let i = 0; i < nodes.length; i++) {
                    nodes[i].context = context === 'node' ? nodes[i] : document;
                }
            }

            setContext('node');
            callback();
            setContext();
        }

        if (nodes.length === 0) {
            contextCallback();
        }
        else {
            that._nodesReadyListeners = 0;

            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];

                const readyEventHandler = function () {
                    that._nodesReadyListeners--;
                    if (that._nodesReadyListeners === 0) {
                        contextCallback();

                        delete that._nodesReadyListeners;
                    }
                }.bind(that);

                if (!node.isCompleted) {
                    that._nodesReadyListeners++;
                    node.completeHandlers = [];
                    node._onCompleted = readyEventHandler;
                }
            }

            if (that._nodesReadyListeners === 0) {
                contextCallback();
            }
        }
    }

    /**
     * Creates the necessary HTML structure for a jqx-menu-item/jqx-menu-items-group.
     */
    _createItemHTMLStructure(currentItem, level, item, index) {
        const that = this,
            labelContainer = document.createElement('div'),
            labelElement = document.createElement('div'),
            labelFragment = document.createDocumentFragment();
        let currentItemPath;

        currentItem.menu = that;

        if (level > 1) {
            currentItem.originalIndex = index;
            currentItemPath = item.path + '.' + currentItem.originalIndex;
            currentItem.parentItem = item;
        }
        else {
            currentItem.originalIndex = index;
            currentItemPath = '' + index;
        }

        currentItem.path = currentItemPath;
        that._menuItems[currentItemPath] = currentItem;

        labelContainer.className = 'jqx-' + that._element + '-item-label-container';
        labelElement.className = 'jqx-' + that._element + '-item-label-element';

        if (that._element === 'tree') {
            // Tree item indentation
            that._setIndentation(labelContainer, level, that.rightToLeft ? 'paddingRight' : 'paddingLeft');
        }

        const currentItemChildNodes = Array.from(currentItem.childNodes);

        for (let i = 0; i < currentItemChildNodes.length; i++) {
            const currentNode = currentItemChildNodes[i];

            if (currentNode instanceof JQX.MenuItem || currentNode instanceof JQX.MenuItemsGroup) {
                break;
            }

            labelElement.appendChild(currentNode);
        }

        if (labelElement.innerHTML.trim() === '') {
            const currentItemLabel = currentItem.label || currentItem.getAttribute('label');

            if (currentItemLabel && currentItemLabel !== '') {
                that._setLabel(currentItemLabel, labelElement, currentItem, true);
            }
            else {
                currentItem.set('label', 'Item ' + index);
                labelElement.innerHTML = 'Item ' + index;
            }
        }
        else {
            currentItem.set('label', labelElement.innerHTML.trim());
        }

        if (currentItem instanceof JQX.MenuItemsGroup && currentItem.titleLabel === undefined) {
            currentItem.titleLabel = currentItem.label;
        }

        labelElement.innerHTML = '<span>' + labelElement.innerHTML + '</span>';
        labelFragment.appendChild(labelElement);
        currentItem.set('level', level);
        currentItem.set('shortcut', currentItem.shortcut || currentItem.getAttribute('shortcut') || '');

        if (currentItem.shortcut && currentItem instanceof JQX.MenuItem) {
            const shortcutElement = document.createElement('div');

            shortcutElement.className = 'jqx-' + that._element + '-item-shortcut';
            shortcutElement.innerHTML = currentItem.shortcut;

            labelFragment.appendChild(shortcutElement);
        }

        labelContainer.appendChild(labelFragment);
        currentItem.insertBefore(labelContainer, currentItem.children[0]);

        if (!currentItem.id) {
            currentItem.id = that.id + 'ItemP' + currentItem.path.replace(/\./g, '_') + 'L' + currentItem.label.replace(/<|\/|>|"|'|=|\s/g, '');
        }
    }

    /**
     * Creates the dropdown container of jqx-menu-items-group.
     */
    _createMenuItemsGroupContainer(item, level) {
        const that = this,
            container = document.createElement('div'),
            itemContainer = document.createElement('div');

        container.className = 'jqx-' + that._element + '-drop-down jqx-visibility-hidden';

        if (that._edgeMacFF && level === 2 && that.mode !== 'tree') {
            container.className += ' not-in-view';
        }

        container.$ = JQX.Utilities.Extend(container);
        container.level = level;
        container.setAttribute('level', level);
        container.menuItemsGroup = item;

        itemContainer.className = 'jqx-' + that._element + '-item-container';
        itemContainer.$ = JQX.Utilities.Extend(itemContainer);
        itemContainer.container = container;
        itemContainer.menuItemsGroup = item;

        if (item.checkable) {
            itemContainer.setAttribute('checkable', '');
        }

        itemContainer.setAttribute('check-mode', item.checkMode);

        container.itemContainer = itemContainer;
        container.appendChild(itemContainer);

        if (item.dropDownHeight !== null) {
            const repeatButtonNear = document.createElement('jqx-repeat-button'),
                repeatButtonFar = document.createElement('jqx-repeat-button');

            repeatButtonNear.className = 'jqx-menu-scroll-button jqx-spin-button jqx-scroll-button-near jqx-hidden';
            repeatButtonNear.innerHTML = '<div id="arrowNear" class="jqx-arrow jqx-arrow-up"></div>';
            repeatButtonNear.animation = that.animation;
            repeatButtonNear.unfocusable = true;
            repeatButtonFar.className = 'jqx-menu-scroll-button jqx-spin-button jqx-scroll-button-far jqx-hidden';
            repeatButtonFar.innerHTML = '<div id="arrowNear" class="jqx-arrow jqx-arrow-down"></div>';
            repeatButtonFar.animation = that.animation;
            repeatButtonFar.unfocusable = true;

            container.insertBefore(repeatButtonNear, itemContainer);
            container.appendChild(repeatButtonFar);

            container.$.addClass('drop-down-height-set');
            itemContainer.dropDownHeightSet = true;
            itemContainer.checkOverflow = true;
            container.style.height = item.dropDownHeight + 'px';
            that._containersFixedHeight.push(container);
            that._additionalScrollButtons.push([repeatButtonNear, repeatButtonFar]);
        }

        return container;
    }

    /**
     * Removes "focused" class added by keyboard navigation.
     */
    _discardKeyboardHover(overrideCheck) {
        const that = this;

        if (!that._focusedViaKeyboard) {
            return;
        }

        if (!overrideCheck &&
            that._focusedViaKeyboard instanceof JQX.MenuItemsGroup &&
            that._isContainerOpened(that._focusedViaKeyboard.level + 1, that._focusedViaKeyboard.container)) {
            return;
        }

        that._focusedViaKeyboard.$.removeClass('focus');
        that._focusedViaKeyboard.removeAttribute('focus');
        that._focusedViaKeyboard.$.removeClass('hover');
        that._focusedViaKeyboard.removeAttribute('hover');

        that._focusedViaKeyboard = undefined;
    }

    /**
     * Document down handler.
     */
    _documentDownHandler(event) {
        const that = this;

        if (that.closeAction === 'down') {
            that._closeOnDocumentInteraction(event.originalEvent);
        }
    }

    /**
     * Document up handler.
     */
    _documentUpHandler(event) {
        const that = this,
            target = event.originalEvent.target;

        if (that.disabled || that.displayLoadingIndicator || !target.closest) {
            return;
        }

        const closed = that.closeAction === 'up' ? that._closeOnDocumentInteraction(event.originalEvent) : false;

        if (closed) {
            return;
        }

        let activeElement, isInsideElement;

        if (JQX.EnableShadowDOM) {
            activeElement = that.isInShadowRoot ? that.getRootNode().activeElement :
                (that.shadowRoot ? that.shadowRoot.activeElement || document.activeElement : document.activeElement);
            isInsideElement = that.$.container.contains(event.originalEvent.composedPath()[0]);
        }
        else {
            activeElement = document.activeElement;
            isInsideElement = that.contains(target);
        }

        if (!closed && that !== activeElement && activeElement.closest('[template-applied]') === null) {
            if (isInsideElement || target.closest('.jqx-list-menu-view') === that.$.view) {
                that.focus();
                return;
            }

            const closestDropDown = target.closest('.jqx-drop-down-repositioned');

            if (closestDropDown && closestDropDown.ownerElement === that) {
                that.focus();
            }
        }
    }

    /**
     * Closes Menu drop downs on interaction with the document.
     */
    _closeOnDocumentInteraction(event) {
        const that = this,
            target = event.target;
        let shadowRootTarget, isInsideElement;

        if (JQX.EnableShadowDOM) {
            shadowRootTarget = event.composedPath()[0];
            isInsideElement = that.$.container.contains(shadowRootTarget);
        }
        else {
            isInsideElement = that.contains(target);
        }

        if (that.mode === 'dropDown' && that.opened) {
            const closestDropDown = target.closest('.jqx-drop-down-repositioned');

            if (!isInsideElement && (!closestDropDown || closestDropDown.ownerElement !== that)) {
                that.close({ trigger: 'interaction', target: JQX.EnableShadowDOM ? shadowRootTarget : target });
                return true;
            }
        }

        if (!isInsideElement && target.closest('.jqx-menu-drop-down') === null ||
            shadowRootTarget && shadowRootTarget === that.$.mainContainer || target === that.$.mainContainer) {
            if (that.mode === 'tree') {
                return true;
            }

            that._close();
            return true;
        }
    }

    /**
     * Ends swiping and scrolls kinetically.
     */
    _endSwiping(event, now, noBounce) {
        const that = this;

        if (!that._dragStartDetails) {
            return;
        }

        const mainContainer = that.$.mainContainer,
            timeDifference = Math.abs(that._dragStartDetails.startTime - now),
            speed = 300 / timeDifference,
            distanceDifference = (that._dragStartDetails.startY - event.pageY) * speed;
        let remaining = Math.abs(distanceDifference);

        const scrollable = function () {
            if (distanceDifference > 0 &&
                mainContainer.scrollTop === mainContainer.scrollHeight - mainContainer.offsetHeight ||
                distanceDifference < 0 && mainContainer.scrollTop === 0) {
                return false;
            }

            return true;
        }

        let scrollStep = 0.03 * Math.abs(distanceDifference) * speed;

        const kineticScrolling = function () {
            if (scrollStep > 5) {
                const remainingPart = (remaining - scrollStep) / Math.abs(distanceDifference);

                if (remainingPart < 0.1) {
                    scrollStep /= 1.25;
                }
                else if (remainingPart < 0.15) {
                    scrollStep /= 1.2;
                }
                else if (remainingPart < 0.2) {
                    scrollStep /= 1.15;
                }
                else if (remainingPart < 0.25) {
                    scrollStep /= 1.1;
                }
                else if (remainingPart < 0.3) {
                    scrollStep /= 1.05;
                }
            }

            const oldScrollTop = mainContainer.scrollTop;

            if (distanceDifference > 0) {
                mainContainer.scrollTop = Math.min(oldScrollTop + scrollStep, mainContainer.scrollHeight - mainContainer.offsetHeight);
            }
            else {
                mainContainer.scrollTop = Math.max(oldScrollTop - scrollStep, 0);
            }

            remaining -= scrollStep;

            that._updateScrollButtonVisibility(that.$.mainContainer, that.mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]);

            const canBeScrolled = scrollable();

            if (remaining > 0 && canBeScrolled) {
                that._scrollingAnimationFrame = window.requestAnimationFrame(kineticScrolling);
            }
            else {
                that._wheelInProgress = false;

                if (!canBeScrolled) {
                    if (that._fireScrollBottomReachedEvent) {
                        that._fireScrollBottomReachedEvent(oldScrollTop);
                    }

                    if (noBounce !== true) {
                        const initialScrollTop = that.$.mainContainer.scrollTop;

                        if (initialScrollTop === 0) {
                            that._bounceTop();
                        }
                        else {
                            that._bounceBottom(initialScrollTop);
                        }
                    }
                }
            }
        };

        if (that._scrollingAnimationFrame) {
            cancelAnimationFrame(that._scrollingAnimationFrame);
        }

        if (timeDifference < 1000 && scrollable()) {
            that._scrollingAnimationFrame = window.requestAnimationFrame(kineticScrolling);
        }
        else {
            that._wheelInProgress = false;
        }

        delete that._dragStartDetails;
    }

    /**
     * Makes sure a jqx-menu-item/jqx-menu-items-group is visible by scrolling to it.
     */
    _ensureVisible(scrollTarget) {
        const that = this;

        if (that._minimized) {
            return;
        }

        const mode = that.mode;
        let parent, scrollButtons;

        if (mode !== 'tree' && scrollTarget.parentElement !== that.$.mainContainer) {
            if (scrollTarget.dropDownHeight === null) {
                return;
            }

            parent = scrollTarget.parentElement;
            scrollButtons = [parent.container.children[0], parent.container.children[2]];
        }
        else {
            parent = that.$.mainContainer;
            scrollButtons = [that.$.scrollButtonNear, that.$.scrollButtonFar];
        }

        if (parent === that.$.mainContainer &&
            (that.dropDownAppendTo === null && that.mode !== 'tree' && !that.$mainContainer.hasClass('simple') ||
                !parent.$.hasClass('scroll-buttons-shown') && that.overflow !== 'hidden')) {
            return;
        }

        const parentBoundingRect = parent.getBoundingClientRect(),
            scrollTargetBoundingRect = scrollTarget.getBoundingClientRect();

        if (mode === 'tree') {
            that._ensureVisibleTreeMode(scrollTarget, scrollTargetBoundingRect, parent, parentBoundingRect, 0);
            return;
        }

        function setTargetScrollValue(scrollValue, scrollDimension, dimension) {
            let targetScrollValue = scrollTarget.firstElementChild[dimension] + scrollValue - parent[dimension];

            if (targetScrollValue < 0) {
                targetScrollValue = scrollValue;
            }

            parent['scroll' + scrollDimension] = targetScrollValue;
        }

        function scrollTo(scrollDimension, dimension) {
            let scrollValue = scrollTarget['offset' + scrollDimension],
                oldParentDimension = parent[dimension];

            if (scrollDimension === 'Top' && parent !== that.$.mainContainer && !scrollButtons[0].$.hasClass('jqx-hidden')) {
                scrollValue -= scrollButtons[0][dimension];
            }

            setTargetScrollValue(scrollValue, scrollDimension, dimension);
            that._updateScrollButtonVisibility(parent, scrollDimension === 'Left', scrollButtons);

            if (oldParentDimension !== parent[dimension]) {
                setTargetScrollValue(scrollValue, scrollDimension, dimension);
            }
        }

        if ((parent === that.$.mainContainer && mode === 'horizontal') &&
            (parentBoundingRect.left > scrollTargetBoundingRect.left || parentBoundingRect.right < scrollTargetBoundingRect.right)) {
            scrollTo('Left', 'offsetWidth');
        }
        else if (parentBoundingRect.top > scrollTargetBoundingRect.top || parentBoundingRect.bottom < scrollTargetBoundingRect.bottom) {
            scrollTo('Top', 'offsetHeight');
        }
    }

    /**
     * Makes sure a jqx-menu-item/jqx-menu-items-group is visible by scrolling to it (when "mode" is 'tree').
     */
    _ensureVisibleTreeMode(item, scrollTargetBoundingRect, parent, parentBoundingRect, padding) {
        const that = this;

        if ((that._element === 'menu' || that.scrollMode === 'scrollButtons') && !parent.$.hasClass('scroll-buttons-shown') && that.overflow !== 'hidden') {
            return;
        }

        const oldHeight = parent.offsetHeight,
            scrollButtonNearHidden = that.$scrollButtonNear.hasClass('jqx-hidden');
        let newScrollTop;

        if (parentBoundingRect.top > scrollTargetBoundingRect.top) {
            newScrollTop = that._getOffsetTop(item);
        }
        else {
            let itemHeight = !item.expanded ?
                item.offsetHeight :
                item.firstElementChild.offsetHeight + parseInt(window.getComputedStyle(item.children[1]).marginTop, 10);

            if (that._element === 'tree') {
                itemHeight += parseFloat(getComputedStyle(that).getPropertyValue('--jqx-tree-item-vertical-offset')) || 0;
            }

            if (parentBoundingRect.bottom < scrollTargetBoundingRect.top + itemHeight) {
                newScrollTop = that._getOffsetTop(item) - oldHeight + itemHeight + padding;
            }
            else {
                return;
            }
        }

        parent.scrollTop = newScrollTop;

        if (that._element === 'menu' || that.scrollMode === 'scrollButtons') {
            that._updateScrollButtonVisibility(parent, false, [that.$.scrollButtonNear, that.$.scrollButtonFar]);
        }

        if (that.overflow === 'auto' && scrollButtonNearHidden && !that.$scrollButtonNear.hasClass('jqx-hidden')) {
            parent.scrollTop += oldHeight - parent.offsetHeight;
        }
    }

    /**
     * Escape key handler.
     */
    _escapeHandler(focusedItem, level, lastOpenedContainer) {
        const that = this;

        if (focusedItem) {
            focusedItem.$.removeClass('focus');
            focusedItem.removeAttribute('focus');
        }

        that._closeSubContainers(level, undefined, undefined, true);
        that._hoverViaKeyboard(lastOpenedContainer.menuItemsGroup);
    }

    /**
     * Expand items by default.
     */
    _expandItemsByDefault(collapseBeforehand) {
        const that = this;

        if (that._menuItemsGroupsToExpand.length === 0 && !collapseBeforehand ||
            that.mode !== 'tree' && !that._minimized) {
            return;
        }

        const restoreAnimation = that.hasAnimation,
            animationType = that.animation;

        if (restoreAnimation) {
            that.animation = 'none';
        }

        if (collapseBeforehand) {
            that._collapseAll(false);
        }

        for (let i = 0; i < that._menuItemsGroupsToExpand.length; i++) {
            that.expandItem(that._menuItemsGroupsToExpand[i].path, undefined, false);
        }

        if (restoreAnimation) {
            that.animation = animationType;
        }

        that._menuItemsGroupsToExpand = [];
    }

    /**
     * Expands a section (in tree/minimized mode).
     */
    _expandSection(element) {
        const that = this,
            oldHeight = element.style.height,
            sectionHeight = element.scrollHeight + 'px';

        element.style.height = sectionHeight;
        that._treeAnimationInProgress = element;

        if (oldHeight === sectionHeight ||
            !parseFloat(oldHeight) && !parseFloat(sectionHeight)) {
            that._transitionendHandlerExpand(that, element);
            return;
        }

        element.addEventListener('transitionend', that._transitionendHandlerExpand);
    }

    /**
     * Filter input keyup handler.
     */
    _filterInputKeyupHandler() {
        const that = this;

        if (that._filterTimer) {
            clearTimeout(that._filterTimer);
        }

        that._filterTimer = setTimeout(function () {
            const context = that.context;

            that.context = that;
            that._applyFilter(that.$.filterInput.value, that._view);
            that._checkOverflow();
            that.context = context;
        }, 300);
    }

    /**
     * Finds an item based on filter criteria.
     */
    _findItem(item, filterQuery) {
        if (filterQuery === '') {
            return item;
        }

        const that = this;

        switch (that.filterMode) {
            case 'startsWith':
                if (item.label.indexOf(filterQuery) === 0) {
                    return item;
                }

                break;
            case 'startsWithIgnoreCase':
                if (item.label.toLowerCase().indexOf(filterQuery.toLowerCase()) === 0) {
                    return item;
                }

                break;
            case 'doesNotContain':
                if (item.label.indexOf(filterQuery) < 0) {
                    return item;
                }

                break;
            case 'doesNotContainIgnoreCase':
                if (item.label.toLowerCase().indexOf(filterQuery.toLowerCase()) < 0) {
                    return item;
                }

                break;
            case 'contains':
                if (item.label.indexOf(filterQuery) > -1) {
                    return item;
                }

                break;
            case 'containsIgnoreCase':
                if (item.label.toLowerCase().indexOf(filterQuery.toLowerCase()) > -1) {
                    return item;
                }

                break;
            case 'equals':
                if (item.label.localeCompare(filterQuery) === 0) {
                    return item;
                }

                break;
            case 'equalsIgnoreCase':
                if (item.label.toLowerCase().localeCompare(filterQuery.toLowerCase()) === 0) {
                    return item;
                }

                break;
            case 'endsWith':
                if (item.label.endsWith(filterQuery)) {
                    return item;
                }

                break;
            case 'endsWithIgnoreCase':
                if (item.label.toLowerCase().endsWith(filterQuery.toLowerCase())) {
                    return item;
                }

                break;
        }

        return null;
    }

    /**
     * Returns the first MenuItem/MenuItemsGroup that is not disabled.
     */
    _getFirstEnabledChild(parent) {
        const children = parent.children;

        for (let i = 0; i < children.length; i++) {
            if (this._isChildEnabled(children[i])) {
                return children[i];
            }
        }
    }

    /**
     * Returns the last MenuItem/MenuItemsGroup that is not disabled.
     */
    _getLastEnabledChild(parent) {
        const children = parent.children;

        for (let i = children.length - 1; i >= 0; i--) {
            if (this._isChildEnabled(children[i])) {
                return children[i];
            }
        }
    }

    /**
     * Returns the next MenuItem/MenuItemsGroup that is not disabled.
     */
    _getNextEnabledChild(child) {
        if (!child) {
            return;
        }

        while (child.nextElementSibling) {
            const nextElementSibling = child.nextElementSibling;

            if (this._isChildEnabled(nextElementSibling)) {
                return nextElementSibling;
            }

            child = nextElementSibling;
        }
    }

    /**
     * Gets an item's offset from the top of the main container.
     */
    _getOffsetTop(target) {
        let offsetTop = target.offsetTop;

        while (target.offsetParent !== this.$.mainContainer) {
            target = target.offsetParent;
            offsetTop += target.offsetTop;
        }

        return offsetTop;
    }

    /**
     * Returns the previous MenuItem/MenuItemsGroup that is not disabled.
     */
    _getPreviousEnabledChild(child) {
        if (!child) {
            return;
        }

        while (child.previousElementSibling) {
            const previousElementSibling = child.previousElementSibling;

            if (this._isChildEnabled(previousElementSibling)) {
                return previousElementSibling;
            }

            child = previousElementSibling;
        }
    }

    /**
     * Hamburger icon click handler.
     */
    _hamburgerIconClickHandler(event, itemContainer) {
        if (event) {
            event.stopPropagation();
        }

        const that = this;

        if (itemContainer === undefined) {
            if (JQX.ListMenu && that instanceof JQX.ListMenu) {
                itemContainer = that.$.view;
            }
            else {
                itemContainer = that.$.mainContainer;
            }
        }

        if (that.disabled) {
            return;
        }

        if (!that._minimizedDropDownOpened) {
            that._positionDetection.placeOverlay();

            if (that.dropDownAppendTo !== null) {
                const dropDownPosition = that.dropDownPosition,
                    menuBoundingRect = that.getBoundingClientRect(),
                    dropDownOffset = that._positionDetection.getDropDownOffset();

                if (dropDownPosition.indexOf('right') !== -1 || dropDownPosition === 'auto') {
                    itemContainer.style.left = menuBoundingRect.left + dropDownOffset.x + 'px';
                    itemContainer.style.right = 'initial';
                }
                else if (dropDownPosition.indexOf('left') !== -1) {
                    itemContainer.style.left = menuBoundingRect.right - itemContainer.offsetWidth + dropDownOffset.x + 'px';
                    itemContainer.style.right = 'initial';
                }

                if (dropDownPosition.indexOf('bottom') !== -1 || dropDownPosition.indexOf('overlay') !== -1 || dropDownPosition === 'auto') {
                    itemContainer.style.top = menuBoundingRect.bottom + dropDownOffset.y + 'px';
                }
                else if (dropDownPosition.indexOf('top') !== -1) {
                    itemContainer.style.top = menuBoundingRect.top + dropDownOffset.y + 'px';
                }
            }

            if (that._edgeMacFF) {
                itemContainer.$.removeClass('not-in-view');
            }

            itemContainer.$.removeClass('jqx-visibility-hidden');
            that.$hamburgerIcon.addClass('jqx-close-button');
            that._minimizedDropDownOpened = true;

            that._browserBoundsDetection(itemContainer);
        }
        else {
            that._close();
        }
    }

    /**
     * Handles change to the "overflow" property.
     */
    _handleOverflowChange() {
        const that = this;

        if ((that._minimized || that.dropDownAppendTo === null && !that.$mainContainer.hasClass('simple') && that.mode !== 'tree') && !(JQX.ListMenu && that instanceof JQX.ListMenu)) {
            return;
        }

        const overflow = that.overflow;
        let horizontal;

        if (that.mode === 'horizontal') {
            horizontal = true;
            that.$.mainContainer.scrollLeft = 0;
        }
        else {
            horizontal = false;
            that.$.mainContainer.scrollTop = 0;
        }

        if (overflow === 'hidden') {
            that.$mainContainer.removeClass('scroll-buttons-shown');
            that.$scrollButtonNear.addClass('jqx-hidden');
            that.$scrollButtonFar.addClass('jqx-hidden');
        }
        else {
            that.$.scrollButtonNear.disabled = that.disabled;
            that.$.scrollButtonFar.disabled = that.disabled;

            if (overflow === 'auto') {
                that.$scrollButtonNear.addClass('jqx-hidden');
                that.$scrollButtonFar.addClass('jqx-hidden');
                that._checkOverflow(that.$.mainContainer, horizontal, [that.$.scrollButtonNear, that.$.scrollButtonFar]);
            }
            else {
                that.$mainContainer.addClass('scroll-buttons-shown');
                that.$mainContainer.removeClass('one-button-shown');
                that.$scrollButtonNear.removeClass('jqx-hidden');
                that.$scrollButtonFar.removeClass('jqx-hidden');
                that._updateScrollButtonVisibility(that.$.mainContainer, horizontal, [that.$.scrollButtonNear, that.$.scrollButtonFar]);
            }
        }
    }

    /**
     * Hides main container scroll buttons.
     */
    _hideMainContainerScrollButtons() {
        const that = this;

        that.$scrollButtonNear.addClass('jqx-hidden');
        that.$scrollButtonFar.addClass('jqx-hidden');
        that.$mainContainer.removeClass('scroll-buttons-shown');
        that.$mainContainer.removeClass('one-button-shown');
    }

    /**
     * Hovers an item via the keyboard.
     */
    _hoverViaKeyboard(item) {
        if (!item) {
            return;
        }

        const that = this;

        item.$.addClass('focus');
        item.setAttribute('focus', '');

        that._focusedViaKeyboard = item;
        that._ensureVisible(item);
    }

    /**
     * Checks if all items in a tree branch are expanded.
     */
    _isBranchExpanded(item) {
        const that = this;

        if (that.mode !== 'tree') {
            return true;
        }

        let expanded = true;

        while (item.parentItem) {
            expanded = expanded && item.parentItem.expanded;
            item = item.parentItem;
        }

        return expanded;
    }

    /**
     * Checks if an item can be focused.
     */
    _isChildEnabled(child) {
        return !(child.disabled || child.templateApplied || child.hidden || child instanceof HTMLDivElement || child.offsetHeight === 0);
    }

    /**
     * Checks if a container is opened.
     */
    _isContainerOpened(level, container) {
        const that = this;

        if (that.mode === 'tree' || that._minimized) {
            if (!that._openedContainers[level]) {
                that._openedContainers[level] = [];
            }

            return that._openedContainers[level].indexOf(container) !== -1;
        }
        else {
            return that._openedContainers[level] === container;
        }
    }

    /**
     * Keydown event handler.
     */
    _keydownHandler(event) {
        const that = this,
            key = event.key;

        if (document.activeElement !== that ||
            ['ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'End', 'Enter', 'Escape', 'Home', ' '].indexOf(key) === -1 ||
            that.disabled) {
            return;
        }

        event.preventDefault();

        const mode = that.mode;

        if (mode === 'tree' || that._minimized) {
            that._keydownHandlerTreeMode(key);
            return;
        }

        const dropDownPosition = that.dropDownPosition,
            leftOrientation = dropDownPosition.indexOf('left') !== -1,
            topOrientation = dropDownPosition === 'top-left' || dropDownPosition === 'top-right',
            openedContainers = that._openedContainers;
        let lastOpenedContainer = that.$.mainContainer,
            level = 1,
            focusedItem;

        for (let i = openedContainers.length - 1; i >= 0; i--) {
            if (openedContainers[i] !== undefined) {
                lastOpenedContainer = openedContainers[i];
                level = lastOpenedContainer.level;
                lastOpenedContainer = lastOpenedContainer.itemContainer;
                break;
            }
        }

        focusedItem = lastOpenedContainer.querySelector('[focus][level="' + level + '"]');

        switch (key) {
            case 'ArrowDown':
                if (level === 1) {
                    if (mode === 'horizontal' && !topOrientation) {
                        that._levelOneOpenDropDown(focusedItem);
                    }
                    else if (mode !== 'horizontal') {
                        that._levelOneNavigate('_getFirstEnabledChild', focusedItem, lastOpenedContainer);
                    }
                }
                else {
                    that._navigate('_getNextEnabledChild', focusedItem, lastOpenedContainer);
                }

                break;
            case 'ArrowLeft':
                if (!leftOrientation) {
                    that._arrowLeftHandler(level, mode, focusedItem, lastOpenedContainer);
                }
                else {
                    if (level === 1) {
                        if (mode === 'horizontal') {
                            that._levelOneNavigate('_getLastEnabledChild', focusedItem, lastOpenedContainer);
                        }
                        else {
                            that._levelOneOpenDropDown(focusedItem);
                        }
                    }
                    else {
                        if (focusedItem instanceof JQX.MenuItemsGroup) {
                            that._selectionHandler({ target: focusedItem, isTrusted: true });
                        }
                        else {
                            that._levelOneNavigateFromLowerLevel('_getPreviousEnabledChild', focusedItem);
                        }
                    }
                }
                break;
            case 'ArrowRight':
                if (!leftOrientation) {
                    that._arrowRightHandler(level, mode, focusedItem, lastOpenedContainer);
                }
                else {
                    if (level === 1) {
                        if (mode === 'horizontal') {
                            that._levelOneNavigate('_getFirstEnabledChild', focusedItem, lastOpenedContainer);
                        }
                    }
                    else {
                        if (level === 2) {
                            that._levelOneNavigateFromLowerLevel('_getNextEnabledChild', focusedItem);
                        }
                        else {
                            that._escapeHandler(focusedItem, level, lastOpenedContainer);
                        }
                    }
                }
                break;
            case 'ArrowUp':
                if (level === 1) {
                    if (mode === 'horizontal' && topOrientation) {
                        that._levelOneOpenDropDown(focusedItem);
                    }
                    else if (mode !== 'horizontal') {
                        that._levelOneNavigate('_getLastEnabledChild', focusedItem, lastOpenedContainer);
                    }
                }
                else {
                    that._navigate('_getPreviousEnabledChild', focusedItem, lastOpenedContainer);
                }

                break;
            case 'End':
            case 'Home': {
                const enabledChild = key === 'End' ?
                    that._getLastEnabledChild(lastOpenedContainer) :
                    that._getFirstEnabledChild(lastOpenedContainer);

                if (!enabledChild || focusedItem === enabledChild) {
                    return;
                }

                if (focusedItem) {
                    focusedItem.$.removeClass('focus');
                    focusedItem.removeAttribute('focus');
                }

                that._hoverViaKeyboard(enabledChild);
                break;
            }
            case 'Enter':
                if (focusedItem) {
                    that._selectionHandler({ target: focusedItem, isTrusted: true });
                }

                break;
            case 'Escape':
                if (level > 1) {
                    if (level === 2) {
                        that._positionDetection.removeOverlay();
                    }

                    that._escapeHandler(focusedItem, level, lastOpenedContainer);
                }
                else if (mode === 'dropDown' && that.opened) {
                    that.close({ trigger: 'interaction', target: 'Escape' });
                }

                break;
            case ' ':
                if (focusedItem) {
                    that._toggleItem(focusedItem);
                }

                break;
        }
    }

    /**
     * Keydown event handler.
     */
    _keydownHandlerTreeMode(key) {
        const that = this,
            menuItems = Array.from(that.$.mainContainer.querySelectorAll('jqx-menu-item, jqx-menu-items-group')),
            focusedItem = that.$.mainContainer.getElementsByClassName('focus')[0];

        function canItemBefocused(item) {
            const level = item.level;

            return item.disabled === false &&
                item.templateApplied !== true &&
                (level === 1 ||
                    level > 1 &&
                    that._isContainerOpened(level, item.parentElement.container) &&
                    item.getBoundingClientRect().height > 0);
        }

        function moveDown(startIndex) {
            for (let i = startIndex; i < menuItems.length; i++) {
                const currentItem = menuItems[i];

                if (canItemBefocused(currentItem)) {
                    if (focusedItem) {
                        if (focusedItem === currentItem) {
                            break;
                        }

                        focusedItem.$.removeClass('focus');
                        focusedItem.removeAttribute('focus');
                    }

                    that._hoverViaKeyboard(currentItem);
                    break;
                }
            }
        }

        function moveUp(startIndex) {
            for (let i = startIndex; i >= 0; i--) {
                const currentItem = menuItems[i];

                if (canItemBefocused(currentItem)) {
                    if (focusedItem) {
                        if (focusedItem === currentItem) {
                            break;
                        }

                        focusedItem.$.removeClass('focus');
                        focusedItem.removeAttribute('focus');
                    }

                    that._hoverViaKeyboard(currentItem);
                    break;
                }
            }
        }

        function navigateToParentItem() {
            if (focusedItem.level > 1) {
                focusedItem.$.removeClass('focus');
                focusedItem.removeAttribute('focus');
                that._hoverViaKeyboard(focusedItem.parentItem);
            }
        }

        let startIndex;

        switch (key) {
            case 'ArrowDown':
                if (focusedItem) {
                    startIndex = menuItems.indexOf(focusedItem) + 1;
                }
                else {
                    startIndex = 0;
                }

                moveDown(startIndex);
                break;
            case 'ArrowLeft':
                if (!focusedItem) {
                    return;
                }

                if (focusedItem instanceof JQX.MenuItem) {
                    navigateToParentItem();
                }
                else {
                    if (that._isContainerOpened(focusedItem.level + 1, focusedItem.container)) {
                        that._closeSubContainers(focusedItem.level + 1, focusedItem.container, true, true);
                        return;
                    }

                    navigateToParentItem();
                }
                break;
            case 'ArrowRight':
                if (!focusedItem || focusedItem instanceof JQX.MenuItem) {
                    return;
                }

                if (that._isContainerOpened(focusedItem.level + 1, focusedItem.container)) {
                    focusedItem.$.removeClass('focus');
                    focusedItem.removeAttribute('focus');
                    that._hoverViaKeyboard(that._getFirstEnabledChild(focusedItem.itemContainer));
                }
                else {
                    that._selectionHandler({ target: focusedItem, type: 'keydown', isTrusted: true }, focusedItem);
                }

                break;
            case 'ArrowUp':
                if (focusedItem) {
                    startIndex = menuItems.indexOf(focusedItem) - 1;
                }
                else {
                    startIndex = menuItems.length - 1;
                }

                moveUp(startIndex);
                break;
            case 'End':
                moveUp(menuItems.length - 1);
                break;
            case 'Enter':
                if (that._minimized && !that._minimizedDropDownOpened) {
                    that._hamburgerIconClickHandler(undefined, that.$.mainContainer);
                }
                else if (focusedItem) {
                    that._selectionHandler({ target: focusedItem, type: 'keydown', isTrusted: true });
                }

                break;
            case 'Escape':
                if (that._minimized && that._minimizedDropDownOpened) {
                    that._close();
                }

                break;
            case 'Home':
                moveDown(0);
                break;
            case ' ':
                if (focusedItem) {
                    that._toggleItem(focusedItem);
                }

                break;
        }
    }

    /**
     * Navigates through first-level items.
     */
    _levelOneNavigate(method, focusedItem, lastOpenedContainer) {
        const that = this;

        if (!focusedItem) {
            const enabledChild = that[method](lastOpenedContainer);

            if (enabledChild) {
                that._hoverViaKeyboard(enabledChild);
            }
        }
        else {
            if (method === '_getLastEnabledChild') {
                that._navigate('_getPreviousEnabledChild', focusedItem, lastOpenedContainer);
            }
            else {
                that._navigate('_getNextEnabledChild', focusedItem, lastOpenedContainer);
            }
        }
    }

    /**
     * Navigates to a first-level item.
     */
    _levelOneNavigateFromLowerLevel(method, focusedItem) {
        const that = this,
            firstLevelItem = that[method](that._openedContainers[2].menuItemsGroup);

        if (firstLevelItem) {
            if (focusedItem) {
                focusedItem.$.removeClass('focus');
                focusedItem.removeAttribute('focus');
            }

            that._closeSubContainers(2);

            if (firstLevelItem instanceof JQX.MenuItemsGroup) {
                that._selectionHandler({ target: firstLevelItem, isTrusted: true });
            }
            else {
                that._hoverViaKeyboard(firstLevelItem);
            }
        }
    }

    /**
     * Opens first-level dropdown containers via the keyboard.
     */
    _levelOneOpenDropDown(focusedItem) {
        if (focusedItem && focusedItem instanceof JQX.MenuItemsGroup) {
            this._selectionHandler({ target: focusedItem, isTrusted: true });
        }
    }

    /**
     * External main container handler.
     */
    _mainContainerHandler(event) {
        const that = this;

        if (!that._minimized || that.dropDownAppendTo === null) {
            return;
        }

        switch (event.type) {
            case 'click':
                that._selectionHandler(event);
                break;
            case 'mouseleave':
                that._mouseleaveHandler(event);
                break;
            case 'mouseout':
                that._mouseoutMouseoverHandler(event);
                break;
            case 'mouseover':
                that._mouseoutMouseoverHandler(event);
                break;
        }
    }

    /**
     * jqx-menu-item selection handler.
     */
    _menuItemSelectionHandler(closestItem, event) {
        const that = this;

        function focus() {
            if (that.enableShadowDOM && ((that.shadowRoot.activeElement || document.activeElement) !== that &&
                that.dropDownAppendTo !== null && event.type === 'click' && !that.shadowRoot.contains(closestItem))) {
                that.focus();
            }
            else if (document.activeElement !== that && that.dropDownAppendTo !== null && event.type === 'click' && !that.contains(closestItem)) {
                that.focus();
            }
        }

        if (closestItem.disabled || closestItem.templateApplied) {
            focus();
            return;
        }

        if (!that._toggleItem(closestItem)) {
            that.$.fireEvent('itemClick', { 'item': closestItem, 'label': closestItem.label, 'value': closestItem.value });

            if (that.mode !== 'tree') {
                that._close();

                if (that.mode === 'dropDown') {
                    that._ripple(closestItem, event);
                    that.close({ trigger: 'interaction', target: closestItem });
                    return;
                }
            }
        }

        that._ripple(closestItem, event);
        focus();
    }

    /**
     * jqx-menu-items-group selection handler.
     */
    _menuItemsGroupSelectionHandler(closestItemsGroup, event, fireEvent) {
        const that = this,
            mode = that.mode,
            container = closestItemsGroup.container,
            level = container.level,
            defaultView = mode !== 'tree' && !that._minimized;

        if (that._treeAnimationInProgress === container) {
            return;
        }

        that._discardKeyboardHover();

        if (document.activeElement !== that && that.dropDownAppendTo !== null && event.type === 'click' && !that.contains(event.target)) {
            that.focus();
        }

        if (event.type === 'click' &&
            ((!event.target.classList.contains('jqx-' + that._element + '-items-group-arrow') && that._toggleItem(closestItemsGroup)) ||
                (that.selectionMode === 'mouseenter' && mode !== 'tree' && !that._minimized))) {
            return;
        }

        let animation = that.hasAnimation;

        if (that._isContainerOpened(level, container)) {
            that._closeSubContainers(level, container, true, fireEvent !== false);

            if (defaultView && closestItemsGroup.hasAttribute('focus')) {
                that._focusedViaKeyboard = closestItemsGroup;
            }
        }
        else {
            const expandingEvent = that.$.fireEvent('expanding', {
                'item': closestItemsGroup,
                'label': closestItemsGroup.label,
                'path': closestItemsGroup.path,
                'value': closestItemsGroup.value,
                'children': closestItemsGroup.itemContainer.children
            });

            if (expandingEvent.defaultPrevented) {
                return;
            }

            that._positionDetection.placeOverlay();

            if (defaultView) {
                that._closeSubContainers(level);
            }

            if (animation && !defaultView) {
                if (event.type !== 'expand') {
                    that._ensureVisibleOnTransitionend = closestItemsGroup;
                }

                that._expandSection(container);
            }

            if (that._edgeMacFF && level === 2 && defaultView) {
                container.$.removeClass('not-in-view');
            }

            container.$.removeClass('jqx-visibility-hidden');

            if (defaultView || event.type !== 'expand') {
                if (!defaultView) {
                    const currentFocus = that.$.mainContainer.getElementsByClassName('focus')[0];

                    if (currentFocus) {
                        currentFocus.$.removeClass('focus');
                        currentFocus.removeAttribute('focus');
                    }

                    that._focusedViaKeyboard = closestItemsGroup;
                }
                else if (event.type === 'keydown') {
                    that._focusedViaKeyboard = closestItemsGroup;
                }

                closestItemsGroup.$.addClass('focus');
                closestItemsGroup.setAttribute('focus', '');
            }

            closestItemsGroup.$.addClass('jqx-' + that._element + '-items-group-opened');
            closestItemsGroup.$.addClass('jqx-' + that._element + '-items-group-expanded');

            that._addOpenedContainer(level, container);

            if (defaultView) {
                that._ensureVisible(closestItemsGroup);

                if (closestItemsGroup.level > 1 && closestItemsGroup.parentElement.dropDownHeightSet) {
                    const dropDownPosition = that.dropDownPosition,
                        top = closestItemsGroup.getBoundingClientRect().top - closestItemsGroup.parentElement.container.getBoundingClientRect().top;

                    if (dropDownPosition.indexOf('bottom') !== -1 || dropDownPosition === 'auto') {
                        container.style.top = top + 'px';
                    }
                    else if (dropDownPosition.indexOf('top') !== -1) {
                        container.style.top = top + closestItemsGroup.offsetHeight + 'px';
                    }
                    else {
                        container.style.top = (top + closestItemsGroup.offsetHeight / 2) + 'px';
                    }
                }

                if (container.itemContainer.checkOverflow && container.itemContainer.dropDownHeightSet) {
                    that._checkOverflow(container.itemContainer, false, [container.children[0], container.children[2]]);
                    delete container.itemContainer.checkOverflow;
                }
            }

            that._positionExternalContainer(container, closestItemsGroup);

            if (mode !== 'tree' && !that._minimized) {
                that._browserBoundsDetection(container);
            }
            else if (!animation) {
                that._browserBoundsDetection(that.$.mainContainer);
            }

            if (event.type === undefined) {
                that._hoverViaKeyboard(that._getFirstEnabledChild(closestItemsGroup.itemContainer));
            }

            if (fireEvent !== false) {
                that.$.fireEvent('expand', {
                    'item': closestItemsGroup,
                    'label': closestItemsGroup.label,
                    'path': closestItemsGroup.path,
                    'value': closestItemsGroup.value,
                    'children': closestItemsGroup.itemContainer.children
                });
            }
        }

        if (defaultView) {
            that._ripple(closestItemsGroup, event);
        }
        else if (mode === 'tree' && !animation) {
            that._checkOverflow(that.$.mainContainer, false, [that.$.scrollButtonNear, that.$.scrollButtonFar]);

            if (!that._minimized && event.type !== 'expand') {
                that._ensureVisible(closestItemsGroup);
            }
        }
    }

    /**
     * Mouseenter handler.
     */
    _mouseenterHandler() {
        const that = this;

        if (that.autoFocusOnMouseenter && document.activeElement !== that) {
            that.focus();
        }
    }

    /**
     * Mouseleave handler.
     */
    _mouseleaveHandler(event) {
        const that = this;

        if (that.selectionMode === 'mouseenter' && that.mode !== 'tree' && !that._minimized) {
            if (that.dropDownAppendTo !== null && event.relatedTarget) {
                if (that.contains(event.target)) {
                    const externalContainer = event.relatedTarget.closest('.jqx-menu-drop-down');

                    if (externalContainer && externalContainer.ownerElement === that) {
                        return;
                    }
                }
                else if (that.contains(event.relatedTarget)) {
                    return;
                }
            }

            that._isElementHovered = false;

            that._autoCloseTimeout = setTimeout(function () {
                const context = that.context;

                clearTimeout(that._autoCloseTimeout);

                if (!that._isElementHovered) {
                    that.context = that;
                    that._close();
                    that.context = context;
                }
            }, that.autoCloseDelay);
        }
    }

    /**
     * Mouseout/mouseover handler.
     */
    _mouseoutMouseoverHandler(event) {
        const that = this;

        if (that.disabled || that.displayLoadingIndicator) {
            return;
        }

        let closestItem = event.target.closest('jqx-menu-item') || event.target.closest('jqx-menu-items-group');

        if (that.enableShadowDOM) {
            closestItem = event.composedPath()[0].closest('jqx-menu-item') || event.composedPath()[0].closest('jqx-menu-items-group') || closestItem;
        }

        if (event.type === 'mouseover') {
            that._isElementHovered = true;
        }

        if (closestItem === null || closestItem.disabled || closestItem.templateApplied) {
            return;
        }

        if ((that.mode === 'tree' || that._minimized) && closestItem.hasAttribute('focus') && event.relatedTarget &&
            (event.target.parentElement === event.relatedTarget || event.relatedTarget.parentElement === event.target)) {
            return;
        }

        that._discardKeyboardHover(false);

        if (event.type === 'mouseover') {
            if (that.selectionMode === 'mouseenter' && that.mode !== 'tree' && !that._minimized) {
                if (closestItem instanceof JQX.MenuItemsGroup && !closestItem.hasAttribute('hover')) {
                    that._selectionHandler(event, closestItem);
                }
                else if (closestItem instanceof JQX.MenuItem) {
                    that._closeSubContainers(closestItem.level + 1);
                }
            }

            const closestDropDown = event.target.closest('.jqx-menu-drop-down');

            if (!closestDropDown || closestDropDown && !closestItem.contains(closestDropDown)) {
                closestItem.$.addClass('hover');
                closestItem.setAttribute('hover', '');
                that._discardKeyboardHover(true);
            }
        }
        else {
            if (that.mode !== 'tree' && !that._minimized) {
                if (that.selectionMode === 'mouseenter' && event.relatedTarget === that.$.mainContainer) {
                    that._close();
                }

                if (closestItem instanceof JQX.MenuItemsGroup &&
                    closestItem.container &&
                    !closestItem.container.$.hasClass('jqx-visibility-hidden')) {
                    return;
                }
            }

            closestItem.$.removeClass('hover');
            closestItem.removeAttribute('hover');
        }
    }

    /**
     * Moves dropdowns to external container.
     */
    _moveDropDownsToExternalContainer() {
        const that = this;

        for (let i = 0; i < that._containersInBody.length; i++) {
            const container = that._containersInBody[i];

            that._dropDownParent.appendChild(container);

            container.$.listen('click', that._selectionHandler.bind(that));
            container.$.listen('mouseleave', that._mouseleaveHandler.bind(that));
            container.$.listen('mouseout', that._mouseoutMouseoverHandler.bind(that));
            container.$.listen('mouseover', that._mouseoutMouseoverHandler.bind(that));
        }

        for (let i = 0; i < that._containers.length; i++) {
            const container = that._containers[i];

            container.ownerElement = that;

            if (that.theme !== '') {
                container.classList.add(that.theme);
            }

            container.classList.add('jqx-drop-down-repositioned');
            container.setAttribute('mode', that.mode);
            container.setAttribute('drop-down-position', that.dropDownPosition);

            if (that.checkboxes) {
                container.setAttribute('checkboxes', '');
            }
        }
    }

    /**
     * Moves dropdowns to the Menu.
     */
    _moveDropDownsToMenu() {
        const that = this;

        for (let i = 0; i < that._containersInBody.length; i++) {
            const container = that._containersInBody[i];

            container.$.unlisten('click');
            container.$.unlisten('mouseleave');
            container.$.unlisten('mouseout');
            container.$.unlisten('mouseover');

            container.style.left = '';
            container.style.right = '';
            container.style.top = '';
            container.style.marginLeft = '';
            container.style.marginTop = '';

            container.menuItemsGroup.appendChild(container);
        }

        for (let i = 0; i < that._containers.length; i++) {
            const container = that._containers[i];

            if (that.theme !== '') {
                container.classList.remove(that.theme);
            }

            container.classList.remove('jqx-drop-down-repositioned');
            container.removeAttribute('mode');
            container.removeAttribute('drop-down-position');
            container.removeAttribute('checkboxes');
        }
    }

    /**
     * Navigates to an item via the keyboard.
     */
    _navigate(method, focusedItem, lastOpenedContainer) {
        const that = this;

        if (!focusedItem) {
            if (method === '_getNextEnabledChild') {
                that._hoverViaKeyboard(that._getFirstEnabledChild(lastOpenedContainer));
            }
            else {
                that._hoverViaKeyboard(that._getLastEnabledChild(lastOpenedContainer));
            }

            return;
        }

        const navigateToChild = that[method](focusedItem);

        if (navigateToChild) {
            focusedItem.$.removeClass('focus');
            focusedItem.removeAttribute('focus');

            that._hoverViaKeyboard(navigateToChild);
        }
    }

    /**
     * Positions an external dropdown container.
     */
    _positionExternalContainer(container, menuItemsGroup) {
        const that = this;

        if (that.dropDownAppendTo === null || container.level !== 2) {
            return;
        }

        const dropDownPosition = that.dropDownPosition,
            mode = that.mode,
            menuItemsGroupRect = menuItemsGroup.getBoundingClientRect(),
            dropDownOffset = that._positionDetection.getDropDownOffset(),
            top = menuItemsGroupRect.top + dropDownOffset.y,
            bottom = menuItemsGroupRect.bottom + dropDownOffset.y;
        let left = menuItemsGroupRect.left + dropDownOffset.x;

        container.style.left = '';
        container.style.right = '';
        container.style.top = '';

        if (dropDownPosition.indexOf('left') !== -1) {
            left -= container.offsetWidth;

            if (mode === 'horizontal' || dropDownPosition === 'overlay-left') {
                left += menuItemsGroupRect.width;
            }

            container.style.left = left + 'px';
            container.style.right = 'initial';
        }
        else if (mode === 'horizontal' || dropDownPosition === 'overlay-right') {
            container.style.left = left + 'px';
        }
        else {
            container.style.left = (left + menuItemsGroupRect.width) + 'px';
        }

        switch (dropDownPosition) {
            case 'bottom-right':
            case 'bottom-left':
            case 'auto':
                if (mode === 'horizontal') {
                    container.style.top = bottom + 'px';
                }
                else {
                    container.style.top = top + 'px';
                }

                break;
            case 'top-right':
            case 'top-left':
                if (mode === 'horizontal') {
                    container.style.top = (top - container.offsetHeight) + 'px';
                }
                else {
                    container.style.top = (bottom - container.offsetHeight) + 'px';
                }

                break;
            case 'overlay-right':
            case 'overlay-left':
                container.style.top = (top + menuItemsGroupRect.height / 2) + 'px';
                break;
        }
    }

    /**
     * Processes "dataSource" object.
     */
    _processDataSource() {
        const that = this,
            dataSource = that.dataSource,
            displayMember = that.displayMember,
            itemsMember = that.itemsMember,
            valueMember = that.valueMember;

        function processItem(item, parent) {
            let element;

            if (Array.isArray(item[itemsMember]) && item[itemsMember].length > 0) {
                element = document.createElement('jqx-' + that._element + '-items-group');

                if (item.checkable === true) {
                    element.set('checkable', true);
                }

                if (item.checkMode === 'checkbox' || item.checkMode === 'radioButton') {
                    element.set('checkMode', item.checkMode);
                }

                if (item.dropDownHeight) {
                    element.set('dropDownHeight', item.dropDownHeight);
                }

                if (item.expanded === true && that.mode === 'tree') {
                    element.set('expanded', true);
                }

                for (let i = 0; i < item[itemsMember].length; i++) {
                    processItem(item[itemsMember][i], element);
                }
            }
            else {
                element = document.createElement('jqx-' + that._element + '-item');

                if (item.shortcut !== undefined) {
                    element.set('shortcut', item.shortcut);
                }

                if (item.customAttribute) {
                    element.setAttribute(item.customAttribute, '');
                }
            }

            if (item.checked === true) {
                element.set('checked', true);
            }

            if (item.disabled === true) {
                element.set('disabled', true);
            }

            if (item[displayMember] !== undefined) {
                element.set('label', item[displayMember]);
            }

            if (item.selected === true) {
                element.set('selected', true);
            }

            if (item.separator === true) {
                element.set('separator', true);
            }

            if (item[valueMember] !== undefined) {
                element.set('value', item[valueMember]);
            }

            parent.appendChild(element);
        }

        that.$.mainContainer.innerHTML = '';

        for (let i = 0; i < dataSource.length; i++) {
            const currentItem = dataSource[i];

            processItem(currentItem, that.$.mainContainer);
        }

        that._processHTML(that.$.mainContainer, 1);
    }

    /**
     * Processes initial HTML structure.
     */
    _processHTML(item, level, autoSort) {
        const that = this;
        let container, itemContainer;

        if (level > 1) {
            container = that._createMenuItemsGroupContainer(item, level);
            itemContainer = container.itemContainer;

            if ((item.expanded || item.hasAttribute('expanded')) && that.mode === 'tree') {
                that._menuItemsGroupsToExpand.push(item);
            }
            else {
                item.set('expanded', false);
                item.removeAttribute('expanded');
            }
        }

        const itemChildren = Array.from(item.children),
            checkedChildren = [],
            itemFragment = document.createDocumentFragment();
        let pathOffset = 0;

        for (let i = 0; i < itemChildren.length; i++) {
            if (level > 1 && i === 0) {
                pathOffset++;
                continue;
            }

            const currentItem = itemChildren[i];

            if (!(currentItem instanceof JQX.MenuItem || currentItem instanceof JQX.MenuItemsGroup)) {
                currentItem.parentElement.removeChild(currentItem);
                pathOffset++;
                continue;
            }

            that._createItemHTMLStructure(currentItem, level, item, i - pathOffset);

            if (currentItem.checked || currentItem.hasAttribute('checked')) {
                if (!currentItem.disabled && !currentItem.hasAttribute('disabled') && !currentItem.templateApplied) {
                    checkedChildren.push(currentItem);
                }
                else {
                    currentItem.set('checked', false);
                    currentItem.removeAttribute('checked');
                }
            }

            if (level > 1) {
                itemFragment.appendChild(currentItem);
            }

            if (currentItem instanceof JQX.MenuItemsGroup) {
                that._processHTML(currentItem, level + 1);
            }
        }

        if (level > 1) {
            itemContainer.appendChild(itemFragment);
            item.container = container;
            item.itemContainer = itemContainer;

            if (item instanceof JQX.MenuItemsGroup) {
                const arrowElement = document.createElement('div');

                arrowElement.className = 'jqx-' + that._element + '-items-group-arrow';
                that._setArrowDirection(arrowElement, level);

                item.firstElementChild.appendChild(arrowElement);
            }

            that._containers.push(container);

            if (level === 2) {
                that._containersInBody.push(container);

                if (that._edgeMacFF) {
                    container.addEventListener('transitionend', function (event) {
                        if (event.target === this && this.$.hasClass('jqx-visibility-hidden')) {
                            this.style.left = '';
                            this.style.top = '';
                            this.$.addClass('not-in-view');
                        }
                    });
                }
            }

            if (that.dropDownAppendTo === null || that.mode === 'tree' || that._minimized) {
                item.appendChild(container);
            }
            else {
                container.ownerElement = that;

                container.classList.add('jqx-drop-down-repositioned');
                container.setAttribute('mode', that.mode);
                container.setAttribute('drop-down-position', that.dropDownPosition);

                if (that.checkboxes) {
                    container.setAttribute('checkboxes', '');
                }

                if (that.theme !== '') {
                    container.$.addClass(that.theme);
                }

                container.setAttribute('animation', that.animation);

                if (level === 2) {
                    that._dropDownParent.appendChild(container);

                    container.$.listen('click', that._selectionHandler.bind(that));
                    container.$.listen('mouseleave', that._mouseleaveHandler.bind(that));
                    container.$.listen('mouseout', that._mouseoutMouseoverHandler.bind(that));
                    container.$.listen('mouseover', that._mouseoutMouseoverHandler.bind(that));
                }
                else {
                    item.appendChild(container);
                }
            }
        }

        that._validateRadioButtonSelection(item, level, checkedChildren);

        if (that._sortItems && autoSort !== false) {
            that._sortItems(item);
        }
    }

    /**
     * Processes initial HTML structure with <ul> element.
     */
    _processUList() {
        const that = this,
            menuItemsGroupOpeningTagRegex = new RegExp(/<li>(.(?!<\/li>)|\n)*?<ul>/),
            menuItemsGroupClosingTagRegex = new RegExp(/<\/ul>(.|\n)*?<\/li>/);
        let innerHTML = that.$.mainContainer.firstElementChild.innerHTML;

        innerHTML = innerHTML.replace(/\r?\n|\r/g, '');
        innerHTML = innerHTML.replace(/<li(.|\n)*?>/g, '<li>');
        innerHTML = innerHTML.replace(/<li><\/li>/g, '<li> </li>');
        innerHTML = innerHTML.replace(/<ul(.|\n)*?>/g, '<ul>');

        while (menuItemsGroupOpeningTagRegex.test(innerHTML)) {
            const match = menuItemsGroupOpeningTagRegex.exec(innerHTML),
                content = '<jqx-' + that._element + '-items-group>' + match[0].slice(4, match[0].length - 4);

            innerHTML = innerHTML.replace(match[0], content);
        }

        while (menuItemsGroupClosingTagRegex.test(innerHTML)) {
            const match = menuItemsGroupClosingTagRegex.exec(innerHTML),
                content = '</jqx-' + that._element + '-items-group>';

            innerHTML = innerHTML.replace(match[0], content);
        }

        innerHTML = innerHTML.replace(/li>/g, 'jqx-' + that._element + '-item>');

        that.$.mainContainer.innerHTML = innerHTML;
    }

    /**
     * Refreshes the "_containers" and "_containersFixedHeight" arrays.
     */
    _refreshContainersArrays() {
        const that = this;

        for (let i = that._containers.length - 1; i >= 0; i--) {
            const container = that._containers[i];

            if (!document.body.contains(container)) {
                that._containers.splice(i, 1);

                const index = that._containersFixedHeight.indexOf(container);

                if (index > -1) {
                    that._containersFixedHeight.splice(index, 1);
                    that._additionalScrollButtons.splice(index, 1);
                }
            }
        }

        that._checkContainersLength();
    }

    /**
     * Refreshes numeric item paths.
     */
    _refreshItemPaths(item, firstLevel, getChildren, resetOriginalIndex) {
        const that = this;
        let container;

        if (firstLevel) {
            container = item;
        }
        else {
            container = item.container.itemContainer;
        }

        const children = getChildren ? getChildren(item) : container.children;

        for (let i = 0; i < children.length; i++) {
            const currentItem = children[i];
            let currentItemPath;

            if (resetOriginalIndex) {
                currentItem.originalIndex = i;
            }

            if (!firstLevel) {
                currentItemPath = item.path + '.' + i;
            }
            else {
                currentItemPath = '' + i;
            }

            currentItem.path = currentItemPath;
            that._menuItems[currentItemPath] = currentItem;

            if (currentItem instanceof JQX.MenuItemsGroup) {
                that._refreshItemPaths(currentItem, undefined, getChildren, resetOriginalIndex);
            }
        }
    }

    /**
     * Removes fixed heights of containers.
     */
    _removeContainerFixedHeight() {
        const that = this;

        for (let i = 0; i < that._containersFixedHeight.length; i++) {
            const container = that._containersFixedHeight[i];

            container.style.height = '';
            container.itemContainer.$.removeClass('scroll-buttons-shown');
            container.itemContainer.$.removeClass('one-button-shown');
            container.children[0].$.addClass('jqx-hidden');
            container.children[2].$.addClass('jqx-hidden');
            container.itemContainer.checkOverflow = true;
        }
    }

    /**
     * Removes containers added to the body or a custom external element.
     */
    _removeContainersInBody() {
        const that = this;

        if (that.dropDownAppendTo !== null && !that._minimized) {
            for (let i = 0; i < that._containersInBody.length; i++) {
                that._dropDownParent.removeChild(that._containersInBody[i]);
            }
        }
    }

    /**
     * Changes the parent of a Menu in 'dropDown' mode.
     */
    _reparentMenu(dynamicChange, oldDropDownParent) {
        const that = this;

        if (that.mode !== 'dropDown' ||
            that._dropDownParent === null && !dynamicChange ||
            that._dropDownParent === that.parentElement) {
            return;
        }

        if (!dynamicChange || oldDropDownParent === null) {
            that._positionRelativeTo = that.parentElement;
        }
        else if (that._dropDownParent === null) {
            that._positionRelativeTo.appendChild(that);
            that._positionRelativeTo = null;
            return;
        }

        that._dropDownParent.appendChild(that);
    }

    /**
     * Resize handler.
     */
    _resizeHandler() {
        const that = this;

        if (that._suppressResizeHandler) {
            delete that._suppressResizeHandler;
            return;
        }

        const minimizeWidth = that.minimizeWidth,
            mode = that.mode;

        if (minimizeWidth !== null && mode !== 'dropDown') {
            if (that.offsetWidth <= minimizeWidth && !that._minimized) {
                that.minimize();
                return;
            }
            else if (that.offsetWidth > minimizeWidth) {
                that.maximize();
            }
        }

        if (that.dropDownAppendTo !== null || mode === 'tree') {
            that._checkOverflow(that.$.mainContainer, mode === 'horizontal', [that.$.scrollButtonNear, that.$.scrollButtonFar]);
        }
    }

    /**
     * Triggers ripple effect.
     */
    _ripple(target, event) {
        const that = this;

        if (that.hasRippleAnimation && event.type === 'click') {
            JQX.Utilities.Animation.Ripple.animate(target, event.pageX, event.pageY);
            return true;
        }
    }

    /**
     * Scrolls using scroll buttons.
     */
    _scroll(scrollButton) {
        if (scrollButton.closest('[template-applied]')) {
            return;
        }

        const that = this,
            mode = that.mode,
            scrollCoefficient = scrollButton.classList.contains('jqx-scroll-button-near') ? -1 : 1;

        if (scrollButton.parentElement === that.$.container) {
            const mainContainer = that.$.mainContainer;

            if (mode !== 'tree') {
                that._closeSubContainers(2);
            }

            if (that.mode === 'horizontal') {
                mainContainer.scrollLeft = mainContainer.scrollLeft + scrollCoefficient * 10;
                that._updateScrollButtonVisibility(mainContainer, true, [that.$.scrollButtonNear, that.$.scrollButtonFar]);
            }
            else {
                mainContainer.scrollTop = mainContainer.scrollTop + scrollCoefficient * 10;
                that._updateScrollButtonVisibility(mainContainer, false, [that.$.scrollButtonNear, that.$.scrollButtonFar]);
            }
        }
        else {
            const container = scrollButton.parentElement,
                itemContainer = container.itemContainer;

            that._closeSubContainers(container.level + 1);

            itemContainer.scrollTop = itemContainer.scrollTop + scrollCoefficient * 10;
            that._updateScrollButtonVisibility(itemContainer, false, [container.children[0], container.children[2]]);
        }
    }

    /**
     * Selection handler.
     */
    _selectionHandler(event, closestItemsGroup) {
        const that = this,
            target = event.target;

        if (target.closest('[template-applied]')) {
            event.stopPropagation();
        }

        if (that.disabled || that.displayLoadingIndicator) {
            return;
        }

        if (closestItemsGroup === undefined) {
            if (event.type === 'click') {
                const closestScrollButton = target.closest('jqx-repeat-button');

                if (closestScrollButton) {
                    that._scroll(closestScrollButton, event);
                    return;
                }
            }

            if (!event.isTrusted) {
                return;
            }

            const closestItem = target.closest('jqx-' + that._element + '-item');

            if (closestItem) {
                that._menuItemSelectionHandler(closestItem, event);
                return;
            }

            closestItemsGroup = target.closest('jqx-' + that._element + '-items-group');

            if (closestItemsGroup && (target === closestItemsGroup.container || target === closestItemsGroup.container.firstElementChild)) {
                return;
            }
        }

        if (closestItemsGroup && !closestItemsGroup.disabled) {
            that._menuItemsGroupSelectionHandler(closestItemsGroup, event);
        }
    }

    /**
     * Sets direction of arrows.
     */
    _setArrowDirection(arrowElement, level) {
        const that = this,
            mode = that.mode;

        if (mode === 'tree' || that._minimized) {
            arrowElement.className = 'jqx-' + that._element + '-items-group-arrow down jqx-arrow-down';
            return;
        }

        if (that.dropDownPosition.slice(0, 7) !== 'overlay') {
            if (level === 2 && mode === 'horizontal') {
                if (that.dropDownPosition.slice(0, 3) !== 'top') {
                    arrowElement.className = 'jqx-menu-items-group-arrow down jqx-arrow-down';
                }
                else {
                    arrowElement.className = 'jqx-menu-items-group-arrow up jqx-arrow-up';
                }
            }
            else {
                arrowElement.className = 'jqx-menu-items-group-arrow right jqx-arrow-right';
            }
        }
        else {
            arrowElement.className = 'jqx-menu-items-group-arrow minus';
        }
    }

    /**
     * Sets whether the element can be focused.
     */
    _setFocusable() {
        const that = this;

        if (that.disabled || that.unfocusable) {
            that.removeAttribute('tabindex');
            return;
        }

        const tabindex = that.getAttribute('tabindex');

        if (tabindex === null || tabindex < 0) {
            that.setAttribute('tabindex', 0);
        }
    }

    /**
     * Sets the HTML content of an item's label or shortcut.
     */
    _setLabel(label, labelElement, item, labelSet) {
        const potentialHTMLTemplate = document.getElementById(label);

        if (potentialHTMLTemplate !== null && potentialHTMLTemplate.tagName.toLowerCase() === 'template') {
            // label is the id of an HTML template
            const templateContent = document.importNode(potentialHTMLTemplate.content, true);

            if (item instanceof JQX.MenuItem) {
                labelElement.appendChild(templateContent);

                if (labelSet) {
                    item.setAttribute('template-applied', '');
                    item.templateApplied = true;
                }
            }
            else if (JQX.ListMenu && this instanceof JQX.ListMenu) {
                const regex = new RegExp(/{{title="(.*)"}}/);

                for (let i = 0; i < templateContent.childNodes.length; i++) {
                    if (regex.test(templateContent.childNodes[i].innerHTML)) {
                        item.titleLabel = regex.exec(templateContent.childNodes[i].innerHTML)[1];
                        templateContent.childNodes[i].innerHTML = templateContent.childNodes[i].innerHTML.replace(regex, '');
                    }
                    else if (regex.test(templateContent.childNodes[i].textContent)) {
                        item.titleLabel = regex.exec(templateContent.childNodes[i].textContent)[1];
                        templateContent.childNodes[i].textContent = templateContent.childNodes[i].textContent.replace(regex, '');
                    }
                }

                if (item.titleLabel === undefined) {
                    item.titleLabel = templateContent.textContent;
                }

                labelElement.appendChild(templateContent);
            }
            else {
                labelElement.innerHTML = label;
                item.titleLabel = label;
            }
        }
        else {
            labelElement.innerHTML = label;

            if (item instanceof JQX.MenuItemsGroup) {
                item.titleLabel = label;
            }
        }
    }

    /**
     * Toggles an item's checked state.
     */
    _toggleItem(item) {
        const that = this;

        if (that.checkboxes) {
            const parent = item.level === 1 ? that : item.parentItem;

            if (parent.checkable) {
                let fireItemClick = false;

                if (parent.checkMode === 'checkbox') {
                    fireItemClick = true;
                    item.set('checked', !item.checked);
                    that.$.fireEvent('itemCheckChange', { 'item': item, 'label': item.label, 'value': item.value, checked: item.checked });
                }
                else if (!item.checked) {
                    fireItemClick = true;
                    item.set('checked', true);
                    that._uncheckSiblings(item);
                    that.$.fireEvent('itemCheckChange', { 'item': item, 'label': item.label, 'value': item.value, checked: true });
                }

                if (item instanceof JQX.MenuItem && fireItemClick) {
                    that.$.fireEvent('itemClick', { 'item': item, 'label': item.label, 'value': item.value });
                }

                if (that.mode !== 'tree' && that.elementName !== 'ListMenu') {
                    that._close();
                    that.close();
                }

                return true;
            }
        }

        return false;
    }

    /**
     * transitionend handler.
     */
    _transitionendHandler(event) {
        const that = this;

        if (that.mode === 'dropDown' && that.opened && event.target === that &&
            document.activeElement !== that && !that._noAutoFocus) {
            that.focus();
        }
    }

    /**
     * Collapse animation transitionend handler.
     */
    _transitionendHandlerCollapse() {
        let menu, container;

        if (arguments.length === 1) {
            if (arguments[0].propertyName === 'visibility') {
                return;
            }

            container = this;
            menu = container.menuItemsGroup.menu;
        }
        else {
            menu = arguments[0];
            container = arguments[1];
        }

        container.menuItemsGroup.$.removeClass('jqx-' + menu._element + '-items-group-expanded');
        container.removeEventListener('transitionend', menu._transitionendHandlerCollapse);
        container.style.height = null;
        container.$.addClass('jqx-visibility-hidden');
        menu._checkOverflow(menu.$.mainContainer, false, [menu.$.scrollButtonNear, menu.$.scrollButtonFar]);

        if (menu._minimized) {
            menu._browserBoundsDetection(menu.$.mainContainer);
        }

        delete menu._treeAnimationInProgress;
    }

    /**
     * Expand animation transitionend handler.
     */
    _transitionendHandlerExpand() {
        let menu, container;

        if (arguments.length === 1) {
            if (arguments[0].propertyName === 'visibility') {
                return;
            }

            container = this;
            menu = container.menuItemsGroup.menu;
        }
        else {
            menu = arguments[0];
            container = arguments[1];
        }

        container.removeEventListener('transitionend', menu._transitionendHandlerExpand);
        container.style.height = null;
        menu._checkOverflow(menu.$.mainContainer, false, [menu.$.scrollButtonNear, menu.$.scrollButtonFar]);

        if (menu._minimized) {
            menu._browserBoundsDetection(menu.$.mainContainer);
        }

        if (menu._ensureVisibleOnTransitionend) {
            menu._ensureVisible(menu._ensureVisibleOnTransitionend);
            delete menu._ensureVisibleOnTransitionend;
        }

        delete menu._treeAnimationInProgress;
    }

    /**
     * Unchecks siblings (when "checkMode" is 'radioButton').
     */
    _uncheckSiblings(item) {
        for (let i = 0; i < item.parentElement.childElementCount; i++) {
            const currentItem = item.parentElement.children[i];

            if (currentItem !== item && currentItem.checked) {
                currentItem.set('checked', false);
                this.$.fireEvent('itemCheckChange', { 'item': currentItem, 'label': currentItem.label, 'value': currentItem.value, checked: false });
            }
        }
    }

    /**
     * Unsorts items.
     */
    _unsortItems(item, noRecursion) {
        const that = this;
        let itemChildren,
            parent,
            originalOrder = [];

        if (item === that.$.mainContainer) {
            parent = item;
            itemChildren = item.children;
        }
        else {
            parent = item.container.firstElementChild;
            itemChildren = parent.children;
        }

        for (let i = 0; i < itemChildren.length; i++) {
            const currentItem = itemChildren[i];

            originalOrder[currentItem.originalIndex] = currentItem;

            if (currentItem instanceof JQX.MenuItemsGroup && noRecursion === undefined) {
                that._unsortItems(currentItem);
            }
        }

        if (originalOrder.length < 2) {
            return;
        }

        for (let i = 0; i < originalOrder.length; i++) {
            parent.appendChild(originalOrder[i]);
        }
    }

    /**
     * Updates scroll button visibility.
     */
    _updateScrollButtonVisibility(element, horizontal, scrollButtons) {
        const that = this,
            overflow = that.overflow,
            mainContainer = element === that.$.mainContainer;

        if (mainContainer && overflow === 'hidden') {
            return;
        }

        let showNear = true,
            showFar = true,
            scrollDirection, dimension, scrollDimension;

        if (horizontal) {
            scrollDirection = 'scrollLeft';
            dimension = 'offsetWidth';
            scrollDimension = 'scrollWidth';
        }
        else {
            scrollDirection = 'scrollTop';
            dimension = 'offsetHeight';
            scrollDimension = 'scrollHeight';
        }

        if (Math.round(element[scrollDirection]) === 0) {
            showNear = false;
        }

        if (Math.round(element[dimension] + element[scrollDirection]) >= Math.round(element[scrollDimension])) {
            showFar = false;
        }

        if (!mainContainer || overflow === 'auto') {
            if (showNear && showFar) {
                scrollButtons[0].$.removeClass('jqx-hidden');
                scrollButtons[1].$.removeClass('jqx-hidden');
                element.classList.remove('one-button-shown');
                return;
            }

            if (showNear) {
                scrollButtons[0].$.removeClass('jqx-hidden');
            }
            else {
                scrollButtons[0].$.addClass('jqx-hidden');
            }

            if (showFar) {
                scrollButtons[1].$.removeClass('jqx-hidden');
            }
            else {
                scrollButtons[1].$.addClass('jqx-hidden');
            }

            element.classList.add('one-button-shown');
        }
        else if (overflow === 'scroll' && !that.disabled) {
            scrollButtons[0].disabled = !showNear;
            scrollButtons[1].disabled = !showFar;
        }
    }

    /**
     * Validates radio button selection.
     */
    _validateRadioButtonSelection(item, level, checkedChildren) {
        const that = this;

        if (that.checkboxes) {
            let parentItem, parentElement;

            if (level === 1) {
                parentItem = that;
                parentElement = that.$.mainContainer;
            }
            else {
                parentItem = item;
                parentElement = item.itemContainer;
            }

            if (parentItem.checkMode === 'radioButton' && parentItem.checkable) {
                if (checkedChildren.length > 1) {
                    for (let i = checkedChildren.length - 2; i >= 0; i--) {
                        checkedChildren[i].set('checked', false);
                    }
                }
                else if (checkedChildren.length === 0) {
                    const firstEnabledChild = that._getFirstEnabledChild(parentElement);

                    if (firstEnabledChild) {
                        firstEnabledChild.set('checked', true);
                    }
                }
            }
        }
    }

    /**
     * wheel handler.
     */
    _wheelHandler(event) {
        const that = this;

        if (!that.enableMouseWheelAction || that._wheelInProgress || that.disabled || that.displayLoadingIndicator ||
            that.$.mainContainer.offsetHeight === that.$.mainContainer.scrollHeight) {
            if (that._wheelInProgress) {
                event.preventDefault();
            }

            return;
        }

        event.preventDefault();

        that._dragStartDetails = { startY: event.pageY, x: event.pageX, y: event.pageY, startTime: Date.now(), target: event.target };
        that._wheelInProgress = true;

        const swipeInfo = { pageY: event.pageY + (event.deltaY > 0 ? -1 : 1) * 50 };

        that._endSwiping(swipeInfo, that._dragStartDetails.startTime + 100, true);
    }
});

/**
 * List Menu custom element.
 */
JQX('jqx-list-menu', class ListMenu extends JQX.Menu {
    // List Menu's properties.
    static get properties() {
        return {
            'displayLoadingIndicator': {
                value: false,
                type: 'boolean'
            },
            'dropDownPosition': {
                value: 'auto',
                allowedValues: ['top-left', 'top-right', 'bottom-left', 'bottom-right', 'auto'],
                type: 'string'
            },
            'filterable': {
                value: false,
                type: 'boolean'
            },
            'filterInputPlaceholder': {
                value: '',
                type: 'string'
            },
            'filterMode': {
                value: 'containsIgnoreCase',
                allowedValues: ['contains', 'containsIgnoreCase', 'doesNotContain', 'doesNotContainIgnoreCase', 'equals', 'equalsIgnoreCase', 'startsWith', 'startsWithIgnoreCase', 'endsWith', 'endsWithIgnoreCase'],
                type: 'string'
            },
            'grouped': {
                value: false,
                type: 'boolean'
            },
            'loadingIndicatorPlaceholder': {
                value: 'Loading...',
                type: 'string'
            },
            'loadingIndicatorPosition': {
                value: 'center',
                allowedValues: ['bottom', 'center', 'top'],
                type: 'string'
            }
        };
    }

    /**
     * List Menu's event listeners.
     */
    static get listeners() {
        return {
            'resize': '_resizeHandler',
            'backButton.click': '_backButtonClickHandler',
            'filterInput.keyup': '_filterInputKeyupHandler',
            'mainContainer.down': '_mainContainerDownHandler',
            'mainContainer.move': '_mainContainerMoveHandler',
            'mainContainer.swipeleft': '_mainContainerSwipeHandler',
            'mainContainer.swiperight': '_mainContainerSwipeHandler',
            'view.click': '_viewHandler',
            'view.mouseout': '_viewHandler',
            'view.mouseover': '_viewHandler',
            'view.transitionend': '_viewHandler',
            'view.wheel': '_wheelHandler'
        };
    }

    /**
     * CSS files needed for the element (ShadowDOM)
     */
    static get styleUrls() {
        return [
            'jqx.listmenu.css'
        ]
    }

    /**
     * List Menu's HTML template.
     */
    template() {
        return `<div id="container">
                    <div id="hamburgerIcon" class="jqx-hamburger-icon jqx-hidden">
                        <div id="hamburgerIconLineTop" class="jqx-hamburger-icon-line jqx-hamburger-icon-line-top"></div>
                        <div id="hamburgerIconLineCenter" class="jqx-hamburger-icon-line jqx-hamburger-icon-line-center"></div>
                        <div id="hamburgerIconLineBottom" class="jqx-hamburger-icon-line jqx-hamburger-icon-line-bottom"></div>
                        <div id="customIconContainer" class="jqx-hamburger-icon-custom-container jqx-hidden"></div>
                    </div>
                    <div id="view" class="jqx-list-menu-view">
                        <div id="header" class="jqx-header jqx-hidden">
                            <jqx-button id="backButton" animation="[[animation]]" disabled="[[disabled]]" unfocusable>
                                <div class="jqx-arrow jqx-arrow-left"></div>
                            </jqx-button>
                            <div id="title" class="jqx-title"></div>
                        </div>
                        <div class="jqx-list-menu-filter-input-container jqx-hidden" id="filterInputContainer">
                            <input id="filterInput" class="jqx-filter-input" disabled="[[disabled]]" placeholder="[[filterInputPlaceholder]]" type="text" />
                        </div>
                        <jqx-repeat-button id="scrollButtonNear" class="jqx-menu-scroll-button jqx-spin-button jqx-scroll-button-near jqx-hidden" animation="[[animation]]" unfocusable>
                            <div id="arrowNear" class="jqx-arrow jqx-arrow-up"></div>
                        </jqx-repeat-button>
                        <div id="mainContainer" class="jqx-menu-main-container">
                            <content></content>
                        </div>
                        <jqx-repeat-button id="scrollButtonFar" class="jqx-menu-scroll-button jqx-spin-button jqx-scroll-button-far jqx-hidden" animation="[[animation]]" unfocusable>
                            <div id="arrowFar" class="jqx-arrow jqx-arrow-down"></div>
                        </jqx-repeat-button>
                        <div id="loadingIndicatorContainer" class="jqx-loader-container jqx-hidden">
                            <span id="loadingIndicator" class="jqx-loader"></span>
                            <span id="loadingIndicatorPlaceHolder" class="jqx-loader-label jqx-hidden">[[loadingIndicatorPlaceholder]]</span>
                        </div>
                    </div>
                </div>`;
    }

    /**
     * Called when the element is attached to the DOM.
     */
    attached() {
        const that = this;

        super.attached();

        if (that.isCompleted && that.dropDownAppendTo !== null && that._minimized) {
            that._dropDownParent.appendChild(that.$.view);
        }
    }

    /**
     * Called when the element is detached from the DOM.
     */
    detached() {
        const that = this;

        super.detached();

        that._close();

        if (that.dropDownAppendTo !== null && that._minimized) {
            that._dropDownParent.removeChild(that.$.view);
        }
    }

    /**
     * Adds an item.
     *
     * @param {HTMLElement} item A jqx-menu-item to add to the List Menu.
     * @param {HTMLElement/String} parent Optional The jqx-menu-items-group (or its id or numeric path) to add the item to.
     */
    addItem(item, parent) {
        const that = this;

        if (!(item instanceof JQX.MenuItem || item instanceof JQX.MenuItemsGroup)) {
            return;
        }

        let parentView, level, container, appliedFilter;

        if (parent === undefined) {
            parent = that.$.mainContainer;
            parentView = undefined;
            level = 1;
            container = parent;
            appliedFilter = that._topLevelFilter;
        }
        else {
            if (typeof parent === 'string') {
                parent = that.getItem(parent);
            }

            if (parent === undefined ||
                !(parent instanceof JQX.MenuItemsGroup &&
                    (that.contains(parent) ||
                        parent.closest('.jqx-list-menu-view') === that.$.view))) {
                return;
            }

            parentView = parent;
            level = parent.level + 1;
            container = parent.itemContainer;
            appliedFilter = parent.filter;
        }

        that._createItemHTMLStructure(item, level, parent, that._getCurrentViewItems(parentView).length, 0);

        if (item instanceof JQX.MenuItemsGroup) {
            that._processHTML(item, level + 1);
        }

        if (that._view !== parent && !parent.$.hasClass('jqx-hidden') &&
            parent.offsetHeight > 0 && parent.offsetWidth > 0 &&
            (!that._view && !that.$.mainContainer.contains(parent) ||
                that._view && !that._view.contains(parent))) {
            item.$.addClass('jqx-hidden');
        }

        if (that.grouped) {
            const children = Array.from(container.children);

            for (let i = children.length - 1; i >= 0; i--) {
                if (children[i].$.hasClass('jqx-list-menu-group-label')) {
                    container.removeChild(children[i]);
                }
            }

            that._unsortItems(parent, true);
        }

        container.appendChild(item);

        if (that.grouped) {
            const view = that._view;

            that._applyGrouping(parent, true);
            that._home();

            if (view) {
                that.changePage(view.path);
            }

        }

        if (that.filterable && appliedFilter !== undefined &&
            appliedFilter !== '' && that._findItem(item, appliedFilter) === null) {
            item.$.addClass('jqx-hidden');
            item.hidden = true;
        }

        that._toggleFilterInputGroupLabelVisibility();
        that._checkOverflow();
    }

    /**
     * Navigates to the previous page (jqx-menu-items-group).
     *
     * @param {Boolean} animation Optional If set to false, disables collapse animation even if animation is enabled for the element.
     */
    back(animation) {
        const that = this,
            animationType = that.animation,
            restoreAnimation = animation === false && animationType !== 'none';

        if (restoreAnimation) {
            that.animation = 'none';
        }

        that._backButtonClickHandler();

        if (restoreAnimation) {
            that.animation = animationType;
        }
    }

    /**
     * Navigates to a particular page (jqx-menu-items-group).
     *
     * @param {String} id The id or numeric path of a page (jqx-menu-items-group).
     */
    changePage(id) {
        const that = this,
            item = that.getItem(id);

        if (item === undefined || item instanceof JQX.MenuItem || item.hidden) {
            return;
        }

        const stack = [item];
        let stackItem = item.parentItem,
            start = 0;

        that._discardKeyboardHover();

        while (stackItem) {
            stack.unshift(stackItem);
            stackItem = stackItem.parentItem;
        }

        if (that._view) {
            const index = stack.indexOf(that._view);

            if (index === -1) {
                that._home();
            }
            else {
                start = index + 1;
            }
        }

        for (let i = start; i < stack.length; i++) {
            if (stack[i].disabled || stack[i].hidden) {
                break;
            }

            that._menuItemsGroupSelectionHandler(stack[i], { type: 'expand' }, true);
        }
    }

    /**
     * Maximizes the List Menu.
     */
    maximize() {
        const that = this;

        if (!that._minimized) {
            return;
        }

        that._positionDetection.removeOverlay();
        that._minimized = false;

        if (that._minimizedDropDownOpened) {
            that.$hamburgerIcon.removeClass('jqx-close-button');
            that._minimizedDropDownOpened = false;
        }

        if (that.dropDownAppendTo !== null) {
            that._appendMinimizedContainerToMenu(that.$.view, null);
        }

        that.$view.removeClass('jqx-visibility-hidden');
        that.$view.removeClass('jqx-list-menu-view-minimized');
        that.$hamburgerIcon.addClass('jqx-hidden');

        that.removeAttribute('minimized');

        if (that.enableShadowDOM) {
            that.$.view.id = that.$.view.getAttribute('jqx-id');

            const templateElements = that.$.view.querySelectorAll('[jqx-id]');

            for (let i = 0; i < templateElements.length; i++) {
                templateElements[i].id = templateElements[i].getAttribute('jqx-id');
            }
        }

        that.$.mainContainer.scrollTop = 0;
        that._checkOverflow();
    }

    /**
     * Minimizes the List Menu.
     */
    minimize() {
        const that = this;

        if (that._minimized) {
            return;
        }

        that.$view.addClass('jqx-visibility-hidden');

        if (that.enableShadowDOM) {
            that.$.view.removeAttribute('id');

            const templateElements = that.$.view.querySelectorAll('[jqx-id]');

            for (let i = 0; i < templateElements.length; i++) {
                templateElements[i].removeAttribute('id');
            }
        }

        if (that._edgeMacFF) {
            that.$view.addClass('not-in-view');
        }

        that.$hamburgerIcon.removeClass('jqx-hidden');

        setTimeout(function () {
            if (that.dropDownAppendTo !== null) {
                that._appendMinimizedContainerToExternalElement(that.$.view);
            }

            that.$view.addClass('jqx-list-menu-view-minimized');

            that.$.mainContainer.scrollTop = 0;
            that._checkOverflow();
        }, 0);

        that._minimized = true;
        that.setAttribute('minimized', '');
    }

    /**
     * Removes an item.
     *
     * @param {HTMLElement/String} item The jqx-menu-item/jqx-menu-items-group (or its id or numeric path) to remove.
     */
    removeItem(item) {
        const that = this;

        if (typeof item === 'string') {
            item = that.getItem(item);
        }

        if (item === undefined ||
            !(item instanceof JQX.MenuItem || item instanceof JQX.MenuItemsGroup) ||
            !(that.contains(item) || item.closest('.jqx-list-menu-view') === that.$.view)) {
            return;
        }

        const itemParent = item.parentElement;

        while (item.contains(that._view)) {
            that._backButtonClickHandler(undefined, true);
        }

        const view = that._view;

        if (that.grouped) {
            that._home();
            that._discardGrouping();
        }

        itemParent.removeChild(item);
        that._menuItems = {};
        that._refreshItemPaths(that.$.mainContainer, true, function (item) {
            return that._getCurrentViewItems(item === that.$.mainContainer ? undefined : item);
        });

        if (that.grouped) {
            that._applyGrouping(that.$.mainContainer);

            if (view) {
                that.changePage(view.path);
            }
        }

        that._toggleFilterInputGroupLabelVisibility();
        that._checkOverflow();
    }

    /**
     * Called when a property is changed.
     */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        if (propertyName === 'disabled' ||
            propertyName === 'dropDownOverlay' ||
            propertyName === 'minimizeIconTemplate' ||
            propertyName === 'minimizeWidth' ||
            propertyName === 'overflow' ||
            propertyName === 'unfocusable') {
            super.propertyChangedHandler(propertyName, oldValue, newValue);
            return;
        }

        const that = this;

        switch (propertyName) {
            case 'animation':
                that.$.view.setAttribute('animation', newValue);
                break;
            case 'checkable':
            case 'checkboxes':
                if (that._minimized && that.dropDownAppendTo !== null) {
                    if (newValue) {
                        that.$.view.setAttribute(propertyName, '');
                    }
                    else {
                        that.$.view.removeAttribute(propertyName);
                    }
                }

                break;
            case 'checkMode':
                that._changeToRadioButtonMode(newValue, that.$.mainContainer);

                if (that._minimized && that.dropDownAppendTo !== null) {
                    that.$.view.setAttribute('check-mode', newValue);
                }

                break;
            case 'dataSource':
                that.$header.addClass('jqx-hidden');
                that.$mainContainer.removeClass('header-shown');
                that._view = undefined;

                that._menuItems = {};
                that._topLevelFilter = '';
                that._processDataSource();
                that._toggleFilterInputGroupLabelVisibility();
                that._checkOverflow();
                break;
            case 'displayLoadingIndicator':
                if (newValue) {
                    const hoveredItem = that.$.mainContainer.querySelector('[hover]');

                    if (hoveredItem) {
                        hoveredItem.removeAttribute('hover');
                    }

                    that._discardKeyboardHover();
                    that.$loadingIndicatorContainer.removeClass('jqx-hidden');
                }
                else {
                    that.$loadingIndicatorContainer.addClass('jqx-hidden');
                }

                break;
            case 'dropDownAppendTo': {
                const oldDropDownParent = that._dropDownParent;

                that._positionDetection.getDropDownParent();

                if (that._dropDownParent === oldDropDownParent || !that._minimized) {
                    return;
                }

                that._close();

                if (newValue === null) {
                    that._appendMinimizedContainerToMenu(that.$.view, null);
                }
                else {
                    that._appendMinimizedContainerToExternalElement(that.$.view);
                }

                that.$.mainContainer.scrollTop = 0;
                that._checkOverflow();
                break;
            }
            case 'dropDownPosition': {
                that._close();

                if (that._minimized && that.dropDownAppendTo !== null) {
                    that.$.view.setAttribute('drop-down-position', newValue);
                }

                break;
            }
            case 'filterable':
                that._toggleFilterInputGroupLabelVisibility(true);

                if (newValue === false) {
                    if (that._topLevelFilter !== '') {
                        that._applyFilter('');
                    }

                    for (let i = that._filteredLowerLevelGroups.length - 1; i >= 0; i--) {
                        that._applyFilter('', that._filteredLowerLevelGroups[i]);
                    }
                }

                that._checkOverflow();
                break;
            case 'filterMode':
                if (!that.filterable) {
                    return;
                }

                if (that._topLevelFilter !== '') {
                    that._applyFilter(that._topLevelFilter);
                }

                for (let i = that._filteredLowerLevelGroups.length - 1; i >= 0; i--) {
                    that._applyFilter(that._filteredLowerLevelGroups[i].filter, that._filteredLowerLevelGroups[i]);
                }

                break;
            case 'grouped':
                that._home();

                if (newValue) {
                    that._applyGrouping(that.$.mainContainer);
                }
                else {
                    that._discardGrouping();
                }

                that._toggleFilterInputGroupLabelVisibility(false, true);
                that._checkOverflow();
                break;
            case 'loadingIndicatorPosition':
                if (that.dropDownAppendTo !== null && that._minimized) {
                    that.$.view.setAttribute('loading-indicator-position', newValue);
                }

                if (newValue === 'center') {
                    that.$loadingIndicatorPlaceHolder.addClass('jqx-hidden');
                }
                else {
                    that.$loadingIndicatorPlaceHolder.removeClass('jqx-hidden');
                }

                break;
            case 'theme':
                super.propertyChangedHandler(propertyName, oldValue, newValue);

                if (that.dropDownAppendTo !== null && that._minimized) {
                    if (oldValue !== '') {
                        that.$view.removeClass(oldValue);
                    }

                    if (newValue) {
                        that.$view.addClass(newValue);
                    }
                }

                break;
        }
    }

    /**
     * Appends group headers.
     */
    _appendGroupLabels(groups, groupChildren) {
        for (let i = 0; i < groups.length; i++) {
            const groupLabel = document.createElement('div');

            groupLabel.$ = JQX.Utilities.Extend(groupLabel);
            groupLabel.className = 'jqx-list-menu-group-label';
            groupLabel.innerHTML = groups[i];
            groupLabel.groupChildren = groupChildren[i];
            groupChildren[i][0].parentElement.insertBefore(groupLabel, groupChildren[i][0]);

            for (let j = 0; j < groupChildren[i].length; j++) {
                groupChildren[i][j].groupLabel = groupLabel;
            }
        }
    }

    /**
     * Applies filter.
     */
    _applyFilter(filterQuery, view) {
        const that = this,
            items = that._getCurrentViewItems(view);

        for (let i = 0; i < items.length; i++) {
            const item = that._findItem(items[i], filterQuery);

            if (item && item.hidden) {
                item.hidden = false;
                if (view === that._view ||
                    (that._view !== undefined && view !== undefined && !view.contains(that._view)) ||
                    that._view === undefined) {
                    item.$.removeClass('jqx-hidden');
                }
            }
            else if (!item) {
                items[i].hidden = true;
                items[i].$.addClass('jqx-hidden');
            }
        }

        if (view) {
            view.filter = filterQuery;

            const index = that._filteredLowerLevelGroups.indexOf(view);

            if (filterQuery === '') {
                if (index !== -1) {
                    that._filteredLowerLevelGroups.splice(index, 1);
                }
            }
            else if (index === -1) {
                that._filteredLowerLevelGroups.push(view);
            }
        }
        else {
            that._topLevelFilter = filterQuery;
        }
    }

    /**
     * Back button click handler.
     */
    _backButtonClickHandler(event, noAnimation) {
        const that = this,
            view = that._view;

        if (event) {
            event.stopPropagation();
        }

        if (!view || that.disabled && event || that.displayLoadingIndicator || that._inTransition) {
            return;
        }

        let animation = that.hasAnimation,
            animationType = that.animation,
            resetAnimation = false;

        if (animation && noAnimation) {
            animation = false;
            resetAnimation = true;
            that.animation = 'none';
        }

        that._discardKeyboardHover();

        that.$scrollButtonNear.addClass('jqx-hidden');
        that.$scrollButtonFar.addClass('jqx-hidden');
        that.$mainContainer.removeClass('scroll-buttons-shown');
        view.firstElementChild.classList.remove('jqx-hidden');

        if (!animation) {
            view.$.removeClass('jqx-menu-items-group-opened');
            view.container.$.addClass('jqx-hidden');
        }
        else {
            that._inTransition = true;
            view.container.$.addClass('no-transition');
            view.container.$.addClass('jqx-hidden');
            view.$.addClass('right');
            view.$.removeClass('right');
            view.container.$.removeClass('no-transition');
        }

        that._showHideMenuItemsGroupSiblings(view, 'removeClass', animation);

        if (animation) {
            setTimeout(function () {
                view.container.style.top = view.parentElement.getBoundingClientRect().top - view.getBoundingClientRect().top + 'px';
            }, 0);
        }
        else if (resetAnimation) {
            that.animation = animationType;
        }

        if (view.level === 1) {
            that.$header.addClass('jqx-hidden');
            that.$mainContainer.removeClass('header-shown');
            that._view = undefined;
        }
        else {
            that.$.title.innerHTML = view.parentItem.titleLabel;
            that._view = view.parentItem;
        }

        that._toggleFilterInputGroupLabelVisibility();

        that.$.mainContainer.scrollTop = 0;

        if (!animation) {
            that._checkOverflow();
        }

        if (event) {
            that.focus();
        }
    }

    /**
     * Applies bottom bounce effect.
     */
    _bounceBottom(initialScrollTop) {
        const that = this,
            mainContainer = that.$.mainContainer;

        that.$mainContainer.addClass('bounce-bottom');

        function bounceBack() {
            mainContainer.scrollTop -= 5;

            if (mainContainer.scrollTop > initialScrollTop) {
                window.requestAnimationFrame(bounceBack);
            }
            else {
                that.$mainContainer.removeClass('bounce-bottom');
            }
        }

        function bounceForth() {
            mainContainer.scrollTop += 5;

            if (mainContainer.scrollTop !== mainContainer.scrollHeight - mainContainer.offsetHeight) {
                window.requestAnimationFrame(bounceForth);
            }
            else {
                window.requestAnimationFrame(bounceBack);
            }
        }

        window.requestAnimationFrame(bounceForth);
    }

    /**
     * Applies top bounce effect.
     */
    _bounceTop() {
        const that = this,
            mainContainer = that.$.mainContainer;

        that.$mainContainer.addClass('bounce-top');

        function bounceBack() {
            mainContainer.scrollTop -= 5;

            if (mainContainer.scrollTop > 0) {
                window.requestAnimationFrame(bounceBack);
            }
            else {
                window.requestAnimationFrame(bounceForth);
            }
        }

        function bounceForth() {
            mainContainer.scrollTop += 5;

            if (mainContainer.scrollTop !== 50) {
                window.requestAnimationFrame(bounceForth);
            }
            else {
                mainContainer.scrollTop = 0;
                that.$mainContainer.removeClass('bounce-top');
            }
        }

        window.requestAnimationFrame(bounceBack);
    }

    /**
     * Checks if items overflow and shows/hides scroll buttons.
     */
    _checkOverflow() {
        const that = this,
            overflow = that.overflow;

        if (overflow === 'hidden') {
            return;
        }

        const overflowing = Math.round(that.$.mainContainer.scrollHeight) > Math.round(that.$.mainContainer.offsetHeight),
            showNear = Math.round(that.$.mainContainer.scrollTop) > 0,
            showFar = Math.round(that.$.mainContainer.offsetHeight + that.$.mainContainer.scrollTop) < Math.round(that.$.mainContainer.scrollHeight);

        if (overflowing) {
            if (overflow === 'auto') {
                if (!that.$mainContainer.hasClass('scroll-buttons-shown')) {
                    that.$mainContainer.addClass('scroll-buttons-shown');
                }

                if (showNear) {
                    that.$scrollButtonNear.removeClass('jqx-hidden');
                }
                else {
                    that.$scrollButtonNear.addClass('jqx-hidden');
                }

                if (showFar) {
                    that.$scrollButtonFar.removeClass('jqx-hidden');
                }
                else {
                    that.$scrollButtonFar.addClass('jqx-hidden');
                }

                if ((showNear && showFar) === false) {
                    that.$mainContainer.addClass('one-button-shown');
                }
                else {
                    that.$mainContainer.removeClass('one-button-shown');
                }

                if (!that.disabled) {
                    that.$.scrollButtonNear.disabled = false;
                    that.$.scrollButtonFar.disabled = false;
                }
            }
            else {
                that.$scrollButtonNear.removeClass('jqx-hidden');
                that.$scrollButtonFar.removeClass('jqx-hidden');

                if (that.disabled) {
                    that.$.scrollButtonNear.disabled = true;
                    that.$.scrollButtonFar.disabled = true;
                }
                else {
                    that.$.scrollButtonNear.disabled = !showNear;
                    that.$.scrollButtonFar.disabled = !showFar;
                }
            }
        }
        else if (!overflowing && overflow === 'auto' && that.$mainContainer.hasClass('scroll-buttons-shown')) {
            that.$mainContainer.removeClass('scroll-buttons-shown');
            that.$mainContainer.removeClass('one-button-shown');
            that.$scrollButtonNear.addClass('jqx-hidden');
            that.$scrollButtonFar.addClass('jqx-hidden');
        }
        else if (!overflowing && overflow === 'scroll') {
            that.$.scrollButtonNear.disabled = true;
            that.$.scrollButtonFar.disabled = true;
        }
    }

    /**
     * Closes any open pop-up containers.
     */
    _close() {
        const that = this;

        that._discardKeyboardHover(true);

        if (that._minimized && that._minimizedDropDownOpened) {
            that._positionDetection.removeOverlay();
            that.$view.addClass('jqx-visibility-hidden');

            if (that._edgeMacFF) {
                that.$.view.style.left = '';
                that.$.view.style.top = '';
                that.$view.addClass('not-in-view');
            }

            that.$hamburgerIcon.removeClass('jqx-close-button');
            that._minimizedDropDownOpened = false;
        }
    }

    /**
     * Applies initial settings to the List Menu element.
     */
    _createElement() {
        const that = this;

        that.mode = 'vertical';

        that._positionDetection = new JQX.Utilities.PositionDetection(that);
        that._positionDetection.getDropDownParent();

        if (that.dataSource === null && that.$.mainContainer.firstElementChild instanceof HTMLUListElement) {
            that._processUList();
        }

        const items = that.getElementsByTagName('jqx-menu-item'),
            itemsReady = function () {
                that._setFocusable();
                that._menuItems = {};
                that._topLevelFilter = '';
                that._filteredLowerLevelGroups = [];

                that.$.view.setAttribute('animation', that.animation);

                if (that.dataSource === null) {
                    that._processHTML(undefined, 1);
                }
                else {
                    that._processDataSource();
                }

                that._toggleFilterInputGroupLabelVisibility();

                if (that.overflow === 'scroll') {
                    that.$mainContainer.addClass('scroll-buttons-shown');
                    that.$scrollButtonNear.removeClass('jqx-hidden');
                    that.$scrollButtonFar.removeClass('jqx-hidden');
                    that._updateScrollButtonVisibility(that.$.mainContainer, false, [that.$.scrollButtonNear, that.$.scrollButtonFar]);
                }

                that._applyMinimizeIconTemplate(that.minimizeIconTemplate, null);

                if (that.minimizeWidth !== null && that.offsetWidth <= that.minimizeWidth) {
                    that.minimize();
                }
                else {
                    that._checkOverflow();
                }

                if (that.displayLoadingIndicator) {
                    that.$loadingIndicatorContainer.removeClass('jqx-hidden');
                }

                if (that.loadingIndicatorPosition !== 'center') {
                    that.$loadingIndicatorPlaceHolder.removeClass('jqx-hidden');
                }

                if (that.__onCompleted) {
                    that._onCompleted = that.__onCompleted;
                    that.__onCompleted = null;
                    that._onCompleted();
                }
            }

        if (items.length === 0) {
            itemsReady();
        }
        else {
            if (that._onCompleted) {
                that.__onCompleted = that._onCompleted;
                that._onCompleted = null;
            }
            that._ensureItemsReady(items, itemsReady);
        }
    }

    /**
     * Creates the pop-up container of jqx-menu-items-group.
     */
    _createMenuItemsGroupContainer(item, level) {
        const container = document.createElement('div'),
            itemContainer = document.createElement('div');

        container.className = 'jqx-menu-drop-down jqx-hidden';
        container.$ = JQX.Utilities.Extend(container);
        container.level = level;
        container.setAttribute('level', level);
        container.menuItemsGroup = item;

        itemContainer.className = 'jqx-menu-item-container';
        itemContainer.$ = JQX.Utilities.Extend(itemContainer);
        itemContainer.container = container;
        itemContainer.menuItemsGroup = item;

        if (item.checkable) {
            itemContainer.setAttribute('checkable', '');
        }

        itemContainer.setAttribute('check-mode', item.checkMode);

        container.itemContainer = itemContainer;
        container.appendChild(itemContainer);

        return container;
    }

    /**
     * Removes grouping.
     */
    _discardGrouping() {
        const that = this,
            groupLabels = Array.from(that.$.view.getElementsByClassName('jqx-list-menu-group-label'));

        for (let i = 0; i < groupLabels.length; i++) {
            let currentGroupLabel = groupLabels[i];

            currentGroupLabel.parentElement.removeChild(currentGroupLabel);
        }

        that._unsortItems(that.$.mainContainer);
    }

    /**
     * Removes "hover" attribute added by keyboard navigation.
     */
    _discardKeyboardHover() {
        const that = this;

        if (!that._focusedViaKeyboard) {
            return;
        }

        if (that._focusedViaKeyboard === that.$.backButton) {
            that.$.backButton.removeAttribute('hover');
            that.$.backButton.$.button.removeAttribute('hover');
        }
        else {
            that._focusedViaKeyboard.removeAttribute('focus');
            that._focusedViaKeyboard.removeAttribute('hover');
        }

        that._focusedViaKeyboard = undefined;
    }

    /**
     * Document up handler.
     */
    _documentUpHandler(event) {
        const that = this,
            target = event.originalEvent.target;

        that._endSwiping(event, Date.now());

        if (that._swipeDetails) {
            if (that._swipeDetails.direction === 'left') {
                if (that._swipeDetails.start > event.pageX && that._swipeDetails.start - event.pageX > that.offsetWidth / 4) {
                    that._selectionHandler({ target: that._swipeDetails.target }, that._swipeDetails.target, true);
                }
            }
            else {
                if (that._swipeDetails.start < event.pageX && event.pageX - that._swipeDetails.start > that.offsetWidth / 4) {
                    that._backButtonClickHandler();
                }
            }

            delete that._swipeDetails;
            return;
        }

        if (target === that.$.filterInput || that.disabled || that.displayLoadingIndicator || !target.closest) {
            return;
        }

        if (!that.contains(target) && target.closest('.jqx-list-menu-view') !== that.$.view) {
            that._close();

            if (that._scrolling) {
                delete that._scrolling;
            }
        }
        else if ((that.contains(target) || target.closest('.jqx-list-menu-view') === that.$.view) &&
            that !== document.activeElement) {
            that.focus();
        }
    }

    /**
     * Makes sure a jqx-menu-item/jqx-menu-items-group is visible by scrolling to it.
     */
    _ensureVisible(scrollTarget) {
        const that = this,
            parent = that.$.mainContainer;

        if (!parent.$.hasClass('scroll-buttons-shown') && that.overflow !== 'hidden') {
            return;
        }

        const parentBoundingRect = parent.getBoundingClientRect(),
            scrollTargetBoundingRect = scrollTarget.getBoundingClientRect(),
            scrollButtons = [that.$.scrollButtonNear, that.$.scrollButtonFar],
            oldScrollTop = parent.scrollTop;

        if (parentBoundingRect.top > scrollTargetBoundingRect.top || parentBoundingRect.bottom < scrollTargetBoundingRect.bottom) {
            parent.scrollTop = scrollTarget.offsetTop;
            that._updateScrollButtonVisibility(parent, false, scrollButtons);
        }

        that._fireScrollBottomReachedEvent(oldScrollTop);
    }

    /**
     * Fires the "scrollBottomReached" event.
     */
    _fireScrollBottomReachedEvent(oldScrollTop) {
        const that = this,
            mainContainer = that.$.mainContainer,
            currentScrollTop = mainContainer.scrollTop;

        if (oldScrollTop === currentScrollTop ||
            currentScrollTop !== mainContainer.scrollHeight - mainContainer.offsetHeight) {
            return;
        }

        that.$.fireEvent('scrollBottomReached');
    }

    /**
     * Gets all jqx-menu-item and jqx-menu-items-group elements in current view.
     */
    _getCurrentViewItems(view) {
        const that = this;

        if (!that.grouped) {
            if (view === undefined) {
                return that.$.mainContainer.children;
            }
            else {
                return view.container.firstElementChild.children;
            }
        }
        else {
            if (view === undefined) {
                return that.$.view.querySelectorAll('.jqx-menu-main-container > jqx-menu-item, .jqx-menu-main-container > jqx-menu-items-group');
            }
            else {
                const allChildren = view.container.firstElementChild.children,
                    items = [];

                for (let i = 0; i < allChildren.length; i++) {
                    let currentItem = allChildren[i];

                    if (currentItem instanceof JQX.MenuItem || currentItem instanceof JQX.MenuItemsGroup) {
                        items.push(currentItem);
                    }
                }

                return items;
            }
        }
    }

    /**
     * Sorts and groups items.
     */
    _sortItems(item) {
        const that = this;

        if (!that.grouped) {
            return;
        }

        const groups = [],
            groupChildren = [];
        let parent;

        if (item instanceof JQX.MenuItemsGroup) {
            parent = item.container.firstElementChild;
        }
        else if (item === that.$.mainContainer) {
            parent = item;
        }

        const children = Array.from(parent.children);

        children.sort(function (a, b) {
            return (a.label).localeCompare(b.label);
        });

        // sort items in DOM
        for (let i = children.length - 1; i >= 0; i--) {
            parent.insertBefore(children[i], parent.firstElementChild);
        }

        // retrieve groups and first elements in groups
        for (let i = 0; i < children.length; i++) {
            const currentChild = children[i],
                firstCharacter = currentChild.label.charAt(0),
                index = groups.indexOf(firstCharacter.toUpperCase());

            if (index === -1) {
                groups.push(firstCharacter.toUpperCase());
                groupChildren.push([currentChild]);
            }
            else {
                groupChildren[index].push(currentChild);
            }
        }

        that._appendGroupLabels(groups, groupChildren);
    }

    /**
     * Displays top-level view.
     */
    _home() {
        const that = this;

        while (that._view) {
            that._backButtonClickHandler(undefined, true);
        }
    }

    /**
     * Keydown event handler.
     */
    _keydownHandler(event) {
        const that = this,
            key = event.key;

        if (document.activeElement !== that ||
            ['ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'End', 'Enter', 'Escape', 'Home', ' '].indexOf(key) === -1 ||
            that.disabled || that.displayLoadingIndicator) {
            return;
        }

        event.preventDefault();

        const view = that._view,
            lastOpenedContainer = view ? view.itemContainer : that.$.mainContainer,
            hoveredItem = that.$.backButton.hasAttribute('hover') ? that.$.backButton : lastOpenedContainer.querySelector('[focus]');

        switch (key) {
            case 'ArrowDown':
                that._navigate('_getNextEnabledChild', hoveredItem, lastOpenedContainer);
                break;
            case 'ArrowLeft':
                that._backButtonClickHandler();
                break;
            case 'ArrowRight':
                if (hoveredItem && hoveredItem instanceof JQX.MenuItemsGroup) {
                    that._menuItemsGroupSelectionHandler(hoveredItem, { type: 'keydown' });
                }

                break;
            case 'ArrowUp':
                that._navigate('_getPreviousEnabledChild', hoveredItem, lastOpenedContainer);
                break;
            case 'End':
            case 'Home': {
                if (view && key === 'Home') {
                    that.$.mainContainer.scrollTop = 0;
                    that._checkOverflow();
                    that.$.backButton.setAttribute('hover', '');
                    that.$.backButton.$.button.setAttribute('hover', '');
                    that._focusedViaKeyboard = that.$.backButton;

                    if (hoveredItem) {
                        hoveredItem.removeAttribute('focus');
                    }

                    return;
                }

                const enabledChild = key === 'End' ?
                    that._getLastEnabledChild(lastOpenedContainer) :
                    that._getFirstEnabledChild(lastOpenedContainer);

                if (!enabledChild || hoveredItem === enabledChild) {
                    return;
                }

                if (hoveredItem) {
                    if (hoveredItem === that.$.backButton) {
                        that.$.backButton.removeAttribute('hover');
                        that.$.backButton.$.button.removeAttribute('hover');
                    }
                    else {
                        hoveredItem.removeAttribute('focus');
                    }
                }

                that._hoverViaKeyboard(enabledChild);
                break;
            }
            case 'Enter':
                if (that._minimized && !that._minimizedDropDownOpened) {
                    that._hamburgerIconClickHandler(undefined, that.$.view);
                }
                else if (hoveredItem) {
                    if (hoveredItem === that.$.backButton) {
                        that._backButtonClickHandler();
                    }
                    else {
                        that._selectionHandler({ target: hoveredItem });
                    }
                }

                break;
            case 'Escape':
                if (that._minimized && that._minimizedDropDownOpened && !that._view) {
                    that._close();
                }
                else {
                    that._backButtonClickHandler();
                }

                break;
            case ' ':
                if (hoveredItem) {
                    if (hoveredItem === that.$.backButton) {
                        that._backButtonClickHandler();
                    }
                    else {
                        that._toggleItem(hoveredItem);
                    }
                }

                break;
        }
    }

    /**
     * mainContainer down handler.
     */
    _mainContainerDownHandler(event) {
        const that = this;

        if (!JQX.Utilities.Core.isMobile || that.disabled || that.displayLoadingIndicator) {
            return;
        }

        that._dragStartDetails = { startY: event.pageY, x: event.pageX, y: event.pageY, startTime: Date.now(), target: event.originalEvent.target };
    }

    /**
     * mainContainer handler.
     */
    _mainContainerHandler() {
        return;
    }

    /**
     * mainContainer move handler.
     */
    _mainContainerMoveHandler(event) {
        const that = this;

        if (!that._dragStartDetails) {
            return;
        }

        const pageY = event.pageY,
            difference = that._dragStartDetails.y - pageY,
            oldScrollTop = that.$.mainContainer.scrollTop;

        that.$.mainContainer.scrollTop += difference;

        if (oldScrollTop !== that.$.mainContainer.scrollTop) {
            that._checkOverflow();
            that._fireScrollBottomReachedEvent(oldScrollTop);
        }

        that._dragStartDetails = { startY: that._dragStartDetails.startY, x: event.pageX, y: pageY, startTime: that._dragStartDetails.startTime, target: event.originalEvent.target };
        that._scrolling = true;
    }

    /**
     * mainContainer swipeleft/swiperight handler.
     */
    _mainContainerSwipeHandler(event) {
        const that = this;

        if (!JQX.Utilities.Core.isMobile || that.disabled || that.displayLoadingIndicator) {
            return;
        }

        const target = event.originalEvent.target,
            closestItem = target.closest('jqx-menu-item'),
            closestGroup = target.closest('jqx-menu-items-group');

        if (event.type === 'swiperight') {
            const target = closestItem || closestGroup;

            if (target) {
                delete that._dragStartDetails;
                delete that._scrolling;

                that._swipeDetails = { direction: 'right', start: event.pageX, target: target };
            }
        }
        else if (closestGroup && closestItem === null) {
            delete that._dragStartDetails;
            delete that._scrolling;

            that._swipeDetails = { direction: 'left', start: event.pageX, target: closestGroup };
        }
    }

    /**
     * Returns the root's activeElement and isInside flag indicating whether the target is inside the element or not.
     * @param {any} target - target
     */
    _getRootDetails(rootNode, event) {
        const that = this;

        if (!rootNode) {
            return;
        }

        if (!that.enableShadowDOM) {
            return { activeElement: rootNode.activeElement, isInsideElement: that.contains(event.target) };
        }

        let activeElement, isInsideElement;

        while (rootNode) {
            if (!activeElement && rootNode.activeElement) {
                activeElement = rootNode.activeElement;
            }

            if (rootNode.host === that) {
                isInsideElement = true;
            }

            if (rootNode === document) {
                break;
            }

            rootNode = rootNode.host ? rootNode.host.getRootNode() : rootNode.getRootNode();
        }

        return { activeElement: activeElement, isInsideElement: isInsideElement };
    }

    /**
     * jqx-menu-items-group selection handler.
     */
    _menuItemsGroupSelectionHandler(closestItemsGroup, event, noAnimation) {
        const that = this,
            container = closestItemsGroup.container,
            level = container.level,
            rootDetails = that._getRootDetails(event.target ? event.target.getRootNode() : null, event);

        if (that._view === closestItemsGroup) {
            return;
        }

        that._discardKeyboardHover();

        if (rootDetails && rootDetails.activeElement !== that && that.dropDownAppendTo !== null && event.type === 'click' && !rootDetails.isInsideElement) {
            that.focus();
        }

        if (that._inTransition) {
            return;
        }

        if (event.type === 'click' && !event.target.classList.contains('jqx-menu-items-group-arrow') && that._toggleItem(closestItemsGroup)) {
            that._ripple(closestItemsGroup, event);
            return;
        }

        let animation = that.hasAnimation,
            animationType = that.animation,
            resetAnimation = false;

        if (animation && noAnimation) {
            animation = false;
            resetAnimation = true;
            that.animation = 'none';
        }

        if (level === 2) {
            that.$header.removeClass('jqx-hidden');
            that.$mainContainer.addClass('header-shown');
        }

        that.$.title.innerHTML = closestItemsGroup.titleLabel;
        that._view = closestItemsGroup;
        that._toggleFilterInputGroupLabelVisibility();

        closestItemsGroup.removeAttribute('hover');
        closestItemsGroup.removeAttribute('focus');
        closestItemsGroup.$.addClass('jqx-menu-items-group-opened');

        that._showHideMenuItemsGroupSiblings(closestItemsGroup, 'addClass', animation);

        if (!animation) {
            closestItemsGroup.firstElementChild.classList.add('jqx-hidden');
        }
        else {
            that._inTransition = true;
            closestItemsGroup.firstElementChild.classList.add('animate');
            setTimeout(function () {
                container.style.top = closestItemsGroup.parentElement.getBoundingClientRect().top - closestItemsGroup.getBoundingClientRect().top + 'px';
            }, 0);
        }

        container.$.removeClass('jqx-hidden');

        if (resetAnimation) {
            that.animation = animationType;
        }

        that.$.mainContainer.scrollTop = 0;

        if (!animation) {
            that._checkOverflow();
        }

        that.$.fireEvent('expand', { 'item': closestItemsGroup, 'label': closestItemsGroup.label, 'path': closestItemsGroup.path, 'value': closestItemsGroup.value });
    }

    /**
     * Mouseout/mouseover handler.
     */
    _mouseoutMouseoverHandler(event) {
        const that = this;

        if (that.disabled || that.displayLoadingIndicator) {
            return;
        }

        const closestItem = event.target.closest('jqx-menu-item') || event.target.closest('jqx-menu-items-group');

        if (closestItem === null || (that._view && closestItem.level <= that._view.level) || closestItem.disabled || closestItem.templateApplied) {
            return;
        }

        that._discardKeyboardHover();

        if (event.type === 'mouseover') {
            closestItem.setAttribute('hover', '');
            that._discardKeyboardHover(true);
        }
        else {
            closestItem.removeAttribute('hover');
        }
    }

    /**
     * Navigates to an item via the keyboard.
     */
    _navigate(method, hoveredItem, lastOpenedContainer) {
        const that = this;

        if (!hoveredItem) {
            if (method === '_getNextEnabledChild') {
                if (that._view) {
                    that.$.backButton.setAttribute('hover', '');
                    that.$.backButton.$.button.setAttribute('hover', '');
                    that._focusedViaKeyboard = that.$.backButton;
                }
                else {
                    that._hoverViaKeyboard(that._getFirstEnabledChild(lastOpenedContainer));
                }
            }
            else {
                that._hoverViaKeyboard(that._getLastEnabledChild(lastOpenedContainer));
            }

            return;
        }

        let navigateToChild;

        if (method === '_getNextEnabledChild' && hoveredItem === that.$.backButton) {
            navigateToChild = that._getFirstEnabledChild(lastOpenedContainer);

            if (navigateToChild) {
                that.$.backButton.removeAttribute('hover');
                that.$.backButton.$.button.removeAttribute('hover');
            }
            else {
                return;
            }
        }
        else if (method === '_getPreviousEnabledChild' && that._view && hoveredItem === that._getFirstEnabledChild(lastOpenedContainer)) {
            that.$.backButton.setAttribute('hover', '');
            that.$.backButton.$.button.setAttribute('hover', '');
            that._focusedViaKeyboard = that.$.backButton;
            hoveredItem.removeAttribute('focus');
            return;
        }
        else {
            navigateToChild = that[method](hoveredItem);
        }

        if (navigateToChild) {
            hoveredItem.removeAttribute('focus');
            that._hoverViaKeyboard(navigateToChild);
        }
    }

    /**
     * Processes initial HTML structure.
     */
    _processHTML(item, level) {
        const that = this;
        let container, itemContainer;

        if (item === undefined) {
            item = that.$.mainContainer;
        }

        if (level > 1) {
            container = that._createMenuItemsGroupContainer(item, level);
            itemContainer = container.itemContainer;
        }

        const itemChildren = Array.from(item.children),
            checkedChildren = [];
        let pathOffset = 0;

        for (let i = 0; i < itemChildren.length; i++) {
            if (level > 1 && i === 0) {
                pathOffset++;
                continue;
            }

            const currentItem = itemChildren[i];

            if (!(currentItem instanceof JQX.MenuItem || currentItem instanceof JQX.MenuItemsGroup)) {
                currentItem.parentElement.removeChild(currentItem);
                pathOffset++;
                continue;
            }

            that._createItemHTMLStructure(currentItem, level, item, i - pathOffset);

            if (currentItem.checked) {
                if (!currentItem.disabled && !currentItem.templateApplied) {
                    checkedChildren.push(currentItem);
                }
                else {
                    currentItem.checked = false;
                }
            }

            if (level > 1) {
                itemContainer.appendChild(currentItem);
            }

            if (currentItem instanceof JQX.MenuItemsGroup) {
                that._processHTML(currentItem, level + 1);
            }
        }

        if (level > 1) {
            item.container = container;
            item.itemContainer = itemContainer;

            if (item instanceof JQX.MenuItemsGroup) {
                const arrowElement = document.createElement('div');

                arrowElement.className = 'jqx-menu-items-group-arrow jqx-arrow-right right';
                item.children[0].appendChild(arrowElement);
            }

            item.appendChild(container);
        }

        that._validateRadioButtonSelection(item, level, checkedChildren);

        that._sortItems(item);
    }

    /**
     * Resize handler.
     */
    _resizeHandler() {
        const that = this,
            minimizeWidth = that.minimizeWidth;

        if (minimizeWidth !== null) {
            if (!that._minimized && that.offsetWidth <= minimizeWidth) {
                that.minimize();
                return;
            }
            else if (that._minimized && that.offsetWidth > minimizeWidth) {
                that.maximize();
                return;
            }
        }

        that._checkOverflow();
    }

    /**
     * Scrolls using scroll buttons.
     */
    _scroll(scrollButton) {
        const that = this,
            mainContainer = that.$.mainContainer,
            scrollCoefficient = scrollButton.classList.contains('jqx-scroll-button-near') ? -1 : 1,
            oldScrollTop = mainContainer.scrollTop;

        mainContainer.scrollTop = mainContainer.scrollTop + scrollCoefficient * 10;

        if (oldScrollTop !== mainContainer.scrollTop) {
            that._updateScrollButtonVisibility(mainContainer, false, [that.$.scrollButtonNear, that.$.scrollButtonFar]);
            that._fireScrollBottomReachedEvent(oldScrollTop);
        }
    }

    /**
     * Selection handler.
     */
    _selectionHandler(event, closestItemsGroup, swipe) {
        const that = this,
            target = event.target;

        if (that.disabled || that.displayLoadingIndicator) {
            return;
        }

        if (that._scrolling || that._swipeDetails && !swipe) {
            delete that._dragStartDetails;
            delete that._scrolling;
            delete that._swipeDetails;
            return;
        }

        function focus() {
            const rootDetails = that._getRootDetails(target.getRootNode(), event);

            if (rootDetails && rootDetails.activeElement !== that && that.dropDownAppendTo !== null && event.type === 'click' && !rootDetails.isInsideElement) {
                that.focus();
            }
        }

        if (closestItemsGroup === undefined) {
            if (event.type === 'click') {
                const closestScrollButton = target.closest('jqx-repeat-button');

                if (closestScrollButton) {
                    that._scroll(closestScrollButton, event);
                    return;
                }
            }

            const closestItem = target.closest('jqx-menu-item');

            if (closestItem) {
                if (closestItem.disabled || closestItem.templateApplied) {
                    focus();
                    return;
                }

                if (!that._toggleItem(closestItem)) {
                    that.$.fireEvent('itemClick', { 'item': closestItem, 'label': closestItem.label, 'value': closestItem.value });
                }

                that._ensureVisible(closestItem);
                that._ripple(closestItem, event);
                focus();
                return;
            }

            closestItemsGroup = target.closest('jqx-menu-items-group');

            if (closestItemsGroup && (target === closestItemsGroup.container || target === closestItemsGroup.container.firstElementChild)) {
                return;
            }
        }

        if (closestItemsGroup && !closestItemsGroup.disabled) {
            that._menuItemsGroupSelectionHandler(closestItemsGroup, event);
        }
    }

    /**
     * Shows/hides the siblings of a jqx-menu-items-group.
     */
    _showHideMenuItemsGroupSiblings(menuItemsGroup, method, animation) {
        const parentElement = menuItemsGroup.parentElement,
            children = parentElement.children;

        for (let i = 0; i < children.length; i++) {
            const currentChild = children[i];

            if (currentChild === menuItemsGroup) {
                continue;
            }

            if (!currentChild.hidden) {
                if (!animation) {
                    currentChild.$[method]('jqx-hidden');
                }
                else {
                    if (method === 'addClass') {
                        currentChild.$.addClass('animate');
                    }
                    else {
                        currentChild.$.removeClass('jqx-hidden');
                        currentChild.$.addClass('right');
                        setTimeout(function () {
                            currentChild.$.removeClass('right');
                        }, 0);
                    }
                }
            }
        }
    }

    /**
     * Toggles the visibility of the filter input.
     */
    _toggleFilterInputGroupLabelVisibility(filterableChanged, groupedChanged) {
        const that = this,
            itemsCount = that._getCurrentViewItems(that._view).length;

        if (groupedChanged !== true) {
            const shown = !that.$filterInputContainer.hasClass('jqx-hidden');

            if (that.filterable && itemsCount > 1) {
                if (!shown) {
                    that.$mainContainer.addClass('filter-input-shown');
                    that.$filterInputContainer.removeClass('jqx-hidden');
                }

                if (that._view) {
                    that.$.filterInput.value = that._view.filter || '';
                }
                else {
                    that.$.filterInput.value = that._topLevelFilter;
                }
            }
            else if (shown) {
                that.$mainContainer.removeClass('filter-input-shown');
                that.$filterInputContainer.addClass('jqx-hidden');
            }
        }

        if (!filterableChanged && that.grouped && itemsCount > 0) {
            const firstGroupLabel = that._view ?
                that._view.container.firstElementChild.firstElementChild.$ :
                that.$.mainContainer.firstElementChild.$;

            if (itemsCount === 1) {
                firstGroupLabel.addClass('jqx-hidden');
            }
            else {
                firstGroupLabel.removeClass('jqx-hidden');
            }
        }
    }

    /**
     * External view handler.
     */
    _viewHandler(event) {
        const that = this;

        if (event.type === 'transitionend') {
            const target = event.target;

            if (target === that.$.view || that.$.backButton.contains(target)) {
                return;
            }

            if (target.classList.contains('animate')) {
                target.classList.remove('animate');
                target.classList.add('jqx-hidden');
            }

            if (target.classList.contains('jqx-menu-drop-down')) {
                target.style.top = '';
            }

            if (target.classList.contains('jqx-menu-items-group-opened')) {
                target.classList.remove('jqx-menu-items-group-opened');
            }

            that._checkOverflow();
            that._inTransition = false;
            return;
        }

        if (!that._minimized || that.dropDownAppendTo === null) {
            return;
        }

        switch (event.type) {
            case 'click':
                that._selectionHandler(event);
                break;
            case 'mouseout':
                that._mouseoutMouseoverHandler(event);
                break;
            case 'mouseover':
                that._mouseoutMouseoverHandler(event);
                break;
        }
    }
});

/**
 * Tank custom element.
 */
JQX('jqx-tank', class Tank extends JQX.BaseElement {
    /**
     * Tank's properties.
     */
    static get properties() {
        return {
            'coerce': {
                value: false,
                type: 'boolean'
            },
            'customInterval': {
                value: false,
                type: 'boolean'
            },
            'customTicks': {
                reflectToAttribute: false,
                value: ['0', '50', '100'],
                type: 'array'
            },
            'dateLabelFormatString': {
                value: 'd',
                type: 'string'
            },
            'decimalSeparator': {
                value: '.',
                type: 'string'
            },
            'interval': {
                value: '1',
                type: 'any'
            },
            'inverted': {
                value: false,
                type: 'boolean'
            },
            'labelFormatFunction': {
                value: null,
                type: 'function?'
            },
            'labelsVisibility': {
                value: 'all',
                allowedValues: ['all', 'endPoints', 'none'],
                type: 'string'
            },
            'logarithmicScale': {
                value: false,
                type: 'boolean'
            },
            'max': {
                value: '100',
                type: 'any'
            },
            'mechanicalAction': {
                value: 'switchWhileDragging',
                allowedValues: ['switchUntilReleased', 'switchWhenReleased', 'switchWhileDragging'],
                type: 'string'
            },
            'messages': {
                value: {
                    'en': {
                        'missingReference': '{{elementType}}: Missing reference to {{files}}.',
                        'significantPrecisionDigits': '{{elementType}}: the properties significantDigits and precisionDigits cannot be set at the same time.',
                        'invalidMinOrMax': '{{elementType}}: Invalid {{property}} value. Max cannot be lower than Min.',
                        'noInteger': '{{elementType}}: precisionDigits could be set only on "floatingPoint" scaleType.'
                    }
                },
                type: 'object',
                extend: true
            },
            'min': {
                value: '0',
                type: 'any'
            },
            'mode': {
                value: 'numeric',
                allowedValues: ['numeric', 'date'],
                type: 'string'
            },
            'name': {
                value: '',
                type: 'string'
            },
            'orientation': {
                value: 'vertical',
                allowedValues: ['horizontal', 'vertical'],
                type: 'string'
            },
            'precisionDigits': {
                value: null,
                type: 'number?'
            },
            'scalePosition': {
                value: 'near',
                allowedValues: ['near', 'far', 'both', 'none'],
                type: 'string'
            },
            'scaleType': {
                value: 'floatingPoint',
                allowedValues: ['floatingPoint', 'integer'],
                type: 'string'
            },
            'scientificNotation': {
                value: false,
                type: 'boolean'
            },
            'showThumbLabel': {
                value: false,
                type: 'boolean'
            },
            'showTooltip': {
                value: false,
                type: 'boolean'
            },
            'showUnit': {
                value: false,
                type: 'boolean'
            },
            'significantDigits': {
                value: null,
                type: 'number?'
            },
            'thumbLabelPosition': {
                value: 'near',
                allowedValues: ['near', 'far'],
                type: 'string'
            },
            'ticksPosition': {
                value: 'scale',
                allowedValues: ['scale', 'track'],
                type: 'string'
            },
            'ticksVisibility': {
                value: 'minor',
                allowedValues: ['major', 'minor', 'none'],
                type: 'string'
            },
            'tooltipPosition': {
                value: 'near',
                allowedValues: ['near', 'far'],
                type: 'string'
            },
            'unit': {
                value: 'kg',
                type: 'string'
            },
            'validation': {
                value: 'strict',
                allowedValues: ['strict', 'interaction'],
                type: 'string'
            },
            'value': {
                value: '0',
                type: 'any'
            },
            'wordLength': {
                value: 'int32',
                allowedValues: ['int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32', 'int64', 'uint64'],
                type: 'string'
            }
        };
    }

    /**
     * Tank's event listeners.
     */
    static get listeners() {
        return {
            'track.down': '_trackDownHandler',
            'track.move': '_trackMoveHandler',
            'document.move': '_documentMoveHandler',
            'document.up': '_documentUpHandler',
            'keydown': '_keydownHandler',
            'resize': '_resizeHandler',
            'styleChanged': '_styleChangedHandler',
            'document.selectstart': '_selectStartHandler',
            'track.mouseenter': '_trackOnMouseEnterHandler',
            'track.mouseleave': '_trackOnMouseLeaveHandler'
        };
    }

    static get requires() {
        return {
            'JQX.Utilities.BigNumber': 'jqxmath.js',
            'JQX.Utilities.NumericProcessor': 'jqxnumeric.js',
            'JQX.Utilities.TickIntervalHandler': 'jqxtickintervalhandler.js'
        }
    }

    /**
    * CSS files needed for the element (ShadowDOM)
    */
    static get styleUrls() {
        return [
            'jqx.tank.css'
        ]
    }

    /**
     * Tank's HTML template.
     */
    template() {
        return `<div id="container" class="jqx-container">
                    <div id="scaleNear" class="jqx-scale jqx-scale-near"></div>
                    <div id="track" class="jqx-track">
                        <div id="fill" class="jqx-value">
                            <div id="bubbleContainer" class="jqx-bubble-container"></div>
                            <div id="tooltip" class="jqx-tooltip"><div id="tooltipContent" class="jqx-tooltip-content jqx-unselectable"></div></div>
                            <div id="thumb" class="jqx-thumb">
                                <div class="jqx-thumb-label-container">
                                    <span id="thumbLabel" class="jqx-thumb-label"></span>
                                </div>
                            </div>
                        </div>
                        <div id="trackTicksContainer" class="jqx-track-ticks-container jqx-hidden"></div>
                    </div>
                    <div id="scaleFar" class="jqx-scale jqx-scale-far"></div>
                    <input id="hiddenInput" type="hidden" name="[[name]]">
                </div>`;
    }

    /**
     * Invoked when an instance of custom element is attached to the DOM for the first time.
     */
    ready() {
        super.ready();

        const that = this;

        that._redefineProperty('customTicks');
        this._createElement();
    }

    _createElement() {
        const that = this;

        //Escape the initial transiton
        that.$.fill.style.transition = 'none';

        if (that.mode === 'numeric') {
            that._getEventValue = function () {
                return that.value;
            };
        }
        else {
            that._handleDateScale();
        }

        that._setSettingsObject();
        that._setDrawVariables();
        that._getLayoutType();

        //Creating instances of NumericProcessor and NumberRenderer
        that._numericProcessor = new JQX.Utilities.NumericProcessor(that, 'scaleType');
        that._numberRenderer = new JQX.Utilities.NumberRenderer();

        if (!that._isVisible()) {
            that._renderingSuspended = true;
            return;
        }

        that._renderingSuspended = false;

        that._setInitialComponentDisplay();
        that._measurements = {};
        that._wordLengthNumber = that._numericProcessor.getWordLength(that.wordLength);
        that._validateInitialPropertyValues();
        that._setTicksAndInterval();

        // Initial adjustments
        that._validate(true);

        that._updateTooltipValue(that._drawValue);
        that._setFocusable();
        that._setTrackSize();

        //Add bubbles effect
        that._setBubbles();

        //Restore CSS transition
        that.$.fill.style.transition = '';

        that.$.hiddenInput.value = that._getEventValue();
    }

    /*
     * Public methods
     */

    /**
     * Sets or gets the value of the tank.
     *
     * @param {Number/String} value Optional value to be set to the tank. If this parameter is not set, the method gets the value.
     */
    val(value) {
        const that = this;

        if (value !== undefined) {
            if (that.mode === 'date') {
                let newValue = JQX.Utilities.DateTime.validateDate(value);

                newValue = newValue.getTimeStamp();

                if (newValue.compare(that.value) !== 0) {
                    that._validate(false, newValue, undefined, true);
                    return;
                }

                return that._valueDate;
            }

            if (that.value.toString().toUpperCase() !== value.toString().toUpperCase()) {

                // use as value setter
                value = value.toString().replace(/\s/g, '');
                if (that._numericProcessor.regexScientificNotation.test(value)) {
                    value = that._numericProcessor.scientificToDecimal(value);
                }

                const valueToValidate = that._discardDecimalSeparator(value.toString());

                that._validate(false, valueToValidate, undefined, true);
                delete that._valueBeforeCoercion;
            }
            else {
                return that.value = typeof (value) === 'string' ? value : value.toString();
            }
        }
        else {
            // use as value getter
            return that._getEventValue();
        }
    }

    /**
    * Adds bubbles in the fill area.
    */
    _setBubbles() {
        const that = this;

        if (!that.hasAnimation) {
            //Removes the bubble elements

            //const bubbles = that.getElementsByClassName('bubble');

            //if (bubbles.length > 0) {
            //    for (let b = bubbles.length; b > -1; b--) {
            //        b[0].parentElement.removeChild(b[0]);
            //    }
            //}

            return;
        }

        let fragment = document.createDocumentFragment(),
            bubble;

        for (let b = 0; b < 5; b++) {
            bubble = document.createElement('div');
            bubble.classList.add('bubble');
            bubble.classList.add('bubble' + (b + 1));
            fragment.appendChild(bubble);
        }

        that.$.bubbleContainer.appendChild(fragment);
    }

    _setTrackSize() {
        const that = this;

        //Calculte initial track size
        if (that.orientation === 'vertical') {
            that._trackSize = that.$.track.offsetWidth;
        }
        else {
            that._trackSize = that.$.track.offsetHeight;
        }
    }

    /**
     * Gets the optimal size of the tank.
     */
    getOptimalSize() {
        const that = this;

        if (that._renderingSuspended) {
            return { width: 0, height: 0 };
        }

        let propertiesObj, largestLabelSize, sizeObject;

        switch (that.labelsVisibility) {
            case 'all':
                largestLabelSize = that._numericProcessor._longestLabelSize
                break;
            case 'endPoints':
                largestLabelSize = Math.max(that._tickIntervalHandler.labelsSize.minLabelOtherSize, that._tickIntervalHandler.labelsSize.maxLabelOtherSize);
                break;
            case 'none':
                largestLabelSize = 0;
                break;
        }

        switch (that.orientation) {
            case 'horizontal':
                propertiesObj = {
                    marginA: 'marginBottom',
                    marginB: 'marginTop',
                    nearScaleDistance: 'bottom',
                    farScaleDistance: 'top',
                    paddingA: 'paddingBottom',
                    paddingB: 'paddingTop',
                    offset: 'offsetWidth',
                    distance: 'left'
                };

                if (that._orientationChanged) {
                    propertiesObj.offset = 'offsetHeight';
                    that._trackChanged = true;
                }

                sizeObject = that._getSize(largestLabelSize, propertiesObj);
                return { width: sizeObject.optimalOtherSize, height: sizeObject.optimalSize };
            case 'vertical':
                propertiesObj = {
                    marginA: 'marginLeft',
                    marginB: 'marginRight',
                    nearScaleDistance: 'right',
                    farScaleDistance: 'left',
                    paddingA: 'paddingLeft',
                    paddingB: 'paddingRight',
                    offset: 'offsetHeight',
                    distance: 'top'
                };

                if (that._orientationChanged) {
                    propertiesObj.offset = 'offsetWidth';
                    that._trackChanged = true;
                }

                sizeObject = that._getSize(largestLabelSize, propertiesObj);
                return { width: sizeObject.optimalSize, height: sizeObject.optimalOtherSize };
        }
    }



    /**
     * Invoked when the value of a public property has been changed by the user.
     */
    propertyChangedHandler(key, oldValue, value) {
        super.propertyChangedHandler(key, oldValue, value);

        const that = this;

        if (!that._isVisible() || that._renderingSuspended) {
            that._renderingSuspended = true;
            return;
        }

        // eslint-disable-next-line
        if (value == oldValue) {
            that[key] = oldValue;
            return;
        }

        switch (key) {
            case 'labelsVisibility':
            case 'ticksVisibility':
                that._updateScaleWidth(that._numericProcessor._longestLabelSize);
                return;
            case 'coerce':
                if (value) {
                    const valueBeforeCoercion = that.value,
                        coercedValue = value = that.logarithmicScale ? Math.pow(10, that._numericProcessor.getCoercedValue(Math.log10(valueBeforeCoercion))) : that._numericProcessor.getCoercedValue(valueBeforeCoercion);

                    that._validate(false, coercedValue, true, true);
                    that._valueBeforeCoercion = valueBeforeCoercion; // stores value before coercion
                }
                else {
                    if (that._valueBeforeCoercion !== undefined) {
                        that._validate(false, that._valueBeforeCoercion, false, true);
                    }
                }
                return;
            case 'interval': {
                //Validates the Interval
                that._numericProcessor.validateInterval(value);

                const newValue = value = that.logarithmicScale ? Math.pow(10, that._numericProcessor.getCoercedValue(Math.log10(that.value))) : that._numericProcessor.getCoercedValue(that.value);
                that._validate(false, newValue, that.coerce, true);
                break;
            }
            case 'min':
            case 'max': {
                if (that.mode === 'date') {
                    delete that._dateInterval;

                    that[key] = JQX.Utilities.DateTime.validateDate(value).getTimeStamp();
                }

                that._validateMinMax(key, false, oldValue);

                const validValue = that._numericProcessor.createDescriptor(that._discardDecimalSeparator(that.value, that.decimalSeparator), undefined, true, that.validation === 'strict');

                that._setTicksAndInterval();
                that._numericProcessor.updateValue(validValue);

                let optimalSize = that.getOptimalSize(),
                    actualSize = that.getBoundingClientRect(),
                    trackSize = that.$.track.getBoundingClientRect();

                if (optimalSize.width > actualSize.width && trackSize.width < 20) {
                    that.style.width = optimalSize.width + 'px';
                    that.style.height = optimalSize.height + 'px';
                }
                break;
            }
            case 'inverted': {
                that._getLayoutType();
                if (that._normalLayout) {
                    that.$.fill.style[that._settings.margin] = '0px';
                }

                let invertedNumberToValidate = that._numericProcessor.createDescriptor(that.value),
                    validInvertedValue = that._numericProcessor.validate(invertedNumberToValidate, that._minObject, that._maxObject);

                that._setTicksAndInterval();
                that._numericProcessor.updateValue(validInvertedValue);
                break;
            }
            case 'orientation': {
                const fillStyle = that.$.fill.style,
                    containerStyle = that.$.container.style;

                //resizeChange handler flag
                if (that._orientationChanged !== true) {
                    that._orientationChanged = true;
                }
                that._tankSizeBeforeOrientation = { width: that.offsetWidth, height: that.offsetHeight };
                that._setSettingsObject();
                that._getLayoutType();

                if (that.inverted) {
                    fillStyle.marginTop = '0';
                    fillStyle.marginLeft = '0';

                }
                switch (that.orientation) {
                    case 'vertical':
                        if (!that.inverted) {
                            fillStyle.marginTop = 'auto';
                            fillStyle.marginLeft = '0';
                        }
                        fillStyle.width = '100%';
                        containerStyle.paddingLeft = '0';
                        containerStyle.paddingRight = '0';
                        break;
                    case 'horizontal':
                        if (!that.inverted) {
                            fillStyle.marginTop = '0';
                            fillStyle.marginLeft = 'auto'
                        }
                        fillStyle.height = '100%';
                        containerStyle.paddingTop = '0';
                        containerStyle.paddingBottom = '0';
                        break;
                }
                that._validateMinMax('both');

                const orientationNumberToValidate = that._numericProcessor.createDescriptor(that.value),
                    validOrientationValue = that._numericProcessor.validate(orientationNumberToValidate, that._minObject, that._maxObject);

                that._setTicksAndInterval();
                that._setTicksAndInterval();//
                that._numericProcessor.updateValue(validOrientationValue);

                that._trackChanged = true;
                break;
            }
            case 'significantDigits':
            case 'precisionDigits': {
                if (that.mode === 'date') {
                    return;
                }

                if (key === 'precisionDigits' && that.scaleType === 'integer') {
                    that.error(that.localize('noInteger', { elementType: that.nodeName.toLowerCase(), property: key }));
                }

                if (key === 'significantDigits' && that.precisionDigits !== null) {
                    that.precisionDigits = null;
                }
                else if (key === 'precisionDigits' && that.significantDigits !== null) {
                    that.significantDigits = null;
                }

                // Validates significantDigits
                that._validateInitialPropertyValues();

                // Redraw the labels
                that._setTicksAndInterval();

                if (that.orientation === 'horizontal' && that.inverted) {
                    const px = that._numericProcessor.valueToPx(that._numericProcessor.getCoercedValue(that._drawValue));

                    that.updateFillSizeAndPosition(px, that._settings.margin, value, false);
                }
                break;
            }
            case 'decimalSeparator': {
                if (that.scaleType === 'integer' || that.mode === 'date') {
                    return;
                }

                const numericValue = that._discardDecimalSeparator(that.value, oldValue),
                    valueWithNewSeparator = that._applyDecimalSeparator(numericValue);

                that.value = numericValue;
                delete that._valueBeforeCoercion;

                // Redraw the labels
                that._numericProcessor.addTicksAndLabels();
                that._updateTooltipValue(valueWithNewSeparator);
                break;
            }
            case 'value': {
                that.value = oldValue;

                if (value === null) {
                    return;
                }

                if (that.mode === 'date') {
                    let newValue = JQX.Utilities.DateTime.validateDate(value);

                    newValue = newValue.getTimeStamp();

                    if (newValue.compare(oldValue) !== 0) {
                        that._validate(false, newValue, undefined, true);
                    }

                    return;
                }

                if (value.toString().toUpperCase() !== oldValue.toString().toUpperCase()) {
                    let valueToValidate = value !== undefined ? value.toString().replace(/\s/g, '') : oldValue.toString().replace(/\s/g, '');

                    if (that._numericProcessor.regexScientificNotation.test(valueToValidate)) {
                        valueToValidate = that._numericProcessor.scientificToDecimal(valueToValidate);
                    }

                    that._validate(false, valueToValidate, undefined, true);
                    delete that._valueBeforeCoercion;
                }
                else {
                    that.value = typeof (value) === 'string' ? value : value.toString();
                }

                break;
            }
            case 'scaleType':
                if (that.mode === 'date') {
                    that.scaleType = 'integer';
                    return;
                }

                that._changeScaleType(oldValue, value);
                break;
            case 'disabled':
            case 'unfocusable':
                that._setFocusable();
                break;
            case 'showUnit':
            case 'unit': {
                that._setTicksAndInterval();
                that._moveThumbBasedOnValue(that._drawValue);
                break;
            }
            case 'tooltipPosition':
                break;
            case 'wordLength': {
                if (that.mode === 'date') {
                    that.wordLength = 'uint64';
                    return;
                }

                that._wordLengthNumber = that._numericProcessor.getWordLength(value);
                that._validateMinMax('both');

                const numberToValidate = that._numericProcessor.createDescriptor(that.value),
                    validValue = that._numericProcessor.validate(numberToValidate, that._minObject, that._maxObject);

                that._setTicksAndInterval();
                that._numericProcessor.updateValue(validValue);
                break;
            }
            case 'scalePosition': {
                that._setInitialComponentDisplay();
                that._setTicksAndInterval();
                that._moveThumbBasedOnValue(that._drawValue);
                break;
            }
            case 'labelFormatFunction':
            case 'scientificNotation': {
                if (that.mode === 'date' && key === 'scientificNotation') {
                    return;
                }

                const numericValue = that._discardDecimalSeparator(that.value, that.decimalSeparator);

                // Recalculate label position and redraw the labels
                that._setTicksAndInterval();

                //Update toolTip\'s value
                that._updateTooltipValue(numericValue);
                break;
            }
            case 'logarithmicScale':
                if (that.mode === 'date') {
                    that.logarithmicScale = false;
                    return;
                }

                that._validateMinMax('both');
                that._setTicksAndInterval();
                that._validate(false, that.value, undefined, true);
                break;
            case 'ticksPosition':
                if (value === 'scale') {
                    that.$trackTicksContainer.addClass('jqx-hidden');
                    that.$.trackTicksContainer.innerHTML = '';
                }
                else {
                    that.$trackTicksContainer.removeClass('jqx-hidden');
                }
                that._numericProcessor.addTicksAndLabels();
                break;
            case 'customInterval':
                if (value) {
                    if (that._customTicks) {
                        that.customTicks = that._customTicks;
                    }

                    that._numericProcessor.validateCustomTicks();
                }
                else if (that.mode === 'date') {
                    that._customTicks = that.customTicks;
                }

                that._setTicksAndInterval();
                that._coerceCustomInterval();
                break;
            case 'customTicks':
                if (that.mode === 'date' && !that.customInterval) {
                    that._customTicks = value;
                    that.customTicks = oldValue;
                    return;
                }

                that._numericProcessor.validateCustomTicks();

                if (that.customInterval) {
                    that._setTicksAndInterval();
                    that._coerceCustomInterval();
                }

                break;
            case 'dateLabelFormatString':
                if (that.mode === 'date') {
                    that._setTicksAndInterval();
                }

                break;
            case 'mode':
                that.mode = oldValue;
                break;
            case 'showThumbLabel':
                if (value && that.showTooltip) {
                    that.showTooltip = false;
                }

                break;
            case 'showTooltip':
                if (value && that.showThumbLabel) {
                    that.showThumbLabel = false;
                }

                break;
            case 'validation':
                if (value === 'strict') {
                    that._validate(false, that.value);
                }

                break;
        }
    }

    /**
     * Sets the "_settings" object.
     */
    _setSettingsObject() {
        const that = this;

        if (that.orientation === 'horizontal') {
            that._settings = {
                clientSize: 'clientWidth',
                dimension: 'width',
                leftOrTop: 'left',
                margin: 'marginLeft',
                offset: 'offsetLeft',
                otherSize: 'offsetHeight',
                size: 'offsetWidth',
                page: 'pageX'
            };
        }
        else {
            that._settings = {
                clientSize: 'clientHeight',
                dimension: 'height',
                leftOrTop: 'top',
                margin: 'marginTop',
                offset: 'offsetTop',
                otherSize: 'offsetWidth',
                size: 'offsetHeight',
                page: 'pageY'
            };
        }
    }

    /**
     * Sets the display of the scales.
     */
    _setInitialComponentDisplay() {
        const that = this;

        switch (that.scalePosition) {
            case 'near':
                that.$scaleNear.removeClass('jqx-hidden');
                that.$scaleFar.addClass('jqx-hidden');
                break;
            case 'far':
                that.$scaleNear.addClass('jqx-hidden');
                that.$scaleFar.removeClass('jqx-hidden');
                break;
            case 'both':
                that.$scaleFar.removeClass('jqx-hidden');
                that.$scaleNear.removeClass('jqx-hidden');
                break;
            case 'none':
                that.$scaleFar.addClass('jqx-hidden');
                that.$scaleNear.addClass('jqx-hidden');
                break;
        }
        that.$tooltip.addClass('jqx-hidden');

        if (that.ticksPosition === 'track') {
            that.$trackTicksContainer.removeClass('jqx-hidden');
        }
    }

    /**
    * Style changed event handler.
    **/
    _styleChangedHandler() {
        const that = this;

        if (!that._isVisible()) {
            that._renderingSuspended = true;
            return;
        }
        else if (that._renderingSuspended) {
            that._createElement();
            return;
        }

        if (that._renderingSuspended) {
            return;
        }

        that._setTicksAndInterval();
        that._moveThumbBasedOnValue(that._drawValue);
    }

    /**
     * Validates initial property values.
     */
    _validateInitialPropertyValues() {
        const that = this,
            value = typeof (that.value) === String ? that.value.replace(/\s/g, '') : that.value.toString().replace(/\s/g, '');

        if (that.mode === 'numeric' && that._numericProcessor.regexScientificNotation.test(value)) {
            that.value = that._numericProcessor.scientificToDecimal(value);
            delete that._valueBeforeCoercion;
        }

        //Validates significantDigits
        that.significantDigits = (that.significantDigits !== null) ? Math.min(Math.max(that.significantDigits, 1), 21) : null;

        if (that.significantDigits === null && that.precisionDigits === null) {
            that.significantDigits = 8;
        }
        else if (that.significantDigits !== null && that.precisionDigits !== null) {
            that.error(that.localize('significantPrecisionDigits', { elementType: that.nodeName.toLowerCase() }));
        }

        //minMax validation
        that._validateMinMax('both', true);

        if (that.showTooltip && that.showThumbLabel) {
            that.showTooltip = false;
        }
    }

    /**
      * Validates the properties "min" and "max".
      */
    _validateMinMax(validatedProperty, initialValidation, oldValue) {
        const that = this;

        let validateMin = validatedProperty === 'min' || validatedProperty === 'both',
            validateMax = validatedProperty === 'max' || validatedProperty === 'both';

        if (typeof (initialValidation) === undefined) {
            initialValidation = false;
        }

        if (validatedProperty === 'both') {
            validator('min', oldValue);
            validator('max', oldValue);
        }
        else {
            validator(validatedProperty, oldValue);
        }

        function validator(param, oldValue) {
            that._numericProcessor.validateMinMax(param === 'min' || initialValidation, param === 'max' || initialValidation);
            const value = that['_' + param + 'Object'];
            let validateCondition = param === 'min' ? that._numericProcessor.compare(that.max, value, true) <= 0 :
                that._numericProcessor.compare(that.min, value, true) > 0;

            if (validateCondition) {
                if (oldValue) {
                    that._numberRenderer = new JQX.Utilities.NumberRenderer(oldValue);
                    param === 'min' ? validateMin = false : validateMax = false;
                    that[param] = oldValue;
                    that['_' + param + 'Object'] = oldValue;
                }
                else {
                    that.error(that.localize('invalidMinOrMax', { elementType: that.nodeName.toLowerCase(), property: param }));
                }
            }
            else {
                that._numberRenderer = new JQX.Utilities.NumberRenderer(value);
                that[param] = that['_' + param + 'Object'];
            }
        }

        if (that.logarithmicScale) {
            that._validateOnLogarithmicScale(validateMin, validateMax, oldValue);
        }
        else {
            that._drawMin = that.min;
            that._drawMax = that.max;
        }

        that.min = that.min.toString();
        that.max = that.max.toString();

        that._minObject = that._numericProcessor.createDescriptor(that.min);
        that._maxObject = that._numericProcessor.createDescriptor(that.max);

        if (that.mode === 'date') {
            that._minDate = JQX.Utilities.DateTime.fromFullTimeStamp(that.min);
            that._maxDate = JQX.Utilities.DateTime.fromFullTimeStamp(that.max);
        }

        //Validates the Interval
        that._numericProcessor.validateInterval(that.interval);

        if (that.customInterval) {
            that._numericProcessor.validateCustomTicks();
        }
    }

    /**
     * Calculates the tank's major and minor ticks interval.
     */
    _calculateTickInterval() {
        const that = this;
        let intervals = that._tickIntervalHandler.getInterval('linear', that._drawMin, that._drawMax, that.$.track, that.logarithmicScale);

        if (intervals.major !== that._majorTicksInterval) {
            that._intervalHasChanged = true;
            that._majorTicksInterval = intervals.major;
        }
        else {
            that._intervalHasChanged = true;
        }

        that._minorTicksInterval = intervals.minor;

        if (that.mode === 'date') {
            that._calculateDateInterval(intervals.major);
        }
    }

    /**
     * Calculates the tank's ticks when the scale is date.
     */
    _calculateDateInterval(majorTicksInterval) {
        const that = this,
            timeParts = {
                month: '2628000000000000000000000000000',
                day: '86400000000000000000000000000',
                hour: '3600000000000000000000000000',
                minute: '60000000000000000000000000',
                second: '1000000000000000000000000'
            };
        let part = 'year',
            bigNumberTimePart = new JQX.Utilities.BigNumber('31536000000000000000000000000000'),
            difference = bigNumberTimePart.subtract(majorTicksInterval).abs(),
            range = new JQX.Utilities.BigNumber(that.min).subtract(that.max).abs(),
            projectedNumberOfTicks = range.divide(majorTicksInterval).toString();

        if (projectedNumberOfTicks < 2) {
            majorTicksInterval = range.divide(3);
        }

        for (let timePart in timeParts) {
            if (timeParts.hasOwnProperty(timePart)) {
                const currentBigNumberTimePart = new JQX.Utilities.BigNumber(timeParts[timePart]),
                    currentDifference = currentBigNumberTimePart.subtract(majorTicksInterval).abs();

                if (currentDifference.compare(difference) === -1) {
                    part = timePart;
                    bigNumberTimePart = currentBigNumberTimePart;
                    difference = currentDifference;
                }
                else {
                    break;
                }
            }
        }

        if (part === 'second') {
            that._numberRenderer.numericValue = parseFloat(majorTicksInterval);

            if (that._numberRenderer.numericValue < 1000) {
                that._dateIncrementMethod = 'addYoctoseconds';
                that._dateIntervalNumber = 1;
                return;
            }

            let scientificPrefix = that._numberRenderer.toScientific(10);

            scientificPrefix = scientificPrefix.charAt(scientificPrefix.length - 1);

            that._dateIncrementMethod = that._unitToMethod[scientificPrefix];
            that._dateIntervalNumber = Math.pow(10, that._numericProcessor.prefixesToPowers[scientificPrefix]);
            return;
        }

        that._dateInterval = true;

        const calculatedInterval = !that.customInterval;
        let customTicks, numberOfTimeParts, toAdd;

        if (calculatedInterval) {
            customTicks = [new JQX.Utilities.BigNumber(that.min)];
            numberOfTimeParts = range.divide(bigNumberTimePart).toString();
            toAdd = Math.max(1, Math.floor(numberOfTimeParts / projectedNumberOfTicks));
        }

        switch (part) {
            case 'year':
                if (calculatedInterval) {
                    for (let i = that._minDate.year() + toAdd; i < that._maxDate.year(); i += toAdd) {
                        customTicks.push(new JQX.Utilities.BigNumber(new JQX.Utilities.DateTime(i, 1, 1).getTimeStamp()));
                    }
                }

                that._dateIncrementMethod = 'addYears';
                break;
            case 'month':
                if (calculatedInterval) {
                    for (let i = new JQX.Utilities.DateTime(that._minDate.year(), that._minDate.month() + toAdd, 1);
                        i.compare(that._maxDate) === -1; i.addMonths(toAdd, false)) {
                        customTicks.push(new JQX.Utilities.BigNumber(i.getTimeStamp()));
                    }
                }

                that._dateIncrementMethod = 'addMonths';
                break;
            case 'day':
                if (calculatedInterval) {
                    for (let i = new JQX.Utilities.DateTime(that._minDate.year(), that._minDate.month(), that._minDate.day() + toAdd);
                        i.compare(that._maxDate) === -1; i.addDays(toAdd, false)) {
                        customTicks.push(new JQX.Utilities.BigNumber(i.getTimeStamp()));
                    }
                }

                that._dateIncrementMethod = 'addDays';
                that._dateIntervalNumber = 86400000000000000000000000000;
                break;
            case 'hour':
                if (calculatedInterval) {
                    for (let i = new JQX.Utilities.DateTime(that._minDate.year(), that._minDate.month(), that._minDate.day(), that._minDate.hour() + toAdd);
                        i.compare(that._maxDate) === -1; i.addHours(toAdd, false)) {
                        customTicks.push(new JQX.Utilities.BigNumber(i.getTimeStamp()));
                    }
                }

                that._dateIncrementMethod = 'addHours';
                that._dateIntervalNumber = 3600000000000000000000000000;
                break;
            case 'minute':
                if (calculatedInterval) {
                    for (let i = new JQX.Utilities.DateTime(that._minDate.year(), that._minDate.month(), that._minDate.day(), that._minDate.hour(), that._minDate.minute() + toAdd);
                        i.compare(that._maxDate) === -1; i.addMinutes(toAdd, false)) {
                        customTicks.push(new JQX.Utilities.BigNumber(i.getTimeStamp()));
                    }
                }

                that._dateIncrementMethod = 'addMinutes';
                that._dateIntervalNumber = 60000000000000000000000000;
                break;
        }

        if (calculatedInterval) {
            if (customTicks[customTicks.length - 1].compare(that.max) === -1) {
                customTicks.push(new JQX.Utilities.BigNumber(that.max));
            }

            that.customTicks = customTicks;
        }
    }

    /**
     * Formats the value.
     */
    _formatNumber(value) {
        const that = this;

        if (that.mode === 'date') {
            const date = JQX.Utilities.DateTime.fromFullTimeStamp(value);

            return date.toString(that.dateLabelFormatString);
        }

        const numberRenderer = that._numberRenderer;
        let renderedNumber = parseFloat(value);

        numberRenderer.numericValue = value;

        if (that.scientificNotation) {
            renderedNumber = that._numberRenderer.toScientific(that.significantDigits, that.precisionDigits);
        }
        else {
            switch (that.scaleType) {
                case 'floatingPoint':
                    renderedNumber = that._applyDecimalSeparator(numberRenderer.toDigits(that.significantDigits, that.precisionDigits));
                    break;
                case 'integer':
                    renderedNumber = numberRenderer.isENotation(renderedNumber) ? Math.round(numberRenderer.largeExponentialToDecimal(renderedNumber)) : Math.round(renderedNumber);
                    renderedNumber = numberRenderer.toDigits(that.significantDigits, 0);
                    break;
            }
        }
        return renderedNumber;
    }

    /**
    * Applies formatting to tank labels.
    */
    _formatLabel(labelValue, unselectableUnit) {
        const that = this;
        let renderedLabel;

        if (that.labelFormatFunction) {
            if (that.mode === 'date') {
                labelValue = JQX.Utilities.DateTime.fromFullTimeStamp(labelValue);
            }

            renderedLabel = that.labelFormatFunction(labelValue);

            if (renderedLabel !== undefined && renderedLabel !== '') {
                return renderedLabel;
            }
        }

        renderedLabel = that._formatNumber(labelValue);
        that._numberRenderer = new JQX.Utilities.NumberRenderer(renderedLabel);
        if (that.showUnit) {
            if (unselectableUnit !== false) {
                renderedLabel += ' <span class="jqx-unselectable">' + that.unit + '</span>';
            }
            else {
                renderedLabel += ' ' + that.unit;
            }
        }
        return renderedLabel;
    }

    /**
     * Applies necessary paddings to the track container.
     */
    _layout() {
        const that = this,
            containerStyle = that.$.container.style,
            paddingStart = that._tickIntervalHandler.labelsSize.minLabelSize / 2 + 'px',
            paddingEnd = that._tickIntervalHandler.labelsSize.maxLabelSize / 2 + 'px';

        switch (that.orientation) {
            case 'horizontal':
                if (that.scalePosition === 'none') {
                    containerStyle.paddingLeft = '';
                    containerStyle.paddingRight = '';
                    break;
                }
                if (!that.inverted) {
                    containerStyle.paddingLeft = paddingStart;
                    containerStyle.paddingRight = paddingEnd;
                }
                else {
                    containerStyle.paddingLeft = paddingEnd;
                    containerStyle.paddingRight = paddingStart;
                }
                break;
            case 'vertical':
                if (that.scalePosition === 'none') {
                    containerStyle.paddingTop = '';
                    containerStyle.paddingBottom = '';
                    break;
                }
                if (!that.inverted) {
                    containerStyle.paddingBottom = paddingStart;
                    containerStyle.paddingTop = paddingEnd;
                }
                else {
                    containerStyle.paddingBottom = paddingEnd;
                    containerStyle.paddingTop = paddingStart;
                }
                break;
        }
        that._measurements.trackLength = that.$.track[this._settings.clientSize];
    }

    /**
     * Track click event handler.
     */
    _trackDownHandler(event) {
        const that = this;

        if (that.disabled || that.readonly || (!JQX.Utilities.Core.isMobile && event.button !== 0)) {
            return;
        }

        if (that.mechanicalAction === 'switchUntilReleased') {
            that._cachedValue = {};
            that._cachedValue._number = that._number;
            that._cachedValue._drawValue = that._drawValue;
            that._cachedValue.value = that.value;

            if (that._valueDate) {
                that._cachedValue._valueDate = that._valueDate;
            }
        }

        that._getTrackStartAndEnd();
        that._moveThumbBasedOnCoordinates(event, true, that.mechanicalAction !== 'switchWhenReleased');
        that._thumbDragged = true;
        that.$track.addClass('jqx-dragged');

        if (that.showTooltip) {
            that.$tooltip.removeClass('jqx-hidden');
        }
    }

    /**
     * Track mousemove event handler.
     */
    _trackMoveHandler(event) {
        if (event.originalEvent.type === 'touchmove') {
            event.originalEvent.preventDefault();
        }
    }

    /**
     * Document mousemove event handler.
     */
    _documentMoveHandler(event) {
        const that = this;

        if (that._thumbDragged) {
            event.originalEvent.preventDefault();
            that._moveThumbBasedOnCoordinates(event, true, that.mechanicalAction !== 'switchWhenReleased');
            that.$fill.addClass('disable-animation');
        }
    }

    /**
     * Document mouseup event handler.
     */
    _documentUpHandler(event) {
        const that = this;

        if (!that._thumbDragged) {
            return;
        }

        if (that.mechanicalAction === 'switchWhenReleased') {
            that._moveThumbBasedOnCoordinates(event, true, true);
        }
        else if (that.mechanicalAction === 'switchUntilReleased') {
            if (that._numericProcessor.compare(that._number, that._cachedValue._number)) {
                const oldValue = that._getEventValue();

                that._number = that._cachedValue._number;
                that._drawValue = that._cachedValue._drawValue;

                if (that._cachedValue._valueDate) {
                    that._valueDate = that._cachedValue._valueDate;
                }

                that.value = that._cachedValue.value;

                that._moveThumbBasedOnValue(that._drawValue);

                const value = that._getEventValue();

                that.$.fireEvent('change', { 'value': value, 'oldValue': oldValue });
                that.$.hiddenInput.value = value;
            }
        }

        if (that.showTooltip) {
            that.$tooltip.addClass('jqx-hidden');
        }

        that._thumbDragged = false;
        that.$track.removeClass('jqx-dragged');
        that.$fill.removeClass('disable-animation');
    }

    /**
     * Document select start handler.
     */
    _selectStartHandler(event) {
        const that = this;

        if (that._thumbDragged) {
            event.preventDefault();
        }
    }

    /**
     * Tank resize event handler.
     */
    _resizeHandler() {
        const that = this;

        if (!that._isVisible()) {
            that._renderingSuspended = true;
            return;
        }
        else if (that._renderingSuspended) {
            that._createElement();
            return;
        }

        if (that._renderingSuspended) {
            return;
        }

        if (that._orientationChanged !== true) {
            that._setTicksAndInterval();
            that._moveThumbBasedOnValue(that._drawValue);
        }

        //Needed for getOptimalSize method
        if (that._trackChanged) {
            that._measurements.trackLength = that.$.track[this._settings.clientSize];
            that._setTicksAndInterval();
            that._moveThumbBasedOnValue(that._drawValue);
        }

        that._setTrackSize();
        delete that._orientationChanged;
        delete that._trackChanged;
    }

    /**
     * Moves the tank's thumb and updates the filled part of the track based on the position of the mouse.
     */
    _moveThumbBasedOnCoordinates(event, checkBoundaries, changeValue) {
        const that = this;
        let coordinate = checkBoundaries ? Math.min(Math.max(event[that._settings.page], that._trackStart), that._trackEnd) : event[that._settings.page],
            value = that._numericProcessor.pxToValue(coordinate);

        if (that.logarithmicScale) {
            that._drawValue = Math.log10(value);
            value = that._numericProcessor.getCoercedValue(that._drawValue);
        }
        else {
            that._drawValue = value;
            value = that._numericProcessor.getCoercedValue(value);
        }

        // Validating the coordinate
        coordinate = Math.min(Math.max(that._numericProcessor.valueToPx(value) + that._trackStart, that._trackStart), that._trackEnd);

        const size = coordinate - that._trackStart;

        that.updateFillSizeAndPosition(size, that._settings.margin, value, true, changeValue);

        if (event.originalEvent) {
            event.originalEvent.stopPropagation();
        }
    }

    /**
     * Moves the tank's thumb and updates the filled part of the track based on a passed value.
     */
    _moveThumbBasedOnValue(value) {
        const that = this,
            px = that._numericProcessor.valueToPx(that._numericProcessor.getCoercedValue(value));

        that.updateFillSizeAndPosition(px, that._settings.margin, value, true);
    }

    /**
    * Applies the filling, updates the tooltip and the value
    */
    updateFillSizeAndPosition(size, margin, newValue, updateTooltip, changeValue) {
        const that = this,
            fillStyle = that.$.fill.style;

        if (that._normalLayout) {
            fillStyle[that._settings.dimension] = size + 'px';
        }
        else {
            fillStyle[that._settings.dimension] = Math.min(that._measurements.trackLength, Math.max(0, (that._measurements.trackLength - size))) + 'px';
            fillStyle[margin] = size + 'px';
        }

        if (updateTooltip) {
            const oldValue = that.value;

            delete that._valueBeforeCoercion;
            that._numericProcessor.updateToolTipAndValue(newValue, oldValue, changeValue);
        }
    }

    /**
    * Sets tooltip's value.
    */
    _updateTooltipValue(value) {
        const that = this;

        if (value === undefined) {
            value = that.value;
        }

        if (that.logarithmicScale) {
            value = Math.pow(10, value.toString());
        }

        value = that._formatLabel(value);
        that.$.tooltipContent.innerHTML = value;
        that.$.thumbLabel.innerHTML = value;
    }

    /**
    * Returns the optimal size, based on tank settings.
    **/
    _getSize(largestLabelSize, properties) {
        const that = this,
            tankStyle = window.getComputedStyle(that),
            trackStyle = window.getComputedStyle(that.$.track),
            trackSize = that._trackSize + parseFloat(trackStyle[properties.marginA]) + parseFloat(trackStyle[properties.marginB]);
        let firstLabel, lastLabel, optimalSize, optimalOtherSize;

        function calcScaleSize(selector, distance) {
            const labels = selector.getElementsByClassName('jqx-label');

            firstLabel = labels[0];
            lastLabel = labels[labels.length - 1];

            const firstLabelStyle = window.getComputedStyle(labels[0])[distance];

            optimalSize += parseFloat(firstLabelStyle);
        }

        optimalSize = trackSize;
        switch (that.scalePosition) {
            case 'none':
                optimalSize += parseFloat(tankStyle[properties.paddingA]) + parseFloat(tankStyle[properties.paddingB]);
                if (typeof (that._tankSizeBeforeOrientation) !== 'undefined') {
                    optimalOtherSize = that.orientation === 'horizontal' ? that._tankSizeBeforeOrientation.height : that._tankSizeBeforeOrientation.width;
                }
                else {
                    optimalOtherSize = that.orientation === 'horizontal' ? parseFloat(trackStyle.width) : parseFloat(trackStyle.height);
                }
                if (that._trackChanged !== true) {
                    that._trackChanged = true;
                }

                return { optimalSize: optimalSize, optimalOtherSize: optimalOtherSize };
            case 'near':
                optimalSize += largestLabelSize;
                calcScaleSize(that.$.scaleNear, properties.nearScaleDistance);
                break;
            case 'far':
                optimalSize += largestLabelSize;
                calcScaleSize(that.$.scaleFar, properties.farScaleDistance);
                break;
            case 'both':
                optimalSize += 2 * largestLabelSize;
                calcScaleSize(that.$.scaleNear, properties.nearScaleDistance);
                calcScaleSize(that.$.scaleFar, properties.farScaleDistance);
                break
        }

        let firstRect, lastRect, difference;

        optimalSize += parseFloat(tankStyle[properties.paddingA]) + parseFloat(tankStyle[properties.paddingB]);
        firstRect = firstLabel.getBoundingClientRect();
        lastRect = lastLabel.getBoundingClientRect();

        optimalOtherSize = that[properties.offset];

        difference = firstRect[properties.distance] + firstLabel[properties.offset] - lastRect[properties.distance];
        if (difference > 0) {
            optimalOtherSize = firstLabel[properties.offset] + lastLabel[properties.offset];
        }

        return { optimalSize: optimalSize, optimalOtherSize: optimalOtherSize };
    }

    /**
     * Calculates the tank's current value range.
     */
    _getRange() {
        const that = this;

        if (that.logarithmicScale) {
            that._range = that._drawMax - that._drawMin;
            return;
        }

        if (that.scaleType === 'floatingPoint') {
            that._range = (that._drawMax - that._drawMin).toString();
        }
        else {
            that._range = new JQX.Utilities.BigNumber(that._drawMax).subtract(that._drawMin).toString();
        }
    }

    /**
     * Gets the coordinates of the track and the value per pixel ratio.
     */
    _getTrackStartAndEnd() {
        const that = this;
        let trackStart,
            offset = that.$.track.getBoundingClientRect();

        if (that.orientation === 'horizontal') {
            const scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft;
            trackStart = offset.left + scrollLeft;
        }
        else {
            const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
            trackStart = offset.top + scrollTop;
        }

        const trackEnd = trackStart + that._measurements.trackLength,
            pxRange = trackEnd - trackStart;

        that._trackStart = trackStart;
        that._trackEnd = trackEnd;
        that._valuePerPx = that._numericProcessor.getValuePerPx(that._range, pxRange);
    }

    /**
    * Update scale's width.
    */
    _updateScaleWidth(longestLabelSize) {
        const that = this;
        let scaleCoeficient = that.ticksPosition === 'track' ? 4 : 12;

        switch (that.labelsVisibility) {
            case 'all':
                longestLabelSize = that._numericProcessor._longestLabelSize
                break;
            case 'endPoints':
                longestLabelSize = Math.max(that._tickIntervalHandler.labelsSize.minLabelOtherSize, that._tickIntervalHandler.labelsSize.maxLabelOtherSize);
                break;
            case 'none':
                longestLabelSize = 0;
                break;
        }

        let scaleSize = scaleCoeficient + longestLabelSize,
            trackComputedStyle = window.getComputedStyle(that.$.track),
            variablesUsed = Boolean(trackComputedStyle.getPropertyValue('--jqx-tank-scale-size'));

        if (variablesUsed) {
            that.$.container.style.setProperty('--jqx-tank-scale-size', scaleSize + 'px');
        }
        else {
            const computedStyles = window.getComputedStyle(that),
                scaleNearStyle = that.$.scaleNear.style,
                scaleFarStyle = that.$.scaleFar.style,
                trackStyle = that.$.track.style,
                trackMinWidth = parseFloat(trackComputedStyle.getPropertyValue('min-width'));
            let dimension,
                dimension2,
                dimensionValue,
                margins,
                outlineWidth = parseFloat(trackComputedStyle.getPropertyValue('outline-width')) || 0,
                outlineOffset = parseFloat(trackComputedStyle.getPropertyValue('outline-offset')) || 0,
                outline = outlineWidth + outlineOffset,
                paddings;

            switch (that.orientation) {
                case 'horizontal':
                    dimension = 'height';
                    dimension2 = 'width';
                    dimensionValue = that.offsetHeight;
                    paddings = parseFloat(computedStyles.getPropertyValue('padding-top')) + parseFloat(computedStyles.getPropertyValue('padding-bottom'));
                    margins = parseFloat(trackComputedStyle.getPropertyValue('margin-top')) + parseFloat(trackComputedStyle.getPropertyValue('margin-bottom'));
                    break;
                case 'vertical':
                    dimension = 'width';
                    dimension2 = 'height';
                    dimensionValue = that.offsetWidth;
                    paddings = parseFloat(computedStyles.getPropertyValue('padding-left')) + parseFloat(computedStyles.getPropertyValue('padding-right'));
                    margins = parseFloat(trackComputedStyle.getPropertyValue('margin-left')) + parseFloat(trackComputedStyle.getPropertyValue('margin-right'));
                    break;
            }
            switch (that.scalePosition) {
                case 'near':
                    scaleNearStyle.setProperty(dimension, scaleSize + 'px');
                    trackStyle.setProperty(dimension, Math.max(isNaN ? 0 : trackMinWidth, dimensionValue - paddings - scaleSize - 4 - margins - outline) + 'px');
                    break;
                case 'far':
                    scaleFarStyle.setProperty(dimension, scaleSize + 'px');
                    trackStyle.setProperty(dimension, Math.max(isNaN ? 0 : trackMinWidth, dimensionValue - paddings - scaleSize - 4 - margins - outline) + 'px');
                    break;
                case 'both':
                    scaleNearStyle.setProperty(dimension, scaleSize + 'px');
                    scaleFarStyle.setProperty(dimension, scaleSize + 'px');
                    trackStyle.setProperty(dimension, Math.max(isNaN ? 0 : trackMinWidth, dimensionValue - paddings - 2 * scaleSize - 4 - margins - outline) + 'px');
                    break;
                case 'none':
                    trackStyle.setProperty(dimension, '');
                    break;
            }

            trackStyle.setProperty(dimension2, '100%');
            scaleNearStyle.setProperty(dimension2, '100%');
            scaleFarStyle.setProperty(dimension2, '100%');
        }
    }

    /**
     * Appends ticks and labels to the scales.
     */
    _appendTicksAndLabelsToScales(ticks, labels) {
        const that = this;

        function applyTicksAndLabels(scaleElement) {
            scaleElement.innerHTML = labels;

            if (that.ticksPosition === 'scale')
                scaleElement.innerHTML += ticks;
        }

        switch (that.scalePosition) {
            case 'near':
                applyTicksAndLabels(that.$.scaleNear);
                break;
            case 'far':
                applyTicksAndLabels(that.$.scaleFar);
                break;
            case 'both':
                applyTicksAndLabels(that.$.scaleNear);
                applyTicksAndLabels(that.$.scaleFar);
                break;
        }

        if (that.ticksPosition === 'track') {
            that.$.trackTicksContainer.innerHTML = ticks;
        }
    }

    /**
     * Replaces a custom decimal separator with the default one.
     */
    _discardDecimalSeparator(value, separator) {
        const that = this;

        if (separator === undefined) {
            separator = that.decimalSeparator;
        }

        if (separator !== '.') {
            let decimalSeparatorRegExp = new RegExp(separator, 'g');
            return typeof value === 'string' ? value.replace(decimalSeparatorRegExp, '.') : value.toString().replace(decimalSeparatorRegExp, '.');
        }
        else {
            return value;
        }
    }

    /**
    * Applies a custom decimal separator.
    */
    _applyDecimalSeparator(value) {
        const that = this;

        if (typeof value !== 'string') {
            value = value.toString();
        }

        if (that.decimalSeparator !== '.') {
            value = value.replace(/\./g, that.decimalSeparator);
        }

        return value;
    }

    /**
     * Validates the value of the Tank.
     */
    _validate(initialValidation, programmaticValue, coerced, programmaticValueIsSet) {
        const that = this;
        let value;

        that._programmaticValueIsSet = programmaticValueIsSet && that.validation === 'interaction';

        if (initialValidation) {
            value = that.value;
        }
        else {
            value = programmaticValue;
        }

        let actualValue, validNumber;

        if (coerced !== true && that.coerce) {
            actualValue = that._numericProcessor.createDescriptor(value, true, true, true);
            actualValue = that.logarithmicScale ? Math.pow(10, that._numericProcessor.getCoercedValue(Math.log10(actualValue))) : that._numericProcessor.getCoercedValue(actualValue);
            validNumber = actualValue;
        }
        else if (that.validation === 'strict' || !initialValidation && !that._programmaticValueIsSet) {
            actualValue = that._numericProcessor.createDescriptor(value, true, true, true);
            validNumber = actualValue;
        }
        else {
            actualValue = that._numericProcessor.createDescriptor(value, true, true, false);
            validNumber = that._numericProcessor.validate(actualValue, that._minObject, that._maxObject);
        }

        if (that._numericProcessor.regexScientificNotation.test(validNumber)) {
            validNumber = that._numericProcessor.scientificToDecimal(validNumber);
        }

        validNumber = that._discardDecimalSeparator(validNumber, that.decimalSeparator);

        if (initialValidation) {
            that._number = validNumber;
            that._drawValue = that.logarithmicScale ? Math.log10(validNumber) : validNumber;

            if (that.mode === 'numeric') {
                that.value = actualValue.toString();
            }
            else {
                that._valueDate = JQX.Utilities.DateTime.fromFullTimeStamp(actualValue);
                that.value = actualValue;
            }

            delete that._valueBeforeCoercion;
            that._moveThumbBasedOnValue(that._drawValue);
        }
        else {
            that._numericProcessor.updateValue(actualValue);
        }

        that._programmaticValueIsSet = false;
    }

    /**
     * Changes the input format.
     */
    _changeScaleType() {
        const that = this;

        that._numericProcessor = new JQX.Utilities.NumericProcessor(that, 'scaleType');

        that._validateMinMax('both');

        that._setTicksAndInterval();
        that._scaleTypeChangedFlag = true;
        that._validate(true, that._number.toString());
        that._scaleTypeChangedFlag = false;
    }

    /**
    * Sets new Ticks and Interval 
    */
    _setTicksAndInterval() {
        const that = this;

        if (!that._isVisible() || that._renderingSuspended) {
            that._renderingSuspended = true;
            return;
        }

        //Set the New Format here
        let minLabel = that._formatLabel(that.min),
            maxLabel = that._formatLabel(that.max);

        //gets the range with the new min/max
        that._getRange();

        //creates a new tickIntervalHandler instance
        that._tickIntervalHandler = new JQX.Utilities.TickIntervalHandler(that, minLabel, maxLabel, 'jqx-label', that._settings.size, that.scaleType === 'integer', that.logarithmicScale);

        //re-arranges the layout
        that._layout();

        if (!that.customInterval) {
            // calculates the tickInterval
            that._calculateTickInterval();

            if (that._dateInterval) {
                that._intervalHasChanged = true;
                that._numericProcessor.addCustomTicks();
            }
            else {
                // Add the ticks and labels
                that._numericProcessor.addTicksAndLabels();
            }
        }
        else {
            if (that.mode === 'date') {
                that._calculateTickInterval()
            }

            // custom ticks
            that._intervalHasChanged = true;
            that._numericProcessor.addCustomTicks();
        }
    }

    /**
    * Sets tab index 
    */
    _setFocusable() {
        const that = this;

        if (that.disabled || that.unfocusable) {
            that.removeAttribute('tabindex');
            return;
        }

        that.tabIndex = that.tabIndex > 0 ? that.tabIndex : 0;
    }

    /**
     * Increments or decrements a value when a key is pressed.
     */
    _keyIncrementDecrement(action, preValue) {
        const that = this,
            actionCoefficient = action === 'add' ? 1 : -1,
            calculatePreValue = preValue === undefined;

        if (calculatePreValue) {
            preValue = that.logarithmicScale ? new JQX.Utilities.BigNumber(that._drawValue) : that._drawValue;
        }

        if (that.customInterval && that.coerce) {
            if (calculatePreValue) {
                if (that.logarithmicScale) {
                    preValue = that.value;
                }

                if (that.mode === 'numeric') {
                    preValue = preValue.toString();
                }
            }

            let possibleValues, index;

            if (that.mode === 'numeric') {
                possibleValues = that.customTicks.indexOf(that.min) !== -1 ? that.customTicks.slice(0) : [that.min].concat(that.customTicks);
                index = possibleValues.indexOf(preValue);
            }
            else {
                possibleValues = that.customTicks.findIndex(function (element) {
                    return element.compare(that._drawMin) === 0;
                }) !== -1 ?
                    that.customTicks.slice(0) : [that._drawMin].concat(that.customTicks);

                index = possibleValues.findIndex(function (element) {
                    return element.compare(preValue) === 0;
                });
            }

            const adjacent = possibleValues[index + 1 * actionCoefficient];

            if (adjacent !== undefined) {
                return adjacent;
            }
            else if (preValue === that.max && action === 'subtract') {
                return possibleValues[possibleValues.length - 2];
            }

            return preValue;
        }

        if (that.mode === 'numeric') {
            let newValue = that._numericProcessor.incrementDecrement(preValue, action, that._validInterval);
            if (that.logarithmicScale) {
                that._drawValue = newValue;
                newValue = Math.pow(10, Math.round(newValue));
            }
            return newValue;
        }

        if (that.validation === 'interaction' &&
            (that._valueDate.compare(that._minDate) === -1 ||
                that._valueDate.compare(that._maxDate) === 1)) {
            that._valueDate = JQX.Utilities.DateTime.fromFullTimeStamp(that._drawValue);
        }

        that._valueDate[that._dateIncrementMethod](actionCoefficient * parseFloat(that.interval), false);
        that._drawValue = new JQX.Utilities.BigNumber(that._valueDate.getTimeStamp());

        if (that._drawValue.compare(that._drawMin) === -1) {
            that._drawValue = new JQX.Utilities.BigNumber(that._drawMin);
            that._valueDate = JQX.Utilities.DateTime.fromFullTimeStamp(that._drawValue);
        }

        if (that._drawValue.compare(that._drawMax) === 1) {
            that._drawValue = new JQX.Utilities.BigNumber(that._drawMax);
            that._valueDate = JQX.Utilities.DateTime.fromFullTimeStamp(that._drawValue);
        }

        return that._drawValue;
    }

    /**
    * Tank keydown event handler. Changes the value when user press an arrow, home or end key.
    */
    _keydownHandler(event) {
        const that = this;

        if ((that.disabled) || (that.readonly)) {
            return;
        }

        const keyCode = !event.charCode ? event.which : event.charCode,
            handledKeyCodes = [35, 36, 37, 38, 39, 40];

        if (handledKeyCodes.indexOf(keyCode) === -1) {
            return;
        }

        const isIncrementKey = [35, 38, 39].indexOf(keyCode) > -1,
            isDecrementKey = [36, 37, 40].indexOf(keyCode) > -1;

        event.preventDefault();

        if (that.scaleType === 'floatingPoint') {
            if ((parseFloat(that.value) <= parseFloat(that.min)) && isDecrementKey || (parseFloat(that.value) >= parseFloat(that.max)) && isIncrementKey) {
                return;
            }
        }
        else {
            let testValue = new JQX.Utilities.BigNumber(that._drawValue);

            if ((testValue.compare(that._drawMin) !== 1) && isDecrementKey || (testValue.compare(that._drawMax) !== -1) && isIncrementKey) {
                return;
            }
        }

        let newValue;

        switch (keyCode) {
            case 40:    //down arrow
            case 37:    //left arrow
                newValue = that._keyIncrementDecrement('subtract');
                break;
            case 38:    //top arrow
            case 39:    //right arrow
                newValue = that._keyIncrementDecrement('add');
                break;
            case 36:    //home
                that._drawValue = that._drawMin;
                newValue = that.min;
                break;
            case 35:    //end
                that._drawValue = that._drawMax;
                newValue = that.max;
                break;
        }

        that._validate(false, newValue, keyCode);

        return false;
    }

    /**
    * Sets internal variables, used about scale drawing and preserving the value from initial validation
    **/
    _setDrawVariables() {
        const that = this;

        if (that.logarithmicScale) {
            that._drawValue = Math.log10(that.value);
            that._drawMin = Math.log10(that.min);
            that._drawMax = Math.log10(that.max);
        }
        else {
            that._drawValue = that.value;
            that._drawMin = that.min;
            that._drawMax = that.max;
        }
    }

    /**
    * validates values when is used logarithmic scale
    **/
    _validateOnLogarithmicScale(validateMin, validateMax) {
        const that = this;

        function findNearestPowerOfTen(value) {
            return Math.pow(10, Math.round(Math.log10(value) - Math.log10(5.5) + 0.5));
        }

        if (validateMin) {
            if (that.min <= 0) {
                that.min = 1;
                that._drawMin = 0;
            }
            else if (Math.log10(that.min) % 1 !== 0) {
                let nearestPowerOfTen = findNearestPowerOfTen(parseFloat(that.min));
                if (nearestPowerOfTen > that.min) {
                    nearestPowerOfTen /= 10;
                }
                that._drawMin = Math.log10(that.min);
            }
            else {
                that._drawMin = Math.log10(that.min);
            }
        }

        if (validateMax) {
            if (that.max <= 0) {
                that.max = 1;
                that._drawMax = 0;
            }
            else if (Math.log10(that.max) % 1 !== 0) {
                let nearestPowerOfTen = findNearestPowerOfTen(parseFloat(that.max));
                if (nearestPowerOfTen < that.max) {
                    nearestPowerOfTen *= 10;
                }
                that._drawMax = Math.log10(that.max);
            }
            else {
                that._drawMax = Math.log10(that.max);
            }
        }

        if (that.scaleType === 'integer') {
            if (that._drawMin < 0) {
                that._drawMin = 0;
                that.min = 1;
            }

            if (that._drawMax < 0) {
                that._drawMax = 1;
                that.max = 10;
            }
        }

        if (that._drawMax === that._drawMin) {
            that._drawMax = that._drawMin + 1;
        }
    }

    /**
     * Sets the internal property "_normalLayout" based on the properties "orientation" and "inverted".
     */
    _getLayoutType() {
        const that = this,
            orientation = that.orientation,
            inverted = that.inverted;

        that._normalLayout = orientation === 'horizontal' && !inverted || orientation === 'vertical' && inverted;
    }

    /**
     * Applies a CSS class to change fill's pointer. Used instead of :hover CSS selector.
    **/
    _trackOnMouseEnterHandler() {
        const that = this;

        if (!that.readonly && !that.disabled) {
            that.$track.addClass('track-hovered');
            that.$.track.setAttribute('hover', '');
        }
    }

    /**
     * Removes the CSS class used to change fill's pointer.
    **/
    _trackOnMouseLeaveHandler() {
        const that = this;

        if (!that.readonly && !that.disabled) {
            that.$track.removeClass('track-hovered');
            that.$.track.removeAttribute('hover');
        }
    }

    /**
     * Checks if the element is visible.
     */
    _isVisible() {
        const that = this;

        return !!(that.offsetWidth || that.offsetHeight || that.getClientRects().length);
    }

    /**
     * Coerces the value when changes to custom interval-related settings are made.
     */
    _coerceCustomInterval() {
        const that = this;

        if (!that.coerce) {
            return;
        }

        const valueBeforeCoercion = that._valueBeforeCoercion,
            newCoercedValue = that.logarithmicScale ? Math.pow(10, that._numericProcessor.getCoercedValue(Math.log10(that.value))) : that._numericProcessor.getCoercedValue(that.value);

        that._validate(false, newCoercedValue, true, true);
        that._valueBeforeCoercion = valueBeforeCoercion;
    }

    /**
     * Handles date scale.
     */
    _handleDateScale() {
        const that = this,
            dateTime = JQX.Utilities.DateTime;

        if (!dateTime) {
            that.error(that.localize('missingReference', { elementType: that.nodeName.toLowerCase(), files: 'jqxdate.js' }));
        }

        that._customTicks = that.customTicks;

        that._unitToMethod = {
            'Y': 'addSeconds', 'Z': 'addMilliseconds', 'E': 'addMicroseconds', 'P': 'addNanoseconds', 'T': 'addPicoseconds', 'G': 'addFemtoseconds', 'M': 'addAttoseconds', 'k': 'addZeptoseconds'
        };

        that._minDate = dateTime.validateDate(that.min);
        that.min = that._minDate.getTimeStamp();
        that._maxDate = dateTime.validateDate(that.max);
        that.max = that._maxDate.getTimeStamp();

        if (!that.rangeSlider) {
            that._valueDate = dateTime.validateDate(that.value);
            that.value = that._valueDate.getTimeStamp();
        }

        that._properties.min.serialize = '_serializeMin';
        that._properties.max.serialize = '_serializeMax';
        that._properties.value.serialize = '_serializeValue';

        that.scaleType = 'integer';
        that.logarithmicScale = false;
        that.wordLength = 'uint64';

        const propertiesToRedefine = ['min', 'max', 'value'];

        for (let i = 0; i < propertiesToRedefine.length; i++) {
            const propertyName = propertiesToRedefine[i];

            Object.defineProperty(that, propertyName, {
                get: function () {
                    if (that.context === that) {
                        return that.properties[propertyName].value;
                    }
                    else {
                        return that['_' + propertyName + 'Date'];
                    }
                },
                set(value) {
                    that.updateProperty(that, that._properties[propertyName], value);
                }
            });
        }

        that._getEventValue = function () {
            return that._valueDate.clone();
        };
    }

    /**
     * Serializes "min".
     */
    _serializeMin() {
        return this._minDate.toString();
    }

    /**
     * Serializes "max".
     */
    _serializeMax() {
        return this._maxDate.toString();
    }

    /**
     * Serializes "value".
     */
    _serializeValue() {
        return this._valueDate.toString();
    }

    /**
     * Redefines property getter and setter.
     */
    _redefineProperty(propertyName) {
        const that = this;

        Object.defineProperty(that, propertyName, {
            get: function () {
                return that.properties[propertyName].value;
            },
            set(value) {
                function replacer(key, value) {
                    if (value instanceof JQX.Utilities.BigNumber) {
                        return value.toString();
                    }

                    return value;
                }

                const oldValue = that.properties[propertyName].value,
                    stringifiedOldValue = JSON.stringify(oldValue, replacer),
                    stringifiedValue = JSON.stringify(value, replacer);

                if (stringifiedOldValue === stringifiedValue) {
                    return;
                }

                that.properties[propertyName].value = value;

                if (that.isReady && (!that.ownerElement || (that.ownerElement && that.ownerElement.isReady)) && that.context !== that) {
                    const context = that.context;

                    that.context = that;
                    that.propertyChangedHandler(propertyName, oldValue, value);
                    that.context = context;
                }
            }
        });
    }
});

/**
 * Gauge custom element.
 */
JQX('jqx-gauge', class Gauge extends JQX.Tank {
    /**
     * Gauge's properties.
     */
    static get properties() {
        return {
            'analogDisplayType': {
                value: 'needle',
                allowedValues: ['needle', 'fill', 'line'],
                type: 'string'
            },
            'animationDuration': {
                value: 300,
                type: 'number'
            },
            'digitalDisplay': {
                value: false,
                type: 'boolean'
            },
            'digitalDisplayPosition': {
                value: 'bottom',
                allowedValues: ['top', 'bottom', 'right', 'left', 'center'],
                type: 'string'
            },
            'drawNeedle': {
                value: null,
                type: 'function?'
            },
            'endAngle': {
                value: 210,
                type: 'number'
            },
            'needlePosition': {
                value: 'center',
                allowedValues: ['center', 'edge'],
                type: 'string'
            },
            'ranges': {
                value: [],
                type: 'array'
            },
            'scalePosition': {
                value: 'inside',
                allowedValues: ['outside', 'inside', 'none'],
                type: 'string'
            },
            'showRanges': {
                value: false,
                type: 'boolean'
            },
            'sizeMode': {
                value: 'circle',
                allowedValues: ['circle', 'auto'],
                type: 'string'
            },
            'startAngle': {
                value: -30,
                type: 'number'
            }
        };
    }

    /**
     * Gauge's event listeners.
     */
    static get listeners() {
        return {
            'down': '_downHandler',
            'resize': '_resizeHandler',
            'styleChanged': '_styleChangedHandler',
            'document.move': '_documentMoveHandler',
            'document.up': '_documentUpHandler',
            'document.selectstart': '_selectStartHandler',
            'keydown': '_keydownHandler',
            'move': '_trackMoveHandler'
        };
    }

    /**
     * Gauge's required files.
     */
    static get requires() {
        return {
            'JQX.Utilities.Draw': 'jqxdraw.js',
            'JQX.NumericTextBox': 'jqxnumerictextbox.js'
        }
    }

    /**
    * CSS files needed for the element (ShadowDOM)
    */
    static get styleUrls() {
        return [
            'jqx.gauge.css'
        ]
    }

    /**
     * Gauge's HTML template.
     */
    template() {
        const template =
            `<div id="container">
                <div id="svgContainer" class="jqx-svg-container"></div>
                <div class="jqx-digital-display-container">
                    <jqx-numeric-text-box id="digitalDisplay"
                                            class="jqx-digital-display"
                                            decimal-separator="[[decimalSeparator]]"
                                            max="[[max]]"
                                            min="[[min]]"
                                            name="[[name]]"
                                            readonly
                                            input-format="[[scaleType]]"
                                            scientific-notation="[[scientificNotation]]"
                                            show-unit="[[showUnit]]"
                                            unit="[[unit]]"
                                            unfocusable
                                            validation="interaction"
                                            word-length="[[wordLength]]">
                    </jqx-numeric-text-box>
                </div>
            </div>`;

        return template;
    }

    /**
     * Called when the element is attached to the DOM.
     */
    attached() {
        const that = this;

        super.attached();

        if (!that.isCompleted) {
            return;
        }

        if (that._trackListener) {
            that._trackListener = new JQX.Utilities.InputEvents(that._track);
            that._trackListener.down(function (event) {
                that._SVGElementDownHandler(event);
            });
        }

        if (that._fillListener) {
            that._fillListener = new JQX.Utilities.InputEvents(that._fill);
            that._fillListener.down(function (event) {
                that._SVGElementDownHandler(event);
            });
        }

        if (that._lineListener) {
            that._lineListener = new JQX.Utilities.InputEvents(that._line);
            that._lineListener.down(function (event) {
                that._SVGElementDownHandler(event);
            });
        }
    }

    /**
     * Called when the element is detached from the DOM.
     */
    detached() {
        const that = this;

        super.detached();

        that._unlisten();
    }

    /**
     * Invoked when an instance of custom element is attached to the DOM for the first time.
     */
    ready() {
        super.ready();
    }

    /**
     * Gets the optimal size of the Gauge.
     */
    getOptimalSize() {
        const that = this;

        if (that._renderingSuspended) {
            return { width: 0, height: 0 };
        }

        if (that.sizeMode === 'circle') {
            return { width: that.offsetWidth, height: that._updateSize(true) };
        }
        else {
            return { width: that.offsetWidth, height: that.offsetHeight };
        }
    }

    /**
     * Sets or gets the value of the Gauge.
     *
     * @param {Number/String} value Optional value to be set to the Gauge. If this parameter is not set, the method gets the value.
     */
    val(value) {
        const that = this;

        if (value !== undefined) {
            // use as value setter
            if (that.mode === 'date') {
                value = JQX.Utilities.DateTime.validateDate(value);
                value = value.getTimeStamp();
            }

            // eslint-disable-next-line
            if (that._numericProcessor.compare(value, that.value)) {
                const oldValue = that.value;

                that._validateValue(value, that.value);

                if (!that._isVisible() || that._renderingSuspended) {
                    that._renderingSuspended = true;
                    return;
                }

                that._animate(oldValue);
            }
        }
        else {
            // use as value getter
            return that._getEventValue();
        }
    }

    /**
     * Applies initial settings to the Gauge element.
     */
    _createElement() {
        const that = this;

        if (that.mode === 'numeric') {
            that._getEventValue = function () {
                return that.value;
            };
        }
        else {
            that._handleDateScale();
            that.digitalDisplay = false;
        }

        //Creating instances of NumericProcessor, NumberRenderer and Draw
        that._numericProcessor = new JQX.Utilities.NumericProcessor(that, 'scaleType');
        that._numberRenderer = new JQX.Utilities.NumberRenderer();
        that._draw = new JQX.Utilities.Draw(that.$.svgContainer);

        if (!that._isVisible()) {
            that._renderingSuspended = true;
            return;
        }

        that._renderingSuspended = false;

        that._setSettingsObject();


        that._wordLengthNumber = that._numericProcessor.getWordLength(that.wordLength);

        that._measurements = {};
        that._validateInitialPropertyValues();
        that._getMeasurements();

        that._setDrawVariables();
        that._getRange();
        that._numericProcessor.getAngleRangeCoefficient();

        if (that.mode === 'numeric' || !that.coerce) {
            that._validateValue();
        }
        else {
            that._coerceInitialDateValue = true;
        }

        that._initTickIntervalHandler();

        that._renderAnalogItems();
        delete that._preventResizeHandler;

        that._setFocusable();

        that._setUpdatePointerMethod();
    }

    /**
     * Invoked when the value of a public property has been changed by the user.
     */
    propertyChangedHandler(key, oldValue, value) {
        function validateMinMax(validateMin, validateMax, oldMin, oldMax) {
            const toValidate = validateMin && validateMax ? 'both' : key;

            that._validateMinMax(toValidate, false, oldValue);

            if (key !== 'logarithmicScale' && key !== 'scaleType' && (key !== 'wordLength' && that[key] === oldValue || key === 'wordLength' && that.min === oldMin && that.max === oldMax)) {
                return;
            }

            that._setDrawVariables();
            that._getRange();
            that._numericProcessor.getAngleRangeCoefficient();
            that._initTickIntervalHandler();
            that._renderAnalogItems();

            that._validateValue(that.value, that.value);
            that._updatePointer();
        }

        const that = this;

        if (!that._isVisible() || that._renderingSuspended) {
            that._renderingSuspended = true;
            return;
        }

        switch (key) {
            case 'analogDisplayType':
                delete that._customSVGElements;

                that._getMeasurements();

                if (value === 'needle' && that.digitalDisplayPosition === 'center') {
                    that.digitalDisplayPosition = 'bottom';
                }
                else if (oldValue === 'needle' && that.digitalDisplayPosition === 'bottom') {
                    that.digitalDisplayPosition = 'center';
                }

                that._renderAnalogItems();
                that._setUpdatePointerMethod();
                break;
            case 'coerce':
                if (value) {
                    const valueBeforeCoercion = that.value;
                    that._validateValue(valueBeforeCoercion);
                    that._updatePointer();
                    that._valueBeforeCoercion = valueBeforeCoercion; // stores value before coercion
                }
                else {
                    if (that._valueBeforeCoercion !== undefined) {
                        that._validateValue(that._valueBeforeCoercion); // restores the value from before coercion
                        that._updatePointer();
                    }
                }
                break;
            case 'customInterval':
                if (value) {
                    if (that._customTicks) {
                        that.customTicks = that._customTicks;
                    }

                    that._numericProcessor.validateCustomTicks();
                }
                else if (that.mode === 'date') {
                    that._customTicks = that.customTicks;
                }

                that._initTickIntervalHandler();
                that._renderAnalogItems();
                that._coerceCustomInterval();
                break;
            case 'customTicks':
                if (that.mode === 'date' && !that.customInterval) {
                    that._customTicks = value;
                    that.customTicks = oldValue;
                    return;
                }

                that._numericProcessor.validateCustomTicks();

                if (that.customInterval) {
                    that._initTickIntervalHandler();
                    that._renderAnalogItems();
                    that._coerceCustomInterval();
                }

                break;
            case 'dateLabelFormatString':
            case 'showUnit':
            case 'unit': that._initTickIntervalHandler();
                that._renderAnalogItems();
                break;
            case 'decimalSeparator':
            case 'scientificNotation':
                if (that.mode === 'date') {
                    return;
                }

                that._initTickIntervalHandler();
                that._renderAnalogItems();
                break;
            case 'digitalDisplay':
            case 'digitalDisplayPosition':
                if (that.mode === 'date') {
                    if (key === 'digitalDisplay') {
                        that.digitalDisplay = false;
                    }

                    return;
                }

                that._updateSize();
                break;
            case 'mechanicalAction':
            case 'messages':
            case 'readonly':
                break;
            case 'disabled':
            case 'unfocusable':
                that._setFocusable();
                break;
            case 'drawNeedle':
                if (that.analogDisplayType !== 'needle') {
                    return;
                }

                if (oldValue === null) {
                    that._draw.removeElement(that._needle);
                }

                if (value !== null) {
                    that._updatePointer();
                }
                else {
                    that._renderAnalogItems();
                    delete that._customSVGElements;
                }

                break;
            case 'endAngle':
            case 'startAngle':
                that._validateAngles();
                that._numericProcessor.getAngleRangeCoefficient();
                that._renderAnalogItems();
                break;
            case 'interval':
                that._numericProcessor.validateInterval(that.interval);
                that._validateValue();
                that._updatePointer();
                break;
            case 'inverted':
            case 'labelFormatFunction':
            case 'showRanges':
                that._renderAnalogItems();
                break;
            case 'labelsVisibility':
                if (oldValue === 'all' && value === 'endPoints' || oldValue === 'endPoints' && value === 'all') {
                    return;
                }
                that._getMeasurements();
                that._renderAnalogItems();
                break;
            case 'logarithmicScale':
                if (that.mode === 'date') {
                    that.logarithmicScale = false;
                    return;
                }

                that._initTickIntervalHandler();
                validateMinMax(true, true);
                break;
            case 'max':
            case 'min':
                if (that.mode === 'date') {
                    delete that._dateInterval;

                    that[key] = JQX.Utilities.DateTime.validateDate(value).getTimeStamp();
                }

                validateMinMax(key === 'min', key === 'max');
                break;
            case 'mode':
                that.mode = oldValue;
                break;
            case 'needlePosition':
                if (that.analogDisplayType === 'needle') {
                    that._updatePointer();
                }
                break;
            case 'precisionDigits':
            case 'significantDigits':
                if (that.mode === 'date') {
                    return;
                }

                if (key === 'precisionDigits' && that.scaleType === 'integer') {
                    that.error(that.localize('noInteger', { elementType: that.nodeName.toLowerCase(), property: key }));
                }

                if (key === 'significantDigits' && that.precisionDigits !== null) {
                    that.precisionDigits = null;
                }
                else if (key === 'precisionDigits' && that.significantDigits !== null) {
                    that.significantDigits = null;
                }

                if (value !== null) {
                    that.$.digitalDisplay.precisionDigits = that.precisionDigits;
                    that.$.digitalDisplay.significantDigits = that.significantDigits;
                }
                that._initTickIntervalHandler();
                that._renderAnalogItems();
                break;
            case 'ranges':
                if (!that.showRanges) {
                    return;
                }

                that._renderAnalogItems();
                break;
            case 'scaleType':
                if (that.mode === 'date') {
                    that.scaleType = 'integer';
                    return;
                }

                that._numericProcessor = new JQX.Utilities.NumericProcessor(that, 'scaleType');

                validateMinMax(true, true);
                break;
            case 'scalePosition':
            case 'ticksPosition':
                that._getMeasurements();
                that._renderAnalogItems();
                break;
            case 'sizeMode':
                that._preventResizeHandler = true;

                if (value === 'circle') {
                    that.$.container.removeAttribute('style');
                    that.style.height = that.offsetWidth + 'px';
                    that._measurements.cachedHeight = that.offsetHeight;
                }
                else {
                    that.$.container.style.height = that.offsetWidth + 'px';
                    that._updateSize();
                }

                break;
            case 'theme':
                super.propertyChangedHandler(key, oldValue, value);
                that._getMeasurements();
                that._renderAnalogItems();
                break;
            case 'ticksVisibility':
                if (oldValue === 'minor' && value === 'major' || oldValue === 'major' && value === 'minor') {
                    return;
                }
                that._getMeasurements();
                that._renderAnalogItems();
                break;
            case 'validation':
                if (value === 'strict') {
                    that._validateValue(that.value, that.value);
                }

                break;
            case 'value': {
                if (that.mode === 'date') {
                    value = JQX.Utilities.DateTime.validateDate(value);
                    value = value.getTimeStamp();
                }

                that._validateValue(value, oldValue);

                const stringValue = value.toString();

                if (that.value.toString() === stringValue) {
                    that._drawValue = that.logarithmicScale ? Math.log10(stringValue).toString() : stringValue;
                }

                that._animate(oldValue);
                break;
            }
            case 'wordLength':
                if (that.mode === 'date') {
                    that.wordLength = 'uint64';
                    return;
                }

                that._wordLengthNumber = that._numericProcessor.getWordLength(that.wordLength);
                if (that.scaleType === 'integer') {
                    validateMinMax(true, true, that.min, that.max);
                }
                break;
        }
    }

    /**
     * Draws the Gauge's analog display.
     */
    _addAnalogDisplay() {
        const that = this,
            measurements = that._measurements,
            radius = measurements.radius,
            draw = that._draw;

        if (that.analogDisplayType === 'needle') {
            // needle
            that._drawNeedle(false);
            // central circle
            const centralCircleRadius = (measurements.needleWidth + 5) / 2;

            that._centralCircle = draw.circle(radius, radius, centralCircleRadius, { 'class': 'jqx-needle-central-circle' });
            that._minCoordinates.push(radius - centralCircleRadius);
            that._maxCoordinates.push(radius + centralCircleRadius);
        }
        else {
            const distance = radius - that._distance.trackDistance - measurements.trackBorderWidth / 2 - 1;
            // track
            that._track = draw.pieslice(radius, radius, distance - measurements.trackWidth, distance, that.startAngle, that.endAngle, 0, { 'class': 'jqx-track' });
            that._trackListener = new JQX.Utilities.InputEvents(that._track);
            that._trackListener.down(function (event) {
                that._SVGElementDownHandler(event);
            });
        }
    }

    /**
     * Calculates the tick drawing distance.
     */
    _calculateTickAndLabelDistance() {
        const that = this,
            measurements = that._measurements;

        if (that.scalePosition === 'none') {
            that._plotLabels = false;
            that._plotTicks = false;

            measurements.innerRadius = measurements.radius;

            return { majorTickDistance: 0, minorTickDistance: 0, labelDistance: 0, needleDistance: 0, trackDistance: 0 };
        }

        const labelsSize = that._tickIntervalHandler.labelsSize,
            labelSizeCoefficient = that._largestLabelSize || Math.max(labelsSize.minLabelSize, labelsSize.minLabelOtherSize, labelsSize.maxLabelSize, labelsSize.maxLabelOtherSize);
        let majorTickDistance = 1,
            minorTickDistance,
            labelDistance,
            needleDistance,
            trackDistance = 0;

        that._largestLabelSize = labelSizeCoefficient;

        if (that.scalePosition === 'outside') {
            majorTickDistance = labelSizeCoefficient;
            minorTickDistance = majorTickDistance + measurements.majorTickSize - measurements.minorTickSize;
            labelDistance = 0;
        }

        if (that.analogDisplayType === 'needle') {
            if (that.scalePosition === 'outside') {
                needleDistance = majorTickDistance + measurements.majorTickSize;
            }
            else {
                needleDistance = majorTickDistance + measurements.majorTickSize + labelSizeCoefficient;
            }

            if (that.ticksVisibility === 'none') {
                labelDistance = 0;
                needleDistance -= measurements.majorTickSize;
            }
            if (that.labelsVisibility === 'none') {
                needleDistance -= labelSizeCoefficient;
                if (that.scalePosition === 'outside') {
                    majorTickDistance -= labelSizeCoefficient;
                    minorTickDistance -= labelSizeCoefficient;
                }
            }
        }
        else {
            if (that.labelsVisibility === 'none' && that.ticksVisibility === 'none') {
                trackDistance = 0;
            }
            else {
                if (that.scalePosition === 'outside') {
                    if (that.ticksPosition === 'scale') {
                        if (that.labelsVisibility === 'none') {
                            majorTickDistance = 1;
                            minorTickDistance = 1 + measurements.majorTickSize - measurements.minorTickSize;
                        }
                        if (that.ticksVisibility !== 'none') {
                            trackDistance = majorTickDistance + measurements.majorTickSize + 2;
                        }
                        else {
                            trackDistance = labelSizeCoefficient;
                        }
                    }
                    else {
                        if (that.labelsVisibility !== 'none') {
                            minorTickDistance = minorTickDistance - (measurements.trackWidth + measurements.trackBorderWidth) / 4;
                            trackDistance = majorTickDistance - 1;
                        }
                        else {
                            majorTickDistance = 1;
                            minorTickDistance = (measurements.trackWidth + measurements.trackBorderWidth) / 4 + 1;
                            trackDistance = 0;
                        }
                    }
                }
                else {
                    if (that.ticksPosition === 'scale') {
                        majorTickDistance = measurements.trackWidth + 1.5 * measurements.trackBorderWidth + 2;
                        if (that.ticksVisibility === 'none') {
                            labelDistance = majorTickDistance;
                        }
                    }
                    else {
                        minorTickDistance = (measurements.trackWidth + measurements.trackBorderWidth) / 4 + 1;
                    }
                }
            }
        }

        if (minorTickDistance === undefined) {
            minorTickDistance = majorTickDistance;
        }

        if (labelDistance === undefined) {
            labelDistance = majorTickDistance + measurements.majorTickSize;
        }

        measurements.innerRadius = measurements.radius - labelDistance;

        delete that._plotLabels;
        delete that._plotTicks;
        delete that._equalToHalfRadius;
        if (that.scalePosition === 'inside') {
            if (measurements.innerRadius < labelSizeCoefficient) {
                that._plotLabels = false;

                if (that.ticksPosition === 'scale') {
                    if (that.analogDisplayType !== 'needle' && measurements.innerRadius < measurements.majorTickSize) {
                        that._plotTicks = false;
                    }
                }
                else {
                    that._equalToHalfRadius = true;
                    measurements.innerRadius = measurements.radius / 2;
                }
            }
        }
        else if (measurements.radius - trackDistance - measurements.trackBorderWidth < measurements.trackWidth) {
            measurements.trackWidth = measurements.radius - trackDistance - measurements.trackBorderWidth;
            measurements.lineSize = measurements.trackWidth + measurements.trackBorderWidth;
            if (that.ticksPosition === 'track') {
                measurements.majorTickSize = measurements.lineSize;
                measurements.minorTickSize = measurements.majorTickSize / 2;
                minorTickDistance = majorTickDistance + (measurements.majorTickSize - measurements.minorTickSize) / 2;
            }
        }

        return { majorTickDistance: majorTickDistance, minorTickDistance: minorTickDistance, labelDistance: labelDistance, needleDistance: needleDistance, trackDistance: trackDistance };
    }

    /**
     * Calculates the tank's major and minor ticks intervals.
     */
    _calculateTickInterval() {
        const that = this,
            intervals = that._tickIntervalHandler.getInterval('radial', that._drawMin, that._drawMax, that.$.container, that.logarithmicScale);

        if (intervals.major !== that._majorTicksInterval) {
            that._intervalHasChanged = true;
            that._majorTicksInterval = intervals.major;
        }
        else {
            that._intervalHasChanged = true;
        }

        that._minorTicksInterval = intervals.minor;

        if (that.mode === 'date') {
            that._calculateDateInterval(intervals.major);
        }
    }

    /**
     * Computes the points of a needle (needlePosition: 'center').
     */
    _computeNeedlePointsCenter(pointerWidth, angle) {
        const that = this,
            measurements = that._measurements,
            innerRadius = measurements.innerRadius,
            radius = measurements.radius,
            sin = Math.sin(angle),
            cos = Math.cos(angle);
        let pointerLength;

        if (that.scalePosition === 'inside') {
            pointerLength = (innerRadius - that._largestLabelSize) * 0.9;
        }
        else {
            pointerLength = (innerRadius - that._distance.needleDistance) * 0.9;
        }

        const x = radius + pointerLength * sin,
            y = radius + pointerLength * cos,
            startX1 = radius + pointerWidth * cos,
            startY1 = radius - pointerWidth * sin,
            startX2 = radius - pointerWidth * cos,
            startY2 = radius + pointerWidth * sin,

            points = 'M ' + startX1 + ',' + startY1 + ' L ' + startX2 + ',' + startY2 + ' L ' + x + ',' + y + ' Z';

        return points;
    }

    /**
     * Computes the points of a needle (needlePosition: 'edge').
     */
    _computeNeedlePointsEdge(pointerWidth, angle, pointerLength) {
        const that = this,
            radius = that._measurements.radius,
            distance = radius - that._distance.needleDistance,
            distanceMinusPointerLength = distance - pointerLength,
            sin = Math.sin(angle),
            cos = Math.cos(angle),
            hPointX = radius + distanceMinusPointerLength * sin,
            hPointY = radius + distanceMinusPointerLength * cos,
            startPointX1 = hPointX + pointerWidth * cos,
            startPointY1 = hPointY - pointerWidth * sin,
            startPointX2 = hPointX - pointerWidth * cos,
            startPointY2 = hPointY + pointerWidth * sin,
            endPointX = radius + distance * sin,
            endPointY = radius + distance * cos,

            points = 'M ' + startPointX1 + ',' + startPointY1 + ' L ' + startPointX2 + ',' + startPointY2 + ' L ' + endPointX + ',' + endPointY + ' Z';

        return points;
    }

    /**
     * Document (mouse)move event handler.
     */
    _documentMoveHandler(event) {
        if (!this._dragging) {
            return;
        }

        const that = this,
            angle = that._getAngleByCoordinate(event.pageX, event.pageY),
            quadrant = that._getQuadrant(angle),
            rotationDirection = that._getRotationDirection();

        if (that._normalizedStartAngle === that.endAngle) {
            let normalizedReferentAngle;

            if (!that.inverted) {
                if (that._lockCW && rotationDirection === 'ccw') {
                    normalizedReferentAngle = that.endAngle;
                    that._unlockRotation('_lockCW', angle, quadrant, normalizedReferentAngle, { firstCondition: angle > normalizedReferentAngle, secondCondition: angle < normalizedReferentAngle });
                }
                else if (that._lockCCW && rotationDirection === 'cw') {
                    normalizedReferentAngle = that._normalizedStartAngle;
                    that._unlockRotation('_lockCCW', angle, quadrant, normalizedReferentAngle, { firstCondition: angle < normalizedReferentAngle, secondCondition: angle > normalizedReferentAngle });
                }
            }
            else {
                if (that._lockCW && rotationDirection === 'cw') {
                    normalizedReferentAngle = that._normalizedStartAngle;
                    that._unlockRotation('_lockCW', angle, quadrant, normalizedReferentAngle, { firstCondition: angle < normalizedReferentAngle, secondCondition: angle > normalizedReferentAngle });
                }
                else if (that._lockCCW && rotationDirection === 'ccw') {
                    normalizedReferentAngle = that.endAngle;
                    that._unlockRotation('_lockCCW', angle, quadrant, normalizedReferentAngle, { firstCondition: angle > normalizedReferentAngle, secondCondition: angle < normalizedReferentAngle });
                }
            }
        }
        else {
            if (that._lockCW && rotationDirection === 'ccw' && !that._outsideRange && that._numericProcessor._getAngleDifference(angle, that._normalizedStartAngle) < 10) {
                that._lockCW = false;
            }
            else if (that._lockCCW && rotationDirection === 'cw' && !that._outsideRange && that._numericProcessor._getAngleDifference(angle, that.endAngle) < 10) {
                that._lockCCW = false;
            }
        }

        that._angle = angle;
        that._quadrant = quadrant;

        if (event.originalEvent) {
            event.originalEvent.stopPropagation();
            event.originalEvent.preventDefault();
        }

        if (that._lockCW || that._lockCCW) {
            return;
        }

        let newValue = that._numericProcessor.getValueByAngle(angle);

        if (that._normalizedStartAngle === that.endAngle) {
            const lockedValue = that._numericProcessor.lockRotation(rotationDirection === 'cw' && !that.inverted || rotationDirection === 'ccw' && that.inverted, newValue);

            if (lockedValue !== undefined) {
                newValue = lockedValue;
            }
        }
        else {
            if (rotationDirection === 'ccw' && that._outsideEnd) {
                that._lockCCW = true;
            }
            else if (rotationDirection === 'cw' && that._outsideStart) {
                that._lockCW = true;
            }
        }

        if (newValue !== undefined && that._numericProcessor.compare(newValue, that.value)) {
            cancelAnimationFrame(that._animationFrameId);
            that._updatePointer(newValue);

            if (that.mechanicalAction !== 'switchWhenReleased') {
                that._numericProcessor.updateGaugeValue(newValue);
            }
            else {
                that._valueAtMoveEnd = newValue;
            }
        }
    }

    /**
     * Gauge (mouse)up event handler.
     */
    _documentUpHandler() {
        const that = this;

        if (that._dragging) {
            that._lockCW = false;
            that._lockCCW = false;

            that._dragging = false;
            that.removeAttribute('dragged');

            if (that.mechanicalAction !== 'switchWhileDragging') {
                const newValue = that.mechanicalAction === 'switchUntilReleased' ? that._valueAtDragStart : that._valueAtMoveEnd;

                if (that._numericProcessor.compare(newValue, that.value)) {
                    if (that.mechanicalAction === 'switchUntilReleased') {
                        that._animate(that.value, newValue);
                    }

                    that._numericProcessor.updateGaugeValue(newValue);
                }
            }
        }
    }

    /**
     * Gauge (mouse)down event handler.
     */
    _downHandler(event, targetIsTrack) {
        const that = this,
            target = that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target;

        if (that.analogDisplayType !== 'needle' && !targetIsTrack || that.disabled || that.readonly ||
            (that.enableShadowDOM ? target.getRootNode().host === that.$.digitalDisplay : that.$.digitalDisplay.contains(target)) ||
            (!JQX.Utilities.Core.isMobile && (('buttons' in event && event.buttons !== 1) || event.which !== 1))) {
            event.stopPropagation();
            return;
        }

        const x = event.pageX,
            y = event.pageY;

        that._measurements.center = that._getCenterCoordinates();

        if (that.analogDisplayType === 'needle') {
            const distanceFromCenter = Math.sqrt(Math.pow(that._measurements.center.x - x, 2) + Math.pow(that._measurements.center.y - y, 2));
            if (distanceFromCenter > that._measurements.radius) {
                event.stopPropagation();
                return;
            }
        }

        if (that.mechanicalAction === 'switchUntilReleased') {
            that._valueAtDragStart = that.value;
        }

        that._angle = that._getAngleByCoordinate(x, y);
        that._quadrant = that._getQuadrant(that._angle);

        const newValue = that._numericProcessor.getValueByAngle(that._angle);

        if (newValue !== undefined && that._numericProcessor.compare(newValue, that.value)) {
            that._animate(that.value, newValue);

            if (that.mechanicalAction !== 'switchWhenReleased') {
                that._numericProcessor.updateGaugeValue(newValue);
            }
            else {
                that._valueAtMoveEnd = newValue;
            }
        }

        that._dragging = true;
        that.setAttribute('dragged', '');
    }

    /**
     * Animates pointer.
     */
    _animate(oldValue, newValue) {
        const that = this,
            logarithmicScale = that.logarithmicScale,
            totalIterations = Math.max(1, Math.round(that.animationDuration / 15));

        cancelAnimationFrame(that._animationFrameId);

        if (!that.hasAnimation || totalIterations === 1) {
            that._updatePointer(newValue);
            return;
        }

        const numericProcessor = that._numericProcessor;
        let i = 1,
            nextValue, getNextValue, oldDrawValue, newDrawValue;


        if (newValue === undefined) {
            newValue = that.value;
        }

        oldValue = parseFloat(numericProcessor.validate(numericProcessor.createDescriptor(oldValue), that._minObject, that._maxObject));
        newValue = parseFloat(numericProcessor.validate(numericProcessor.createDescriptor(newValue), that._minObject, that._maxObject));

        if (logarithmicScale) {
            oldDrawValue = Math.log10(oldValue);
            newDrawValue = Math.log10(newValue);
        }
        else {
            oldDrawValue = oldValue;
            newDrawValue = newValue;
        }

        const total = Math.abs(newDrawValue - oldDrawValue);

        if (newValue > oldValue) {
            getNextValue = function () {
                return Math.min(JQX.Utilities.Animation.Easings.easeInOutSine(i, oldDrawValue, total, totalIterations), newDrawValue);
            }
        }
        else {
            getNextValue = function () {
                return Math.max(2 * oldDrawValue - JQX.Utilities.Animation.Easings.easeInOutSine(i, oldDrawValue, total, totalIterations), newDrawValue);
            }
        }

        function getNextDrawValue() {
            nextValue = getNextValue();

            if (logarithmicScale) {
                nextValue = Math.pow(10, nextValue);
            }
        }

        function animate() {
            i++;

            if (i === totalIterations) {
                nextValue = newValue;
                that._updatePointer(nextValue);
                return;
            }

            that._updatePointer(nextValue);
            getNextDrawValue();
            that._animationFrameId = requestAnimationFrame(animate);
        }

        getNextDrawValue();
        that._animationFrameId = requestAnimationFrame(animate);
    }

    /**
     * Draws/updates the fill or line.
     */
    _drawFill(update, value) {
        const that = this;

        if (that.analogDisplayType === 'needle') {
            return;
        }

        if (value === undefined) {
            value = that._number;
        }

        const measurements = that._measurements,
            radius = measurements.radius,
            distance = radius - that._distance.trackDistance - measurements.trackBorderWidth / 2 - 1;

        if (that.analogDisplayType === 'fill') {
            const angle = that._numericProcessor.getAngleByValue(value, true, true);
            let startAngle, endAngle;

            if (!that.inverted) {
                startAngle = angle;
                endAngle = that.endAngle;
            }
            else {
                startAngle = that.startAngle;
                endAngle = angle;
            }

            if (update) {
                that._fill.setAttribute('d', that._draw.pieSlicePath(radius, radius, distance - measurements.trackWidth, distance, startAngle, endAngle, 0));
            }
            else {
                that._fill = that._draw.pieslice(radius, radius, distance - measurements.trackWidth, distance, startAngle, endAngle, 0, { 'class': 'jqx-value' });
                that._fillListener = new JQX.Utilities.InputEvents(that._fill);
                that._fillListener.down(function (event) {
                    that._SVGElementDownHandler(event);
                });
            }
        }
        else {
            const width = distance + measurements.trackBorderWidth / 2,
                innerWidth = width - measurements.lineSize,
                angle = that._numericProcessor.getAngleByValue(value),
                angleSin = Math.sin(angle),
                angleCos = Math.cos(angle),
                x1 = radius + width * angleSin,
                y1 = radius + width * angleCos,
                x2 = radius + innerWidth * angleSin,
                y2 = radius + innerWidth * angleCos;

            if (update) {
                that._line.setAttribute('x1', x1);
                that._line.setAttribute('y1', y1);
                that._line.setAttribute('x2', x2);
                that._line.setAttribute('y2', y2);
            }
            else {
                that._line = that._draw.line(x1, y1, x2, y2, { 'class': 'jqx-line' });
                that._lineListener = new JQX.Utilities.InputEvents(that._line);
                that._lineListener.down(function (event) {
                    that._SVGElementDownHandler(event);
                });
            }
        }
    }

    /**
     * Draws a label.
     */
    _drawLabel(angle, value, distance, middle) {
        const that = this,
            measurements = that._measurements,
            r = measurements.radius,
            stylingObj = {
                'class': 'jqx-label' + (middle !== false ? ' jqx-label-middle' : ''),
                'font-size': measurements.fontSize,
                'font-family': measurements.fontFamily,
                'font-weight': measurements.fontWeight,
                'font-style': measurements.fontStyle
            };

        value = that._formatLabel(value.toString(), false);

        const textSize = that._draw.measureText(value, 0, stylingObj),
            w = r - distance - that._largestLabelSize / 2,
            x = Math.round(r + w * Math.sin(angle)) - textSize.width / 2,
            y = Math.round(r + w * Math.cos(angle)) - textSize.height / 2,

            label = that._draw.text(value, x, y, textSize.width, textSize.height, 0, stylingObj);

        that._minCoordinates.push(y);
        that._maxCoordinates.push(y + label.getBBox().height);
    }

    /**
     * Draws/updates the needle.
     */
    _drawNeedle(update, value) {
        const that = this,
            measurements = that._measurements;

        if (value === undefined) {
            value = that._number;
        }

        const angle = that._numericProcessor.getAngleByValue(value);

        if (!that.drawNeedle) {
            let points;

            if (that.needlePosition === 'center') {
                points = that._computeNeedlePointsCenter(measurements.needleWidth / 2, angle);
            }
            else {
                points = that._computeNeedlePointsEdge(measurements.needleWidth / 2, angle, measurements.needleLength);
            }

            if (update) {
                that._needle.setAttribute('d', points);
            }
            else {
                that._needle = that._draw.path(points, { 'class': 'jqx-needle' });
            }
        }
        else {
            that._customSVGElements = that.drawNeedle(that, that._draw, measurements.radius, angle, that._distance.needleDistance);
            if (that._customSVGElements) {
                const parent = that._customSVGElements[0].parentElement || that._customSVGElements[0].parentNode;
                for (let i = 0; i < that._customSVGElements.length; i++) {
                    parent.insertBefore(that._customSVGElements[i], that._centralCircle);
                }
            }
        }
    }

    /**
     * Draws ranges.
     */
    _drawRanges() {
        const that = this,
            numericProcessor = that._numericProcessor,
            ranges = that.ranges;

        if (!that.showRanges || ranges.length === 0) {
            return;
        }

        const measurements = that._measurements,
            radius = measurements.radius;
        let distance, rangeSize, startValue, endValue;

        if (that.analogDisplayType === 'needle') {
            rangeSize = measurements.rangeSize;
            if (that.scalePosition === 'inside') {
                distance = radius - 1;
            }
            else {
                distance = radius - that._distance.needleDistance - 2;
                if (that.labelsVisibility === 'none' && that.ticksVisibility === 'none') {
                    distance += 1;
                }
            }
        }
        else {
            distance = radius - that._distance.trackDistance - measurements.trackBorderWidth / 2 - 1;
            rangeSize = measurements.trackWidth;
        }

        if (!that.inverted) {
            startValue = 'startValue';
            endValue = 'endValue';
        }
        else {
            startValue = 'endValue';
            endValue = 'startValue';
        }

        for (let i = 0; i < ranges.length; i += 1) {
            let currentRange = ranges[i],
                validStartValue = numericProcessor.validateColorRange(currentRange[startValue]),
                validEndValue = numericProcessor.validateColorRange(currentRange[endValue]);

            const range = that._draw.pieslice(radius, radius, distance - rangeSize, distance, numericProcessor.getAngleByValue(validEndValue, true, true), numericProcessor.getAngleByValue(validStartValue, true, true), 0, { 'class': 'jqx-range ' + currentRange.className });

            that._ranges.push(range);
        }
    }

    /**
     * Draws a tick.
     */
    _drawTick(angle, width, type) {
        const that = this,
            measurements = that._measurements,
            r = measurements.radius;

        let className = 'jqx-tick',
            size;

        if (type === 'major') {
            size = measurements.majorTickSize;
        }
        else {
            size = measurements.minorTickSize;
            className += ' jqx-tick-minor';
        }

        const innerWidth = width - size,
            x1 = r + width * Math.sin(angle),
            y1 = r + width * Math.cos(angle),
            x2 = r + innerWidth * Math.sin(angle),
            y2 = r + innerWidth * Math.cos(angle);
        that._draw.line(x1, y1, x2, y2, { 'class': className });

        that._minCoordinates.push(Math.min(y1, y2));
        that._maxCoordinates.push(Math.max(y1, y2));
    }

    /**
     * Returns the angle equivalent of coordinates.
     */
    _getAngleByCoordinate(x, y) {
        function isInRange(from, to, angle) {
            while (to < from) to += 360;

            while (angle < from) angle += 360;

            return angle >= from && angle <= to;
        }

        const that = this,
            center = that._measurements.center,
            angleRadians = Math.atan2(y - center.y, x - center.x);
        let angleDeg = -1 * angleRadians * 180 / Math.PI;

        if (angleDeg < 0) {
            angleDeg += 360;
        }

        that._actualAngle = angleDeg;

        if (that._normalizedStartAngle !== that.endAngle && !isInRange(that._normalizedStartAngle, that.endAngle, angleDeg)) {
            // coordinates are outside the range
            if (that._numericProcessor._getAngleDifference(angleDeg, that._normalizedStartAngle) <=
                that._numericProcessor._getAngleDifference(angleDeg, that.endAngle)) {
                angleDeg = that._normalizedStartAngle;
                that._outsideStart = true;
                that._outsideEnd = false;
            }
            else {
                angleDeg = that.endAngle;
                that._outsideEnd = true;
                that._outsideStart = false;
            }

            that._outsideRange = true;
        }
        else {
            that._outsideRange = false;
            that._outsideStart = false;
            that._outsideEnd = false;
        }

        return angleDeg;
    }

    /**
     * Returns the coordinates of the Gauge's center.
     */
    _getCenterCoordinates() {
        const that = this,
            offset = that.$.container.getBoundingClientRect(),
            radius = that._measurements.radius,
            scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft,
            scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
        return { x: offset.left + scrollLeft + radius, y: offset.top + scrollTop + radius };
    }

    /**
     * Gets inline "fill"/"stroke" set to _track, _fill or _line.
     */
    _getInlineColors() {
        const that = this;
        let trackColor = '',
            fillColor = '',
            lineColor = '';

        if (that._track) {
            trackColor = that._track.style.fill;
        }

        if (that._fill) {
            fillColor = that._fill.style.fill;
        }

        if (that._line) {
            lineColor = that._line.style.stroke;
        }

        return [trackColor, fillColor, lineColor];
    }

    /**
     * Measures some elements of the Gauge and stores the results.
     */
    _getMeasurements() {
        const that = this;

        if (!that._isVisible() || that._renderingSuspended) {
            that._renderingSuspended = true;
            return;
        }

        const measurements = that._measurements;

        measurements.cachedWidth = that.offsetWidth;
        measurements.cachedHeight = that.offsetHeight;

        measurements.radius = measurements.cachedWidth / 2;

        const measureElement = document.createElement('div');

        if (that.enableShadowDOM) {
            that.shadowRoot.appendChild(measureElement);
        }
        else {
            that.appendChild(measureElement);
        }

        // ticks
        measureElement.className = 'jqx-tick';
        measurements.majorTickSize = measureElement.offsetWidth;
        measureElement.className += ' jqx-tick-minor';
        measurements.minorTickSize = measureElement.offsetWidth;

        // labels
        measureElement.className = 'jqx-label';
        const measureElementStyle = window.getComputedStyle(measureElement);
        measurements.fontSize = measureElementStyle.fontSize;
        measurements.fontFamily = measureElementStyle.fontFamily;
        measurements.fontWeight = measureElementStyle.fontWeight;
        measurements.fontStyle = measureElementStyle.fontStyle;

        measurements.trackWidth = 0;
        measurements.trackBorderWidth = 0;

        if (that.analogDisplayType === 'needle') {
            // needle
            measureElement.className = 'jqx-needle';
            measurements.needleWidth = measureElement.offsetWidth;
            measurements.needleLength = measureElement.offsetHeight;

            // ranges
            measureElement.className = 'jqx-range';
            measurements.rangeSize = measureElement.offsetWidth;
        }
        else { // 'fill' and 'line' case
            // track
            measureElement.className = 'jqx-track';
            measurements.trackBorderWidth = parseFloat(measureElementStyle.strokeWidth);
            measurements.trackWidth = Math.min(measureElement.offsetWidth, measurements.radius - measurements.trackBorderWidth)
            measurements.lineSize = measurements.trackWidth + measurements.trackBorderWidth;

            if (that.ticksPosition === 'track') {
                measurements.majorTickSize = measurements.lineSize;
                measurements.minorTickSize = measurements.majorTickSize / 2;
            }
        }

        if (that.enableShadowDOM) {
            that.shadowRoot.removeChild(measureElement);
        }
        else {
            that.removeChild(measureElement);
        }
    }

    /**
     * Returns the quadrant of an angle.
     */
    _getQuadrant(angle) {
        if (angle > 270) {
            return 4;
        }
        else if (angle > 180) {
            return 3;
        }
        else if (angle > 90) {
            return 2;
        }
        else {
            return 1;
        }
    }

    /**
     * Returns the rotation direction.
     */
    _getRotationDirection() {
        const that = this,
            quadrant = that._getQuadrant(that._actualAngle);

        if ((that._actualAngle < that._angle && (quadrant !== 1 || that._quadrant !== 4)) || (that._actualAngle > that._angle && quadrant === 4 && that._quadrant === 1)) {
            return 'cw';
        }
        else {
            return 'ccw';
        }
    }

    /**
     * Creates a new TickIntervalHandler instance.
     */
    _initTickIntervalHandler() {
        const that = this;

        if (!that._isVisible() || that._renderingSuspended) {
            that._renderingSuspended = true;
            return;
        }

        const minLabel = that._formatLabel(that.min, false),
            maxLabel = that._formatLabel(that.max, false);

        that._tickIntervalHandler = new JQX.Utilities.TickIntervalHandler(that, minLabel, maxLabel, 'jqx-label', that._settings.size, that.scaleType === 'integer', that.logarithmicScale);
    }

    /**
     * Gauge keydown event handler.
     */
    _keydownHandler(event) {
        const that = this,
            oldValue = that._getEventValue(),
            stringValue = that._number.toString();

        if (that.mode === 'numeric') {
            if (that.value.toString() !== stringValue) {
                that.value = stringValue;
                that.$.digitalDisplay.value = stringValue;
            }

            super._keydownHandler(event);

            if (that.value.toString() !== oldValue) {
                that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValue });
            }
        }
        else {
            if (that.value.toString() !== stringValue) {
                that._valueDate = JQX.Utilities.DateTime.fromFullTimeStamp(stringValue);
                that.value = that._number;
                that.$.digitalDisplay.$.input.value = that._valueDate;
            }

            super._keydownHandler(event);

            if (that._valueDate.compare(oldValue) !== 0) {
                that.$.fireEvent('change', { 'value': that._getEventValue(), 'oldValue': oldValue });
            }
        }
    }

    /**
     * Normalizes the value of an angle.
     */
    _normalizeAngle(angle) {
        angle = angle % 360;

        if (angle < 0) {
            angle += 360;
        }

        return angle;
    }

    /**
     * Renders the analog display, ticks and labels in the correct order
     */
    _renderAnalogItems(distanceCalculation) {
        const that = this;

        if (!that._isVisible() || that._renderingSuspended) {
            that._renderingSuspended = true;
            return;
        }

        const colors = that._getInlineColors();

        that._unlisten();
        that._draw.clear();
        delete that._needle;
        delete that._centralCircle;
        delete that._track;
        delete that._trackListener;
        delete that._fill;
        delete that._fillListener;
        delete that._line;
        delete that._lineListener;
        that._ranges = [];
        that._minCoordinates = [];
        that._maxCoordinates = [];

        if (distanceCalculation !== false) {
            delete that._largestLabelSize;
            that._distance = that._calculateTickAndLabelDistance();
        }

        if (that._plotTicks !== false || that._plotLabels !== false) {
            that._calculateTickInterval();

            const cachedLabelsSize = that._cachedLabelsSize,
                alternativeLargestLabelSize = Math.max(cachedLabelsSize.minLabelSize, cachedLabelsSize.minLabelOtherSize, cachedLabelsSize.maxLabelSize, cachedLabelsSize.maxLabelOtherSize);
            if (distanceCalculation !== false && that._largestLabelSize !== alternativeLargestLabelSize) {
                that._largestLabelSize = alternativeLargestLabelSize;

                that._distance = that._calculateTickAndLabelDistance();
                that._calculateTickInterval();
            }
        }

        if (that._coerceInitialDateValue) {
            that._validateValue();
            delete that._coerceInitialDateValue;
        }

        that._drawRanges();
        that._addAnalogDisplay();

        if (that.ticksVisibility !== 'none' && that._plotTicks !== false || that.labelsVisibility !== 'none' && that._plotLabels !== false) {
            if (!(that.customInterval || that._dateInterval)) {
                that._numericProcessor.addGaugeTicksAndLabels();
            }
            else {
                that._numericProcessor.addGaugeCustomTicks();
            }
        }

        that._drawFill(false);

        that._updateSize();

        that._restoreInlineColors(colors[0], colors[1], colors[2]);
    }

    /**
     * Gauge resize event handler. Ensures the Gauge's bounding box always has the correct proportions.
     */
    _resizeHandler() {
        const that = this;

        if (that._preventResizeHandler) {
            delete that._preventResizeHandler;
            return;
        }

        if (!that._isVisible()) {
            that._renderingSuspended = true;
            return;
        }
        else if (that._renderingSuspended) {
            that._createElement();
            return;
        }

        const measurements = that._measurements;

        if (that._renderingSuspended || measurements.cachedWidth === that.offsetWidth && measurements.cachedHeight === that.offsetHeight) {
            return;
        }

        if (that.sizeMode === 'circle') {
            if (that.offsetWidth !== that.offsetHeight) {
                if (measurements.cachedWidth !== that.offsetWidth) {
                    that.style.height = that.offsetWidth + 'px';
                    that._preventResizeHandler = true;
                }
                else if (measurements.cachedHeight !== that.offsetHeight) {
                    that.style.width = that.offsetHeight + 'px';
                    that._preventResizeHandler = true;
                }
            }
        }
        else {
            if (measurements.cachedHeight !== that.offsetHeight && measurements.cachedWidth === that.offsetWidth) {
                that.style.height = measurements.cachedHeight + 'px';
                that._preventResizeHandler = true;
                return;
            }

            that.$.container.style.height = that.offsetWidth + 'px';
        }

        measurements.cachedWidth = that.offsetWidth;
        measurements.cachedHeight = that.offsetHeight;
        measurements.radius = measurements.cachedWidth / 2;

        if (!that._equalToHalfRadius) {
            measurements.innerRadius = measurements.radius - that._distance.labelDistance;
        }
        else {
            measurements.innerRadius = measurements.radius / 2;
        }

        that._renderAnalogItems(false);
    }

    /**
     * Restores inline "fill"/"stroke" previously set to _track, _fill or _line.
     */
    _restoreInlineColors(trackColor, fillColor, lineColor) {
        const that = this;

        if (that._track && trackColor !== '') {
            that._track.style.fill = trackColor;
        }

        if (that._fill && fillColor !== '') {
            that._fill.style.fill = fillColor;
        }

        if (that._line && lineColor !== '') {
            that._line.style.stroke = lineColor;
        }
    }

    /**
     * Document select start handler.
     */
    _selectStartHandler(event) {
        if (this._dragging) {
            event.preventDefault();
        }
    }

    /**
     * Specifies the behaviour of the method "_updatePointer".
     */
    _setUpdatePointerMethod() {
        const that = this;

        if (that.analogDisplayType === 'needle') {
            that._updatePointer = function (value) {
                if (that._customSVGElements) {
                    for (let i = 0; i < that._customSVGElements.length; i++) {
                        that._draw.removeElement(that._customSVGElements[i]);
                    }
                }

                that._drawNeedle(true, value);
            }
        }
        else {
            that._updatePointer = function (value) {
                that._drawFill(true, value);
            }
        }
    }

    /**
     * styleChanged event handler.
     */
    _styleChangedHandler(event) {
        const that = this;

        if (event.detail.styleProperties && event.detail.styleProperties['min-height']) {
            return;
        }

        if (!that._isVisible()) {
            that._renderingSuspended = true;
            return;
        }
        else if (that._renderingSuspended) {
            that._createElement();
            return;
        }

        that._getMeasurements();
        that._initTickIntervalHandler();
        that._renderAnalogItems();
    }

    /**
     * (Mouse)down event handler for the track, fill and line SVG elements.
     */
    _SVGElementDownHandler(event) {
        const that = this,
            oldContext = that.context;

        that.context = that;
        that._downHandler(event, true);
        that.context = oldContext;
    }

    /**
     * Unlocks rotation of the analog display.
     */
    _unlockRotation(lockName, angle, quadrant, referentAngle, conditions) {
        const that = this,
            firstCondition = conditions.firstCondition,
            secondCondition = conditions.secondCondition,
            angleQuadrant = that._getQuadrant(referentAngle);

        if (((firstCondition && (quadrant !== 4 || angleQuadrant !== 1)) ||
            (secondCondition && (quadrant === 4 && angleQuadrant === 1))) &&
            that._numericProcessor._getAngleDifference(angle, referentAngle) < 10) {
            that[lockName] = false;
        }
    }

    /**
     * Updates the size of the Gauge when "sizeMode" is 'circle'.
     */
    _updateSize(getter) {
        const that = this;

        if (that.sizeMode === 'circle' && getter === undefined) {
            return;
        }

        const minCoordinates = that._minCoordinates,
            maxCoordinates = that._maxCoordinates;
        let top = minCoordinates[0],
            bottom = maxCoordinates[0];

        for (let i = 1; i < minCoordinates.length; i++) {
            top = Math.min(top, minCoordinates[i]);
        }

        for (let i = 1; i < maxCoordinates.length; i++) {
            bottom = Math.max(bottom, maxCoordinates[i]);
        }

        const gaugeClientRect = that.getBoundingClientRect();

        if (that.digitalDisplay) {
            const digitalDisplayClientRect = that.$.digitalDisplay.getBoundingClientRect();

            top = Math.min(top, digitalDisplayClientRect.top - gaugeClientRect.top);
            bottom = Math.max(bottom, digitalDisplayClientRect.bottom - gaugeClientRect.top);
        }

        if (that.analogDisplayType !== 'needle') {
            const trackBBox = that._track.getBBox();

            top = Math.min(top, trackBBox.y);
            bottom = Math.max(bottom, trackBBox.y + trackBBox.height);
        }

        for (let i = 0; i < that._ranges.length; i++) {
            const rangeBBox = that._ranges[i].getBBox();

            top = Math.min(top, rangeBBox.y - gaugeClientRect.top);
            bottom = Math.max(bottom, rangeBBox.y + rangeBBox.height - gaugeClientRect.top);
        }

        top -= 2;

        const newHeight = bottom - top;

        if (getter === undefined) {
            that._preventResizeHandler = true;

            that.style.height = newHeight + 'px';
            that.$.container.style.marginTop = -1 * top + 'px';

            that._measurements.cachedHeight = newHeight;
        }
        else {
            return Math.round(newHeight);
        }
    }

    /**
     * Updates the values of the Gauge and its digital display and fires the "change" event.
     */
    _updateValue(newValue) {
        this._numericProcessor.updateGaugeValue(newValue);
    }

    /**
     * Validates the value and updates the pointer.
     */
    _validate(initialValidation, programmaticValue, keyCode) {
        const that = this,
            oldValue = that.value;

        that._validateValue(programmaticValue);

        if (keyCode && (keyCode === 35 || keyCode === 36)) {
            that._animate(oldValue);
        }
        else {
            that._updatePointer();
        }
    }

    /**
     * Validates the startAngle and endAngle properties.
     */
    _validateAngles() {
        const that = this;

        that._normalizedStartAngle = that._normalizeAngle(that.startAngle);
        that.endAngle = that._normalizeAngle(that.endAngle);

        if (that._normalizedStartAngle < that.endAngle) {
            that.startAngle = that._normalizedStartAngle;
        }
        else {
            that.startAngle = that._normalizedStartAngle - 360;
        }

        that._angleDifference = that.endAngle - that.startAngle;
    }

    /**
     * Validates initial property values.
     */
    _validateInitialPropertyValues() {
        super._validateInitialPropertyValues();

        const that = this;

        if (that.sizeMode === 'circle') {
            if (that.offsetWidth < that.offsetHeight) {
                that.style.height = that.offsetWidth + 'px';
            }
            else if (that.offsetWidth > that.offsetHeight) {
                that.style.width = that.offsetHeight + 'px';
            }
        }
        else {
            if (that.offsetHeight !== that.offsetWidth) {
                that.style.height = that.offsetWidth + 'px';
            }

            that.$.container.style.height = that.offsetWidth + 'px';
        }

        that._validateAngles();

        if (that.significantDigits !== null) {
            that.$.digitalDisplay.significantDigits = that.significantDigits;
        }
        else if (that.precisionDigits !== null) {
            that.$.digitalDisplay.precisionDigits = that.precisionDigits;
        }
    }

    /**
     * Validates the Gauge's value.
     */
    _validateValue(value, oldValue) {
        const that = this,
            numericProcessor = that._numericProcessor,
            logarithmicGauge = that.logarithmicScale,
            strictValidation = that.validation === 'strict';
        let fireEvent = strictValidation && oldValue !== undefined;

        if (value === undefined) {
            fireEvent = false;
            value = that.value;
        }
        else {
            value = value.toString();
        }

        if (numericProcessor.regexScientificNotation.test(value)) {
            value = numericProcessor.scientificToDecimal(value);
        }

        if (isNaN(value)) {
            value = oldValue || 0;
        }

        let valueNoRangeValidation, stringValueNoRangeValidation, stringValue;

        if (that.coerce) {
            valueNoRangeValidation = numericProcessor.getCoercedValue(numericProcessor.createDescriptor(value, true, true, true), false, logarithmicGauge);
            that._number = valueNoRangeValidation;
            stringValueNoRangeValidation = valueNoRangeValidation.toString();
            stringValue = stringValueNoRangeValidation;
        }
        else if (strictValidation) {
            valueNoRangeValidation = numericProcessor.getCoercedValue(numericProcessor.createDescriptor(value, true, true, true), false, logarithmicGauge);
            that._number = valueNoRangeValidation;
            stringValueNoRangeValidation = valueNoRangeValidation.toString();
            stringValue = stringValueNoRangeValidation;
        }
        else {
            fireEvent = false;
            valueNoRangeValidation = numericProcessor.getCoercedValue(numericProcessor.createDescriptor(value, true, true, false), false, logarithmicGauge);
            that._number = numericProcessor.validate(valueNoRangeValidation, numericProcessor.createDescriptor(that._minObject), numericProcessor.createDescriptor(that._maxObject));
            stringValueNoRangeValidation = valueNoRangeValidation.toString();
            stringValue = that._number.toString();
        }

        let oldValueDetail, valueDetail;

        if (that.mode === 'numeric') {
            oldValueDetail = oldValue;
            valueDetail = stringValueNoRangeValidation;
            that.value = stringValueNoRangeValidation; // the "value" property continues to return the value set by the user
            that.$.digitalDisplay.value = stringValueNoRangeValidation;
        }
        else {
            oldValueDetail = that._valueDate;
            that._valueDate = JQX.Utilities.DateTime.fromFullTimeStamp(stringValueNoRangeValidation);
            valueDetail = that._valueDate;
            that.value = valueNoRangeValidation;
            that.$.digitalDisplay.$.input.value = that._valueDate;
        }

        that._drawValue = logarithmicGauge ? Math.log10(stringValue).toString() : stringValue;

        if (fireEvent && (numericProcessor.compare(that._number, oldValue))) {
            that.$.fireEvent('change', { 'value': valueDetail, 'oldValue': oldValueDetail });
        }

        delete that._valueBeforeCoercion;
    }

    /**
     * Removes custom event listeners.
     */
    _unlisten() {
        const that = this;

        if (that._trackListener) {
            that._trackListener.unlisten();
        }

        if (that._fillListener) {
            that._fillListener.unlisten();
        }

        if (that._lineListener) {
            that._lineListener.unlisten();
        }
    }
});

/**
 * Slider custom element.
 */
JQX('jqx-slider', class Slider extends JQX.Tank {
    /**
     * Slider's properties.
     */
    static get properties() {
        return {
            'enableMouseWheelAction': {
                value: false,
                type: 'boolean'
            },
            'orientation': {
                value: 'horizontal',
                allowedValues: ['horizontal', 'vertical'],
                type: 'string',
                defaultReflectToAttribute: true
            },
            'rangeSlider': {
                value: false,
                type: 'boolean'
            },
            'showButtons': {
                value: false,
                type: 'boolean'
            },
            'values': {
                value: ['0', '100'],
                type: 'array'
            }
        };
    }

    /**
     * Slider's event listeners.
     */
    static get listeners() {
        return {
            'track.down': '_trackDownHandler',
            'thumb.down': '_thumbDownHandler',
            'secondThumb.down': '_thumbDownHandler',
            'thumb.mouseleave': '_thumbMoveMouseleaveHandler',
            'secondThumb.mouseleave': '_thumbMoveMouseleaveHandler',
            'thumb.move': '_thumbMoveMouseleaveHandler',
            'secondThumb.move': '_thumbMoveMouseleaveHandler',
            'document.move': '_documentMoveHandler',
            'document.up': '_documentUpHandler',
            'leftButton.click': '_spinButtonClickHandler',
            'rightButton.click': '_spinButtonClickHandler',
            'keydown': '_keydownHandlerSlider',
            'keyup': '_keyupHandlerSlider',
            'resize': '_resizeAndStyleChangedHandler',
            'styleChanged': '_resizeAndStyleChangedHandler',
            'document.selectstart': '_selectStartHandler',
            'wheel': '_wheelHandler'
        };
    }

    /**
     * Slider's required files.
     */
    static get requires() {
        return {
            'JQX.RepeatButton': 'jqxbutton.js'
        }
    }

    /**
    * CSS files needed for the element (ShadowDOM)
    */
    static get styleUrls() {
        return [
            'jqx.slider.css',
            'jqx.button.css'
        ]
    }

    /**
     * Slider's HTML template.
     */
    template() {
        const template =
            `<div id="container" class="jqx-container">
                <div id="scaleNear" class="jqx-scale jqx-scale-near"></div>
                <div id="trackContainer" class="jqx-track-container">
                    <jqx-repeat-button id="leftButton" class="jqx-spin-button" animation="[[animation]]" unfocusable>
                        <div id="leftArrow" class="jqx-arrow"></div>
                    </jqx-repeat-button>
                    <div id="track" class="jqx-track">
                        <div id="fill" class="jqx-value"></div>
                        <div id="trackTicksContainer" class="jqx-track-ticks-container jqx-hidden"></div>
                        <div id="thumb" class="jqx-thumb">
                            <span id="thumbLabel" class="jqx-thumb-label"></span>
                            <div id="tooltip" class="jqx-tooltip">
                                <div id="tooltipContent" class="jqx-tooltip-content jqx-unselectable"></div>
                            </div>
                        </div>
                        <div id="secondThumb" class="jqx-thumb">
                            <span id="secondThumbLabel" class="jqx-thumb-label"></span>
                            <div id="secondTooltip" class="jqx-tooltip">
                                <div id="secondTooltipContent" class="jqx-tooltip-content jqx-unselectable"></div>
                            </div>
                        </div>
                    </div>
                    <jqx-repeat-button id="rightButton" class="jqx-spin-button" animation="[[animation]]" unfocusable>
                        <div id="rightArrow" class="jqx-arrow"></div>
                    </jqx-repeat-button>
                </div>
                <div id="scaleFar" class="jqx-scale jqx-scale-far"></div>
                <input id="hiddenInput" type="hidden" name="[[name]]">
            </div>`;

        return template;
    }

    _createElement() {
        const that = this,
            numericScale = that.mode === 'numeric';

        if (!that._renderingSuspended) {
            if (numericScale) {
                that._redefineProperty('values');
            }
            else if (!numericScale) {
                that._handleDateScale();
            }
        }

        that._setSettingsObject();
        that._setDrawVariables();
        that._getLayoutType();

        //Creating instances of NumericProcessor and NumberRenderer
        that._numericProcessor = new JQX.Utilities.NumericProcessor(that, 'scaleType');
        that._numberRenderer = new JQX.Utilities.NumberRenderer();

        if (!that._isVisible()) {
            that._renderingSuspended = true;
            return;
        }

        that._renderingSuspended = false;

        that._setInitialComponentDisplay();

        that._measurements = {};
        that._getMeasurements();
        that._wordLengthNumber = that._numericProcessor.getWordLength(that.wordLength);

        const valuesHandler = that._valuesHandler = that.rangeSlider ? new JQX.Utilities.SliderMultipleValueHandler(that) : new JQX.Utilities.SliderSingleValueHandler(that);

        if (numericScale) {
            that._getEventValue = function () {
                return that._valuesHandler.getValue();
            };
        }

        that._validateInitialPropertyValues();

        that._setTicksAndInterval();

        valuesHandler.validate(true); // initial value(s) validation
        valuesHandler.updateTooltipValue();

        window.requestAnimationFrame(function () {
            that.$thumb.addClass('enable-animation');
            that.$secondThumb.addClass('enable-animation');
            that.$fill.addClass('enable-animation');
        });

        that._setFocusable();
        that._makeThumbAccessible();

        that.$.hiddenInput.value = that._getEventValue();
    }

    /*
     * Public methods
     */

    /**
     * Sets or gets the value of the slider.
     *
     * @param {Number/String} value Optional value to be set to the slider. If this parameter is not set, the method gets the value.
     */
    val(value) {
        const that = this,
            valuesHandler = that._valuesHandler;

        if (value !== undefined) {
            if (that.mode === 'date') {
                if (!that.rangeSlider) {
                    value = JQX.Utilities.DateTime.validateDate(value);
                    value = value.getTimeStamp();
                }
                else {
                    value[0] = JQX.Utilities.DateTime.validateDate(value[0]);
                    value[1] = JQX.Utilities.DateTime.validateDate(value[1]);
                    value[0] = value[0].getTimeStamp();
                    value[1] = value[1].getTimeStamp();
                }
            }

            // use as value setter
            if (valuesHandler.areDifferent(value)) {
                valuesHandler.validate(false, value, true);
            }
        }
        else {
            // use as value getter
            return that._getEventValue();
        }
    }

    /**
     * Gets the optimal size of the slider.
     */
    getOptimalSize() {
        const that = this;

        if (that._renderingSuspended) {
            return { width: 0, height: 0 };
        }

        const sliderStyle = window.getComputedStyle(that),
            trackStyle = window.getComputedStyle(that.$.trackContainer);
        let optimalSize = 0,
            largestLabelSize, optimalOtherSize, labels, firstLabel, lastLabel, firstRect, lastRect, difference;

        if (that.labelsVisibility === 'all') {
            largestLabelSize = that._numericProcessor._longestLabelSize
        }
        else if (that.labelsVisibility === 'endPoints') {
            largestLabelSize = Math.max(that._tickIntervalHandler.labelsSize.minLabelOtherSize, that._tickIntervalHandler.labelsSize.maxLabelOtherSize);
        }
        else {
            largestLabelSize = 0;
        }

        if (that.orientation === 'horizontal') {
            optimalSize += parseFloat(trackStyle.marginTop) + parseFloat(trackStyle.marginBottom) + that.$.track.offsetHeight;
            if (that.scalePosition === 'near' || that.scalePosition === 'both') {
                optimalSize += largestLabelSize;
                labels = that.$.scaleNear.getElementsByClassName('jqx-label');
                firstLabel = labels[0];
                lastLabel = labels[labels.length - 1];
                optimalSize += parseFloat(window.getComputedStyle(firstLabel).bottom);
            }
            if (that.scalePosition === 'far' || that.scalePosition === 'both') {
                optimalSize += largestLabelSize;
                labels = that.$.scaleFar.getElementsByClassName('jqx-label');
                firstLabel = labels[0];
                lastLabel = labels[labels.length - 1];
                optimalSize += parseFloat(window.getComputedStyle(firstLabel).top);
            }
            optimalSize += parseFloat(sliderStyle.paddingTop) + parseFloat(sliderStyle.paddingBottom);

            optimalOtherSize = that.offsetWidth;

            if (that.scalePosition !== 'none') {
                firstRect = firstLabel.getBoundingClientRect();
                lastRect = lastLabel.getBoundingClientRect();

                difference = firstRect.left + firstLabel.offsetWidth - lastRect.left;
                if (difference > 0) {
                    optimalOtherSize = firstLabel.offsetWidth + lastLabel.offsetWidth + Math.max(10, that.$.thumb.offsetWidth);
                }
            }

            return { width: optimalOtherSize, height: optimalSize };
        }
        else {
            optimalSize += parseFloat(trackStyle.marginLeft) + parseFloat(trackStyle.marginRight) + that.$.track.offsetWidth;
            if (that.scalePosition === 'near' || that.scalePosition === 'both') {
                optimalSize += largestLabelSize;
                labels = that.$.scaleNear.getElementsByClassName('jqx-label');
                firstLabel = labels[0];
                lastLabel = labels[labels.length - 1];
                optimalSize += parseFloat(window.getComputedStyle(firstLabel).right);
            }
            if (that.scalePosition === 'far' || that.scalePosition === 'both') {
                optimalSize += largestLabelSize;
                labels = that.$.scaleFar.getElementsByClassName('jqx-label');
                firstLabel = labels[0];
                lastLabel = labels[labels.length - 1];
                optimalSize += parseFloat(window.getComputedStyle(firstLabel).left);
            }
            optimalSize += parseFloat(sliderStyle.paddingLeft) + parseFloat(sliderStyle.paddingRight);

            optimalOtherSize = that.offsetHeight;

            if (that.scalePosition !== 'none') {
                firstRect = firstLabel.getBoundingClientRect();
                lastRect = lastLabel.getBoundingClientRect();

                difference = firstRect.top + firstLabel.offsetHeight - lastRect.top;
                if (difference > 0) {
                    optimalOtherSize = firstLabel.offsetHeight + lastLabel.offsetHeight + Math.max(10, that.$.thumb.offsetHeight);
                }
            }

            return { width: optimalSize, height: optimalOtherSize };
        }
    }

    /**
     * Invoked when the value of a public property has been changed by the user.
     */
    propertyChangedHandler(key, oldValue, value) {
        const that = this,
            sameHandlers = ['disabled', 'mode', 'readonly', 'showThumbLabel', 'tooltipPosition', 'unfocusable', 'validation'];

        if (!that._isVisible() || that._renderingSuspended) {
            that._renderingSuspended = true;
            return;
        }

        if (sameHandlers.indexOf(key) !== -1) {
            super.propertyChangedHandler(key, oldValue, value);
            return;
        }

        let valuesHandler = that._valuesHandler;

        function redraw() {
            that._setTicksAndInterval();
            valuesHandler.validate(false, valuesHandler.getValue(), true);
        }

        // eslint-disable-next-line
        if (key !== 'values' && value != oldValue || key === 'values' && (value[0] != oldValue[0] || value[1] !== oldValue[1])) {
            switch (key) {
                case 'coerce':
                    if (value) {
                        const valueBeforeCoercion = valuesHandler.getValue();
                        valuesHandler.validate(false, valueBeforeCoercion.slice(0), true);
                        that._valueBeforeCoercion = valueBeforeCoercion; // stores value before coercion
                    }
                    else {
                        if (that._valueBeforeCoercion !== undefined) {
                            valuesHandler.validate(false, that._valueBeforeCoercion.slice(0), true); // restores the value from before coercion
                        }
                    }
                    break;
                case 'customInterval':
                case 'customTicks':
                    super.propertyChangedHandler(key, oldValue, value);

                    if (that.customInterval) {
                        valuesHandler.validate(false, valuesHandler.getValue(), true);
                    }

                    break;
                case 'dateLabelFormatString':
                    if (that.mode === 'date') {
                        redraw();
                    }

                    break;
                case 'decimalSeparator':
                case 'scientificNotation':
                    if (that.mode === 'date') {
                        return;
                    }

                    redraw();
                    break;
                case 'interval':
                    //Validates the Interval
                    that._numericProcessor.validateInterval(value);

                    valuesHandler.validate(false, valuesHandler.getValue(), true);
                    break;
                case 'inverted':
                    that._getLayoutType();
                    if (that._normalLayout) {
                        that.$.fill.style[that._settings.margin] = '0px';
                    }

                    redraw();
                    break;
                case 'labelFormatFunction':
                case 'showUnit':
                case 'unit':
                    redraw();
                    break;
                case 'labelsVisibility':
                case 'ticksVisibility':
                    return;
                case 'logarithmicScale':
                    if (that.mode === 'date') {
                        that.logarithmicScale = false;
                        return;
                    }

                    that._validateMinMax('both');
                    redraw();
                    break;
                case 'min':
                case 'max':
                    if (that.mode === 'date') {
                        delete that._dateInterval;

                        that[key] = JQX.Utilities.DateTime.validateDate(value).getTimeStamp();
                    }

                    that._validateMinMax(key, false, oldValue);
                    redraw();
                    break;
                case 'orientation':
                    // clears previously applied inline styles
                    that.$.container.removeAttribute('style');
                    that.$.trackContainer.removeAttribute('style');
                    that.$.fill.removeAttribute('style');
                    that.$.thumb.removeAttribute('style');
                    that.$.secondThumb.removeAttribute('style');

                    that._setSettingsObject();
                    that._getLayoutType();
                    that._getMeasurements();

                    redraw();

                    if (value === 'horizontal') {
                        that.$leftArrow.removeClass('jqx-arrow-up');
                        that.$rightArrow.removeClass('jqx-arrow-down');
                        that.$leftArrow.addClass('jqx-arrow-left');
                        that.$rightArrow.addClass('jqx-arrow-right');
                    }
                    else {
                        that.$leftArrow.removeClass('jqx-arrow-left');
                        that.$rightArrow.removeClass('jqx-arrow-right');
                        that.$leftArrow.addClass('jqx-arrow-up');
                        that.$rightArrow.addClass('jqx-arrow-down');
                    }
                    break;
                case 'precisionDigits':
                case 'significantDigits':
                    if (that.mode === 'date') {
                        return;
                    }

                    if (key === 'precisionDigits' && that.scaleType === 'integer') {
                        that.error(that.localize('noInteger', { elementType: that.nodeName.toLowerCase(), property: key }));
                    }

                    if (key === 'significantDigits' && that.precisionDigits !== null) {
                        that.precisionDigits = null;
                    }
                    else if (key === 'precisionDigits' && that.significantDigits !== null) {
                        that.significantDigits = null;
                    }

                    redraw();
                    break;
                case 'rangeSlider':
                    if (value) {
                        that.values = [that.min, that.value];
                        that._drawValues = [that._drawMin, that._drawValue];

                        if (that.mode === 'date') {
                            that._valueDate = [that._minDate.clone(), that._valueDate];
                        }

                        if (that._valueBeforeCoercion !== undefined) {
                            that._valueBeforeCoercion = [that.min, that._valueBeforeCoercion];
                        }
                        valuesHandler = that._valuesHandler = new JQX.Utilities.SliderMultipleValueHandler(that);
                    }
                    else {
                        that.value = that.values[1];
                        that._drawValue = that._drawValues[1];

                        if (that.mode === 'date') {
                            that._valueDate = that._valueDate[1];
                        }

                        if (that._valueBeforeCoercion !== undefined) {
                            that._valueBeforeCoercion = that._valueBeforeCoercion[1];
                        }
                        valuesHandler = that._valuesHandler = new JQX.Utilities.SliderSingleValueHandler(that);
                        that.$.fill.style.marginTop = 0;
                        that.$.fill.style.marginLeft = 0;
                    }
                    valuesHandler.validate(false, valuesHandler.getValue(), true);
                    break;
                case 'scalePosition':
                    that._setInitialComponentDisplay();
                    redraw();
                    break;
                case 'scaleType':
                    if (that.mode === 'date') {
                        that.scaleType = 'integer';
                        return;
                    }

                    that._numericProcessor = new JQX.Utilities.NumericProcessor(that, 'scaleType');

                    that._validateMinMax('both');

                    that._setTicksAndInterval();
                    valuesHandler.validate(true);
                    break;
                case 'showButtons':
                    if (value) {
                        that.$leftButton.removeClass('jqx-hidden');
                        that.$rightButton.removeClass('jqx-hidden');
                    }
                    else {
                        that.$leftButton.addClass('jqx-hidden');
                        that.$rightButton.addClass('jqx-hidden');
                    }
                    that._setTicksAndInterval();
                    valuesHandler.moveThumbBasedOnValue(valuesHandler.getDrawValue(), undefined, true);
                    break;
                case 'showTooltip':
                    super.propertyChangedHandler(key, oldValue, value);

                    if (!value) {
                        that.$tooltip.addClass('jqx-hidden');
                        that.$secondTooltip.addClass('jqx-hidden');
                    }

                    break;
                case 'theme':
                    super.propertyChangedHandler(key, oldValue, value);
                    redraw();
                    break;
                case 'ticksPosition':
                    if (value === 'scale') {
                        that.$trackTicksContainer.addClass('jqx-hidden');
                        that.$.trackTicksContainer.innerHTML = '';
                    }
                    else {
                        that.$trackTicksContainer.removeClass('jqx-hidden');
                    }

                    that._setTicksAndInterval();
                    break;
                case 'value':
                case 'values':
                    if (key === 'value' && that.rangeSlider ||
                        key === 'values' && !that.rangeSlider) {
                        return;
                    }

                    that[key] = oldValue;

                    if (that.mode === 'date') {
                        if (key === 'value') {
                            value = JQX.Utilities.DateTime.validateDate(value);
                            value = value.getTimeStamp();
                            that.value = value;

                            if (value.compare(oldValue) === 0) {
                                return;
                            }
                        }
                        else {
                            value[0] = JQX.Utilities.DateTime.validateDate(value[0]);
                            value[1] = JQX.Utilities.DateTime.validateDate(value[1]);
                            value[0] = value[0].getTimeStamp();
                            value[1] = value[1].getTimeStamp();
                            that.values = value;

                            if (value[0].compare(oldValue[0]) === 0 && value[1].compare(oldValue[1]) === 0) {
                                return;
                            }
                        }
                    }

                    valuesHandler.validate(false, value, true);
                    break;
                case 'wordLength':
                    if (that.mode === 'date') {
                        that.wordLength = 'uint64';
                        return;
                    }

                    that._wordLengthNumber = that._numericProcessor.getWordLength(value);
                    that._validateMinMax('both');
                    redraw();
                    break;
            }
        }
        else if (typeof value !== 'string' && typeof oldValue === 'string') {
            that[key] = oldValue;
        }
    }

    /**
     * Adds the class "jqx-moved-thumb" to the moved thumb.
     */
    _addMovedThumbClass() {
        const that = this;

        if (!that.rangeSlider) {
            return;
        }

        that._movedThumb.$.addClass('jqx-moved-thumb');

        if (that._movedThumb === that.$.thumb) {
            that.$secondThumb.removeClass('jqx-moved-thumb');
        }
        else {
            that.$thumb.removeClass('jqx-moved-thumb');
        }
    }

    /**
     * Sets the display of the scales.
     */
    _setInitialComponentDisplay() {
        super._setInitialComponentDisplay();

        const that = this;

        that.$secondTooltip.addClass('jqx-hidden');

        if (!that.showButtons) {
            that.$leftButton.addClass('jqx-hidden');
            that.$rightButton.addClass('jqx-hidden');
        }
    }

    /**
     * Measures some elements of the slider and stores the results.
     */
    _getMeasurements() {
        const that = this,
            measurements = that._measurements,
            track = that.$.track,
            thumb = that.$.thumb;

        if (!that._isVisible() || that._renderingSuspended) {
            that._renderingSuspended = true;
            return;
        }

        if (that.orientation === 'horizontal') {
            measurements.trackWidth = track.offsetHeight;
            measurements.thumbSize = thumb.offsetWidth;
            measurements.borderWidth = parseFloat(window.getComputedStyle(that.$.track).borderLeftWidth);
        }
        else {
            measurements.trackWidth = track.offsetWidth;
            measurements.thumbSize = thumb.offsetHeight;
            measurements.borderWidth = parseFloat(window.getComputedStyle(that.$.track).borderTopWidth);
        }
        measurements.halfThumbSize = measurements.thumbSize / 2;

    }

    /**
     * Applies necessary paddings to the track container.
     */
    _layout() {
        const that = this,
            measurements = that._measurements,
            containerStyle = that.$.container.style,
            thumbPadding = measurements.halfThumbSize,
            labelsSize = that._tickIntervalHandler.labelsSize;
        let minLabelPadding, maxLabelPadding, paddingStart, paddingEnd;

        if (that.scalePosition !== 'none') {
            minLabelPadding = labelsSize.minLabelSize / 2;
            maxLabelPadding = labelsSize.maxLabelSize / 2;
        }
        else {
            minLabelPadding = 0;
            maxLabelPadding = 0;
        }

        if (!that.showButtons) {
            paddingStart = Math.max(thumbPadding, minLabelPadding) + 'px';
            paddingEnd = Math.max(thumbPadding, maxLabelPadding) + 'px';
        }
        else {
            const spinButtonSize = that.$.leftButton[that._settings.size],
                buttonSize = spinButtonSize + thumbPadding;
            paddingStart = Math.max(minLabelPadding - buttonSize, 0) + 'px';
            paddingEnd = Math.max(maxLabelPadding - buttonSize, 0) + 'px';
        }

        if (that.orientation === 'horizontal') {
            if (!that.inverted) {
                containerStyle.paddingLeft = paddingStart;
                containerStyle.paddingRight = paddingEnd;
            }
            else {
                containerStyle.paddingLeft = paddingEnd;
                containerStyle.paddingRight = paddingStart;
            }

            measurements.trackLength = that.$.track.clientWidth;

            that.$leftArrow.addClass('jqx-arrow-left');
            that.$rightArrow.addClass('jqx-arrow-right');
        }
        else {
            if (!that.inverted) {
                containerStyle.paddingBottom = paddingStart;
                containerStyle.paddingTop = paddingEnd;
            }
            else {
                containerStyle.paddingBottom = paddingEnd;
                containerStyle.paddingTop = paddingStart;
            }

            measurements.trackLength = that.$.track.clientHeight;

            that.$leftArrow.addClass('jqx-arrow-up');
            that.$rightArrow.addClass('jqx-arrow-down');
        }
    }

    /**
     * Track click event handler.
     */
    _trackDownHandler(event) {
        const that = this,
            mechanicalAction = that.mechanicalAction;

        if (that.disabled || that.readonly || !that.rangeSlider && event.target === that.$.thumb) {
            return;
        }

        if (that._stopTrackDownHandler) {
            that._stopTrackDownHandler = false;
            return;
        }

        if (mechanicalAction !== 'switchWhileDragging') {
            that._valueAtDragStart = that._valuesHandler.getValue();
        }

        that._getTrackStartAndEnd();
        that._valuesHandler.setActiveThumbOnTrackClick(event);

        that._moveThumbBasedOnCoordinates(event, true, mechanicalAction !== 'switchWhenReleased');

        that._thumbDragged = true;
        that.setAttribute('dragged', '');

        if (that.showTooltip) {
            that._movedTooltip.removeClass('jqx-hidden');
        }
    }

    _trackMoveHandler() { }

    /**
     * Thumb mousedown event handler.
     */
    _thumbDownHandler(event) {
        const that = this;

        if (that.disabled || that.readonly) {
            return;
        }
        that._getTrackStartAndEnd();

        if (event[that._settings.page] < that._trackStart || event[that._settings.page] > that._trackEnd) {
            that._stopTrackDownHandler = true;
        }

        if (that.mechanicalAction !== 'switchWhileDragging') {
            that._valueAtDragStart = that._valuesHandler.getValue();
        }

        window.getSelection().removeAllRanges();

        that._thumbDragged = true;
        that.setAttribute('dragged', '');
        that.$track.addClass('jqx-dragged');
        that._movedThumb = event.target;
        that._addMovedThumbClass();
        that._movedTooltip = that.$tooltip;

        if (that.rangeSlider) {
            if (that._movedThumb === that.$.thumb) {
                that._staticThumb = that.$.secondThumb;
                that.$secondTooltip.addClass('jqx-hidden');
            }
            else {
                that._staticThumb = that.$.thumb;
                that._movedTooltip = that.$secondTooltip;
                that.$tooltip.addClass('jqx-hidden');
            }
        }

        if (that.showTooltip) {
            that._movedTooltip.removeClass('jqx-hidden');
        }

        event.stopPropagation();
    }

    /**
     * Thumb move and mouseleave event handler.
     */
    _thumbMoveMouseleaveHandler(event) {
        const that = this;

        if (that.disabled || that.readonly) {
            return;
        }

        const target = event.target;

        if (event.type === 'move') {
            const targetRect = target.getBoundingClientRect(),
                windowScrollX = window.scrollX || window.pageXOffset,
                windowScrollY = window.scrollY || window.pageYOffset,
                centerX = (targetRect.left + targetRect.right) / 2 + windowScrollX,
                centerY = (targetRect.top + targetRect.bottom) / 2 + windowScrollY,
                rSquared = Math.pow(targetRect.width / 2, 2);

            if ((Math.pow(event.pageX - centerX, 2) + Math.pow(event.pageY - centerY, 2)) > rSquared) {
                return;
            }

            target.setAttribute('hover', '');
        }
        else {
            target.removeAttribute('hover');
        }
    }

    /**
     * Document mousemove event handler.
     */
    _documentMoveHandler(event) {
        const that = this;
        if (that._thumbDragged) {
            that.$thumb.removeClass('enable-animation');
            that.$secondThumb.removeClass('enable-animation');
            that.$fill.removeClass('enable-animation');

            that._moveThumbBasedOnCoordinates(event, true, that.mechanicalAction !== 'switchWhenReleased');
        }
    }

    /**
     * Document mouseup event handler.
     */
    _documentUpHandler(event, canceled) {
        const that = this;

        if (!that._thumbDragged) {
            return;
        }

        that.$thumb.addClass('enable-animation');
        that.$secondThumb.addClass('enable-animation');
        that.$fill.addClass('enable-animation');

        if (!canceled) {
            if (that.mechanicalAction === 'switchUntilReleased') {
                that._valuesHandler.validate(false, that._valueAtDragStart);
            }
            else if (that.mechanicalAction === 'switchWhenReleased') {
                that._moveThumbBasedOnCoordinates(event, true, true);
            }
        }

        if (that.showTooltip) {
            that._movedTooltip.addClass('jqx-hidden');
        }

        that._thumbDragged = false;
        that.removeAttribute('dragged');
        that._makeThumbAccessible();
        that._movedThumb = undefined;
        that.$track.removeClass('jqx-dragged');
    }

    /**
     * Spin button click event handler.
     */
    _spinButtonClickHandler(event) {
        const that = this;

        if (that.disabled || that.readonly) {
            return;
        }

        let operation;

        if (that.$.leftButton.contains(event.target) === that._normalLayout) {
            operation = 'subtract';
        }
        else {
            operation = 'add';
        }

        that._valuesHandler.incrementOrDecrement(operation);
    }

    /**
     * Slider keydown event handler.
     */
    _keydownHandlerSlider(event) {
        const that = this,
            key = event.key;

        if (key === 'Escape' && that._thumbDragged && that.mechanicalAction === 'switchWhenReleased') {
            that._documentUpHandler(undefined, true);
            that._valuesHandler.validate(false, that._valueAtDragStart);
            return;
        }

        if (['ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowUp'].indexOf(key) !== -1 && !that.coerce) {
            that.$thumb.removeClass('enable-animation');
            that.$secondThumb.removeClass('enable-animation');
            that.$fill.removeClass('enable-animation');
            that._restoreAnimationClass = true;
        }

        this._valuesHandler.keydownHandler(event);
    }

    /**
    * Slider keyup event handler.
    */
    _keyupHandlerSlider() {
        const that = this;

        if (that._restoreAnimationClass) {
            that.$thumb.addClass('enable-animation');
            that.$secondThumb.addClass('enable-animation');
            that.$fill.addClass('enable-animation');
        }
    }

    /**
     * Slider resize and styleChanged event handler.
     */
    _resizeAndStyleChangedHandler(event) {
        const that = this,
            valuesHandler = that._valuesHandler;

        if (!that._isVisible()) {
            that._renderingSuspended = true;
            return;
        }
        else if (that._renderingSuspended) {
            that._createElement();
            return;
        }

        if (that._renderingSuspended) {
            return;
        }

        that._getMeasurements();
        that._setTicksAndInterval();
        valuesHandler.validate(false, valuesHandler.getValue(), true);

        if (event.type === 'styleChanged') {
            const changedStyleProperties = event.detail.styleProperties;

            if (changedStyleProperties['font-size'] || changedStyleProperties['font-family'] || changedStyleProperties['font-style'] || changedStyleProperties['font-weight']) {
                const optimum = that.getOptimalSize();
                that.style.width = optimum.width + 'px';
                that.style.height = optimum.height + 'px';
            }
        }
    }

    /**
     * Moves the slider's thumb and updates the filled part of the track based on the position of the mouse.
     */
    _moveThumbBasedOnCoordinates(event, checkBoundaries, changeValue) {
        const that = this,
            numericProcessor = that._numericProcessor,
            trackStart = that._trackStart,
            margin = that._settings.margin;
        let coordinate = event[that._settings.page];

        if (checkBoundaries) {
            coordinate = that._valuesHandler.restrictThumbCoordinates(coordinate, trackStart, that._trackEnd);
        }

        let newValue = numericProcessor.pxToValue(coordinate);

        if (that.rangeSlider && that._movedThumb === that.$.thumb && numericProcessor.compare(newValue, that.values[1], true) === 1) {
            newValue = numericProcessor.createDescriptor(that.values[1]);
        }

        let actualNewValue = newValue;

        if (!that.logarithmicScale) {
            newValue = numericProcessor.getCoercedValue(newValue);
            actualNewValue = newValue;
        }
        else {
            newValue = numericProcessor.getCoercedValue(Math.log10(newValue));
            actualNewValue = parseFloat(Math.pow(10, newValue).toFixed(11));
        }
        coordinate = numericProcessor.valueToPx(newValue) + trackStart;

        const size = coordinate - trackStart;

        that._movedThumb.style[margin] = size - that._measurements.halfThumbSize + 'px';

        that._valuesHandler.updateFillSizeAndPosition(size, margin, actualNewValue, true, changeValue);

        if (JQX.Utilities.Core.isMobile && event.originalEvent) {
            event.originalEvent.stopPropagation();
            event.originalEvent.preventDefault();
        }
    }

    /**
     * Moves the slider's thumb and updates the filled part of the track based on a passed value.
     */
    _moveThumbBasedOnValue(thumb, value, triggerEvent, firstPass) {
        const that = this,
            px = that._numericProcessor.valueToPx(value),
            margin = that._settings.margin;

        thumb.style[margin] = (px - that._measurements.halfThumbSize) + 'px';

        const actualValue = that._getSingleActualValue(value);

        if (!firstPass) {
            that._valuesHandler.updateFillSizeAndPosition(px, margin, actualValue, triggerEvent, triggerEvent);
        }
        else if (that.rangeSlider) {
            that._firstPassSize = px;
        }
    }

    /**
     * Calls the appropriate validation function.
     */
    _validate(initialValidation, programmaticValue, coerced, programmaticValueIsSet) {
        this._valuesHandler.validate(initialValidation, programmaticValue, programmaticValueIsSet);
    }

    /**
     * Calls the appropriate update function.
     */
    _updateValue(value) {
        const valuesHandler = this._valuesHandler;
        valuesHandler.updateValue(valuesHandler.getActualValue(value));
    }

    /**
     * Makes the first thumb accessible.
     */
    _makeThumbAccessible() {
        const that = this;
        if (that.rangeSlider) {
            if (that.$.thumb[that._settings.offset] === that.$.secondThumb[that._settings.offset] && that._numericProcessor.compare(that.values[1], that.max) === false) {
                that.$thumb.addClass('accessible');
            }
            else {
                that.$thumb.removeClass('accessible');
            }
        }
    }

    /**
     * Returns a single, actual value.
     */
    _getSingleActualValue(value) {
        if (this.logarithmicScale) {
            return parseFloat(Math.pow(10, value).toFixed(11));
        }

        return value.toString();
    }

    /**
     * Coerces the value when changes to custom interval-related settings are made.
     */
    _coerceCustomInterval() {
        const that = this;

        if (that.coerce) {
            const valueBeforeCoercion = that._valueBeforeCoercion;

            that._valuesHandler.validate(false, that._valuesHandler.getValue());
            that._valueBeforeCoercion = valueBeforeCoercion;
        }
    }

    /**
     * wheel event handler
     */
    _wheelHandler(event) {
        const that = this;

        if (document.activeElement !== that || !that.enableMouseWheelAction) {
            return;
        }

        event.stopPropagation();
        event.preventDefault();

        if (event.wheelDelta > 0) {
            that._keydownHandlerSlider({ key: 'ArrowRight', which: 39, preventDefault: function () { } });
        }
        else {
            that._keydownHandlerSlider({ key: 'ArrowLeft', which: 37, preventDefault: function () { } });
        }
    }

    /**
     * Handles date scale.
     */
    _handleDateScale() {
        const that = this,
            dateTime = JQX.Utilities.DateTime;

        super._handleDateScale();

        Object.defineProperty(that, 'values', {
            get: function () {
                if (that.context === that) {
                    return that.properties.values.value;
                }
                else {
                    return that._valueDate;
                }
            },
            set(value) {
                function replacer(key, value) {
                    if (value instanceof JQX.Utilities.BigNumber) {
                        return value.toString();
                    }

                    return value;
                }

                const oldValue = that.properties.values.value,
                    stringifiedOldValue = JSON.stringify(oldValue, replacer),
                    stringifiedValue = JSON.stringify(value, replacer);

                if (stringifiedOldValue === stringifiedValue) {
                    return;
                }

                that.properties.values.value = value;

                if (that.isReady && (!that.ownerElement || (that.ownerElement && that.ownerElement.isReady)) && that.context !== that) {
                    const context = that.context;

                    that.context = that;
                    that.propertyChangedHandler('values', oldValue, value);
                    that.context = context;
                }
            }
        });

        if (that.rangeSlider) {
            that._valueDate = [dateTime.validateDate(that.values[0]), dateTime.validateDate(that.values[1])];
            that.values = [that._valueDate[0].getTimeStamp(), that._valueDate[1].getTimeStamp()];
        }

        that._properties.values.serialize = '_serializeValue';
    }

    /**
     * Sets new Ticks and Interval 
     */
    _setTicksAndInterval() {
        const that = this;

        if (that._skipTrackReset) {
            delete that._skipTrackReset;
        }
        else {
            that.$.track.style[that._settings.dimension] = null;
        }

        super._setTicksAndInterval();

        if (that.$.track[that._settings.size] < 10) {
            that._skipTrackReset = true;
            that.$.track.style[that._settings.dimension] = that.getOptimalSize()[that._settings.dimension] + 'px';
            that._getMeasurements();
            that._setTicksAndInterval();
            that._valuesHandler.validate(false, that._valuesHandler.getValue());
        }
    }
});

/**
 * A class for instantiating a tooltip handler object (standard case).
 */
JQX.Utilities.Assign('SliderSingleValueHandler', class SliderSingleValueHandler {
    constructor(context) {
        this.context = context;

        if (context.mode === 'date') {
            context._getEventValue = function (value) {
                if (value !== undefined) {
                    return JQX.Utilities.DateTime.fromFullTimeStamp(value);
                }

                return context._valueDate.clone();
            }
        }
    }

    applyFunctionToValue(fn, argument) {
        const that = this,
            context = that.context;

        if (argument === undefined) {
            argument = context.value;
        }

        const result = fn.apply(context, [argument]);

        return result;
    }

    areDifferent(other) {
        return this.context.value !== other;
    }

    incrementOrDecrement(operation) {
        const context = this.context,
            newValue = context._keyIncrementDecrement(operation);
        this.validate(false, newValue);
    }

    setActiveThumbOnTrackClick() {
        const context = this.context;
        context._movedThumb = context.$.thumb;
        context._addMovedThumbClass();
        context._movedTooltip = context.$tooltip;
    }

    getActualValue(value) {
        return this.context._getSingleActualValue(value);
    }

    getCoercedLogarithmicValue(value) {
        const context = this.context;
        if (context.logarithmicScale) {
            const newDrawValue = context._numericProcessor.getCoercedValue(Math.log10(value));
            return this.getActualValue(newDrawValue);
        }
        return value;
    }

    getDrawValue() {
        return this.context._drawValue;
    }

    getValue() {
        return this.context.value;
    }

    keydownHandler(event) {
        this.context._keydownHandler(event);
    }

    moveThumbBasedOnValue(value, triggerEvent, noUpdate) {
        const context = this.context;

        if (value === undefined) {
            value = context.value;
        }

        context._moveThumbBasedOnValue(context.$.thumb, value, triggerEvent);

        if (noUpdate !== true) {
            context._drawValue = value;
            const actualValue = this.getActualValue(value);
            let updatedValue;

            if (context._valueNoRangeValidation !== undefined) {
                updatedValue = context._valueNoRangeValidation.toString();
            }
            else {
                updatedValue = actualValue.toString();
            }

            if (context.mode === 'date') {
                context._valueDate = JQX.Utilities.DateTime.fromFullTimeStamp(updatedValue);
            }

            context.value = updatedValue;

            delete context._valueBeforeCoercion;
            this.updateTooltipValue(actualValue);
        }
    }

    restrictThumbCoordinates(coordinate, trackStart, trackEnd) {
        coordinate = Math.max(coordinate, trackStart);
        coordinate = Math.min(coordinate, trackEnd);
        return coordinate;
    }

    updateFillSizeAndPosition(size, margin, newValue, updateTooltip, changeValue) {
        const context = this.context,
            fillStyle = context.$.fill.style,
            dimension = context._settings.dimension;

        if (context._normalLayout) {
            fillStyle[dimension] = size + 'px';
        }
        else {
            fillStyle[dimension] = (context._measurements.trackLength - size) + 'px';
            fillStyle[margin] = size + 'px';
        }

        if (updateTooltip) {
            const oldValue = context.value,
                eventOldValue = context._getEventValue(oldValue),
                numericProcessor = context._numericProcessor;
            if (numericProcessor.compare(numericProcessor.createDescriptor(newValue), numericProcessor.createDescriptor(oldValue))) {
                this.updateTooltipValue(newValue);

                if (changeValue) {
                    let updatedValue;

                    context._drawValue = context.logarithmicScale ? Math.log10(newValue) : newValue;

                    if (context._valueNoRangeValidation !== undefined) {
                        updatedValue = context._valueNoRangeValidation.toString();
                    }
                    else {
                        updatedValue = newValue.toString();
                    }

                    if (context.mode === 'date') {
                        context._valueDate = JQX.Utilities.DateTime.fromFullTimeStamp(updatedValue);
                    }

                    context.value = updatedValue;

                    delete context._valueBeforeCoercion;

                    if (context._programmaticValueIsSet !== true) {
                        const eventValue = context._getEventValue();

                        //Update hidden input
                        context.$.hiddenInput.value = eventValue;
                        context.$.fireEvent('change', { 'value': eventValue, 'oldValue': eventOldValue });
                    }
                }
            }
        }
    }

    updateTooltipValue(newValue) {
        const context = this.context;

        if (newValue === undefined) {
            newValue = context.value;
        }

        const newFormattedValue = context._formatLabel(newValue);

        if (context.$.tooltipContent.innerHTML !== newFormattedValue) {
            context.$.tooltipContent.innerHTML = newFormattedValue;
            context.$.thumbLabel.innerHTML = newFormattedValue;
        }
    }

    updateValue(value) {
        const context = this.context,
            renderedValue = context._numericProcessor.createDescriptor(value, true, false);

        context._drawValue = context.logarithmicScale ? Math.log10(renderedValue) : renderedValue;
        this.moveThumbBasedOnValue(context._drawValue, true);
    }

    validate(initialValidation, programmaticValue, programmaticValueIsSet) {
        const context = this.context,
            numericProcessor = context._numericProcessor;
        let value;

        context._programmaticValueIsSet = programmaticValueIsSet && context.validation === 'interaction';

        if (initialValidation) {
            value = context.value;
        }
        else {
            value = programmaticValue;
        }

        let validNumber;

        if (context.coerce) {
            value = context._numericProcessor.createDescriptor(value, true, true, true);
        }

        if (context.logarithmicScale) {
            value = this.getCoercedLogarithmicValue(value);
        }
        else {
            value = numericProcessor.getCoercedValue(value);
        }

        if (context.validation === 'strict') {
            context._valueNoRangeValidation = numericProcessor.createDescriptor(value, true, true, true);
            validNumber = context._valueNoRangeValidation;
        }
        else {
            context._valueNoRangeValidation = numericProcessor.createDescriptor(value, true, true, false);
            validNumber = numericProcessor.validate(context._valueNoRangeValidation, context._minObject, context._maxObject);
        }

        if (initialValidation) {
            context._drawValue = context.logarithmicScale ? Math.log10(validNumber) : validNumber;
            value = context._valueNoRangeValidation.toString();

            if (context.mode === 'date') {
                context._valueDate = JQX.Utilities.DateTime.fromFullTimeStamp(value);
            }

            context.value = value;

            this.moveThumbBasedOnValue(context._drawValue, undefined, true);
        }
        else {
            this.updateValue(validNumber);
        }

        delete context._valueNoRangeValidation;
        context._programmaticValueIsSet = false;
    }
});

/**
 * A class for instantiating a tooltip handler object (range slider case).
 */
JQX.Utilities.Assign('SliderMultipleValueHandler', class SliderMultipleValueHandler {
    constructor(context) {
        this.context = context;

        if (context.mode === 'date') {
            context._getEventValue = function (value, index) {
                const result = [context._valueDate[0].clone(), context._valueDate[1].clone()];

                if (value !== undefined) {
                    result[index] = JQX.Utilities.DateTime.fromFullTimeStamp(value);
                }

                return result;
            }
        }
    }

    applyFunctionToValue(fn, argument) {
        const that = this,
            context = that.context,
            result = [];

        if (argument === undefined) {
            argument = context.values;
        }

        result[0] = fn.apply(context, [argument[0]]);
        result[1] = fn.apply(context, [argument[1]]);

        return result;
    }

    areDifferent(other) {
        const values = this.context.values;
        return (values[0] !== other[0] || values[1] !== other[1]);
    }

    incrementOrDecrement(operation) {
        const context = this.context,
            changedValues = context.values.slice(0);
        let changedIndex;

        if (operation === 'add') {
            changedIndex = 1;
        }
        else {
            changedIndex = 0;
        }

        changedValues[changedIndex] = this.keyIncrementDecrement(operation, changedIndex);

        this.validate(false, changedValues);
    }

    keydownHandler(event) {
        const context = this.context;

        if (context.disabled || context.readonly) {
            return;
        }

        const keyCode = !event.charCode ? event.which : event.charCode,
            handledKeyCodes = [35, 36, 37, 38, 39, 40];

        if (handledKeyCodes.indexOf(keyCode) !== -1) {
            event.preventDefault();

            const updatedValues = context.values.slice(0);
            let newValue;

            switch (keyCode) {
                case 40:    //down arrow
                case 37:    //left arrow
                    newValue = this.keyIncrementDecrement('subtract', 0);
                    updatedValues[0] = newValue;
                    context._movedThumb = context.$.thumb;
                    break;
                case 38:    //top arrow
                case 39:    //right arrow
                    newValue = this.keyIncrementDecrement('add', 1);
                    updatedValues[1] = newValue;
                    context._movedThumb = context.$.secondThumb;
                    break;
                case 36:    //home
                    context._drawValues[0] = context._drawMin;
                    updatedValues[0] = context.min;
                    context._movedThumb = context.$.thumb;
                    break;
                case 35:    //end
                    context._drawValues[1] = context._drawMax;
                    updatedValues[1] = context.max;
                    context._movedThumb = context.$.secondThumb;
                    break;
            }
            this.validate(false, updatedValues);
            return false;
        }
    }

    keyIncrementDecrement(action, changedIndex) {
        const context = this.context;
        let preValue, newValue;

        if (context.customInterval && context.coerce) {
            preValue = this.getValue()[changedIndex];
            return context._keyIncrementDecrement(action, preValue.toString());
        }

        if (context.mode === 'date') {
            preValue = context._valueDate[changedIndex];
            newValue = preValue[context._dateIncrementMethod]((action === 'add' ? 1 : -1) * parseFloat(context.interval), true);
            newValue = newValue.getTimeStamp();

            if (newValue.compare(context._drawMin) === -1) {
                return new JQX.Utilities.BigNumber(context._drawMin);
            }

            if (newValue.compare(context._drawMax) === 1) {
                return new JQX.Utilities.BigNumber(context._drawMax);
            }

            return newValue;
        }

        const drawValue = context._drawValues[changedIndex];

        preValue = context._numericProcessor.createDescriptor(drawValue);

        newValue = context._numericProcessor.incrementDecrement(preValue, action, context._validInterval);
        if (context.logarithmicScale) {
            context._drawValues[changedIndex] = newValue;
            newValue = parseFloat(Math.pow(10, Math.round(newValue)).toFixed(11));
        }
        return newValue;
    }

    setActiveThumbOnTrackClick(event) {
        const context = this.context,
            commonTerm = context._trackStart + context._measurements.halfThumbSize,
            offset = context._settings.offset,
            thumb = context.$.thumb,
            secondThumb = context.$.secondThumb,
            thumbOffset = thumb[offset],
            secondThumbOffset = secondThumb[offset],
            clickedCoordinate = event[context._settings.page];

        let middleBetweenThumbs = context._normalLayout ? commonTerm + thumbOffset + (secondThumbOffset - thumbOffset) / 2 : commonTerm + secondThumbOffset + (thumbOffset - secondThumbOffset) / 2;

        if (context._normalLayout && clickedCoordinate <= middleBetweenThumbs || !context._normalLayout && clickedCoordinate > middleBetweenThumbs) {
            context._movedThumb = thumb;
            context._staticThumb = secondThumb;
            context._movedTooltip = context.$tooltip;
            context.$secondTooltip.addClass('jqx-hidden');
        }
        else {
            context._movedThumb = secondThumb;
            context._staticThumb = thumb;
            context._movedTooltip = context.$secondTooltip;
            context.$tooltip.addClass('jqx-hidden');
        }

        context._addMovedThumbClass();
    }

    getActualValue(values) {
        if (this.context.logarithmicScale) {
            return [parseFloat(Math.pow(10, values[0].toString()).toFixed(11)), parseFloat(Math.pow(10, values[1].toString()).toFixed(11))];
        }
        return [values[0].toString(), values[1].toString()];
    }

    getCoercedLogarithmicValue(values) {
        const context = this.context;
        if (context.logarithmicScale) {
            const newDrawValues = [];
            newDrawValues[0] = context._numericProcessor.getCoercedValue(Math.log10(values[0]));
            newDrawValues[1] = context._numericProcessor.getCoercedValue(Math.log10(values[1]));
            return this.getActualValue(newDrawValues);
        }
        return values;
    }

    getDrawValue() {
        return this.context._drawValues;
    }

    getValue() {
        return this.context.values.slice(0);
    }

    moveThumbBasedOnValue(value, changedIndex, noUpdate) {
        const context = this.context,
            both = changedIndex === undefined;

        if (value === undefined) {
            value = context.values;
        }

        context._numericProcessor.restrictValue(value);

        if (both || changedIndex === 1) {
            context._movedThumb = context.$.secondThumb;
            context._moveThumbBasedOnValue(context.$.secondThumb, value[1], true, both);
        }
        if (both || changedIndex === 0) {
            context._movedThumb = context.$.thumb;
            context._moveThumbBasedOnValue(context.$.thumb, value[0], true);
        }

        delete context._firstPassSize;

        if (noUpdate !== true) {
            context._drawValues = value;
            const actualValues = this.getActualValue(value);
            let updatedValues;

            if (context._valuesNoRangeValidation) {
                updatedValues = [context._valuesNoRangeValidation[0].toString(), context._valuesNoRangeValidation[1].toString()];
            }
            else {
                updatedValues = actualValues;
            }

            if (context.mode === 'date') {
                context._valueDate = [
                    JQX.Utilities.DateTime.fromFullTimeStamp(actualValues[0]),
                    JQX.Utilities.DateTime.fromFullTimeStamp(actualValues[1])
                ];
            }

            context.values = updatedValues;

            delete context._valueBeforeCoercion;
            this.updateTooltipValue();
        }
    }

    restrictThumbCoordinates(coordinate, trackStart, trackEnd) {
        const context = this.context,
            staticThumbOffset = trackStart + context._staticThumb[context._settings.offset] + context._measurements.halfThumbSize;

        if (context._movedThumb === context.$.thumb && context._normalLayout || context._movedThumb === context.$.secondThumb && !context._normalLayout) {
            coordinate = Math.max(coordinate, trackStart);
            coordinate = Math.min(coordinate, trackEnd, staticThumbOffset);
        }
        else {
            coordinate = Math.max(coordinate, trackStart, staticThumbOffset);
            coordinate = Math.min(coordinate, trackEnd);
        }

        return coordinate;
    }

    updateFillSizeAndPosition(size, margin, newValue, updateTooltip, changeValue) {
        const context = this.context,
            fillStyle = context.$.fill.style,
            dimension = context._settings.dimension,
            offset = context._settings.offset,
            halfThumbSize = context._measurements.halfThumbSize;
        let thumbOffset, secondThumbOffset;

        if (context._movedThumb === context.$.thumb) {
            thumbOffset = size - halfThumbSize;
            secondThumbOffset = context._firstPassSize !== undefined ? (context._firstPassSize - halfThumbSize) : context.$.secondThumb[offset];
        }
        else {
            thumbOffset = context._firstPassSize !== undefined ? (context._firstPassSize - halfThumbSize) : context.$.thumb[offset];
            secondThumbOffset = size - halfThumbSize;
        }

        if (context._normalLayout) {
            fillStyle[dimension] = Math.max(0, (secondThumbOffset - thumbOffset)) + 'px';
            fillStyle[margin] = (thumbOffset + halfThumbSize) + 'px';
        }
        else {
            fillStyle[dimension] = Math.max(0, (thumbOffset - secondThumbOffset)) + 'px';
            fillStyle[margin] = (secondThumbOffset + halfThumbSize) + 'px';
        }

        if (updateTooltip) {
            const numericProcessor = context._numericProcessor,
                index = context._movedThumb === context.$.thumb ? 0 : 1,
                oldValue = context.values[index],
                oldValues = context._getEventValue(oldValue, index);
            if (numericProcessor.compare(numericProcessor.createDescriptor(newValue), numericProcessor.createDescriptor(oldValue))) {
                const updatedValues = context.values.slice(0);
                updatedValues[index] = newValue.toString();
                this.updateTooltipValue(newValue, index);

                if (changeValue) {
                    let finalUpdatedValues;

                    this.updateDrawValues(updatedValues);

                    if (context._valuesNoRangeValidation) {
                        finalUpdatedValues = [context._valuesNoRangeValidation[0].toString(), context._valuesNoRangeValidation[1].toString()];
                    }
                    else {
                        finalUpdatedValues = updatedValues;
                    }

                    if (context.mode === 'date') {
                        context._valueDate = [
                            JQX.Utilities.DateTime.fromFullTimeStamp(updatedValues[0]),
                            JQX.Utilities.DateTime.fromFullTimeStamp(updatedValues[1])
                        ];
                    }

                    context.values = finalUpdatedValues;

                    delete context._valueBeforeCoercion;
                    if (context._programmaticValueIsSet !== true) {
                        const newValues = context._getEventValue();

                        //Update hidden input
                        context.$.hiddenInput.value = newValues;

                        context.$.fireEvent('change', { 'value': newValues, 'oldValue': oldValues });
                    }
                }
            }
        }
    }

    updateDrawValues(values) {
        const context = this.context;

        if (context.logarithmicScale) {
            context._drawValues[0] = Math.log10(values[0]);
            context._drawValues[1] = Math.log10(values[1]);
        }
        else {
            context._drawValues = values.slice(0);
        }
    }

    updateTooltipValue(newValue, index) {
        const context = this.context;
        if (newValue === undefined) {
            const values = context.values,
                formattedFirstValue = context._formatLabel(values[0]),
                formattedSecondValue = context._formatLabel(values[1]);

            if (context.$.tooltipContent.innerHTML !== formattedFirstValue) {
                context.$.tooltipContent.innerHTML = formattedFirstValue;
                context.$.thumbLabel.innerHTML = formattedFirstValue;
            }

            if (context.$.secondTooltipContent.innerHTML !== formattedSecondValue) {
                context.$.secondTooltipContent.innerHTML = formattedSecondValue;
            }
        }
        else {
            const formattedNewValue = context._formatLabel(newValue);

            if (index === 0 && context.$.tooltipContent.innerHTML !== formattedNewValue || index === undefined) {
                context.$.tooltipContent.innerHTML = formattedNewValue;
                context.$.thumbLabel.innerHTML = formattedNewValue;
            }

            if (index === 1 && context.$.secondTooltipContent.innerHTML !== formattedNewValue || index === undefined) {
                context.$.secondTooltipContent.innerHTML = formattedNewValue;
                context.$.secondThumbLabel.innerHTML = formattedNewValue;
            }
        }
    }

    updateValue(values) {
        const context = this.context,
            renderedValues = [];
        let changedIndex;

        renderedValues[0] = context._numericProcessor.createDescriptor(values[0], true, false);
        renderedValues[1] = context._numericProcessor.createDescriptor(values[1], true, false);

        this.updateDrawValues(renderedValues);

        if (context._movedThumb === context.$.secondThumb) {
            changedIndex = 1;
        }

        this.moveThumbBasedOnValue(context._drawValues.slice(0), changedIndex);
    }

    validate(initialValidation, programmaticValue, programmaticValueIsSet) {
        const context = this.context,
            numericProcessor = context._numericProcessor;
        let validNumbers = [],
            values;

        context._programmaticValueIsSet = programmaticValueIsSet && context.validation === 'interaction';

        if (initialValidation) {
            values = context.values.slice(0);
        }
        else {
            values = programmaticValue;
        }

        if (context.coerce) {
            values[0] = numericProcessor.createDescriptor(values[0], true, true, true);
            values[1] = numericProcessor.createDescriptor(values[1], true, true, true);
        }

        if (context.logarithmicScale) {
            values = this.getCoercedLogarithmicValue(values);
        }
        else {
            values[0] = numericProcessor.getCoercedValue(values[0]);
            values[1] = numericProcessor.getCoercedValue(values[1]);
        }

        context._valuesNoRangeValidation = [];
        context._valuesNoRangeValidation[0] = numericProcessor.createDescriptor(values[0], true, true, false);
        context._valuesNoRangeValidation[1] = numericProcessor.createDescriptor(values[1], true, true, false);

        context._numericProcessor.restrictValue(context._valuesNoRangeValidation);

        validNumbers[0] = numericProcessor.validate(context._valuesNoRangeValidation[0], context._minObject, context._maxObject);
        validNumbers[1] = numericProcessor.validate(context._valuesNoRangeValidation[1], context._minObject, context._maxObject);

        if (initialValidation) {
            context._drawValues = [];
            this.updateDrawValues(validNumbers);

            values = [context._valuesNoRangeValidation[0].toString(), context._valuesNoRangeValidation[1].toString()];

            if (context.mode === 'date') {
                context._valueDate = [
                    JQX.Utilities.DateTime.fromFullTimeStamp(validNumbers[0]),
                    JQX.Utilities.DateTime.fromFullTimeStamp(validNumbers[1])
                ];
            }

            context.values = values;

            this.moveThumbBasedOnValue(context._drawValues, undefined, true);
        }
        else {
            this.updateValue(validNumbers);
        }

        delete context._valuesNoRangeValidation;
        context._programmaticValueIsSet = false;
    }
});

/**
 * Accordion item custom element.
 */
JQX('jqx-accordion-item', class AccordionItem extends JQX.ContentElement {
    // Accordion item's properties.
    static get properties() {
        return {
            'dragged': {
                value: false,
                type: 'boolean'
            },
            'expanded': {
                value: false,
                type: 'boolean'
            },
            'focused': {
                value: false,
                type: 'boolean'
            },
            'index': {
                value: null,
                type: 'number?'
            },
            'label': {
                value: '',
                type: 'string'
            }
        };
    }

    get enableShadowDOM() {
        return false;
    }

    /**
     * Accordion item's event listeners.
     */
    static get listeners() {
        return {
            'accordionItemHeader.mouseenter': '_headerMouseEnterHandler',
            'accordionItemHeader.mouseleave': '_headerMouseLeaveHandler',
            'accordionItemHeader.down': '_ripple'
        };
    }

    /**
     * Expander item's HTML template.
     */
    template() {
        return `<div id="container">
                    <div id="accordionItemHeader" class ="jqx-accordion-item-header jqx-unselectable">
                        <span id="arrow" class ="jqx-arrow"></span>
                        <span id="label" class ="jqx-label" inner-h-t-m-l='[[label]]'></span>
                    </div>
                    <div id="accordionItemContent" class ="jqx-accordion-item-content">
                        <div id="contentContainer" class ="jqx-content-container"><content></content></div>
                    </div>
                </div>`;
    }

    /**
     * Called when a property is changed.
     */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        oldValue = parseInt(oldValue);
        newValue = parseInt(newValue);

        if (propertyName !== 'index' || isNaN(oldValue) || isNaN(newValue)) {
            return;
        }

        const that = this,
            allSiblingsCount = that.parentElement.parentElement._items.length;

        if (newValue < 0) {
            newValue = 0;
        }
        else if (newValue >= allSiblingsCount) {
            newValue = allSiblingsCount - 1;
        }

        if (newValue !== oldValue) {
            that.$.fireEvent('indexChange', { 'newIndex': newValue, 'oldIndex': oldValue });
        }

        that.index = newValue;
    }

    /**
    * Accordion's header onMouseEnter handler.
    **/
    _headerMouseEnterHandler() {
        const that = this;

        if (that.disabled) {
            return;
        }

        that.setAttribute('hovered', '');
    }

    /**
    * Accordion's header onMouseLeave handler.
    **/
    _headerMouseLeaveHandler() {
        const that = this;

        if (that.disabled) {
            return;
        }

        that.removeAttribute('hovered');
    }

    /**
   * Accordion's material ripple effect
   **/
    _ripple(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        if (that.hasRippleAnimation) {
            JQX.Utilities.Animation.Ripple.animate(that.$.container, event.pageX, event.pageY);
        }
    }

    /**
     * Sets the index without "propertyChangedHandler" being called
     */
    _setIndex(index) {
        const that = this,
            oldContext = that.context;

        that.context = that;
        that.index = index;
        that.context = oldContext;
    }
});


/**
* Accordion custom element.
*/
JQX('jqx-accordion', class Accordion extends JQX.BaseElement {
    /** 
    * Accordion's properties 
    **/
    static get properties() {
        return {
            'expandedIndexes': {
                value: [],
                type: 'array'
            },
            'expandMode': {
                allowedValues: ['single', 'singleFitHeight', 'multiple', 'toggle', 'none'],
                value: 'singleFitHeight',
                type: 'string'
            },
            'messages': {
                extend: true,
                value: {
                    'en': {
                        'accordionItemRequired': '{{elementType}}: "{{method}}" requires an item from type "jqx-accordion-item".',
                        'indexOutOfBound': '{{elementType}}: Out of bound index/indexes in "{{method}}" method.',
                        'invalidSettings': '{{elementType}}: "{{method}}" method accepts a string or an object as it\'s second parameter.',
                        'missingReference': '{{elementType}}: Missing reference to {{files}}.',
                        'noItems': '{{elementType}}: No child elements found.',
                        'overridingProperties': '{{elementType}}: Overriding properties {{property1}} and {{property2}} applied. The "{{property1}}" property is used by default.'
                    }
                },
                type: 'object'
            },
            'reorder': {
                value: false,
                type: 'boolean'
            }
        }
    }

    /**
     * Accordion's event listeners.
     */
    static get listeners() {
        return {
            'down': '_downHandler',
            'focus': '_focusHandler',
            'indexChange': '_indexChangeHandler',
            'keydown': '_keyDownHandler',
            'move': '_moveHandler',
            'resize': '_resizeHandler',
            'styleChanged': '_resizeHandler',
            'document.up': '_upHandler'
        };
    }

    /**
    * Accordion's HTML template.
    */
    template() {
        return `<div id="container">
                    <content></content>
                </div>`;
    }

    /**
    * CSS files needed for the element (ShadowDOM)
    */
    static get styleUrls() {
        return [
            'jqx.accordion.css'
        ]
    }

    /**
    * Called when the element is ready. Used for one-time configuration of the Accordion.
    */
    ready() {
        super.ready();
        const that = this;

        that._createElement();
    }

    /**
   * Updates the accordion when a property is changed.
   * @param {string} propertyName The name of the property.
   * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
   * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
   */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        if (propertyName === 'expandedIndexes') {
            if (oldValue.toString() === newValue.toString()) {
                return;
            }

            let sanitizedNewValue = [];

            if (that._items.length > 0) {
                for (let i = 0; i < newValue.length; i++) {
                    let sanitizedNewValueSingleItem = parseInt(newValue[i]);

                    if (!isNaN(sanitizedNewValueSingleItem)) {
                        if (that._expandModeIs(['single', 'singleFitHeight', 'toggle'])) {
                            if ((sanitizedNewValue.length < 1) && (sanitizedNewValueSingleItem >= 0 && sanitizedNewValueSingleItem < that._items.length)) {
                                sanitizedNewValue.push(sanitizedNewValueSingleItem);
                            }

                            break;
                        }
                        else {
                            if (sanitizedNewValueSingleItem >= 0 && sanitizedNewValueSingleItem <= that._items.length && sanitizedNewValue.indexOf(sanitizedNewValueSingleItem) === -1) {
                                sanitizedNewValue.push(sanitizedNewValueSingleItem);
                            }
                        }
                    }
                }
            }

            if (sanitizedNewValue.length === 0 && that._expandModeIs(['single', 'singleFitHeight'])) {
                newValue = oldValue.slice();
                that.expandedIndexes = newValue;

                return;
            }

            newValue = sanitizedNewValue;

            const indexes = that._compareExpandedIndexes(oldValue, newValue);

            that._toggleItems('collapse', indexes.collapse);
            that._toggleItems('expand', indexes.expand);

            that.expandedIndexes = newValue;

            return;
        }

        super.propertyChangedHandler(propertyName, oldValue, newValue);

        switch (propertyName) {
            case 'disabled':
                that._setFocusable();
                that._enableDisableHandler();
                break;
            case 'expandMode':
                if (that._items.length === 0) {
                    break;
                }

                if ((oldValue === 'multiple' && newValue !== 'none') || (oldValue === 'none' && newValue !== 'multiple')) {
                    const indexesToCollapse = that.expandedIndexes.slice(1);

                    that._toggleItems('collapse', indexesToCollapse);

                    if (that.expandedIndexes.length === 0 && that._expandModeIs(['single', 'singleFitHeight'])) {
                        expandFirstItem();
                    }
                }
                else if (oldValue === 'toggle' && that._expandModeIs(['single', 'singleFitHeight']) && that.expandedIndexes.length === 0) {
                    expandFirstItem();
                }

                if (!that._supportCSSVariables || !that._usedCSSVariables) {
                    const expandedIndex = that.expandedIndexes[0];

                    if (oldValue === 'singleFitHeight') {
                        that._items[expandedIndex].$.accordionItemContent.style.height = '';
                    }
                    else if (newValue === 'singleFitHeight') {
                        that._items[expandedIndex].$.accordionItemContent.style.height = (that._expandedItemsContainerHeight - 1) + 'px';
                    }
                }
                break;
            case 'unfocusable':
                that._setFocusable();
                break;
            default:
                break;
        }

        function expandFirstItem() {
            that._toggleItems('expand', [0]);
            that.expandedIndexes = [0];
        }
    }

    /**
    * Appends a "jqx-accordion-item" node as the last position.
    */
    appendChild(node) {
        const that = this;

        if (!that.isCompleted || node instanceof HTMLElement && (node.classList.contains('jqx-resize-trigger-container') || node.classList.contains('jqx-measure-element'))) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!(node instanceof JQX.AccordionItem)) {
            that.error(that.localize('accordionItemRequired', { method: 'appendChild' }));
        }

        that.insert(that._items.length, node);
    }

    /**
    * Collapse method. Collapses selected item
    */
    collapse(index, programmaticUse) {
        const that = this;

        index = that._validateItemsIndex(index, 'collapse');

        if (isNaN(index)) {
            return;
        }

        const isExpanded = that._items[index].expanded;

        if ((!isExpanded) || (that._expandModeIs(['single', 'singleFitHeight']) && that.expandedIndexes.indexOf(index) > -1)) {
            return;
        }

        that._collapseItem(index, programmaticUse);
    }

    /**
    * Expand method.
    */
    expand(index, programmaticUse) {
        const that = this;

        index = that._validateItemsIndex(index, 'expand');

        if (isNaN(index)) {
            return;
        }

        const isExpanded = that._items[index].expanded;

        if (isExpanded) {
            return;
        }

        if (that._expandModeIs(['single', 'singleFitHeight', 'toggle'])) {
            that._toggleItems('collapse', that.expandedIndexes);
        }

        that._expandItem(index, programmaticUse);
    }

    /**
    * Inserts items in specific position. It has two parameters - index and item(items).
    */
    insert(index, items) {
        const that = this,
            accordionWasEmpty = that._items.length === 0;
        let item,
            fragment;

        if (!items) {
            if (typeof index === 'number') {
                items = [{ label: '', content: '' }];
            }
            else {
                items = [{ label: index ? index.toString() : '', content: index ? index.toString() : '' }];
                index = 0;
            }
        }

        if (items instanceof HTMLElement) {
            if (!(items instanceof JQX.AccordionItem)) {
                that.error(that.localize('accordionItemRequired', { method: 'insert' }));
            }
            else {
                item = items;
            }
        }
        else if (Array.isArray(items)) {
            fragment = document.createDocumentFragment();

            for (let i = 0; i < items.length; i++) {
                const fragmentItem = that._createItem(items[i]);

                fragment.appendChild(fragmentItem);
            }
        }
        else if (items instanceof Object) {
            item = that._createItem(items);
        }
        else if (typeof items === 'string' || typeof items === 'number') {
            item = that._createItem({ label: items.toString(), content: items.toString() });
        }
        else {
            item = that._createItem({ label: '', content: '' });
        }

        if (index > that._items.length) {
            item ? that.$.container.appendChild(item) : that.$.container.appendChild(fragment);
        }
        else {
            item ? that.$.container.insertBefore(item, that._items[index]) : that.$.container.insertBefore(fragment, that._items[index]);
        }

        item && (item.tabIndex = that._tabIndex);
        that._storeItems();

        if (accordionWasEmpty && that._expandModeIs(['single', 'singleFitHeight'])) {
            that._expandItem(0);
        }
        else {
            that.expandedIndexes = that._getExpandedIndexes();
        }

        that._updateExpanedContentHeight();
        that._updateInlineHeight();
        that._storeItemsCoordinates();

        that._updateItemsIndexProperty();
    }

    /**
     * Inserts the specified "jqx-accordion-item" node before the reference "jqx-accordion-item" node.
     */
    insertBefore(newNode, referenceNode) {
        const that = this;

        if (!that.isCompleted) {
            const args = Array.prototype.slice.call(arguments, 2);

            return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (newNode === undefined || referenceNode === undefined || !(newNode instanceof JQX.AccordionItem) || !(referenceNode instanceof JQX.AccordionItem)) {
            that.error(that.localize('accordionItemRequired', { method: 'insertBefore' }));
        }

        if (referenceNode !== undefined && referenceNode !== null) {
            if (!that.contains(referenceNode)) {
                that.error(that.localize('referenceNodeNotChild', { argument: 'referenceNode' }));
            }

            that.insert(that._items.indexOf(referenceNode), newNode);
        }
        else {
            that.insert(that._items.indexOf(referenceNode), newNode);
        }
    }

    /**
    * Removes an item on specific positions or "jqx-accordion-item" child node.
    */
    remove(index) {
        const that = this;
        let item;

        if (index instanceof HTMLElement) {
            if (!(index instanceof JQX.AccordionItem)) {
                that.error(that.localize('accordionItemRequired', { method: 'remove' }));
            }
            else if (!that.contains(index)) {
                that.error(that.localize('referenceNodeNotChild', { argument: 'node' }));
            }

            item = index;
            index = item.index;
        }
        else {
            index = that._validateItemsIndex(index, 'remove');

            if (isNaN(index)) {
                return;
            }

            item = that._items[index];
        }

        if (item) {
            item.parentNode.removeChild(item);
            that._storeItems();

            if (that._expandModeIs(['singleFitHeight'])) {
                that._preventAnimation = true;
            }

            if (that._expandModeIs(['single', 'singleFitHeight']) && index === that.expandedIndexes[0] && that._items.length > 0) {
                that._expandItem(0);
                that._selectedItem = that._items[0];
                that._selectedItemIndex = 0;
                that._itemIsFocussed = true;
            }

            that.expandedIndexes = that._getExpandedIndexes();
            that._updateExpanedContentHeight();
            that._updateInlineHeight();
            that._storeItemsCoordinates();

            that._updateItemsIndexProperty();
        }
    }

    /**
     * Removes a child "jqx-accordion-item" node.
     */
    removeChild(node) {
        const that = this;

        if (!that.isCompleted) {
            const args = Array.prototype.slice.call(arguments, 2);

            return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!(node instanceof HTMLElement)) {
            that.error(that.localize('accordionItemRequired', { method: 'removeChild' }));
        }

        if (node.className === 'jqx-resize-trigger-container') {
            super.removeChild(node);
            return;
        }
        else if (!(node instanceof JQX.AccordionItem)) {
            that.error(that.localize('accordionItemRequired', { method: 'removeChild' }));
        }

        if (!that.contains(node)) {
            that.error(that.localize('referenceNodeNotChild', { argument: 'node' }));
        }

        that.remove(node);
    }

    /**
   * Sets tabIndex.
   */
    _setFocusable() {
        const that = this;

        if (that.disabled || that.unfocusable) {
            that.removeAttribute('tabindex');
            for (let i = 0; i < that._items.length; i++) {
                that._items[i].removeAttribute('tabindex');
            }
            return;
        }

        that.tabIndex = that._tabIndex;

        for (let i = 0; i < that._items.length; i++) {
            that._items[i].tabIndex = that._tabIndex;
        }
    }

    /**
    * Updates an item at a specific index. It has two parameters - index and item.
    */
    update(index, settings) {
        const that = this;

        index = that._validateItemsIndex(index, 'update');

        if (isNaN(index)) {
            return;
        }

        let item = that._items[index];

        if (!settings) {
            that.error(that.localize('invalidSettings', { elementType: that.nodeName.toLowerCase(), method: 'update' }));
        }

        if (item) {
            if (Array.isArray(settings)) {
                if (settings.length === 0) {
                    settings = { 'label': '', 'content': '' }
                }
                else {
                    settings = settings[0];
                }
            }

            if (typeof settings === 'string') {
                item.content = settings;
            }
            else {
                for (let property in settings) {
                    item[property] = settings[property];
                }
            }
        }

        const height = that._getItemsHeights(index);

        that._updateExpanedContentLocalHeight(that._items[index], height);
        that._updateInlineHeight();
        that._storeItemsCoordinates();
    }

    /**
    * Calculates item container's height if items are with set margins
    */
    _adjustHeightValue(currentHeight) {
        const that = this,
            itemsCount = that._items.length;
        let expandedItem, collapsedItem;

        for (let i = 0; i < itemsCount; i++) {
            that._items[i].expanded ? expandedItem = that._items[i] : collapsedItem = that._items[i];

            if (expandedItem && collapsedItem) {
                break;
            }
        }

        if (!expandedItem) {
            expandedItem = that._items[0];
        }

        if (!expandedItem && !collapsedItem) {
            return;
        }

        const expandedItemState = expandedItem.expanded;

        expandedItem.expanded = true;

        const expandedStyles = window.getComputedStyle(expandedItem, null),
            collapsedStyles = collapsedItem ? window.getComputedStyle(collapsedItem, null) : false,
            expandedOffset = parseInt(expandedStyles.getPropertyValue('margin-top')) + parseInt(expandedStyles.getPropertyValue('margin-bottom')),
            collapsedOffset = collapsedStyles ? parseInt(collapsedStyles.getPropertyValue('margin-top')) + parseInt(collapsedStyles.getPropertyValue('margin-bottom')) : 0;

        expandedItem.expanded = expandedItemState;

        return (currentHeight - ((itemsCount - 1) * collapsedOffset + expandedOffset));
    }

    /**
    * Collapses item with specific index.
    */
    _collapseItem(index, programmaticUse) {
        const that = this;
        let item = that._items[index];

        if (!item.expanded) {
            return;
        }

        if (that.expandMode === 'none' && programmaticUse) {
            return;
        }

        item.expanded = false;
        that.$.fireEvent('collapsing', {
            'index': index,
            'label': item.label,
            'content': item.content.innerHTML
        });

        if (that.expandedIndexes.indexOf(index) > -1) {
            let positionInExpandedIndexes = that.expandedIndexes.indexOf(index),
                currentIndexes = that.expandedIndexes.slice();

            currentIndexes.splice(positionInExpandedIndexes, 1);
            that.expandedIndexes = currentIndexes;
        }

        item.$.accordionItemContent.style.height = '';
        that._handleAnimationsDuration(item, index, 'collapsed');
    }

    /**
    * Compares arrays with old and new indexes. Returns which items have to be collapsed and which have to be expanded
    */
    _compareExpandedIndexes(oldIndexes, newIndexes) {
        let indexesToBeCollapsed = [],
            commonIndexes = [],
            indexesToBeExpanded = [],
            oldIndexesCount = oldIndexes.length,
            newIndexesCount = newIndexes.length;

        for (let i = 0; i < oldIndexesCount; i++) {
            if (newIndexes.indexOf(oldIndexes[i]) === -1) {
                if (indexesToBeCollapsed.indexOf(oldIndexes[i]) === -1) {
                    indexesToBeCollapsed.push(oldIndexes[i]);
                }
            }
            else {
                if (commonIndexes.indexOf(oldIndexes[i]) === -1) {
                    commonIndexes.push(oldIndexes[i]);
                }
            }
        }

        for (let i = 0; i < newIndexesCount; i++) {
            if (commonIndexes.indexOf(newIndexes[i]) === -1) {
                indexesToBeExpanded.push(newIndexes[i]);
            }
        }

        return { collapse: indexesToBeCollapsed, expand: indexesToBeExpanded };
    }

    /**
    * Initializes the element. Used as a callback in ready().
    */
    _createElement() {
        const that = this;

        that._reorderItemsByIndex();
        that._usedCSSVariables = Boolean(window.getComputedStyle(that.$.container).getPropertyValue('--jqx-accordion-animation-duration'));
        that._supportCSSVariables = JQX.Utilities.Core.CSSVariablesSupport();
        that._storeItems();
        that._enableDisableHandler();
        that._expandedIndexesHandler();
        that._updateExpanedContentHeight();
        that._tabIndex = that.tabIndex <= 0 ? 0 : that.tabIndex;
        that._setFocusable();
        that._updateItemsIndexProperty();
        that._updateInlineHeight();

        for (let i = 0; i < that._items.length; i++) {
            that._items[i].$.arrow.classList.add('jqx-animate-trigger');
        }
    }

    /**
     * Creates single jqx-accordion-item
     */
    _createItem(settings) {
        const that = this,
            item = document.createElement('jqx-accordion-item');

        if (!settings) {
            return;
        }

        item.disabled = that.disabled;

        if (that._tabIndex > -1) {
            item.tabIndex = that._tabIndex;
        }

        if (typeof settings === 'string' || typeof settings === 'number') {
            item.label = settings + '';
            item.content = settings + '';

            return item;
        }

        item.label = settings.label || '';
        item.content = settings.content || '';

        return item;
    }

    /**
    * Down Handler
    */
    _downHandler(event) {
        const that = this;

        if (that.disabled || that.readonly || that.expandMode === 'none' || that._toggled) {
            return;
        }

        const target = that.enableShadowDOM ? that.shadowRoot.elementFromPoint(event.pageX, event.pageY) : event.originalEvent.target,
            clickedHeader = target.closest('.jqx-accordion-item-header');
        const item = target.closest('jqx-accordion-item');

        if (!clickedHeader) {
            if (item) {
                item.focused = true;
            }

            return;
        }

        that._selectedItem = item;
        that._itemIsPressed = that._itemIsFocussed = true;
        that._reorderedIndex = that._selectedItemIndex = that._items.indexOf(item);

        that._storeItemsCoordinates();
    }

    /**
    * Changes disable state of the internal items.
    */
    _enableDisableHandler() {
        const that = this;

        if (that.disabled) {
            for (let i = 0; i < that._items.length; i++) {
                that._items[i].disabled = true;
            }
        }
        else {
            for (let i = 0; i < that._items.length; i++) {
                that._items[i].disabled = false;
            }
        }
    }

    /**
    * Handles expanded indexes on initialization, according to the chosen 'expandMode'.
    */
    _expandedIndexesHandler() {
        const that = this;
        let initialExpandedIndexes = that._getExpandedIndexes('initial'),
            initialExpandedIndexesCount = initialExpandedIndexes.length,
            expandedIndexesCount = that.expandedIndexes.length;

        if (that._items.length === 0) {
            return;
        }

        if (expandedIndexesCount === 0 && initialExpandedIndexesCount > 0) {
            that.expandedIndexes = initialExpandedIndexes;
            expandedIndexesCount = initialExpandedIndexesCount;
        }

        if (that._expandModeIs(['multiple', 'none']) || expandedIndexesCount === 1) {
            that._toggleItems('expand', that.expandedIndexes);
            return;
        }

        switch (that.expandMode) {
            case 'single':
            case 'singleFitHeight':
                if (expandedIndexesCount === 0) {
                    that._toggleItems('expand', [0]);
                }
                else if (expandedIndexesCount > 1) {
                    that._toggleItems('collapse', that.expandedIndexes.splice(0, 1));
                    that._toggleItems('expand', that.expandedIndexes);
                }
                break;
            case 'toggle':
                if (expandedIndexesCount > 1) {
                    that._toggleItems('collapse', that.expandedIndexes.splice(0, 1));
                    that._toggleItems('expand', that.expandedIndexes);
                }
                break;
            default:
                break;
        }
    }

    /**
    * Expands item with specific index.
    */
    _expandItem(index, programmaticUse) {
        const that = this;
        let item = that._items[index];

        if (item.expanded || (that.expandMode === 'none' && programmaticUse)) {
            return;
        }

        if (!item.$.container.style.getPropertyValue('--jqx-accordion-expanded-content-local-height')) {
            item.expanded = true;
            item.$.container.style.setProperty('--jqx-accordion-expanded-content-local-height', item.$.accordionItemContent.scrollHeight + 'px');
            item.expanded = false;
        }

        item.expanded = true;
        that.$.fireEvent('expanding', {
            'index': index,
            'label': item.label,
            'content': item.content.innerHTML
        });

        if (that.expandedIndexes.indexOf(index) === -1) {
            let currentIndexes = that.expandedIndexes.slice();

            currentIndexes.push(index);
            that.expandedIndexes = currentIndexes;
        }

        

        if ((!that._supportCSSVariables || !that._usedCSSVariables) && that.expandMode === 'singleFitHeight') {
            item.$.accordionItemContent.style.height = (that._expandedItemsContainerHeight - 1) + 'px';
        }

        that._handleAnimationsDuration(item, index, 'expanded');
    }

    /**
    * Check if current expand mode is one of the following.
    */
    _expandModeIs(modesArray) {
        const that = this;

        return modesArray.indexOf(that.expandMode) > -1;
    }

    /**
     * Focus handler.  Sets the focused state of particular item
     */
    _focusHandler() {
        const that = this;

        if (that.disabled || that._items.length === 0) {
            return;
        }

        if (that._itemIsFocussed) {
            that._selectedItem.focused = false;
        }
        else {
            that._items[0].focused = false;
        }
    }

    /**
    * Gets the indexes of all expanded items.
    */
    _getExpandedIndexes(type) {
        const that = this,
            expandedIndexes = [];

        for (let i = 0; i < that._items.length; i++) {
            if (type === 'initial') {
                if (that._items[i].hasAttribute('expanded')) {
                    expandedIndexes.push(i);
                    that._items[i].removeAttribute('expanded');
                }
            }
            else {
                if (that._items[i].expanded) {
                    expandedIndexes.push(i);
                }
            }
        }

        return expandedIndexes.slice();
    }

    /**
   * Gets the height of each item. Calculates it via dummy element
   */

    _getItemsHeights(itemIndex) {
        const that = this,
            items = that._items,
            itemsCount = items.length;
        let itemsHeights = [];

        if (itemsCount === 0) {
            return;
        }

        if (!isNaN(itemIndex) && itemIndex >= 0 && itemIndex < itemsCount) {
            const item = items[itemIndex];
            let height = 0;

            if (item.expanded) {
                height = item.$.accordionItemContent.scrollHeight;
            }
            else {
                item.expanded = true;
                height = item.$.accordionItemContent.scrollHeight;
                item.expanded = false;
            }

            return (height + 'px');
        }

        for (let i = 0; i < itemsCount; i++) {
            const item = items[i];
            let height = 0;

            if (item.expanded) {
                height = item.$.accordionItemContent.scrollHeight;
            }
            else {
                item.expanded = true;
                height = item.$.accordionItemContent.scrollHeight;
                item.expanded = false;
            }

            itemsHeights.push(height + 'px');
        }

        that._heightCalcAfterInitialization = true;

        return itemsHeights;
    }

    /**
    * Adds jqx-toggle class for the period of the animation and fires an event at the end
    */
    _handleAnimationsDuration(item, index, type) {
        const that = this,
            intervalOffset = 50;

        if (!that._animationAfterInitialization) {
            that._animationAfterInitialization = true;
            return;
        }

        if (that._items.length === 1 && that.expandMode === 'singleFitHeight') {
            that.$.fireEvent(type, {
                'index': index,
                'label': item.label,
                'content': item.content.innerHTML
            });
            return;
        }

        if (false === that.hasAnimation || !that._supportCSSVariables) {
            that.$.fireEvent(type, {
                'index': index,
                'label': item.label,
                'content': item.content.innerHTML
            });
            return;
        }

        if (that._preventAnimation) {
            that.$.fireEvent(type, {
                'index': index,
                'label': item.label,
                'content': item.content.innerHTML
            });

            that._preventAnimation = false;
            return;
        }


        that._toggled = true;

        let animationDuration = window.getComputedStyle(that).animationDuration,
            animationDurationInMs;

        if (animationDuration.indexOf('ms') > -1) {
            animationDuration = parseFloat(animationDuration.substring(0, animationDuration.length - 2));
            animationDurationInMs = isNaN(animationDuration) || animationDuration < 0 ? 0 : animationDuration - intervalOffset;
        }
        else if (animationDuration.indexOf('s') > -1) {
            animationDuration = parseFloat(animationDuration.substring(0, animationDuration.length - 1));
            animationDurationInMs = isNaN(animationDuration) || animationDuration < 0 ? 0 : animationDuration * 1000 - intervalOffset;
        }
        else {
            that.$.fireEvent(type, {
                'index': index,
                'label': item.label,
                'content': item.content.innerHTML
            });
            return;
        }

        if (item instanceof JQX.AccordionItem) {
            item.$.addClass('jqx-toggled-item');
            that.$container.addClass('jqx-toggling');
            setTimeout(function () {
                item.$.removeClass('jqx-toggled-item');
                that.$container.removeClass('jqx-toggling');
                that.$.fireEvent(type, {
                    'index': index
                });

                that._toggled = false;
            }, animationDurationInMs);
        }
    }

    /**
    * Index change handler. Used when items are reordered via their indexes
    */
    _indexChangeHandler(event) {
        const that = this,
            items = that._items,
            itemsCount = items.length,
            detail = event.detail;

        if (detail.newIndex >= itemsCount) {
            that.$.container.appendChild(items[detail.oldIndex]);
        }
        else {
            detail.newIndex > detail.oldIndex ? that.$.container.insertBefore(items[detail.oldIndex], items[detail.newIndex + 1]) : that.$.container.insertBefore(items[detail.oldIndex], items[detail.newIndex]);
        }

        let itemsReordered = that.enableShadowDOM ? that.shadowRoot.querySelectorAll('jqx-accordion-item') : that.getElementsByTagName('jqx-accordion-item');

        that._items = Array.from(itemsReordered);
        that._updateItemsIndexProperty();
    }

    /**
    * KeyDown handler. Navigation between the items via arrows, home, end keys
    */
    _keyDownHandler(event) {
        const that = this,
            keyCode = event.key;

        if (that.expandMode === 'none' || that.disabled || that.readonly || that._toggled) {
            return;
        }

        if (['ArrowLeft', 'ArrowDown', 'ArrowRight', 'ArrowUp', 'End', 'Home', ' ', 'Enter', 'Tab'].indexOf(keyCode) === -1 || !(document.activeElement instanceof JQX.AccordionItem)) {
            return;
        }

        if (keyCode !== 'Tab') {
            event.preventDefault();
        }

        let selectedItem,
            selectedIndex,
            itemsCount = that._items.length,
            lastItemPosition = itemsCount - 1;

        for (let i = 0; i < itemsCount; i++) {
            let item = that._items[i];

            if (item.focused) {
                selectedItem = item;
                selectedIndex = i;
            }
        }

        switch (keyCode) {
            case 'Tab':
                event.shiftKey ? moveSelection('up') : moveSelection('down');
                break;
            case 'ArrowLeft':
                that.collapse(selectedIndex);
                break;
            case 'ArrowDown':
                moveSelection('down');
                break;
            case 'ArrowRight':
                that.expand(selectedIndex);
                break;
            case 'ArrowUp':
                moveSelection('up');
                break;
            case 'End':
                updateSelectedItem(lastItemPosition);
                break;
            case 'Home':
                updateSelectedItem(0);
                break;
            case ' ':
            case 'Enter':
                if (selectedItem.expanded) {
                    that.collapse(selectedIndex);
                    return
                }

                that.expand(selectedIndex);
                break;
            default:
                return;
        }

        function updateSelectedItem(index) {
            if (index === selectedIndex || isNaN(index)) {
                return;
            }

            selectedItem.focused = false;
            selectedIndex = index;
            selectedItem = that._items[selectedIndex];
            selectedItem.focused = true;
        }

        function moveSelection(direction) {
            if (direction === 'up') {
                (selectedIndex - 1) < 0 ? updateSelectedItem(0) : updateSelectedItem(selectedIndex - 1);
                return;
            }

            (selectedIndex + 1) > lastItemPosition ? updateSelectedItem(lastItemPosition) : updateSelectedItem(selectedIndex + 1);
        }
    }

    /**
    * Accordion's move handler. Used in reorder functionality
    */
    _moveHandler(event) {
        const that = this;

        if (!that._itemIsPressed || !that.reorder || that.readonly || that._items.length < 2) {
            return;
        }

        if (that._dragStart) {
            that.$container.addClass('jqx-reordering');

            if (!that._dragging) {
                const item = that._selectedItem;

                that.$.fireEvent('dragStart', {
                    'position': { left: event.pageX, top: event.pageY },
                    'target': event.originalEvent.target,
                    'index': that._selectedItemIndex,
                    'label': item.label,
                    'content': item.content.innerHTML
                });

                that._selectedItem.dragged = that._dragging = true;
            }

            const mouseCoordinate = event.clientY;
            let inItem = false;

            for (let i = 0; i < that._itemsCoordinates.length; i++) {
                const currentCoordinateSet = that._itemsCoordinates[i];

                if (mouseCoordinate >= currentCoordinateSet.fromY && mouseCoordinate <= currentCoordinateSet.toY) {
                    inItem = i;
                    break;
                }
            }

            if (that._preventReorder !== true && inItem !== false && inItem !== that._reorderedIndex) {
                if (Math.abs(that._reorderedIndex - inItem) > 1) {
                    const indexOffset = that._reorderedIndex - inItem < 0 ? -1 : 1;

                    that._swapItems(that._reorderedIndex, inItem + indexOffset);
                }

                that._swapItems(that._reorderedIndex, inItem);


                that._reorderedIndex = inItem;
                that._storeItemsCoordinates();
            }

            if (mouseCoordinate < that._itemsCoordinates[that._reorderedIndex].fromY || mouseCoordinate > that._itemsCoordinates[that._reorderedIndex].toY) {
                that._preventReorder = true;
            }
            else {
                that._preventReorder = false;
            }

            if (Math.abs(that._reorderedIndex - inItem) > 1) {
                that._preventReorder = false;
            }
        }
        else {
            that._dragStart = true;
        }
    }

    /**
    * Reorders the items by their indexes when the accordion is initialized.
    */
    _reorderItemsByIndex() {
        const that = this;
        let items = that.enableShadowDOM ? that.shadowRoot.querySelectorAll('jqx-accordion-item') : that.getElementsByTagName('jqx-accordion-item'),
            itemsArray = Array.from(items),
            hasInitialIndexes = false,
            itemsIndexes = itemsArray.map(function (item) {
                if (item.index !== null) {
                    hasInitialIndexes = true;
                }
                else {
                    item.index = 0;
                }

                return item.index;
            });

        if (!hasInitialIndexes) {
            return;
        }

        const itemsCount = itemsArray.length;

        if (itemsCount < 2) {
            return;
        }

        let itemsIndexesSorted = itemsIndexes.slice();

        itemsIndexesSorted.sort(function (a, b) {
            return parseInt(a) - parseInt(b);
        });

        if (itemsIndexes.toString() === itemsIndexesSorted.toString()) {
            return;
        }

        for (let i = 0; i < itemsCount; i++) {
            let reorderedItem;

            for (let j = 0; j < itemsCount; j++) {
                if (items[j].index === itemsIndexesSorted[i]) {
                    reorderedItem = items[j];
                }
            }

            that.$.container.insertBefore(reorderedItem, items[i]);
        }
    }

    /**
    * Resize handler.
    */
    _resizeHandler() {
        const that = this;

        that._updateExpanedContentHeight();
        that._updateInlineHeight();
        that._storeItemsCoordinates();
    }

    /**
    * Stores all items in an Array and updates the animation variables.
    */
    _storeItems() {
        const that = this,
            items = that.enableShadowDOM ? that.shadowRoot.querySelectorAll('jqx-accordion-item') : that.getElementsByTagName('jqx-accordion-item');

        that._items = Array.from(items);

        if (that._items.length === 0) {
            that.$container.addClass('jqx-empty');
            return;
        }

        that.$container.removeClass('jqx-empty');

        const heights = that._getItemsHeights();

        for (let i = 0; i < that._items.length; i++) {
            that._updateExpanedContentLocalHeight(that._items[i], heights[i]);
        }
    }

    /**
     * Stores the coordinates of all items in an Array.
     */
    _storeItemsCoordinates() {
        const that = this;

        if (that.disabled || !that.reorder) {
            return;
        }

        const coordinates = [];

        for (let i = 0; i < that._items.length; i++) {
            const currentItemContainer = that._items[i],
                boundingClientRect = currentItemContainer.getBoundingClientRect();

            coordinates.push({
                fromY: boundingClientRect.top + (window.scrollY || window.pageYOffset),
                toY: boundingClientRect.bottom + (window.scrollY || window.pageYOffset)
            });
        }

        that._itemsCoordinates = coordinates;
    }

    /**
     * Switches the positions of two items.
     */
    _swapItems(firstItemIndex, secondItemIndex) {
        function swap(list, x, y) {
            const temp = list[y];

            list[y] = list[x];
            list[x] = temp;
        }

        const that = this,
            lesserIndex = Math.min(firstItemIndex, secondItemIndex),
            greaterIndex = Math.max(firstItemIndex, secondItemIndex),
            items = that._items;
        let expandedIndexes = that.expandedIndexes.slice();

        if (that._items[firstItemIndex].expanded && !that._items[secondItemIndex].expanded) {
            const indexPosition = expandedIndexes.indexOf(firstItemIndex);

            expandedIndexes[indexPosition] = secondItemIndex;
            that.expandedIndexes = expandedIndexes.slice();
        }
        else if (that._items[secondItemIndex].expanded && !that._items[firstItemIndex].expanded) {
            const indexPosition = expandedIndexes.indexOf(secondItemIndex);

            expandedIndexes[indexPosition] = firstItemIndex;
            that.expandedIndexes = expandedIndexes.slice();
        }

        that.selectedIndex = that.selectedIndex === firstItemIndex ? secondItemIndex : firstItemIndex;
        that.$.container.insertBefore(items[greaterIndex], items[lesserIndex]);
        swap(items, firstItemIndex, secondItemIndex);
        that._items[firstItemIndex].$.removeClass('hovered');

        that._reorderedIndex = secondItemIndex;
    }


    /**
    * Expands/collapses multiple items with particular indexes.
    */
    _toggleItems(action, indexes) {
        const that = this,
            indexesCount = indexes.length;

        if (indexesCount > 0) {
            for (let i = 0; i < indexesCount; i++) {
                that['_' + action + 'Item'](indexes[i]);
            }
        }
    }

    /**
    * Calculates item's content container height and apply it to the current expanded item. Used in singleFitHeight expandMode.
    */
    _updateExpanedContentHeight() {
        const that = this;

        that.$.container.style.setProperty('--jqx-accordion-item-header-height', '');

        const itemsCount = that._items.length,
            containersHeight = that.$.container.offsetHeight,
            expanedItem = that._items[that.expandedIndexes[0]];
        let collapsedItemHeight = 0,
            collapsedItemHeaderHeight = 0,
            expanedItemHeaderOffset = 0,
            i = 0;

        if (itemsCount === 1) {
            let item = that._items[0];

            item.expanded = false;
            collapsedItemHeight = item.offsetHeight;
            collapsedItemHeaderHeight = item.$.accordionItemHeader.offsetHeight;
            item.expanded = true;
        }
        else {
            while (collapsedItemHeight === 0 && i < itemsCount) {
                const item = that._items[i];

                if (item instanceof JQX.AccordionItem && !item.expanded) {
                    collapsedItemHeight = item.offsetHeight;
                    collapsedItemHeaderHeight = item.$.accordionItemHeader.offsetHeight;
                }

                i++;
            }
        }

        if (itemsCount > 1) {
            if (expanedItem instanceof JQX.AccordionItem) {
                const expandedItemHeaderHeight = expanedItem.$.accordionItemHeader.offsetHeight;

                expanedItemHeaderOffset = expandedItemHeaderHeight - collapsedItemHeaderHeight;
            }
        }

        const rootStyle = getComputedStyle(that.$.root);

        const collapsedItemsHeight = collapsedItemHeight * itemsCount;
        let expandedItemsContainerHeight = containersHeight - collapsedItemsHeight - expanedItemHeaderOffset - parseFloat(rootStyle.paddingBottom) - parseFloat(rootStyle.paddingTop);

        if (that.expandMode === 'singleFitHeight') {
            expandedItemsContainerHeight = that._adjustHeightValue(expandedItemsContainerHeight);
        }

        expandedItemsContainerHeight = expandedItemsContainerHeight >= 0 ? expandedItemsContainerHeight : 0;
        that.$.container.style.setProperty('--jqx-accordion-expanded-content-height', expandedItemsContainerHeight + 'px');
        that.$.container.style.setProperty('--jqx-accordion-item-header-height', collapsedItemHeaderHeight + 'px');
        that._expandedItemsContainerHeight = expandedItemsContainerHeight;
    }

    /**
    * Updates the local CSS variable about single item.
    */
    _updateExpanedContentLocalHeight(item, height) {
        const that = this;

        if (!that._supportCSSVariables || !that._usedCSSVariables) {
            return;
        }

        item.$.container.style.setProperty('--jqx-accordion-expanded-content-local-height', height);
    }


    /**
     * Updates inline height in 'singleFitHeight' mode in older browsers
     */
    _updateInlineHeight() {
        const that = this;

        if ((that._supportCSSVariables && that._usedCSSVariables) || that.expandMode !== 'singleFitHeight' || that._items.length === 0) {
            return;
        }

        that._items[that.expandedIndexes[0]].$.accordionItemContent.style.height = (that._expandedItemsContainerHeight - 1) + 'px';
    }

    /**
     * Updates the index property of all accordion items
     */
    _updateItemsIndexProperty() {
        const that = this;
        let newExpandedIndexes = [];

        for (let i = 0; i < that._items.length; i++) {
            that._items[i]._setIndex(i);

            if (that._items[i].expanded) {
                newExpandedIndexes.push(i);
            }
        }

        that.expandedIndexes = newExpandedIndexes.slice();
    }

    /**
     * Up handler.
     */
    _upHandler(event) {
        const that = this;

        if (!that._itemIsPressed || that.disabled || that.readonly) {
            return;
        }

        for (let i = 0; i < that._items.length; i++) {
            if (i !== that._selectedItemIndex) {
                that._items[i].focused = false;
            }
        }

        that._selectedItem.focused = true;

        if (!that._dragging) {
            if (that._selectedItem.expanded) {
                that.collapse(that._selectedItemIndex, true);
            }
            else {
                that.expand(that._selectedItemIndex, true);
            }
        }
        else {
            const item = that._selectedItem;

            that.$container.removeClass('jqx-reordering');
            that.$.fireEvent('dragEnd', {
                'position': { left: event.pageX, top: event.pageY },
                'target': event.originalEvent.target,
                'index': that._selectedItemIndex,
                'label': item.label,
                'content': item.content.innerHTML
            });
        }

        that._reorderedIndex = undefined;
        that._dragStart = false;
        that._dragging = false;
        that._itemIsPressed = false;
        that._selectedItem.dragged = false;

        that._updateItemsIndexProperty();
    }

    /**
    * Validates the values given to the expand and collapse methods.
    */
    _validateItemsIndex(index, method) {
        const that = this;

        if (isNaN(parseInt(index)) || index < 0 || index > that._items.length - 1) {
            that.log(that.localize('indexOutOfBound', { elementType: that.nodeName.toLowerCase(), method: method }));
            return;
        }

        return parseInt(index);
    }
});
/**
 * Array custom element.
 */
JQX('jqx-array', class DataArray extends JQX.BaseElement {
    /**
     * Array's properties.
     */
    static get properties() {
        return {
            'arrayIndexingMode': {
                value: 'LabVIEW',
                allowedValues: ['LabVIEW', 'JavaScript'],
                type: 'string'
            },
            'changeProperty': {
                value: null,
                type: 'function?'
            },
            'columns': {
                value: 1,
                type: 'number'
            },
            'customWidgetDefaultValue': {
                value: null,
                type: 'any?'
            },
            'dimensions': {
                value: 1,
                type: 'number'
            },
            'elementHeight': {
                value: 25,
                type: 'number'
            },
            'elementTemplate': {
                value: null,
                type: 'function?'
            },
            'elementWidth': {
                value: 75,
                type: 'number'
            },
            'getElementValue': {
                value: null,
                type: 'function?'
            },
            'indexerHeight': {
                value: 25,
                type: 'number'
            },
            'indexerWidth': {
                value: 50,
                type: 'number'
            },
            'messages': {
                value: {
                    'en': {
                        'callbackFunctionRequired': 'jqx-array: When "type" is \'custom\', the {{callback}} callback function has to be implemented.'
                    }
                },
                type: 'object',
                extend: true
            },
            'rows': {
                value: 1,
                type: 'number'
            },
            'setElementValue': {
                value: null,
                type: 'function?'
            },
            'showHorizontalScrollbar': {
                value: false,
                type: 'boolean'
            },
            'showIndexDisplay': {
                value: false,
                type: 'boolean'
            },
            'showSelection': {
                value: false,
                type: 'boolean'
            },
            'showVerticalScrollbar': {
                value: false,
                type: 'boolean'
            },
            'type': {
                value: 'none',
                allowedValues: ['none', 'boolean', 'numeric', 'string', 'custom'],
                type: 'string'
            },
            'value': {
                value: null,
                type: 'array?',
                reflectToAttribute: false
            }
        };
    }

    /**
     * Array's event listeners.
     */
    static get listeners() {
        return {
            'resize': '_resizeHandler',
            'horizontalScrollbar.change': '_scrollbarChangeHandler',
            'horizontalScrollbar.click': '_scrollbarClickHandler',
            'verticalScrollbar.change': '_scrollbarChangeHandler',
            'verticalScrollbar.click': '_scrollbarClickHandler'
        };
    }

    /**
     * Array's required files.
     */
    static get requires() {
        return {
            'JQX.NumericTextBox': 'jqxnumerictextbox.js',
            'JQX.ScrollBar': 'jqxscrollbar.js',
            'JQX.SwitchButton': 'jqxswitchbutton.js',
            'JQX.TextBox': 'jqxtextbox.js'
        }
    }

    /**
     * Array's HTML template.
     */
    template() {
        return `<div>
                    <div id="indexerContainer" class="jqx-indexer-container jqx-hidden"></div>
                    <div id="bigContainer" class="jqx-big-container jqx-array-background">
                        <div id="centralContainer">
                            <div id="mainContainer" class="jqx-main-container"></div>
                            <div id="horizontalScrollbarContainer" class="jqx-scrollbar-container-horizontal jqx-hidden">
                                <jqx-scroll-bar id="horizontalScrollbar" animation="[[animation]]" min="0" max="0" value="0" step="1"></jqx-scroll-bar>
                            </div>
                        </div>
                        <div id="verticalScrollbarContainer" class="jqx-scrollbar-container-vertical jqx-hidden">
                            <jqx-scroll-bar id="verticalScrollbar" animation="[[animation]]" orientation="vertical" min="0" max="0" value="0" step="1"></jqx-scroll-bar>
                        </div>
                    </div>
                </div>`;
    }

    /**
     * Called when the element is ready. Used for one-time configuration of the Array.
     */
    ready() {
        super.ready();

        const that = this;

        that._id = that.getAttribute('id') || Math.round(Math.random() * 10000);

        that._cachedWidth = that.offsetWidth;
        that._cachedHeight = that.offsetHeight;

        that._coordinates = [];
        that._getDefaultCellValue();
        that._validateProperties();
        that._addInitialDimensions();

        if (that.type !== 'none') {
            that._addElementStructure();
            that._structureAdded = true;
            that._initializeElements(false);
        }

        that._getInitialFill();
        that._updateWidgetWidth();
        that._updateWidgetHeight();

        that._cachedWidth = that.offsetWidth;
        that._cachedHeight = that.offsetHeight;
    }

    /**
     * Adds a dimension to the array.
     */
    addDimension(changeValueDimensions) {
        const that = this;

        if (that._suppressDimensionChange !== true && that.dimensions === 32) {
            return;
        }

        const indexer = document.createElement('jqx-numeric-text-box');

        indexer.className = 'jqx-array-indexer';
        indexer.style.height = that.indexerHeight + 'px';
        indexer.inputFormat = 'integer';
        indexer.spinButtons = true;
        indexer.min = 0;
        indexer.max = 4294967295;
        indexer.disabled = that.disabled;
        indexer.animation = that.animation;
        indexer.validation = 'interaction';
        indexer.wordLength = 'uint64';
        indexer.onReady = function () {
            indexer.$upButton.addClass('jqx-array-indexer-increment');
            indexer.$downButton.addClass('jqx-array-indexer-decrement');
        }

        that.$.indexerContainer.insertBefore(indexer, that.$.indexerContainer.children ? that.$.indexerContainer.children[0] : null);

        indexer.$.listen('change', that._indexerChangeHandler.bind(that));

        that._dimensions.push({ index: that._dimensions.length, indexer: indexer });

        if (that.arrayIndexingMode === 'LabVIEW') {
            that._indexers.unshift(indexer);
            that._coordinates.unshift(0);
        }
        else {
            that._indexers.push(indexer);
            that._coordinates.push(0);
        }

        indexer.dimension = that._indexers.length - 1;

        if (that._suppressDimensionChange !== true) {
            that.dimensions += 1;
            that.$.fireEvent('dimensionChange', { 'type': 'add' });
        }

        if (that._initialDimensions !== true && changeValueDimensions !== false) {
            that._validateValueArrayDimensions();

            if (that.arrayIndexingMode === 'LabVIEW') {
                that._filledUpTo.unshift(0);
            }
            else {
                that._filledUpTo.push(0);
            }

            if (that._oneDimensionSpecialCase === true) {
                that._oneDimensionSpecialCase = false;
                that.$.verticalScrollbar.value = 0;
                that._scroll();
            }
        }

        if (that._absoluteSelectionStart !== undefined) {
            if (that.arrayIndexingMode === 'LabVIEW') {
                that._absoluteSelectionStart.unshift(0);
            }
            else {
                that._absoluteSelectionStart.push(0);
            }
        }

        if (that._absoluteSelectionEnd !== undefined) {
            if (that.arrayIndexingMode === 'LabVIEW') {
                that._absoluteSelectionEnd.unshift(0);
            }
            else {
                that._absoluteSelectionEnd.push(0);
            }
        }

        if (!that._initialDimensions) {
            that._refreshSelection();
        }

        if (that._suppressDimensionChange === false && that.showIndexDisplay === true && (that.dimensions * (that.indexerHeight + 4) - 2 > that._cachedHeight)) {
            that._updateWidgetHeight('dimensions');
        }
    }

    /**
     * Clears the selection.
     */
    clearSelection() {
        const that = this;

        that._absoluteSelectionStart = undefined;
        that._absoluteSelectionEnd = undefined;

        if (that.showSelection) {
            that._clearSelection();
        }
    }

    /**
     * Copies the value of an array element to the clipboard.
     *
     * @param {Number} rowVisibleIndex The visible index of the row (y coordinate) of the element.
     * @param {Number} columnVisibleIndex The visible index of the column (x coordinate) of the element.
     */
    copyElementValueToClipboard(rowVisibleIndex, columnVisibleIndex) {
        const that = this,
            valueInCell = that._getValueInCell(rowVisibleIndex, columnVisibleIndex);

        if (valueInCell !== undefined) {
            try {
                const dummyInput = document.createElement('input');

                dummyInput.type = 'text';
                dummyInput.style.position = 'absolute';
                dummyInput.value = valueInCell;
                that.appendChild(dummyInput);
                dummyInput.focus();
                dummyInput.setSelectionRange(0, dummyInput.value.length);
                document.execCommand('copy');
                that.removeChild(dummyInput);
            }
            catch (err) {
                //
            }
        }
    }

    /**
     * Deletes a column in the "value" array.
     *
     * @param {Number} index Index of the column to be deleted.
     */
    deleteColumn(index) {
        const that = this,
            lV = that.arrayIndexingMode === 'LabVIEW';
        let filledColumns;

        index = Math.max(0, index);

        if (lV) {
            filledColumns = that._filledUpTo[that._filledUpTo.length - 1];
        }
        else {
            filledColumns = that._filledUpTo[0];
        }

        if (index > filledColumns) {
            return;
        }

        if (filledColumns === 0 || that._oneDimensionSpecialCase && index === 0) {
            that.emptyArray();
            return;
        }

        const oldValue = JSON.stringify(that.value);
        let targetLevel, boundColumnIndex;

        if (lV) {
            targetLevel = that.dimensions - 1;
            boundColumnIndex = index + that._coordinates[targetLevel];

            const recursion = function (arr, level) {
                if (targetLevel !== level) {
                    for (let i = 0; i < arr.length; i++) {
                        recursion(arr[i], level + 1);
                    }
                }
                else {
                    arr.splice(boundColumnIndex, 1);
                }
            };

            recursion(that.value, 0);
        }
        else {
            targetLevel = 0;
            boundColumnIndex = index + that._coordinates[0];
            that.value.splice(boundColumnIndex, 1);
        }

        if (JSON.stringify(that.value) !== oldValue) {
            that._filledUpTo[targetLevel]--;
            that._scroll();
            that.$.fireEvent('change', { 'value': that.value, 'oldValue': JSON.parse(oldValue) });
            that._setMaxValuesOfScrollBars();
        }
    }

    /**
     * Deletes a row in the "value" array.
     *
     * @param {Number} index Index of the row to be deleted.
     */
    deleteRow(index) {
        const that = this,
            oldValue = JSON.stringify(that.value),
            lV = that.arrayIndexingMode === 'LabVIEW';
        let dimension, boundRowIndex, filledRows;

        index = Math.max(0, index);

        if (lV) {
            filledRows = that._filledUpTo[that._filledUpTo.length - 2];
        }
        else {
            filledRows = that._filledUpTo[1];
        }

        if (index > filledRows) {
            return;
        }

        if (filledRows === 0) {
            that.emptyArray();
            return;
        }

        if (that.dimensions === 1) {
            if (!that._oneDimensionSpecialCase) {
                if (index === 0) {
                    that.emptyArray();
                }

                return;
            }
            else {
                that.value.splice(index + that._coordinates[0], 1);
                that._filledUpTo[0]--;
            }
        }
        else {
            if (lV) {
                dimension = that.dimensions - 2;
                boundRowIndex = index + that._coordinates[dimension];

                const recursion = function (arr, level) {
                    if (dimension !== level) {
                        for (let i = 0; i < arr.length; i++) {
                            recursion(arr[i], level + 1);
                        }
                    }
                    else {
                        arr.splice(boundRowIndex, 1);
                    }
                };

                recursion(that.value, 0);
            }
            else {
                dimension = 1;
                boundRowIndex = index + that._coordinates[1];

                for (let i = 0; i < that.value.length; i++) {
                    const currentArray = that.value[i];

                    currentArray.splice(boundRowIndex, 1);
                }
            }

            that._filledUpTo[dimension]--;
        }

        if (oldValue !== JSON.stringify(that.value)) {
            that._scroll();
            that.$.fireEvent('change', { 'value': that.value, 'oldValue': JSON.parse(oldValue) });
            that._setMaxValuesOfScrollBars();
        }
    }

    /**
     * Empties the "value" array.
     */
    emptyArray() {
        const that = this;

        if (that.type === 'none') {
            return;
        }

        const cells = that._cells,
            oldValue = that.value;

        that.value = that._returnEmptyArray();

        if (JSON.stringify(oldValue) === JSON.stringify(that.value)) {
            return;
        }

        for (let i = 0; i < cells.length; i++) {
            for (let j = 0; j < cells[i].length; j++) {
                const cellWidget = cells[i][j].widget,
                    cellWidgetDimensions = { x: j, y: i },
                    defaultValue = that._getDefaultValue();

                cellWidget.classList.add('jqx-array-element-empty');

                if (that._areDifferent(that._getElementValue(cellWidget, cellWidgetDimensions), defaultValue)) {
                    cellWidget.supressChange = true;
                    that._setElementValue(defaultValue, cellWidget, cellWidgetDimensions);
                }
            }
        }

        that._getInitialFill();
        that.clearSelection();
        that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValue });
    }

    /**
     * Designates the end of a selection started with the method "startSelection".
     *
     * @param {Number} rowBoundIndex The bound index of the row (y coordinate) to end the selection to.
     * @param {Number} columnBoundIndex The bound index of the column (x coordinate) to end the selection to.
     */
    endSelection(rowBoundIndex, columnBoundIndex) {
        const that = this;

        if (that._absoluteSelectionStart === undefined) {
            return;
        }

        that._absoluteSelectionEnd = that._coordinates.slice(0);

        const dimensions = that.dimensions;

        if (that.arrayIndexingMode === 'LabVIEW') {
            that._absoluteSelectionEnd[dimensions - 1] = Math.min(columnBoundIndex, that._filledUpTo[dimensions - 1]);

            if (dimensions > 1) {
                that._absoluteSelectionEnd[dimensions - 2] = Math.min(rowBoundIndex, that._filledUpTo[dimensions - 2]);
            }
        }
        else {
            that._absoluteSelectionEnd[0] = Math.min(columnBoundIndex, that._filledUpTo[0]);

            if (dimensions > 1) {
                that._absoluteSelectionEnd[1] = Math.min(rowBoundIndex, that._filledUpTo[1]);
            }
        }

        let validation = true;

        for (let i = 0; i < dimensions; i++) {
            validation = validation && (that._absoluteSelectionStart[i] <= that._absoluteSelectionEnd[i]);
        }

        if (validation) {
            that._refreshSelection();
        }
        else {
            that._absoluteSelectionStart = undefined;
            that._absoluteSelectionEnd = undefined;
        }
    }

    /**
     * Returns the HTML element at the specified visible row and column coordinates of the array.
     *
     * @param {Number} rowVisibleIndex The visible index of the row (y coordinate) of the element.
     * @param {Number} columnVisibleIndex The visible index of the column (x coordinate) of the element.
     */
    getElement(rowVisibleIndex, columnVisibleIndex) {
        const cells = this._cells;

        if (cells[rowVisibleIndex] === undefined || cells[rowVisibleIndex][columnVisibleIndex] === undefined) {
            return undefined;
        }

        return cells[rowVisibleIndex][columnVisibleIndex].widget;
    }

    /**
     * Returns an object with the values of the array element width and height.
     */
    getElementSize() {
        const that = this;
        return { width: that.elementWidth, height: that.elementHeight };
    }

    /**
     * Gets an array with the values of all indexers.
     */
    getIndexerValue() {
        const indexers = this._indexers,
            result = [];

        for (let i = 0; i < indexers.length; i++) {
            result.push(indexers[i].val());
        }

        return result;
    }

    /**
     * Returns an HTML element from the array at the specified page coordinates and other information about this element.
     *
     * @param {Number} x Page x coordinate.
     * @param {Number} y Page y coordinate.
     */
    hitTest(x, y) {
        const that = this,
            topMostElement = document.elementFromPoint(x, y);

        if (!that.contains(topMostElement)) {
            return undefined;
        }

        const closestArrayElement = topMostElement.closest('.jqx-array-element'),
            closestIndexer = topMostElement.closest('.jqx-array-indexer');

        if (closestArrayElement !== null) {
            return { type: 'element', htmlElement: closestArrayElement, row: closestArrayElement.row, column: closestArrayElement.col };
        }
        else if (closestIndexer !== null) {
            let dimension = closestIndexer.dimension;

            if (that.arrayIndexingMode === 'LabVIEW') {
                dimension = that.dimensions - dimension - 1;
            }

            return { type: 'indexer', htmlElement: closestIndexer, dimension: dimension };
        }
        else {
            return { type: 'array', htmlElement: that };
        }
    }

    /**
     * Inserts a column in the "value" array before the specified column. The new column is filled with default values.
     *
     * @param {Number} index Index of the column to add a new column before.
     */
    insertColumnBefore(index, redirect) {
        const that = this,
            oldValue = JSON.stringify(that.value),
            lV = that.arrayIndexingMode === 'LabVIEW';
        let boundColumnIndex;

        if (lV && redirect !== true) {
            that.insertRowBefore(index, true);
            return;
        }

        if (that.dimensions === 1) {
            if (lV === that._oneDimensionSpecialCase) {
                that.value.splice(index + that._coordinates[0], 0, that._getDefaultValue());
                that._scroll();
                that._filledUpTo[0]++;
            }
            else {
                return;
            }
        }
        else {
            const fillUpTo = that._filledUpTo.slice(0);

            if (lV) { // inserts a row
                boundColumnIndex = index + that._coordinates[that.dimensions - 2];
                const targetLevel = that.dimensions - 2,
                    recursion = function (arr, level) {
                        if (targetLevel !== level) {
                            for (let i = 0; i < arr.length; i++) {
                                recursion(arr[i], level + 1);
                            }
                        }
                        else {
                            arr.splice(boundColumnIndex, 0, []);
                        }
                    };

                recursion(that.value, 0);
                fillUpTo[targetLevel]++;
            }
            else { // inserts a column
                boundColumnIndex = index + that._coordinates[0];
                that.value.splice(boundColumnIndex, 0, that._returnEmptyArray()[0]);
                fillUpTo[0]++;
            }

            that._fillValueArray(fillUpTo, true);
        }

        that.$.fireEvent('change', { 'value': that.value, 'oldValue': JSON.parse(oldValue) });
        that._setMaxValuesOfScrollBars();
    }

    /**
     * Inserts a row in the "value" array before the specified row. The new row is filled with default values.
     *
     * @param {Number} index Index of the row to add a new row before.
     */
    insertRowBefore(index, redirect) {
        const that = this,
            oldValue = JSON.stringify(that.value),
            lV = that.arrayIndexingMode === 'LabVIEW';

        if (lV && redirect !== true) {
            that.insertColumnBefore(index, true);
            return;
        }

        if (that.dimensions === 1) {
            if (lV && !that._oneDimensionSpecialCase || !lV && that._oneDimensionSpecialCase) {
                that.value.splice(index + that._coordinates[0], 0, that._getDefaultValue());
                that._scroll();
                that._filledUpTo[0]++;
            }
            else {
                return;
            }
        }
        else {
            const fillUpTo = that._filledUpTo.slice(0);
            let boundRowIndex;

            if (lV) { // inserts a column
                const targetLevel = that.dimensions - 1;

                boundRowIndex = index + that._coordinates[targetLevel];

                const recursion = function (arr, level) {
                    if (targetLevel !== level) {
                        for (let i = 0; i < arr.length; i++) {
                            recursion(arr[i], level + 1);
                        }
                    }
                    else {
                        arr.splice(boundRowIndex, 0, that._getDefaultValue());
                    }
                };

                recursion(that.value, 0);
                fillUpTo[targetLevel]++;
            }
            else { // inserts a row
                boundRowIndex = index + that._coordinates[1];

                for (let i = 0; i < that.value.length; i++) {
                    const currentArray = that.value[i];

                    currentArray.splice(boundRowIndex, 0, undefined);
                }

                fillUpTo[1]++;
            }

            that._fillValueArray(fillUpTo, true);
        }

        that.$.fireEvent('change', { 'value': that.value, 'oldValue': JSON.parse(oldValue) });
        that._setMaxValuesOfScrollBars();
    }

    /**
     * Sets all array members to the default value.
     */
    reinitializeArray() {
        const that = this;

        if (that.type === 'none') {
            return;
        }

        const dimensions = that.dimensions,
            oldValue = JSON.stringify(that.value);

        if (that.dimensions === 1) {
            that.value.fill(that._getDefaultValue());
        }
        else {
            const recursion = function (arr, level) {
                for (let i = 0; i < arr.length; i++) {
                    if (level === dimensions) {
                        arr[i] = that._getDefaultValue();
                    }
                    else {
                        recursion(arr[i], level + 1);
                    }
                }
            };

            recursion(that.value, 1);
        }

        if (oldValue !== JSON.stringify(that.value)) {
            that._scroll();
            that.$.fireEvent('change', { 'value': that.value, 'oldValue': JSON.parse(oldValue) });
        }
    }

    /**
     * Removes a dimension from the array.
     */
    removeDimension(propertyChangedHandler, changeValueDimensions) {
        const that = this,
            index = that._dimensions.length - 1;

        if (that._dimensions.length < 2) {
            return;
        }

        if (that._dimensions.length === 2) {
            const oldRowsCount = that.rows;

            that.rows = 1;
            that._changeRowsColumns('rows', oldRowsCount, 1, undefined, true);
        }

        that.$.indexerContainer.removeChild(that._dimensions[index].indexer);
        that._dimensions.pop();

        let indexerValue;

        if (that.arrayIndexingMode === 'LabVIEW') {
            indexerValue = that._coordinates[0];
            that._indexers.splice(0, 1);
            that._coordinates.splice(0, 1);
        }
        else {
            indexerValue = that._coordinates[index];
            that._indexers.pop();
            that._coordinates.pop();
        }

        if (that._suppressDimensionChange !== true) {
            that.dimensions -= 1;
            that.$.fireEvent('dimensionChange', { 'type': 'remove' });
        }

        if (changeValueDimensions !== false) {
            that._removeDimensionFromJSArray();

            if (that.arrayIndexingMode === 'LabVIEW') {
                that._filledUpTo.splice(0, 1);
            }
            else {
                that._filledUpTo.pop();
            }
        }

        if (that._absoluteSelectionStart !== undefined) {
            if (that.arrayIndexingMode === 'LabVIEW') {
                that._absoluteSelectionStart.splice(0, 1);
            }
            else {
                that._absoluteSelectionStart.pop();
            }
        }

        if (that._absoluteSelectionEnd !== undefined) {
            if (that.arrayIndexingMode === 'LabVIEW') {
                that._absoluteSelectionEnd.splice(0, 1);
            }
            else {
                that._absoluteSelectionEnd.pop();
            }
        }

        if (indexerValue > 0) {
            that._scroll();
        }

        if ((that.dimensions > 1 && that._suppressDimensionChange === false && that.showIndexDisplay === true && ((that.dimensions + 1) * (that.indexerHeight + 4) - 2 >= that._cachedHeight)) || that.dimensions === 1 && propertyChangedHandler !== true) {
            that._updateWidgetHeight('dimensions');
            if (that.dimensions === 1 && that.showVerticalScrollbar) {
                that._showVerticalScrollbar(false);
            }
        }
    }

    /**
     * Sets the array's "type" to 'none'.
     */
    reset(propertyChangedHandler) {
        const that = this;

        if (that.type === 'none' && propertyChangedHandler !== true) {
            return;
        }
        else {
            that.type = 'none';
        }

        let oldValue = that.rows;

        that.rows = 1;
        that._changeRowsColumns('rows', oldValue, 1, true);
        oldValue = that.columns;
        that.columns = 1;
        that._changeRowsColumns('columns', oldValue, 1);

        const remainingCell = that._cells[0][0];

        remainingCell.widget.$.unlisten('change');
        remainingCell.widget.$.unlisten('click');
        remainingCell.td.innerHTML = '';

        that._table.classList.add('jqx-hidden');

        that._defaultValue = undefined;

        const oldValueArray = that.value;

        that.value = null;
        that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValueArray });

        that.$.horizontalScrollbar.max = 0;
        that.$.horizontalScrollbar.value = 0;
        that.$.verticalScrollbar.max = 0;
        that.$.verticalScrollbar.value = 0;
    }

    /**
     * Resizes array elements (changes both the column width and the row height).
     *
     * @param {Number} width The new element (column) width.
     * @param {Number} height The new element (row) height.
     */
    resizeElement(width, height) {
        const that = this;

        width = parseInt(width, 10);
        height = parseInt(height, 10);

        if (width === that.elementWidth && height === that.elementHeight) {
            return;
        }

        if (width === that.elementWidth) {
            that.setRowHeight(height);
            return;
        }

        if (height === that.elementHeight) {
            that.setColumnWidth(width);
            return;
        }

        const cellWidgets = that.getElementsByClassName('jqx-array-element-' + that._id);

        that.elementWidth = width;
        that.elementHeight = height;

        if (that.type !== 'none') {
            that._updateWidgetWidth();
            that._updateWidgetHeight();

            if (that.type !== 'custom') {
                for (let i = 0; i < cellWidgets.length; i++) {
                    cellWidgets[i].style.width = width + 'px';
                    cellWidgets[i].style.height = height + 'px';
                }
            }
            else {
                if (that.changeProperty) {
                    that.changeProperty('width', width, cellWidgets);
                    that.changeProperty('height', height, cellWidgets);
                }
                else {
                    try {
                        that.warn(that.localize('callbackFunctionRequired', { callback: 'changeProperty' }));
                    }
                    catch (err) {
                        //
                    }
                }
            }

            that.$.fireEvent('sizeChange', { 'width': width, 'height': height });
        }
    }

    /**
     * Selects all members of the array.
     */
    selectAll() {
        const that = this;

        if ((that.arrayIndexingMode === 'LabVIEW' && that._filledUpTo[0] === -1) ||
            (that.arrayIndexingMode === 'JavaScript' && that._filledUpTo[that._filledUpTo.length - 1] === -1)) {
            return;
        }

        const start = new Array(that.dimensions);

        start.fill(0);

        that._absoluteSelectionStart = start;
        that._absoluteSelectionEnd = that._filledUpTo.slice(0);
        that._refreshSelection();
    }

    /**
     * Selects an element with the passed row and column bound indexes.
     *
     * @param {Number} rowBoundIndex Row bound index.
     * @param {Number} columnBoundIndex Column bound index.
     */
    selectElement(rowBoundIndex, columnBoundIndex) {
        const that = this;

        that.startSelection(rowBoundIndex, columnBoundIndex);
        that.endSelection(rowBoundIndex, columnBoundIndex);
    }

    /**
     * Sets the column (element) width.
     *
     * @param {Number} width The new column width.
     */
    setColumnWidth(width, propertyChangedHandler) {
        const that = this;

        width = parseInt(width, 10);

        if (width === that.elementWidth && propertyChangedHandler !== true) {
            return;
        }

        const cellWidgets = that.getElementsByClassName('jqx-array-element-' + that._id);

        that.elementWidth = width;

        if (that.type !== 'none') {
            if (that.type !== 'custom') {
                for (let i = 0; i < cellWidgets.length; i++) {
                    cellWidgets[i].style.width = width + 'px';
                }
            }
            else {
                if (that.changeProperty) {
                    that.changeProperty('width', width, cellWidgets);
                }
                else {
                    try {
                        that.warn(that.localize('callbackFunctionRequired', { callback: 'changeProperty' }));
                    }
                    catch (err) {
                        //
                    }
                }
            }

            that._updateWidgetWidth();
            that.$.fireEvent('sizeChange', { 'width': width, 'height': that.elementHeight });
        }
    }

    /**
     * Sets the default value of array members.
     *
     * @param {any} newDefaultValue The new default value. Its data type should correspond to the type of the array.
     */
    setDefaultValue(newDefaultValue) {
        const that = this;

        if (that._areDifferent(newDefaultValue, that._defaultValue)) {
            that._defaultValue = newDefaultValue;
            that._scroll();
        }
    }

    /**
     * Sets the value of one or more array indexers.
     *
     * @param {Array} settings An array of objects with the fields index and value.
     */
    setIndexerValue(settings) {
        const that = this;
        let changed = false;

        for (let i = 0; i < settings.length; i++) {
            const index = settings[i].index,
                absoluteIndex = that.arrayIndexingMode === 'LabVIEW' ? that.dimensions - index - 1 : index,
                value = settings[i].value,
                indexer = that._indexers[index];

            if (indexer !== undefined && value !== that._coordinates[index]) {
                changed = true;
                indexer.val(value);
                that._coordinates[index] = value;

                if (that.type !== 'none' && (absoluteIndex === 0 || absoluteIndex === 1)) {
                    that._syncScrollbar(absoluteIndex, value);
                }
            }
        }

        if (changed === true) {
            that._scroll();
        }
    }

    /**
     * Sets the row (element) height.
     *
     * @param {Number} height The new row height.
     */
    setRowHeight(height, propertyChangedHandler) {
        const that = this;

        height = parseInt(height, 10);

        if (height === that.elementHeight && propertyChangedHandler !== true) {
            return;
        }

        const cellWidgets = that.getElementsByClassName('jqx-array-element-' + that._id);

        that.elementHeight = height;

        if (that.type !== 'none') {
            if (that.type !== 'custom') {
                for (let i = 0; i < cellWidgets.length; i++) {
                    cellWidgets[i].style.height = height + 'px';
                }
            }
            else {
                if (that.changeProperty) {
                    that.changeProperty('height', height, cellWidgets);
                }
                else {
                    try {
                        that.warn(that.localize('callbackFunctionRequired', { callback: 'changeProperty' }));
                    }
                    catch (err) {
                        //
                    }
                }
            }

            that._updateWidgetHeight();
            that.$.fireEvent('sizeChange', { 'width': that.elementWidth, 'height': height });
        }
    }

    /**
     * Makes the last array member visible.
     */
    showLastElement() {
        const that = this,
            settings = [];
        let xDimension, yDimension;

        if (that.type === 'none') {
            return;
        }

        if (that.dimensions === 1) {
            const indexerValue = parseFloat(that._indexers[0].value),
                cellsCount = that._oneDimensionSpecialCase ? that.rows : that.columns,
                filledUpTo = that._filledUpTo[0];

            if (indexerValue + cellsCount < filledUpTo + 1 || indexerValue > filledUpTo) {
                that.setIndexerValue([{ index: 0, value: filledUpTo }]);
            }

            return;
        }

        if (that.arrayIndexingMode === 'LabVIEW') {
            xDimension = that.dimensions - 1;
            yDimension = that.dimensions - 2;
        }
        else {
            xDimension = 0;
            yDimension = 1;
        }

        for (let i = 0; i < that.dimensions; i++) {
            let currentValue = that._filledUpTo[i];

            if (i === xDimension) {
                const indexerValue = parseFloat(that._indexers[i].value);

                if (!(indexerValue + that.columns < currentValue + 1 || indexerValue > currentValue)) {
                    currentValue = indexerValue;
                }
            }
            else if (i === yDimension) {
                const indexerValue = parseFloat(that._indexers[i].value);

                if (!(indexerValue + that.rows < currentValue + 1 || indexerValue > currentValue)) {
                    currentValue = indexerValue;
                }
            }

            settings.push({ index: i, value: currentValue });
        }

        that.setIndexerValue(settings);
    }

    /**
     * Designates the start of a selection.
     *
     * @param {Number} rowBoundIndex The bound index of the row (y coordinate) to start the selection from.
     * @param {Number} columnBoundIndex The bound index of the column (x coordinate) to start the selection from.
     */
    startSelection(rowBoundIndex, columnBoundIndex) {
        const that = this;

        that._absoluteSelectionStart = that._coordinates.slice(0);

        if (that.dimensions === 1) {
            that._absoluteSelectionStart[0] = columnBoundIndex;
        }
        else {
            if (that.arrayIndexingMode === 'LabVIEW') {
                that._absoluteSelectionStart[that.dimensions - 1] = columnBoundIndex;
                that._absoluteSelectionStart[that.dimensions - 2] = rowBoundIndex;
            }
            else {
                that._absoluteSelectionStart[0] = columnBoundIndex;
                that._absoluteSelectionStart[1] = rowBoundIndex;
            }
        }

        that._absoluteSelectionEnd = undefined;
    }

    /**
     * Increases or decreases the visual gap between array elements.
     */
    toggleElementGap() {
        const that = this;

        if (that.type === 'none') {
            return;
        }

        let fn;

        if (that._elementGap === undefined) {
            that._elementGap = false;
        }

        if (that._elementGap) {
            fn = 'remove';
            that._elementGap = false;
        }
        else {
            fn = 'add';
            that._elementGap = true;
        }

        for (let i = 0; i < that.rows; i++) {
            for (let j = 0; j < that.columns; j++) {
                that._cells[i][j].td.classList[fn]('jqx-array-table-data-gap');
            }
        }

        that._updateWidgetWidth();
        that._updateWidgetHeight();
    }

    /**
     * Transposes the array.
     */
    transposeArray() {
        const that = this;

        if (that.dimensions === 2) {
            const transposedValue = that.value[0].map(function (col, i) {
                return that.value.map(function (row) {
                    return row[i];
                });
            }),
                oldValue = JSON.stringify(that.value);

            that.value = transposedValue;
            that._scroll();

            that.$.fireEvent('change', { 'value': transposedValue, 'oldValue': JSON.parse(oldValue) });

            that._filledUpTo.reverse();
        }
    }

    /**
     * Sets or gets the value of the whole array or sets the value of a member of the array.
     *
     * @param {Array/any} newValue Optional If the method is used for setting the value of the whole array, the expected value is an Array. If it is used for setting the value of an array member, the value can be of any applicable type.
     * @param {Array} elementIndexes Optional If this parameter is passed, only the value of the array member with the provided dimension indexes is set. Dimension indexes that are not passed are considered to be 0.
     */
    val(newValue, elementIndexes) {
        const that = this;
        let oldValue;

        if (arguments.length === 2) {
            if (that.type === 'none') {
                return;
            }

            oldValue = JSON.stringify(that.value);

            let tempArray = that.value,
                i;

            for (i = 0; i < that.dimensions - 1; i++) {
                let index = elementIndexes[i];

                if (index === undefined) {
                    index = 0;
                    elementIndexes[i] = 0;
                }

                if (tempArray[index] === undefined) {
                    tempArray[index] = [];
                }

                tempArray = tempArray[index];
            }

            let lastIndex = elementIndexes[i];

            if (lastIndex === undefined) {
                lastIndex = 0;
                elementIndexes[i] = 0;
            }

            if (that._areDifferent(tempArray[lastIndex], newValue)) {
                tempArray[lastIndex] = newValue;
                that._fillValueArray(elementIndexes.slice(0));
                that.$.fireEvent('change', { 'value': that.value, 'oldValue': JSON.parse(oldValue), 'dimensionIndexes': elementIndexes });
            }
        }
        else {
            if (newValue !== undefined && !(typeof newValue === 'object' && Object.keys(newValue).length === 0)) {
                if (that.type === 'none') {
                    return;
                }

                const oldValueStringified = JSON.stringify(that.value);

                if (oldValueStringified !== JSON.stringify(newValue)) {
                    oldValue = that.value;
                    that.value = newValue;
                    that._validateValue();

                    if (oldValueStringified !== JSON.stringify(that.value)) {
                        that._scroll();
                        that._getInitialFill();
                        that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValue });
                    }
                }
            }
            else {
                return that.value;
            }
        }
    }

    /**
     * Called when a property is changed.
     */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this;

        if (newValue !== oldValue) {
            switch (propertyName) {
                case 'arrayIndexingMode':
                    that.arrayIndexingMode = oldValue; // arrayIndexingMode cannot be changed programmatically
                    break;
                case 'columns':
                case 'rows':
                    that._changeRowsColumns(propertyName, oldValue, newValue);
                    break;
                case 'customWidgetDefaultValue':
                    if (that.type === 'custom') {
                        that._defaultValue = newValue;
                        that._scroll();
                    }
                    break;
                case 'dimensions':
                    that._addRemoveMultipleDimensions(oldValue, newValue);
                    break;
                case 'animation':
                case 'disabled':
                    for (let j = 0; j < that._indexers.length; j++) {
                        that._indexers[j][propertyName] = newValue;
                    }

                    if (that.type !== 'none') {
                        const cellWidgets = that.getElementsByClassName('jqx-array-element-' + that._id);

                        if (that.type !== 'custom') {
                            for (let i = 0; i < cellWidgets.length; i++) {
                                cellWidgets[i][propertyName] = newValue;
                            }
                        }
                        else {
                            if (that.changeProperty) {
                                that.changeProperty(propertyName, newValue, cellWidgets);
                            }
                            else {
                                try {
                                    that.warn(that.localize('callbackFunctionRequired', { callback: 'changeProperty' }));
                                }
                                catch (err) {
                                    //
                                }
                            }
                        }

                        that._scroll();
                    }

                    break;
                case 'elementHeight':
                    that.setRowHeight(newValue, true);
                    break;
                case 'elementTemplate':
                    if (that.type !== 'none') {
                        const cellWidgets = that.getElementsByClassName('jqx-array-element-' + that._id);

                        for (let k = 0; k < cellWidgets.length; k++) {
                            let currentWidget = cellWidgets[k];

                            that.elementTemplate(currentWidget, { x: currentWidget.col, y: currentWidget.row });
                        }
                    }
                    break;
                case 'elementWidth':
                    that.setColumnWidth(newValue, true);
                    break;
                case 'indexerHeight':
                    for (let o = 0; o < that._indexers.length; o++) {
                        that._indexers[o].style.height = newValue + 'px';
                    }

                    that._updateWidgetHeight();
                    break;
                case 'indexerWidth':
                    that.$.indexerContainer.style.width = newValue + 'px';
                    that._updateWidgetWidth();
                    break;
                case 'showHorizontalScrollbar':
                    if (that._oneDimensionSpecialCase === true) {
                        that.showHorizontalScrollbar = false;
                        return;
                    }

                    that._showHorizontalScrollbar(newValue);
                    break;
                case 'showIndexDisplay':
                    if (newValue) {
                        that.$indexerContainer.removeClass('jqx-hidden');
                    }
                    else {
                        that.$indexerContainer.addClass('jqx-hidden');
                    }

                    that._updateWidgetWidth();
                    that._updateWidgetHeight('showIndexDisplay');
                    break;
                case 'showSelection':
                    if (newValue) {
                        that._refreshSelection();
                    }
                    else {
                        that._clearSelection();
                    }

                    break;
                case 'showVerticalScrollbar':
                    if (that.dimensions === 1 && that._oneDimensionSpecialCase === false) {
                        that.showVerticalScrollbar = false;
                        return;
                    }

                    that._showVerticalScrollbar(newValue);
                    break;
                case 'type':
                    that._getDefaultCellValue();

                    if (oldValue !== 'none' && newValue !== 'none') {
                        that._initializeElements(true);
                        that._updateWidgetWidth();
                        that._updateWidgetHeight();
                    }
                    else if (oldValue === 'none') {
                        that.value = that._returnEmptyArray();

                        if (that._structureAdded === true) {
                            that._initializeElements(false);
                            that._table.classList.remove('jqx-hidden');
                        }
                        else {
                            that._addElementStructure();
                            that._structureAdded = true;
                            that._initializeElements(false);
                        }

                        that.$.centralContainer.style.width = '';
                        that.$.bigContainer.style.width = '';
                        that.$.mainContainer.style.height = '';
                        that.$.bigContainer.style.height = '';

                        that._updateWidgetWidth();
                        that._updateWidgetHeight();
                        that._getInitialFill();
                    }
                    else if (newValue === 'none') {
                        that.reset(true);
                    }
                    break;
                case 'value':
                    if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
                        that._validateValue();

                        if (JSON.stringify(oldValue) !== JSON.stringify(that.value)) {
                            that._scroll();
                            that._getInitialFill();
                            that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValue });
                        }
                    }

                    break;
            }
        }
    }

    /**
     * Adds dimensions to "value" array.
     */
    _addDimensionToJSArray(dimensions) {
        const that = this;

        if (that.arrayIndexingMode === 'LabVIEW') {
            that.value = [that.value];
        }
        else {
            if (dimensions === undefined) {
                dimensions = that.dimensions - 1;
            }

            const recursion = function (arr, level) {
                for (let i = 0; i < arr.length; i++) {
                    if (level !== dimensions) {
                        recursion(arr[i], level + 1);
                    }
                    else {
                        arr[i] = [arr[i]];
                    }
                }
            };

            recursion(that.value, 1);
        }
    }

    /**
     * Adds element event handlers.
     */
    _addElementHandlers(element) {
        const that = this;

        element.$.listen('change', function (event) {
            if (element.supressChange !== true || element instanceof JQX.NumericTextBox) {
                element.$.removeClass('jqx-array-element-empty');

                const x = element.col,
                    y = element.row;

                that._updateValue(y, x, that._getElementValue(element, { x: x, y: y }, true));
            }
            else {
                element.supressChange = false;
            }

            event.stopPropagation();
        });

        element.$.listen('click', function () {
            that.$.fireEvent('elementClick', { 'element': element });
        });
    }

    /**
     * Adds tabular element structure.
     */
    _addElementStructure() {
        const that = this;

        that._cells = [];
        that._table = document.createElement('table');
        that._table.className = 'jqx-array-element-gap';

        const tableBody = document.createElement('tbody'),
            masterFragment = document.createDocumentFragment();

        for (let i = 0; i < that.rows; i++) {
            const currentRow = document.createElement('tr'),
                childFragment = document.createDocumentFragment();

            currentRow.classList.add('jqx-array-table-row');
            that._cells.push([]);

            for (let j = 0; j < that.columns; j++) {
                const currentCell = document.createElement('td');

                currentCell.classList.add('jqx-array-table-data');

                if (that._elementGap) {
                    currentCell.classList.add('jqx-array-table-data-gap');
                }

                that._cells[i].push({ td: currentCell });
                childFragment.appendChild(currentCell);
            }

            currentRow.appendChild(childFragment);
            masterFragment.appendChild(currentRow);
        }

        tableBody.appendChild(masterFragment);
        that._table.appendChild(tableBody);
        that.$.mainContainer.appendChild(that._table);

        that._tableBody = tableBody;
    }

    /**
     * Adds initial dimensions.
     */
    _addInitialDimensions() {
        const that = this,
            numberOfInitialDimensions = that.dimensions;

        that._dimensions = [];
        that._indexers = [];
        that._suppressDimensionChange = true;
        that._initialDimensions = true;

        for (let i = 0; i < numberOfInitialDimensions; i++) {
            that.addDimension();
        }

        that._suppressDimensionChange = false;
        that._initialDimensions = false;
    }

    /**
     * Adds or removes a column.
     */
    _addRemoveColumn(action) {
        const that = this;

        if (action === 'add') {
            const rows = that._tableBody.children;

            for (let i = 0; i < that._cells.length; i++) {
                const addToRow = that._cells[i],
                    newCell = document.createElement('td');

                newCell.classList.add('jqx-array-table-data');

                if (that._elementGap) {
                    newCell.classList.add('jqx-array-table-data-gap');
                }

                addToRow.push({ td: newCell });
                rows[i].appendChild(newCell);
                that._initializeWidget(i, addToRow.length - 1);
            }

            that.columns++;

            if (that._suppressScroll !== true) {
                that._scroll();
            }
        }
        else if (action === 'remove' && that.columns > 1) {
            for (let j = 0; j < that._cells.length; j++) {
                const removeFromRow = that._cells[j],
                    cellToRemove = removeFromRow[removeFromRow.length - 1];

                cellToRemove.widget.$.unlisten('change');
                cellToRemove.widget.$.unlisten('click');
                cellToRemove.td.parentElement.removeChild(cellToRemove.td);

                removeFromRow.pop();
            }

            that.columns--;
        }
    }

    /**
     * Adds or removes multiple dimensions.
     */
    _addRemoveMultipleDimensions(oldvalue, value, changeValueDimensions) {
        const that = this;

        if (value < 1 || value > 32) {
            that.dimensions = 1;

            if (that.dimensions === oldvalue) {
                return;
            }
        }

        let difference = that.dimensions - oldvalue;

        that._suppressDimensionChange = true;

        if (difference > 0) {
            do {
                that.addDimension(changeValueDimensions);
                difference -= 1;
            } while (difference > 0);

            that.$.fireEvent('dimensionChange', { 'type': 'add' });
        }
        else if (difference < 0) {
            if (value === 1) {
                const oldRowsCount = that.rows;

                that.rows = 1;
                that.dimensions = oldvalue;
                that._changeRowsColumns('rows', oldRowsCount, 1, undefined, true);
                that.dimensions = value;
            }
            do {
                that.removeDimension(true, changeValueDimensions);
                difference += 1;
            } while (difference < 0);

            that.$.fireEvent('dimensionChange', { 'type': 'remove' });

            if (value === 1 && that.showVerticalScrollbar) {
                that._showVerticalScrollbar(false);
            }
        }
        else {
            return;
        }

        that._suppressDimensionChange = false;

        if (that.showIndexDisplay === true &&
            !(value !== 1 &&
                ((value - oldvalue > 0 && value * (that.indexerHeight + 4) - 2 < that._cachedHeight) ||
                    (value - oldvalue < 0 && oldvalue * (that.indexerHeight + 4) - 2 < that._cachedHeight))) ||
            value === 1) {
            that._updateWidgetHeight('dimensions');
        }
    }

    /**
     * Adds or removes a row.
     */
    _addRemoveRow(action) {
        const that = this;

        if (action === 'add' && (that.dimensions > 1 || (that.dimensions === 1 && that.columns === 1))) {
            that._cells.push([]);

            const newRow = document.createElement('tr'),
                fragment = document.createDocumentFragment(),
                newRowIndex = that._cells.length - 1,
                newCells = [];

            newRow.classList.add('jqx-array-table-row');

            for (let j = 0; j < that.columns; j++) {
                const currentNewCell = document.createElement('td');

                currentNewCell.classList.add('jqx-array-table-data');

                if (that._elementGap) {
                    currentNewCell.classList.add('jqx-array-table-data-gap');
                }

                that._cells[newRowIndex].push({ td: currentNewCell });
                newCells.push(currentNewCell);
                fragment.appendChild(currentNewCell);
            }

            newRow.appendChild(fragment);
            that._tableBody.appendChild(newRow);

            for (let i = 0; i < newCells.length; i++) {
                that._initializeWidget(newRowIndex, i);
            }

            that.rows++;

            if (that._suppressScroll !== true) {
                that._scroll();
            }
        }
        else if (action === 'remove' && that.rows > 1) {
            const rowToRemove = that._tableBody.children[that._tableBody.children.length - 1],
                cellsToRemove = that._cells[that._cells.length - 1];

            for (let k = 0; k < cellsToRemove.length; k++) {
                cellsToRemove[k].widget.$.unlisten('change');
                cellsToRemove[k].widget.$.unlisten('click');
            }

            that._tableBody.removeChild(rowToRemove);
            that._cells.pop();
            that.rows--;
        }
    }

    /**
     * Adds selection class.
     */
    _addSelectionClass(x, y, td, skipSelectionCheck) {
        const that = this;

        if (that.showSelection && that._absoluteSelectionStart !== undefined && that._absoluteSelectionEnd !== undefined) {
            if (skipSelectionCheck === false && that._inSelection(x, y)) {
                td.classList.add('jqx-array-element-selected');
            }
            else {
                td.classList.remove('jqx-array-element-selected');
            }
        }
    }

    /**
     * Checks if two objects are different.
     */
    _areDifferent(a, b) {
        if (a instanceof Date) {
            if (b instanceof Date) {
                return a.getTime() !== b.getTime();
            }
            else if (typeof b === 'string') {
                try {
                    return a.getTime() !== new Date(b).getTime();
                }
                catch (err) {
                    //
                }
            }

            return true;
        }

        if (b instanceof Date) {
            if (typeof a === 'string') {
                try {
                    return b.getTime() !== new Date(a).getTime();
                }
                catch (err) {
                    //
                }
            }
            return true;
        }

        if (typeof a !== 'object' || typeof a !== typeof b) {
            if (a !== b) {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            if (JSON.stringify(a) !== JSON.stringify(b)) {
                return true;
            }
            else {
                return false;
            }
        }
    }

    /**
     * Changes rows or columns.
     */
    _changeRowsColumns(key, oldvalue, value, reset, suppressHeightUpdate) {
        const that = this,
            functionName = '_addRemove' + key.charAt(0).toUpperCase() + key.slice(1, key.length - 1);

        if (value < 1) {
            that[key] = 1;

            if (that[key] === oldvalue) {
                return;
            }
        }

        if (that.dimensions === 1) {
            if (that._oneDimensionSpecialCase === true) {
                if (key === 'columns' && that[key] > 1) {
                    if (that.rows > 1) {
                        that.columns = 1;
                        return;
                    }

                    that._oneDimensionSpecialCase = false;
                    if (that.showVerticalScrollbar) {
                        that._showVerticalScrollbar(false);
                        that._showHorizontalScrollbar(true);
                    }
                }
            }
            else {
                if (key === 'rows') {
                    if (that.columns > 1) {
                        that.rows = 1;
                        return;
                    }
                    else if (that.rows > 1) {
                        that._oneDimensionSpecialCase = true;
                        if (that.showHorizontalScrollbar === true) {
                            that._showHorizontalScrollbar(false);
                            that._showVerticalScrollbar(true);
                        }
                    }
                }
            }
        }

        let difference = that[key] - oldvalue;

        that[key] = oldvalue;

        if (difference > 0) {
            that._suppressScroll = true;

            do {
                that[functionName]('add');
                difference -= 1;
            } while (difference > 0);

            that._suppressScroll = false;
            that._scroll();
        }
        else if (difference < 0) {
            do {
                that[functionName]('remove');
                difference += 1;
            } while (difference < 0);
        }

        that.$.fireEvent('arraySizeChange', { 'type': key, 'number': that[key], 'oldNumber': oldvalue });

        if (key === 'columns') {
            that._updateWidgetWidth();
            that._setMaxValuesOfScrollBars('horizontal');
        }
        else if (key === 'rows' && suppressHeightUpdate !== true) {
            that._updateWidgetHeight(reset === true ? 'dimensions' : undefined);
            that._setMaxValuesOfScrollBars('vertical');
        }
    }

    /**
     * Clears the selection.
     */
    _clearSelection() {
        const that = this;

        for (let i = 0; i < that.rows; i++) {
            for (let j = 0; j < that.columns; j++) {
                that._cells[i][j].td.classList.remove('jqx-array-element-selected');
            }
        }
    }

    /**
     * Clones a value.
     */
    _cloneValue(value) {
        if (typeof value !== 'object') {
            return value;
        }
        else {
            if (value instanceof Date) {
                return new Date(value.getTime());
            }
            else if (Array.isArray(value) || value instanceof Object) {
                return JSON.parse(JSON.stringify(value));
            }
        }
    }

    /**
     * Fills the value array.
     */
    _fillValueArray(changedValueDimensions, skipOverride) {
        const that = this,
            dimensions = that.dimensions;

        if (that._filledUpTo !== undefined && skipOverride !== true) {
            let skipFill = true;

            for (let a = 0; a < changedValueDimensions.length; a++) {
                skipFill = skipFill && (that._filledUpTo[a] >= changedValueDimensions[a]);
                changedValueDimensions[a] = Math.max(changedValueDimensions[a], that._filledUpTo[a]);
            }

            if (skipFill === true) {
                that._scroll();
                return;
            }
        }

        that._filledUpTo = changedValueDimensions.slice(0);

        function recursion(arr, level) {
            for (let i = 0; i <= changedValueDimensions[level]; i++) {
                if (level !== dimensions - 1) {
                    if (arr[i] === undefined) {
                        arr[i] = [];
                    }

                    recursion(arr[i], level + 1);
                }
                else if (arr[i] === undefined) {
                    arr[i] = that._getDefaultValue();
                }
            }
        }

        recursion(that.value, 0);

        that._scroll();
        that._setMaxValuesOfScrollBars();
    }

    /**
     * Gets default cell value.
     */
    _getDefaultCellValue() {
        const that = this;

        switch (that.type) {
            case 'custom':
                that._defaultValue = that.customWidgetDefaultValue !== null ? that.customWidgetDefaultValue : undefined;
                break;
            case 'numeric':
                that._defaultValue = 0;
                break;
            case 'boolean':
                that._defaultValue = false;
                break;
            case 'string':
                that._defaultValue = '';
                break;
        }
    }

    /**
     * Gets the default element value.
     */
    _getDefaultValue() {
        const that = this;

        return that._cloneValue(that._defaultValue);
    }

    /**
     * Gets element value.
     */
    _getElementValue(element, dimensions, clone) {
        const that = this;
        let value;

        if (that.getElementValue) {
            value = that.getElementValue(element, dimensions);
        }
        else {
            value = that.type === 'boolean' ? element.checked : element.value;
        }

        if (clone !== true) {
            return value;
        }
        else {
            return that._cloneValue(value);
        }
    }

    /**
     * Gets the initial fill of the value array.
     */
    _getInitialFill() {
        const that = this;

        that._filledUpTo = [];

        if (that.type !== 'none') {
            let tempArray = that.value;

            for (let i = 0; i < that.dimensions; i++) {
                const lastIndex = tempArray.length - 1;

                that._filledUpTo[i] = lastIndex;
                tempArray = tempArray[lastIndex];
            }

            that._setMaxValuesOfScrollBars();
        }
    }

    /**
     * Gets the max value of the horizontal or vertical scrollbar.
     */
    _getMaxValuesOfScrollBars(scrollbar) {
        const that = this,
            length = that._filledUpTo.length;
        let max = 0,
            filledUpTo, visibleCells, value;

        if (scrollbar === 'horizontal') {
            value = that.$.horizontalScrollbar.value;

            if (that.arrayIndexingMode === 'LabVIEW') {
                filledUpTo = that._filledUpTo[length - 1];
            }
            else {
                filledUpTo = that._filledUpTo[0];
            }

            visibleCells = that.columns;
        }
        else {
            value = that.$.verticalScrollbar.value;

            if (!that._oneDimensionSpecialCase) {
                if (that.arrayIndexingMode === 'LabVIEW') {
                    filledUpTo = that._filledUpTo[length - 2];
                }
                else {
                    filledUpTo = that._filledUpTo[1];
                }
            }
            else {
                if (that.arrayIndexingMode === 'LabVIEW') {
                    filledUpTo = that._filledUpTo[length - 1];
                }
                else {
                    filledUpTo = that._filledUpTo[0];
                }
            }

            visibleCells = that.rows;
        }

        if (filledUpTo === undefined) {
            return 0;
        }

        max = filledUpTo - visibleCells + 2;

        return Math.max(max, value);
    }

    /**
     * Gets value in cell.
     */
    _getValueInCell(row, column) {
        const that = this,
            array = that.value,
            dimensionValues = that._coordinates,
            length = dimensionValues.length;
        let value;

        if (length === 1) {
            if (that._oneDimensionSpecialCase === false) {
                value = array[column + dimensionValues[0]];
            }
            else {
                value = array[row + dimensionValues[0]];
            }
        }
        else {
            const actualIndexes = dimensionValues.slice(0);

            if (that.arrayIndexingMode === 'LabVIEW') {
                actualIndexes[length - 1] += column;
                actualIndexes[length - 2] += row;
            }
            else {
                actualIndexes[0] += column;
                actualIndexes[1] += row;
            }

            const oneDimensionalArrayValue = array[actualIndexes[0]];

            if (oneDimensionalArrayValue !== undefined) {
                const twoDimensionalArrayValue = oneDimensionalArrayValue[actualIndexes[1]];

                if (twoDimensionalArrayValue !== undefined) {
                    value = twoDimensionalArrayValue;

                    if (length > 2) {
                        for (let i = 2; i < length; i++) {
                            if (value === undefined) {
                                break;
                            }

                            value = value[actualIndexes[i]];
                        }
                    }
                }
            }
        }

        return value;
    }

    /**
     * Indexer change handler.
     */
    _indexerChangeHandler(event) {
        const that = this,
            oldContext = that.context;

        that.context = that;

        const dimension = event.target.dimension,
            actualDimension = that.arrayIndexingMode === 'LabVIEW' ? that.dimensions - dimension - 1 : dimension,
            value = parseFloat(event.detail.value);

        that._coordinates[actualDimension] = value;
        that._scroll();

        if (that.type !== 'none' && (dimension === 0 || dimension === 1)) {
            that._syncScrollbar(dimension, value);
        }

        event.stopPropagation();

        that.context = oldContext;
    }

    /**
     * Initializes elements.
     */
    _initializeElements(removeOldWidgets) {
        const that = this,
            cells = that._cells;
        that._initializeElement = function () { };

        function setElementTemplate(widget) {
            if (that.elementTemplate) {
                that.elementTemplate(widget, { x: widget.col, y: widget.row });
            }
        }

        if (that.type !== 'custom') {
            switch (that.type) {
                case 'numeric':
                    that._initializeElement = function (widget, value) {
                        widget.style.width = that.elementWidth + 'px';
                        widget.style.height = that.elementHeight + 'px';
                        widget.disabled = that.disabled;
                        widget.animation = that.animation;
                        widget.inputFormat = 'floatingPoint';
                        widget.spinButtons = true;
                        widget.value = value;

                        setElementTemplate(widget);
                    };
                    break;
                case 'boolean':
                    that._initializeElement = function (widget, value) {
                        widget.style.width = that.elementWidth + 'px';
                        widget.style.height = that.elementHeight + 'px';
                        widget.disabled = that.disabled;
                        widget.animation = that.animation;
                        widget.checked = value;

                        setElementTemplate(widget);
                    };
                    break;
                case 'string':
                    that._initializeElement = function (widget, value) {
                        widget.style.width = that.elementWidth + 'px';
                        widget.style.height = that.elementHeight + 'px';
                        widget.disabled = that.disabled;
                        widget.animation = that.animation;
                        widget.value = value;

                        setElementTemplate(widget);
                    };
                    break;
            }
        }
        else {
            that._initializeElement = function (widget, value) {
                if (that.elementTemplate) {
                    const widgetDimensions = { x: widget.col, y: widget.row };

                    that.elementTemplate(widget, widgetDimensions);

                    if (value !== undefined) {
                        that._setElementValue(value, widget, widgetDimensions);
                    }
                }
                else {
                    that.error(that.localize('callbackFunctionRequired', { callback: 'elementTemplate' }));
                }
            };
        }

        for (let i = 0; i < cells.length; i++) { // rows
            for (let j = 0; j < cells[i].length; j++) { // columns
                if (removeOldWidgets === true) {
                    const cell = cells[i][j];

                    cell.widget.$.unlisten('change');
                    cell.widget.$.unlisten('click');
                    cell.td.innerHTML = '';
                }

                that._initializeWidget(i, j);
            }
        }
    }

    /**
     * Initializes custom elements.
     */
    _initializeWidget(i, j) {
        const that = this,
            cell = that._cells[i][j],
            initialValue = that._getValueInCell(i, j);
        let widget;

        switch (that.type) {
            case 'boolean':
                widget = document.createElement('jqx-switch-button');
                break;
            case 'numeric':
                widget = document.createElement('jqx-numeric-text-box');
                widget.validation = 'interaction';
                break;
            case 'string':
                widget = document.createElement('jqx-text-box');
                break;
            case 'custom':
                widget = document.createElement('div');
                widget.$ = JQX.Utilities.Extend(widget);
                break;
        }

        widget.row = i;
        widget.col = j;

        cell.widget = widget;
        that._initializeElement(widget, initialValue === undefined ? that._getDefaultValue() : initialValue, cell);
        cell.td.appendChild(widget);
        widget.classList.add('jqx-array-element');
        widget.classList.add('jqx-array-element-' + that._id);

        if (initialValue === undefined) {
            widget.classList.add('jqx-array-element-empty');
        }

        that._addElementHandlers(widget);
    }

    /**
     * Checks if a cell is in selection.
     */
    _inSelection(x, y) {
        const that = this,
            dimensionValues = that._coordinates;
        let validation = true,
            xDimension, yDimension, boundX, boundY;

        if (that.arrayIndexingMode === 'LabVIEW') {
            xDimension = that.dimensions - 1;
            yDimension = that.dimensions - 2;
        }
        else {
            xDimension = 0;
            yDimension = 1;
        }

        if (!that._oneDimensionSpecialCase) {
            boundX = x + dimensionValues[xDimension];
            boundY = y + dimensionValues[yDimension];
        }
        else {
            boundX = y + dimensionValues[xDimension];
        }

        if (that.dimensions === 1) {
            if (boundX >= that._absoluteSelectionStart[xDimension] && boundX <= that._absoluteSelectionEnd[xDimension]) {
                return true;
            }
            else {
                return false;
            }
        }

        if (boundX >= that._absoluteSelectionStart[xDimension] &&
            boundX <= that._absoluteSelectionEnd[xDimension] &&
            boundY >= that._absoluteSelectionStart[yDimension] &&
            boundY <= that._absoluteSelectionEnd[yDimension]) {
            validation = true;
        }
        else {
            validation = false;
        }

        if (that.arrayIndexingMode === 'LabVIEW') {
            for (let i = 0; i < yDimension; i++) {
                validation = validation && (dimensionValues[i] >= that._absoluteSelectionStart[i] && dimensionValues[i] <= that._absoluteSelectionEnd[i]);
            }
        }
        else {
            for (let j = 2; j < that.dimensions; j++) {
                validation = validation && (dimensionValues[j] >= that._absoluteSelectionStart[j] && dimensionValues[j] <= that._absoluteSelectionEnd[j]);
            }
        }

        return validation;
    }

    /**
     * Moves scrollbar.
     */
    _moveScrollbar(scrollbar, type, index, value) {
        if (isNaN(value)) {
            return;
        }

        const that = this,
            max = that._getMaxValuesOfScrollBars(type),
            currentMax = scrollbar.max;
        let actualIndex;

        if (that.arrayIndexingMode === 'LabVIEW') {
            actualIndex = that.dimensions - index - 1;
        }
        else {
            actualIndex = index;
        }

        that._indexers[actualIndex].val(value);
        that._coordinates[actualIndex] = value;

        if (value <= max) {
            scrollbar.max = max;
        }
        else if (value <= currentMax) {
            scrollbar.max = value;
        }

        that._scroll();

        that.$.fireEvent('scroll', { 'direction': type });
    }

    /**
     * Refreshes selection.
     */
    _refreshSelection() {
        const that = this;

        if (that.showSelection) {
            for (let i = 0; i < that.rows; i++) {
                for (let j = 0; j < that.columns; j++) {
                    const value = that._getValueInCell(i, j),
                        skipSelectionCheck = value === undefined ? true : false;

                    that._addSelectionClass(j, i, that._cells[i][j].td, skipSelectionCheck);
                }
            }
        }
    }

    /**
     * Removes a dimension from "value" array.
     */
    _removeDimensionFromJSArray() {
        const that = this;

        if (that.arrayIndexingMode === 'LabVIEW') {
            that.value = that.value[0];
        }
        else {
            const dimensions = that.dimensions + 1,
                recursion = function (arr, level, parent, index) {
                    for (let i = 0; i < arr.length; i++) {
                        if (level !== dimensions && arr[i].length > 0) {
                            recursion(arr[i], level + 1, arr, i);
                        }
                        else {
                            if (parent !== undefined) {
                                parent[index] = arr[0];
                            }
                            else {
                                that.value = that.value[0];
                            }
                        }
                    }
                };

            recursion(that.value, 1);
        }
    }

    /**
     * Resize handler.
     */
    _resizeHandler() {
        const that = this;

        if (that.offsetWidth !== that._cachedWidth) {
            if (that.type !== 'none') {
                const valueDifference = that.offsetWidth - that._cachedWidth,
                    elementDimension = that.elementWidth;

                if (Math.abs(valueDifference) < elementDimension) {
                    that.style.width = that._cachedWidth + 'px';
                    return;
                }

                const rowsColumnsDifference = Math.round(valueDifference / elementDimension),
                    oldValue = that.columns,
                    newValue = oldValue + rowsColumnsDifference;

                that.columns = newValue;
                that._changeRowsColumns('columns', oldValue, newValue);
            }
            else {
                that._updateWidgetWidth();
            }
        }

        that._cachedWidth = that.offsetWidth;

        if (that.offsetHeight !== that._cachedHeight) {
            if (that.type === 'none') {
                that._updateWidgetHeight();
            }
            else {
                that.style.height = that._cachedHeight + 'px';
                return;
            }
        }

        that._cachedHeight = that.offsetHeight;
    }

    /**
     * Returns an empty array with the necessary dimensions.
     */
    _returnEmptyArray() {
        const that = this,
            emptyArray = [];
        let current = emptyArray;

        if (that.dimensions > 1) {
            for (let i = 1; i < that.dimensions; i++) {
                current[0] = [];
                current = current[0];
            }
        }

        return emptyArray;
    }

    /**
     * Scrolls the Array.
     */
    _scroll() {
        const that = this;

        if (that.type === 'none') {
            return;
        }

        for (let i = 0; i < that._cells.length; i++) {
            for (let j = 0; j < that._cells[i].length; j++) {
                const value = that._getValueInCell(i, j),
                    widget = that._cells[i][j].widget,
                    widgetDimensions = { x: j, y: i },
                    widgetValue = that._getElementValue(widget, widgetDimensions);
                let skipSelectionCheck;

                if (value !== undefined) {
                    widget.classList.remove('jqx-array-element-empty');

                    if (that._areDifferent(widgetValue, value)) {
                        widget.supressChange = true;
                        that._setElementValue(value, widget, widgetDimensions);
                    }
                    else {
                        widget.supressChange = false;
                    }

                    skipSelectionCheck = false;
                }
                else {
                    widget.classList.add('jqx-array-element-empty');

                    if (that._areDifferent(widgetValue, that._defaultValue)) {
                        widget.supressChange = true;
                        that._setElementValue(that._getDefaultValue(), widget, widgetDimensions);
                    }
                    else {
                        widget.supressChange = false;
                    }

                    skipSelectionCheck = true;
                }

                that._addSelectionClass(j, i, that._cells[i][j].td, skipSelectionCheck);
            }
        }
    }

    /**
     * Scrollbar change handler.
     */
    _scrollbarChangeHandler(event) {
        const that = this;
        let direction, index;

        event.stopPropagation();

        if (that.type === 'none') {
            return;
        }

        if (event.target === that.$.horizontalScrollbar) {
            direction = 'horizontal';
            index = 0;
        }
        else {
            direction = 'vertical';
            index = that._oneDimensionSpecialCase ? 0 : 1;
        }

        if (that._suppressScrollbarEvent !== true) {
            that._moveScrollbar(event.target, direction, index, Math.round(event.detail.value));
        }
        else {
            that._suppressScrollbarEvent = false;
        }

        if (!that._clickTriggered) {
            that._changeTriggered = true;

            setTimeout(function () {
                that._changeTriggered = false;
            }, 50);
        }
    }

    /**
     * Scrollbar click handler.
     */
    _scrollbarClickHandler(event) {
        const button = event.target.closest('.jqx-scroll-button');

        if (button === null) {
            return;
        }

        const that = this,
            scrollbar = button.parentElement.parentElement;

        if (button === scrollbar.$.farButton) {
            if (that._changeTriggered) {
                return;
            }

            that._clickTriggered = true;

            setTimeout(function () {
                that._clickTriggered = false;
            }, 50);

            const scrollbarMax = scrollbar.max;
            let scrollbarValue = scrollbar.value;

            if (isNaN(scrollbarValue) === true) {
                scrollbarValue = 0;
            }

            if (scrollbarMax === scrollbarValue) {
                scrollbar.max = scrollbarMax + 1;
                scrollbar.value = scrollbarMax + 1;
            }
        }
    }

    /**
     * Sets the value of an element.
     */
    _setElementValue(value, element, dimensions) {
        const that = this;

        value = that._cloneValue(value);

        if (that.setElementValue) {
            that.setElementValue(value, element, dimensions);

            if (element.supressChange === true) {
                element.supressChange = false;
            }
        }
        else {
            if (that.type === 'boolean') {
                element.checked = value;
            }
            else {
                element.value = value;
            }
        }
    }

    /**
     * Sets the max value of the horizontal or vertical scrollbar.
     */
    _setMaxValuesOfScrollBars(which) {
        const that = this;

        if (that.showHorizontalScrollbar && (which === undefined || which === 'horizontal')) {
            that.$.horizontalScrollbar.max = that._getMaxValuesOfScrollBars('horizontal');
        }

        if (that.showVerticalScrollbar && (which === undefined || which === 'vertical')) {
            that.$.verticalScrollbar.max = that._getMaxValuesOfScrollBars('vertical');
        }
    }

    /**
     * Shows the horizontal scrollbar.
     */
    _showHorizontalScrollbar(show) {
        const that = this;

        that.showHorizontalScrollbar = show;
        that._updateWidgetHeight('showHorizontalScrollbar');

        if (show === true) {
            that.$horizontalScrollbarContainer.removeClass('jqx-hidden');

            if (that.type !== 'none') {
                let xDimension;

                if (that.arrayIndexingMode === 'LabVIEW') {
                    xDimension = that.dimensions - 1;
                }
                else {
                    xDimension = 0;
                }

                that._syncScrollbar(0, that._coordinates[xDimension]);
            }
        }
        else {
            that.$horizontalScrollbarContainer.addClass('jqx-hidden');
        }
    }

    /**
     * Shows the vertical scrollbar.
     */
    _showVerticalScrollbar(show) {
        const that = this;

        that.showVerticalScrollbar = show;
        that._updateWidgetWidth(true);

        if (show === true) {
            that.$verticalScrollbarContainer.removeClass('jqx-hidden');

            if (that.type !== 'none') {
                let yDimension;

                if (that._oneDimensionSpecialCase) {
                    yDimension = 0;
                }
                else if (that.arrayIndexingMode === 'LabVIEW') {
                    yDimension = that.dimensions - 2;
                }
                else {
                    yDimension = 1;
                }

                that._syncScrollbar(1, that._coordinates[yDimension]);
            }
        }
        else {
            that.$verticalScrollbarContainer.addClass('jqx-hidden');
        }
    }

    /**
     * Synchronizes the corresponding scrollbar.
     */
    _syncScrollbar(dimension, value) {
        const that = this;
        let max, scrollbar;

        if (dimension === 0 && that._oneDimensionSpecialCase === false) {
            if (!that.showHorizontalScrollbar) {
                return;
            }

            max = that._getMaxValuesOfScrollBars('horizontal');
            scrollbar = that.$.horizontalScrollbar;
        }
        else {
            if (!that.showVerticalScrollbar) {
                return;
            }

            max = that._getMaxValuesOfScrollBars('vertical');
            scrollbar = that.$.verticalScrollbar;
        }

        if (value > max) {
            max = value;
        }

        const currentMax = scrollbar.max;

        if (currentMax !== max) {
            if (currentMax > max) {
                that._suppressScrollbarEvent = true;
            }

            scrollbar.max = max;
        }

        if (scrollbar.value !== value) {
            that._suppressScrollbarEvent = true;
            scrollbar.value = value;
        }
    }

    /**
     * Updates the value of the Array.
     */
    _updateValue(row, column, newValue) {
        const that = this,
            oldValue = that._getValueInCell(row, column);

        if (!that._areDifferent(newValue, oldValue)) {
            return;
        }

        const dimensionValues = that._coordinates,
            actualIndexes = dimensionValues.slice(0),
            changedValueDimensions = [];

        if (that.arrayIndexingMode === 'LabVIEW') {
            actualIndexes[actualIndexes.length - 1] += column;
            actualIndexes[actualIndexes.length - 2] += row;
        }
        else {
            actualIndexes[0] += column;
            actualIndexes[1] += row;
        }

        for (let i = 0; i < that.dimensions; i++) {
            if (i === 0) { // x
                if (that._oneDimensionSpecialCase === false) {
                    changedValueDimensions.push(actualIndexes[0]);
                }
                else {
                    changedValueDimensions.push(row + dimensionValues[0]);
                }
            }
            else if (i === 1) { // y
                changedValueDimensions.push(actualIndexes[1]);
            }
            else { // other dimensions
                changedValueDimensions.push(actualIndexes[i]);
            }
        }

        let tempArr = that.value;

        for (let j = 0; j < changedValueDimensions.length; j++) {
            if (tempArr[changedValueDimensions[j]] === undefined || tempArr[changedValueDimensions[j]] === oldValue) {
                if (j !== changedValueDimensions.length - 1) {
                    tempArr[changedValueDimensions[j]] = [];
                }
                else {
                    tempArr[changedValueDimensions[j]] = newValue;
                }
            }
            tempArr = tempArr[changedValueDimensions[j]];
        }

        that._fillValueArray(changedValueDimensions.slice(0));

        that.$.fireEvent('change', { 'value': newValue, 'oldValue': oldValue, 'dimensionIndexes': changedValueDimensions });
    }

    /**
     * Updates element height.
     */
    _updateWidgetHeight(propertyChangedHandler) {
        const that = this,
            hScrollbarContainerSize = that.showHorizontalScrollbar ? 20 : 0;
        let mainHeight, indexerContaineHeight;

        if (that.showIndexDisplay) {
            const marginBottom = parseInt(window.getComputedStyle(that._indexers[0]).marginBottom, 10);

            indexerContaineHeight = that.dimensions * (that.indexerHeight + marginBottom) - marginBottom;
        }
        else {
            indexerContaineHeight = 0;
        }

        if (that.type !== 'none') {
            mainHeight = that.$.mainContainer.offsetHeight + hScrollbarContainerSize;
        }
        else {
            if (propertyChangedHandler === 'showHorizontalScrollbar') {
                const currentBigContainerHeight = that.$.bigContainer.offsetHeight;

                if (that.showHorizontalScrollbar === true) {
                    mainHeight = currentBigContainerHeight + 20;
                }
                else {
                    mainHeight = currentBigContainerHeight - 20;
                }
            }
            else if (propertyChangedHandler === 'showIndexDisplay' && that.showIndexDisplay === false || propertyChangedHandler === 'dimensions') {
                mainHeight = that.$.bigContainer.offsetHeight;
            }
            else {
                mainHeight = that.offsetHeight;
            }

            const minHeight = 18 + hScrollbarContainerSize;

            if (mainHeight < minHeight) {
                mainHeight = minHeight;
            }

            that.$.mainContainer.style.height = (mainHeight - hScrollbarContainerSize) + 'px';
        }

        that.$.verticalScrollbarContainer.style.height = (mainHeight - hScrollbarContainerSize) + 'px';
        that.$.bigContainer.style.height = mainHeight + 'px';

        const style = window.getComputedStyle(that);

        that._cachedHeight = Math.max(indexerContaineHeight, mainHeight) + parseInt(style.borderTopWidth, 10) + parseInt(style.borderBottomWidth, 10);

        if (that.type !== 'none') {
            that.style.minHeight = that._cachedHeight + 'px';
            that.style.maxHeight = that._cachedHeight + 'px';
        }

        that.style.height = that._cachedHeight + 'px';
    }

    /**
     * Updates element width.
     */
    _updateWidgetWidth(propertyChangedHandler) {
        const that = this,
            vScrollbarContainerSize = that.showVerticalScrollbar ? 20 : 0,
            indexerWidth = that.showIndexDisplay ? that.indexerWidth : 0,
            marginLeft = parseInt(window.getComputedStyle(that.$.bigContainer).marginLeft, 10);
        let centralContainerWidth, bigContainerWidth, width;

        if (that.type !== 'none') {
            centralContainerWidth = that.$.centralContainer.offsetWidth;
            bigContainerWidth = centralContainerWidth + vScrollbarContainerSize;
            width = bigContainerWidth + indexerWidth + marginLeft;
        }
        else {
            width = that.offsetWidth;

            if (propertyChangedHandler === true) {
                if (that.showVerticalScrollbar === true) {
                    width += 20;
                }
                else {
                    width -= 20;
                }
            }

            const minWidth = indexerWidth + 18 + vScrollbarContainerSize;

            if (width < minWidth) {
                width = minWidth;
            }

            bigContainerWidth = width - indexerWidth - marginLeft;
            centralContainerWidth = bigContainerWidth - vScrollbarContainerSize;
            that.$.centralContainer.style.width = centralContainerWidth + 'px';
        }

        that.$.bigContainer.style.width = bigContainerWidth + 'px';

        const style = window.getComputedStyle(that);

        width += parseInt(style.borderLeftWidth, 10) + parseInt(style.borderRightWidth, 10);
        that.style.width = width + 'px';
        that._cachedWidth = width;
    }

    /**
     * Validates properties.
     */
    _validateProperties() {
        const that = this;

        that._oneDimensionSpecialCase = false;

        if (that.type === 'none') {
            that.rows = 1;
            that.columns = 1;
        }
        else {
            if (that.rows < 1) {
                that.rows = 1;
            }
            if (that.columns < 1) {
                that.columns = 1;
            }
        }

        if (that.dimensions < 1 || that.dimensions > 32) {
            that.dimensions = 1;
        }

        if (that.dimensions === 1) {
            if (that.columns > 1) {
                that.rows = 1;
                if (that.showVerticalScrollbar === true) {
                    that.showVerticalScrollbar = false;
                }
            }
            else if (that.rows !== 1) {
                that._oneDimensionSpecialCase = true;
                if (that.showHorizontalScrollbar === true) {
                    that.showHorizontalScrollbar = false;
                }
            }
            else if (that.columns === 1 && that.rows === 1) {
                if (that.showVerticalScrollbar === true) {
                    that.showVerticalScrollbar = false;
                }
            }
        }

        that._validateValue();

        if (that.showIndexDisplay) {
            that.$indexerContainer.removeClass('jqx-hidden');
        }

        that.$.indexerContainer.style.width = that.indexerWidth + 'px';

        if (that.showHorizontalScrollbar) {
            that.$horizontalScrollbarContainer.removeClass('jqx-hidden');
        }

        if (that.showVerticalScrollbar) {
            that.$verticalScrollbarContainer.removeClass('jqx-hidden');
        }
    }

    /**
     * Validates value.
     */
    _validateValue() {
        const that = this;

        if (that.type === 'none') {
            that.value = null;
        }
        else if (that.value === null || that.value === undefined) {
            that.value = that._returnEmptyArray();
        }
        else {
            that._validateValueArrayDimensions();
        }
    }

    /**
     * Validates the dimensions of the value array.
     */
    _validateValueArrayDimensions() {
        const that = this;
        let dimensions = 0,
            tempArray = that.value,
            emptyArray = false;

        while (tempArray.constructor === Array) {
            dimensions++;
            tempArray = tempArray[0];

            if (tempArray === undefined) {
                emptyArray = true;
                break;
            }
        }

        if (that.dimensions > dimensions) {
            if (emptyArray) {
                that.value = that._returnEmptyArray();
                return;
            }

            while (that.dimensions > dimensions) {
                that._addDimensionToJSArray(dimensions);
                dimensions++;
            }
        }
    }
});

/**
* Calendar custom element.
*/
JQX('jqx-calendar', class Calendar extends JQX.BaseElement {
    /** 
    * Calendar's properties 
    */
    static get properties() {
        return {
            'animationSettings': {
                value: null,
                type: 'object'
            },
            'calendarMode': {
                value: 'default',
                allowedValues: ['default', 'classic'],
                type: 'string'
            },
            'dayNameFormat': {
                value: 'firstTwoLetters',
                allowedValues: ['narrow', 'firstTwoLetters', 'long', 'short'],
                type: 'string'
            },
            'dateFormatFunction': {
                value: null,
                type: 'function'
            },
            'disableAutoNavigation': {
                value: false,
                type: 'boolean'
            },
            'displayMode': {
                value: 'month',
                allowedValues: ['month', 'year', 'decade'],
                type: 'string'
            },
            'displayModeView': {
                value: 'table',
                allowedValues: ['table', 'list'],
                type: 'string'
            },
            'dropDownHeight': {
                value: '200',
                type: 'string'
            },
            'dropDownWidth': {
                value: 'initial',
                type: 'string'
            },
            'firstDayOfWeek': {
                value: 0,
                type: 'number',
                defaultValue: 0,
                validator: '_firstDayOfWeekValidator'
            },
            'footerTemplate': {
                value: null,
                type: 'any'
            },
            'headerTemplate': {
                value: null,
                type: 'any'
            },
            'hideDayNames': {
                value: false,
                type: 'boolean'
            },
            'hideOtherMonthDays': {
                value: false,
                type: 'boolean'
            },
            'hideTooltipArrow': {
                value: false,
                type: 'boolean'
            },
            'importantDates': {
                value: [],
                type: 'array',
                defaultValue: []
            },
            'importantDatesTemplate': {
                value: null,
                type: 'any'
            },
            'max': {
                value: new Date(2100, 1, 1),
                type: 'any',
                defaultValue: new Date(2100, 1, 1)
            },
            'min': {
                value: new Date(1900, 1, 1),
                type: 'any',
                defaultValue: new Date(1900, 1, 1)
            },
            'months': {
                value: 1,
                type: 'number',
                defaultValue: 1,
                validator: '_monthsValidator'
            },
            'monthNameFormat': {
                value: 'long',
                allowedValues: ['narrow', 'firstTwoLetters', 'long', 'short', '2-digit', 'numeric'],
                type: 'string'
            },
            'name': {
                value: '',
                type: 'string'
            },
            'restrictedDates': {
                value: [],
                type: 'array',
                defaultValue: []
            },
            'scrollButtonsNavigationMode': {
                value: 'landscape',
                allowedValues: ['portrait', 'landscape'],
                type: 'string'
            },
            'scrollButtonsPosition': {
                value: 'both',
                allowedValues: ['near', 'far', 'both'],
                type: 'string'
            },
            'selectedDates': {
                value: [],
                type: 'array'
            },
            'selectionMode': {
                value: 'default',
                allowedValues: ['none', 'default', 'one', 'many', 'zeroOrMany', 'oneOrMany', 'zeroOrOne', 'week'],
                type: 'string'
            },
            'spinButtonsDelay': {
                value: 80,
                type: 'number'
            },
            'spinButtonsInitialDelay': {
                value: 0,
                type: 'number'
            },
            'titleTemplate': {
                value: null,
                type: 'any'
            },
            'tooltip': {
                value: false,
                type: 'boolean'
            },
            'tooltipDelay': {
                value: 100,
                type: 'number'
            },
            'tooltipPosition': {
                value: 'top',
                allowedValues: ['bottom', 'top', 'left', 'right', 'absolute'],
                type: 'string'
            },
            'tooltipTemplate': {
                value: null,
                type: 'any'
            },
            'view': {
                value: 'portrait',
                allowedValues: ['landscape', 'portrait'],
                type: 'string'
            },
            'viewSections': {
                value: ['header'],
                type: 'array'
            },
            'weekNumbers': {
                value: false,
                type: 'boolean'
            },
            'weeks': {
                value: 6,
                type: 'number',
                defaultValue: 6,
                validator: '_weeksValidator'
            },
            'yearFormat': {
                value: 'numeric',
                allowedValues: ['2-digit', 'numeric'],
                type: 'string'
            }
        }
    }

    /**
    * Calendar's event listeners.
    */

    static get listeners() {
        return {
            'container.down': '_downHandler',
            'document.up': '_documentUpHandler',
            'container.move': '_moveHandler',
            'container.wheel': '_containerWheelHandler',
            'body.focus': '_bodyFocusStateHandler',
            'body.blur': '_bodyBlurStateHandler',
            'header.click': '_headerClickHandler',
            'header.change': '_headerChangeHandler',
            'keydown': '_keyDownHandler',
            'keyup': '_keyUpHandler',
            'listViewContainer.keydown': '_listViewContainerKeyDownHandler',
            'listViewContainer.change': '_listViewContainerChangeEventHandler',
            'mouseenter': '_mouseEventsHandler',
            'mouseleave': '_mouseEventsHandler',
            'container.mouseover': '_mouseEventsHandler',
            'container.mouseout': '_mouseEventsHandler',
            'tooltip.open': '_tooltipEventHandler',
            'tooltip.close': '_tooltipEventHandler'
        }
    }

    static get methods() {
        return {
            'select': 'select(date=new Date(): date|string): void',
            'clearSelection': 'clearSelection(): void',
            'today': 'today(): date',
            'navigate': 'navigate(step: int): bool'
        }
    }

    /**
    * CSS files needed for the element (ShadowDOM)
    */
    static get styleUrls() {
        return [
            'jqx.button.css',
            'jqx.dropdownlist.css',
            'jqx.dropdown.css',
            'jqx.tooltip.css',
            'jqx.calendar.css'
        ]
    }

    /**
    * Calendar's HTML template.
    */
    template() {
        return `<div id="container">
                    <div id="title" class="jqx-calendar-title">
                        <div id="yearContainer" class="jqx-calendar-year-container"></div>
                        <div id="dateContainer" class="jqx-calendar-date-container jqx-calendar-selected"></div>
                    </div>
                    <div id="calendarContainer" class="jqx-calendar-container">
                        <div id="header" class="jqx-calendar-header">
                            <jqx-repeat-button prev-month class="jqx-calendar-button" id="previousMonthButton" animation="[[animation]]" initial-delay="[[spinButtonsInitialDelay]]" delay="[[spinButtonsDelay]]" disabled="[[disabled]]" readonly="[[readonly]]">
                                <div class="jqx-arrow">&#xe809</div>
                            </jqx-repeat-button>
                            <div id="dateElement" class="jqx-calendar-date-element">
                                <div id="defaultHeaderDate"></div>
                                <div id="classicHeaderDate">
                                    <jqx-drop-down-list class="jqx-calendar-month-element" id="monthElement" drop-down-position="bottom" selection-mode="one" disabled="[[disabled]]" readonly="[[readonly]]" drop-down-width="[[dropDownWidth]]" drop-down-height="[[dropDownHeight]]" theme="[[theme]]">
                                    </jqx-drop-down-list>
                                    <input class="jqx-calendar-year-element" id="yearElement" disabled="[[disabled]]" readonly="[[readonly]]"/>
                                    <span class="jqx-calendar-year-elements">
                                        <jqx-repeat-button next-year class="jqx-calendar-button" id="nextYearButton" animation="[[animation]]" initial-delay="[[spinButtonsInitialDelay]]" delay="[[spinButtonsDelay]]" disabled="[[disabled]]" readonly="[[readonly]]">
                                            <span class="jqx-arrow">&#xe801</span>
                                        </jqx-repeat-button>
                                        <jqx-repeat-button prev-year class="jqx-calendar-button" id="previousYearButton" animation="[[animation]]" initial-delay="[[spinButtonsInitialDelay]]" delay="[[spinButtonsDelay]]" disabled="[[disabled]]" readonly="[[readonly]]">
                                            <span class="jqx-arrow">&#xe804</span>
                                        </jqx-repeat-button>
                                    </span>
                                </div>
                            </div>
                            <jqx-repeat-button next-month class="jqx-calendar-button" id="nextMonthButton" animation="[[animation]]" initial-delay="[[spinButtonsInitialDelay]]" delay="[[spinButtonsDelay]]" disabled="[[disabled]]" readonly="[[readonly]]">
                                <div class="jqx-arrow">&#xe810</div>
                            </jqx-repeat-button>
                        </div>
                        <div id="body" class="jqx-content jqx-calendar-body">
                           <div id="monthsContainer" class="jqx-calendar-months-container">
                              <div id="month" class="jqx-calendar-month">
                                   <div id="monthName" class="jqx-calendar-month-name"></div>
                                   <div id="weekTitles" class="jqx-calendar-week-titles">
                                       <div class="jqx-calendar-week-title"></div>
                                       <div  class="jqx-calendar-week-title"></div>
                                       <div  class="jqx-calendar-week-title"></div>
                                       <div  class="jqx-calendar-week-title"></div>
                                       <div  class="jqx-calendar-week-title"></div>
                                       <div  class="jqx-calendar-week-title"></div>
                                       <div  class="jqx-calendar-week-title"></div>
                                       <div  class="jqx-calendar-week-title"></div>
                                   </div>
                                   <div id="weeks" class="jqx-calendar-weeks">
                                        <div class="jqx-calendar-week">
                                           <div class="jqx-calendar-week-number"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"> </div>
                                        </div>
                                        <div class="jqx-calendar-week">
                                           <div class="jqx-calendar-week-number"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"> </div>
                                           <div class="jqx-calendar-cell"> </div>
                                           <div class="jqx-calendar-cell"> </div>
                                       </div>
                                       <div class="jqx-calendar-week">
                                           <div class="jqx-calendar-week-number"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"> </div>
                                           <div class="jqx-calendar-cell"> </div>
                                           <div class="jqx-calendar-cell"> </div>
                                       </div>
                                       <div class="jqx-calendar-week">
                                           <div class="jqx-calendar-week-number"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"> </div>
                                           <div class="jqx-calendar-cell"> </div>
                                           <div class="jqx-calendar-cell"> </div>
                                       </div>
                                       <div class="jqx-calendar-week">
                                           <div class="jqx-calendar-week-number"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"> </div>
                                           <div class="jqx-calendar-cell"> </div>
                                           <div class="jqx-calendar-cell"> </div>
                                       </div>
                                       <div class="jqx-calendar-week">
                                           <div class="jqx-calendar-week-number"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"></div>
                                           <div class="jqx-calendar-cell"> </div>
                                           <div class="jqx-calendar-cell"> </div>
                                           <div class="jqx-calendar-cell"> </div>
                                       </div>
                                   </div>
                                </div>
                            </div>
                            <div id="dateViewContainer" class="jqx-calendar-date-view-container jqx-hidden">
                                    <div class="jqx-calendar-cell"></div>
                                    <div class="jqx-calendar-cell"></div>
                                    <div class="jqx-calendar-cell"></div>
                                    <div class="jqx-calendar-cell"></div>
                                    <div class="jqx-calendar-cell"></div>
                                    <div class="jqx-calendar-cell"></div>
                                    <div class="jqx-calendar-cell"></div>
                                    <div class="jqx-calendar-cell"></div>
                                    <div class="jqx-calendar-cell"></div>
                                    <div class="jqx-calendar-cell"></div>
                                    <div class="jqx-calendar-cell"></div>
                                    <div class="jqx-calendar-cell"></div>
                            </div>
                            <div id="monthsSeparator" class="jqx-calendar-month-separator"></div>
                            <div id="nextMonthsContainer" class="jqx-calendar-next-months-container"></div>
                            <jqx-list-box item-height="30" unfocusable id="listViewContainer" selection-mode="one" class="jqx-calendar-list-view jqx-hidden" animation="simple"></jqx-list-box>
                            <div id="animationPanel" class="jqx-calendar-animation-panel jqx-hidden"></div>
                        </div>
                        <div id="footer" class="jqx-calendar-footer jqx-hidden">
                            <div id="selectedDatesRange"></div>
                        </div>
                        <jqx-tooltip id="tooltip" open-mode="manual" arrow
                                   tooltip-template="[[tooltipTemplate]]"
                                   position="[[tooltipPosition]]"
                                   delay="[[tooltipDelay]]"
                                   disabled="[[disabled]]">
                         </jqx-tooltip>
                        <input id="hiddenInput" type="hidden" name="[[name]]">
                    </div>
                </div>`;
    }

    /**
    * Updates the Calendar when a property is changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
    * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this;

        switch (propertyName) {
            case 'animationSettings':
                that._applyAnimationSettings();
                break;
            case 'disabled':
            case 'unfocusable':
                that._setFocusable();
                break;
            case 'calendarMode':
                that.displayMode = 'month';
                that._refreshCalendarMode();
                that._setDisplayModeContent();
                break;
            case 'dayNameFormat':
                that._refreshDayOfWeekTitles(that.$.month);
                break;
            case 'dateFormatFunction': {
                let months = that.$.monthsContainer.children;

                for (let m = 0; m < months.length; m++) {
                    months[m].firstElementChild.innerHTML = newValue ? newValue(months[m]._date) :
                        that._monthsNames[months[m]._date.getMonth()] + ' ' + months[m]._date.toLocaleDateString(that.locale, { year: that.yearFormat });
                }

                that._refreshHeaderTitle();
                break;
            }
            case 'displayMode':
                that._setDisplayMode(oldValue, newValue);
                break;
            case 'displayModeView':
                that._applyAnimationSettings(true);
                if (that.displayMode !== 'month') {
                    that._setDisplayModeContent();
                }

                break;
            case 'firstDayOfWeek':
                that._handleMonths();
                that._refreshDayOfWeekTitles();
                break;
            case 'hideTooltipArrow':
                that.$.tooltip.arrow = newValue ? false : true;
                break;
            case 'titleTemplate':
            case 'headerTemplate':
            case 'footerTemplate':
                that._handleLayoutTemplate(that.$[propertyName.split(/[T]/)[0]], newValue);
                if (propertyName === 'titleTemplate') {
                    that._refreshTitle();
                }
                else if (propertyName === 'headerTemplate') {
                    that._refreshHeaderTitle();
                }
                else {
                    that._refreshFooter();
                }

                break;
            case 'importantDates':
                that.importantDates = that._getValidDates(newValue);
                that._refreshImportantDates();
                break;
            case 'importantDatesTemplate':
                that._handleImportantDateTemplate();
                that._refreshImportantDates();
                break;
            case 'locale':
                that._refreshMonthNames();
                that._refreshDayOfWeekTitles();
                that._refreshHeaderTitle();
                that._refreshTitle();
                that._refreshFooter();
                if (that.displayMode && that.displayMode !== 'month') {
                    that._setDisplayModeContent();
                }

                break;
            case 'max':
            case 'min':
                that._validateMinMax(propertyName, newValue, oldValue);
                that._validateSelectedDates();
                that._noFocusingRequired = false;
                that._refreshHeaderElements();
                break;
            case 'months':
                that._handleMonths();
                break;
            case 'monthNameFormat':
                that._refreshCalendarMode();
                that._refreshHeaderTitle();
                break;
            case 'restrictedDates':
                that._setRestrictedDates(that.restrictedDates = that._getValidDates(newValue));
                break;
            case 'rightToLeft':
                that._refreshDayOfWeekTitles();
                that._handleMonths();
                break;
            case 'scrollButtonsNavigationMode':
                that._setScrollButtonsNavigationMode();
                break;
            case 'selectedDates':
                that._clearSelection(true);
                that._validateSelectedDates(that._getValidDates(newValue));
                that._applySelectionMode(true);
                if (that._viewDates) {
                    let lastSelectedDate = that.selectedDates[that.selectedDates.length - 1];

                    !that._isDateInView(lastSelectedDate) ?
                        //true flags indicate eventPrevention and noPropertySynchronization
                        that._handleMonths(lastSelectedDate) : that.selectedDates.map(date => that._selectDate(date, true, true));
                }

                that._refreshFooter();
                that._setWeeksVisibility(that.$.monthsContainer);

                //Update the hidden input
                that.$.hiddenInput.value = that.selectedDates.toString();

                that.$.fireEvent('change', { 'value': that.selectedDates });
                that._refreshTitle();
                break;
            case 'selectionMode':
                that._applySelectionMode();
                that._refreshTitle();
                break;
            case 'view':
                that._refreshTitle();
                break;
            case 'viewSections':
                newValue.indexOf('title') > -1 ? that.$title.removeClass('jqx-hidden') : that.$title.addClass('jqx-hidden');
                that._refreshTitle();
                newValue.indexOf('header') > -1 ? that.$header.removeClass('jqx-hidden') : that.$header.addClass('jqx-hidden');
                that._refreshHeaderTitle();
                newValue.indexOf('footer') > -1 ? that.$footer.removeClass('jqx-hidden') : that.$footer.addClass('jqx-hidden');
                that._refreshFooter();
                that._setFocusable();
                break;
            case 'weeks':
                that._setWeeksVisibility(that.$.monthsContainer);
                break;
            case 'yearFormat':
                that._refreshCalendarMode();
                that._refreshFooter();

                //Set month name
                if (that.months > 1 && that.displayMode === 'month') {
                    let months = that._animationStarted ? that.$.nextMonthsContainer.children : that.$.monthsContainer.children;

                    for (let i = 0; i < months.length; i++) {
                        months[i].firstElementChild.innerHTML = that.dateFormatFunction ? that.dateFormatFunction(months[i]._date) :
                            that._monthsNames[months[i]._date.getMonth()] + ' ' + months[i]._date.toLocaleDateString(that.locale, { year: newValue });
                    }
                }

                that._refreshTitle();
                that._refreshHeaderTitle();
                break;
        }
    }

    /**
    * Calendar ready method.
    */
    ready() {
        super.ready();

        const that = this;

        that._keysPressed = {};

        that._applyAnimationSettings();
        that.importantDates = that._getValidDates(that.importantDates);
        that.restrictedDates = that._getValidDates(that.restrictedDates);

        that._refreshMonthNames();
        that._validateMinMax();

        that._validateSelectedDates(that._getValidDates(that.selectedDates));

        that._handleLayoutTemplate(that.$.title, that.titleTemplate);
        that._handleLayoutTemplate(that.$.header, that.headerTemplate);
        that._handleLayoutTemplate(that.$.footer, that.footerTemplate);
        that._handleImportantDateTemplate();

        that._setFocusable();
        that._refreshDayOfWeekTitles();

        that._applySelectionMode(true);
        that._handleMonths(that.selectedDates.length === 0 ? new Date(new Date().setHours(0, 0, 0, 0)) : that.selectedDates[that.selectedDates.length - 1]);

        that._updateViewSectionsVisibility();
        that._setScrollButtonsNavigationMode();
        that._refreshCalendarMode();
        that._setDisplayMode();
        that._refreshTitle();
        that._refreshFooter();
        that._refreshImportantDates();

        //Since jqxDropDownList uses CSS vars for the width/Height of the drop down list, 
        // recalculation of the size of the drop down is needed since the layout has been changed by populating the Calendar with data.
        if (that.$.monthElement) {
            that.$.monthElement._setDropDownSize();
        }

        that._changeEventFired = 0;
    }

    _updateViewSectionsVisibility() {
        const that = this;

        that.viewSections.indexOf('title') > -1 ? that.$title.removeClass('jqx-hidden') : that.$title.addClass('jqx-hidden');
        that.viewSections.indexOf('header') > -1 ? that.$header.removeClass('jqx-hidden') : that.$header.addClass('jqx-hidden');
        that.viewSections.indexOf('footer') > -1 ? that.$footer.removeClass('jqx-hidden') : that.$footer.addClass('jqx-hidden');
    }

    /**
    * Clears the currently selected dates. Public method
    */
    clearSelection() {
        this._clearSelection();
    }

    /**
    * Sets tab index 
    */
    _setFocusable() {
        const that = this;
        let index = that.tabIndex > 0 ? that.tabIndex : 0;

        //HeaderComponents
        function setHeaderElement(component, componentType) {
            if (!componentType) {
                return;
            }

            if (component && component instanceof componentType) {
                if (typeof (component._setFocusable) === 'function' && component.isCompleted) { //If a JQX element is added to the element and its not ready
                    component.unfocusable = index <= -1;
                }
                else {
                    component.setAttribute('tabindex', index);
                }

                return component;
            }
        }

        if (that.disabled || that.unfocusable) {
            index = -1;
        }

        that.$.previousMonthButton = setHeaderElement(that.$.previousMonthButton, JQX.Button);
        that.$.nextMonthButton = setHeaderElement(that.$.nextMonthButton, JQX.Button);
        that.$.nextYearButton = setHeaderElement(that.$.nextYearButton, JQX.Button);
        that.$.previousYearButton = setHeaderElement(that.$.previousYearButton, JQX.Button);
        that.$.monthElement = setHeaderElement(that.$.monthElement, JQX.DropDownList);
        that.$.yearElement = setHeaderElement(that.$.yearElement, HTMLInputElement);

        if (that.viewSections.indexOf('title') > -1) {
            that.$.dateContainer.setAttribute('tabindex', index);
            that.$.yearContainer.setAttribute('tabindex', index);
        }

        that.$.body.setAttribute('tabindex', index);
        that.calendarMode === 'default' ? that.$.dateElement.setAttribute('tabindex', index) : that.$.dateElement.removeAttribute('tabindex');
        that.tabIndex = that.readonly && !that.disabled ? (that.tabIndex > 0 ? that.tabIndex : 0) : index;
    }

    /**
    * Checks for missing modules.
    */
    static get requires() {
        return {
            'JQX.DropDownList': 'jqxdropdownlist.js',
            'JQX.ListBox': 'jqxlistbox.js',
            'JQX.RepeatButton': 'jqxbutton.js',
            'JQX.Tooltip': 'jqxtooltip.js'
        }
    }

    /**
    * Navigates to a month forwards or backwards.
    * @param {number} step The step that will determine which month to navigate to. Negative step means future month. Positive step means past month.
    */
    navigate(step) {
        const that = this;

        step = parseInt(step);

        if (isNaN(step) || step === 0) {
            return false;
        }

        const navigationDate = that._getNextDate(step);

        if (!navigationDate) {
            return false;
        }

        if (that.displayMode !== 'month') {
            if (that.hasAnimation) {
                that.$nextMonthsContainer.addClass('jqx-calendar-date-view-container');
                if (that.displayModeView === 'list') {
                    that._setDisplayModeContent(navigationDate);
                }
                else {
                    if (!that._navigationDate || that._navigationDate.getTime() !== navigationDate.getTime()) {
                        that._animateNavigation(navigationDate, step);
                    }
                }
            }
            else {
                that._setDisplayModeContent(navigationDate);
            }

            return true;
        }

        if (that.hasAnimation) {
            that._animateNavigation(navigationDate, step);
            if (that.$nextMonthsContainer.hasClass('jqx-date-view-container')) {
                that.$nextMonthsContainer.removeClass('jqx-date-view-container');
            }
        }
        else {
            that._handleMonths(navigationDate);

            //Update Header elements
            that._refreshHeaderElements();
            that._refreshHeaderTitle();
        }

        return true;
    }

    /**
     * Selects a single date.
     * @param {any} date - Date object or a string representing a date.
     */
    select(date) {
        const that = this;

        if (typeof (that._viewDates[0]) === 'undefined' || that.selectionMode === 'none' || !date) {
            return;
        }

        date = that._getValidDate(date);

        if (!(date instanceof Date)) {
            return;
        }

        if (that.selectionMode === 'one' && that.selectedDates.map(Number).indexOf(date.getTime()) > -1) {
            return;
        }

        if (date.getTime() < that.min.getTime() || date.getTime() > that.max.getTime()) {
            return;
        }

        if (that.selectionMode === 'one' || that.selectionMode === 'default' || that.selectionMode === 'zeroOrOne') {
            that._clearSelection(true);
        }

        that._selectDate(date);
        if (that.selectedDates.length === 1 && !that._isDateInView(that.selectedDates[0])) {
            that._handleMonths(that.selectedDates[0]);
        }
    }

    /**
    * Selects the current date(today)
    */
    today() {
        const that = this;

        let today = new Date();

        today.setHours(0, 0, 0, 0);

        if (today.getTime() < that.min.getTime() || today.getTime() > that.max.getTime()) {
            today = new Date(that.max);
        }
        else {
            that.selectedDates = [today];
        }

        that._handleMonths(today);
        return today;
    }

    /**
     * Animates the navigation between months
     */
    _animateNavigation(navigationDate, step, completeAnimation) {
        const that = this;

        that._navigationDate = navigationDate;

        function scroll() {
            let endCondition = step > 0 ? that.$.body[that._animationSettings.scrollSize] >= scrollMax : that.$.body[that._animationSettings.scrollSize] === 0,
                coefficient = that._scrollStep / 2; //oldvalue = 20, used to slow down the animation after half of it has passed

            if (endCondition) {
                that._animateNavigationCompleted();
                return;
            }

            if (step > 0 && that.$.body[that._animationSettings.scrollSize] > scrollMax * that._animationSettings.easeThreshold) {
                coefficient = Math.max(that.$.body[that._animationSettings.scrollSize] / that._animationSettings.stepEaseSize,
                    Math.abs(coefficient - (scrollMax - that.$.body[that._animationSettings.scrollSize]) * that._animationSettings.step));
                that._scrollStep = that._scrollStep * that._animationSettings.step + coefficient;
            }
            else if (step < 0 && that.$.body[that._animationSettings.scrollSize] < scrollMax * that._animationSettings.easeThreshold) {
                coefficient = Math.max(that.$.body[that._animationSettings.scrollMax] / that._animationSettings.stepEaseSize,
                    Math.abs(coefficient - that.$.body[that._animationSettings.scrollSize] * that._animationSettings.step));
                that._scrollStep = that._scrollStep * that._animationSettings.step + coefficient;
            }

            that.$.body[that._animationSettings.scrollSize] += step > 0 ? that._scrollStep : -that._scrollStep;
            that._animationId = requestAnimationFrame(scroll);
        }

        if (!that._animationSettings) {
            that._applyAnimationSettings();
        }

        //If the other animation was running, reset the elements
        that.$animationPanel.addClass('jqx-hidden');
        that.$.dateViewContainer.style.transform = '';
        that.$.dateViewContainer.style.opacity = '';
        that.$.monthsContainer.style.transform = '';
        that.$.monthsContainer.style.opacity = '';

        const animationTarget = that.displayMode !== 'month' ? that.$.dateViewContainer : that.$.monthsContainer,
            scrollMax = that.$.body[that._animationSettings.scrollMax] - that.$.body[that._animationSettings.size]; //that.$.monthsSeparator[that._animationSettings.size];

        that._scrollStep = that.$.body[that._animationSettings.size] * that._animationSettings.startSpeed; //Start speed
        that._animationStarted = true;

        if (that.displayMode !== 'month') {
            that._setCellState(that._focusedCell, 'focus', false);
            that._setDisplayModeContent(navigationDate, that.$.nextMonthsContainer);
        }
        else {
            that._handleMonths(navigationDate, that.$.nextMonthsContainer);
        }

        if (!completeAnimation) {
            if (step > 0) {
                animationTarget.style.order = 1;
                that.$.nextMonthsContainer.style.order = 3;
                if (!that._animationStarted || (that._animationStarted && that.$.body[that._animationSettings.scrollSize] >
                    that.$.body[that._animationSettings.scrollMax] * that._animationSettings.resetThreshold * 2)) {
                    that.$.body[that._animationSettings.scrollSize] = 0;
                }
            }
            else {
                animationTarget.style.order = 3;
                that.$.nextMonthsContainer.style.order = 1;
                if (!that._animationStarted || (that._animationStarted && that.$.body[that._animationSettings.scrollSize] <
                    that.$.body[that._animationSettings.scrollMax] * that._animationSettings.resetThreshold)) {
                    that.$.body[that._animationSettings.scrollSize] = that.$.body[that._animationSettings.scrollMax];
                }
            }
        }

        cancelAnimationFrame(that._animationId);
        that._animationId = requestAnimationFrame(scroll);
    }

    /**
     * Cancels an undergoing animation and resets everything to normal
     */
    _animateNavigationCompleted() {
        const that = this;
        let animationTarget = that.displayMode !== 'month' ? that.$.dateViewContainer : that.$.monthsContainer, focusedDate, newCells, oldCells;

        cancelAnimationFrame(that._animationId);

        if (that.displayMode !== 'month') {
            let focusedItemIndex = [].slice.call(animationTarget.children).indexOf(that._focusedCell);

            animationTarget.innerHTML = that.$.nextMonthsContainer.innerHTML;

            let focusedItem = animationTarget.children[focusedItemIndex], lastFocusableItem;

            newCells = animationTarget.children;
            oldCells = that.$.nextMonthsContainer.children;

            for (let i = 0; i < newCells.length; i++) {
                newCells[i].value = oldCells[i].value;
                newCells[i].restricted = oldCells[i].restricted;
                newCells[i].important = oldCells[i].important;
                newCells[i].otherMonth = oldCells[i].otherMonth;

                if (newCells[i].value.getTime() <= that.max.getTime()) {
                    lastFocusableItem = newCells[i];
                }
            }

            if (focusedItem && focusedItem.value.getTime() >= that.max.getTime()) {
                focusedDate = lastFocusableItem.value;
            }
            else {
                focusedDate = that._focusedCell ? that._focusedCell.value : undefined;
            }
        }
        else {
            let newMonths = animationTarget.children,
                months = that.$.nextMonthsContainer.children;

            for (let i = 0; i < newMonths.length; i++) {
                newMonths[i]._date = months[i]._date;
                newMonths[i].innerHTML = months[i].innerHTML;
                newCells = that._getMonthCells(newMonths[i]);
                oldCells = that._getMonthCells(months[i]);

                for (let i = 0; i < newCells.length; i++) {
                    newCells[i].value = oldCells[i].value;
                    newCells[i].restricted = oldCells[i].restricted;
                    newCells[i].important = oldCells[i].important;
                    newCells[i].otherMonth = oldCells[i].otherMonth;
                }
            }

            //Synch _selectedCells
            if (that._selectedCells.length > 0) {
                that._selectedCells = that._selectedCells.map(date => date = that._getCellByDate(date.value)).filter(date => {
                    return typeof date !== 'undefined';
                });
            }
        }

        that._focusCell(that._getCellByDate(focusedDate));
        animationTarget.style.order = 1;
        that.$.nextMonthsContainer.style.order = 3;
        that.$.body[that._animationSettings.scrollSize] = 0;
        that._animationStarted = false;
        delete that._navigationDate;
    }

    /**
     * Prepares the settings used for the animation
     * @param {any} displayModeChangeOnly - flag indicating if the change is only in the displayModeView
     */
    _applyAnimationSettings(displayModeChangeOnly) {
        const that = this;

        if (!that.hasAnimation) {
            delete that._animationSettings;
            return;
        }

        that._animationSettings = that.animationSettings ? that.animationSettings : that._animationSettings ? that._animationSettings : {};

        //Settings for the scrolling direction
        if (that.scrollButtonsNavigationMode === 'portrait') {
            that._animationSettings.scrollMax = 'scrollHeight';
            that._animationSettings.size = 'offsetHeight';
            that._animationSettings.scrollSize = 'scrollTop';
        }
        else {
            that._animationSettings.scrollMax = 'scrollWidth';
            that._animationSettings.size = 'offsetWidth';
            that._animationSettings.scrollSize = 'scrollLeft';
        }

        if (displayModeChangeOnly) {
            return;
        }

        //Starting speed
        that._animationSettings.startSpeed = that._animationSettings.startSpeed ? that._animationSettings.startSpeed : 0.2;

        //The threshold where the easing effect begins
        that._animationSettings.easeThreshold = that._animationSettings.easeThreshold ? that._animationSettings.easeThreshold : 0.5;

        //Animation step - determines the scroll interval between animation frames in perecentages
        that._animationSettings.step = that._animationSettings.step ? that._animationSettings.step : 0.25;

        //Animation step ease size - additional ease step coefficient that kicks in when the threshold is passed
        that._animationSettings.stepEaseSize = that._animationSettings.stepEaseSize ? that._animationSettings.stepEaseSize : 200;

        //Threshold used to determine if the animation should start over or continue from it's current state
        that._animationSettings.resetThreshold = that._animationSettings.resetThreshold ? that._animationSettings.resetThreshold : 0.2;
    }

    /**
    * Apply selectionMode to reflect on the current selection.
    */
    _applySelectionMode(initial) {
        const that = this;
        let newDate = [],
            preventEvent = initial ? true : false;

        switch (that.selectionMode) {
            case 'none':
                that._clearSelection(preventEvent);
                return;
            case 'many':
            case 'default':
            case 'oneOrMany':
                if (that.selectedDates.length === 0) {
                    newDate.push(new Date(Math.min(Math.max(that.min.getTime(), new Date().setHours(0, 0, 0, 0)), that.max.getTime())));
                    break;
                }

                return;
            case 'one':
                if (that.selectedDates.length === 1) {
                    return;
                }

                if (that.selectedDates.length > 1) {
                    newDate.push(that.selectedDates[that.selectedDates.length - 1]);
                    that._clearSelection(preventEvent);
                }
                else {
                    newDate.push(new Date(Math.min(Math.max(that.min.getTime(), new Date().setHours(0, 0, 0, 0)), that.max.getTime())));
                }

                break;
            case 'zeroOrOne':
                if (that.selectedDates.length > 1) {
                    newDate.push(that.selectedDates[that.selectedDates.length - 1]);
                    that._clearSelection(preventEvent);
                    break;
                }

                return;
            case 'zeroOrMany':
                return;
            case 'week':
                if (that.selectedDates.length >= 1) {
                    let date = that.selectedDates[that.selectedDates.length - 1];

                    for (let i = 0; i < 8; i++) {
                        newDate.push(new Date(date));
                        date.setDate(date.getDate() + 1);
                    }

                    that._clearSelection(preventEvent);
                }

                break;
        }

        that.selectedDates = [];

        if (initial) {
            that.selectedDates = newDate;
            return;
        }

        const newDates = newDate.length;

        for (let d = 0; d < newDates; d++) {
            that._selectDate(newDate[d], d < newDates - 1);
        }
    }

    /**
    * Clears the currently selected dates.
    */
    _clearSelection(eventPrevented) {
        const that = this;

        if (that._selectedCells) {
            that._selectedCells.map(cell => {
                that._setCellState(cell, 'selected', false);
            });
        }

        that.selectedDates = [];
        that._selectedCells = [];

        if (that.selectionMode === 'many') {
            const months = that.$.monthsContainer.children;

            for (let m = 0; m < months.length; m++) {
                that._getMonthCells(months[m]).map(cell => {
                    that._setCellState(cell, 'hover', false);
                });
            }
        }

        that._refreshFooter();

        //Update the hidden input
        that.$.hiddenInput.value = that.selectedDates.toString();

        if (!eventPrevented) {
            that.$.fireEvent('change', {
                'value': []
            });
        }

        that._refreshTitle();
    }

    _bodyBlurStateHandler(event) {
        const that = this;

        that._bodyStateHandler(event);
    }

    _bodyFocusStateHandler(event) {
        const that = this;

        that._bodyStateHandler(event);
    }

    /**
    * body focus event handler.
    */
    _bodyStateHandler(event) {
        const that = this;

        if (that._focusedCell) {
            if (event.type === 'blur' || (event.type === 'focus' && that._noFocusingRequired)) {
                that._noFocusingRequired = false;
                that._setCellState(that._focusedCell, 'focus', false);
                return;
            }

            if (that.displayMode !== 'month') {
                if (event.type === 'focus' && !that.$.dateViewContainer.querySelector('jqx-calendar-cell[focus]')) {
                    that._setCellState(that._focusedCell || that.$.dateViewContainer.querySelector('.jqx-calendar-cell'), 'focus', true);
                }
                return;
            }

        }

        if (event.type === 'focus') {
            that._focusCell();
        }
    }



    /**
    * Container mouse wheel event handler.
    */
    _containerWheelHandler(event) {
        const that = this;

        if (that.disabled || that.readonly) {
            return;
        }

        let step, host, activeElement;

        activeElement = host = document.activeElement;

        if (that.enableShadowDOM) {
            activeElement = that.shadowRoot.activeElement;

            if (activeElement) {
                host = activeElement ? that.shadowRoot.getRootNode().host : undefined;
            }
            else {
                activeElement = function () {
                    let container = that.shadowRoot;

                    while (container && container.host) {
                        if (container.activeElement) {
                            return container.activeElement;
                        }

                        container = container.host.getRootNode();
                    }
                }();
                host = activeElement ? activeElement.closest('jqx-calendar') : undefined;
            }
        }

        // Header component
        if (that.$.yearElement === activeElement) {
            step = 12;
        }

        if (host && host.closest('jqx-calendar') === that) {
            step = event.target === that.$.yearElement ? 12 : 1;
        }

        if (!step) {
            return;
        }

        //Prevent window scrolling
        event.preventDefault();

        step = step === 12 ? step : step * that.months;

        event.deltaY > 0 ? that.navigate(-step) : that.navigate(step);
    }

    /**
    * Calendar down event handler.
    */
    _downHandler(event) {
        const that = this;
        let target = event.originalEvent.target;

        that._dragStartDetails = undefined;
        if (that.disabled || that.readonly) {
            return;
        }

        if (that.hasRippleAnimation) {
            if (target.value instanceof Date ||
                (target.parentElement && target.parentElement.classList.contains('jqx-calendar-title')) ||
                target.parentElement === that.$.dateElement) {
                JQX.Utilities.Animation.Ripple.animate(target, event.pageX, event.pageY);
            }
        }

        target = event.originalEvent.target.closest('.jqx-calendar-header');

        if (event.originalEvent.target.closest('.jqx-calendar-year-container') && that.displayMode !== 'decade') {
            if (that.calendarMode === 'classic') {
                return;
            }

            that._showDateView('year');
            return;
        }

        if (event.originalEvent.target.closest('.jqx-calendar-date-container') && that.displayMode !== 'month') {
            if (that.calendarMode === 'classic') {
                return;
            }

            that._displayModeHandler(that.displayModeView === 'list' ? that.$.listViewContainer.getItem(that.$.listViewContainer.selectedValues[0]) : that._focusedCell, 'month');
            return;
        }

        if (that._animationStarted) {
            that._animateNavigationCompleted();
        }

        if (JQX.Utilities.Core.isMobile && !(target && target === that.$.header)) {
            that._dragStartDetails = { x: event.pageX, y: event.pageY, startTime: Date.now(), target: event.originalEvent.target };
            return;
        }

        target = event.originalEvent.target;

        if (target.closest('.jqx-calendar-week') || target.parentElement === that.$.dateViewContainer) {
            while (target && !(target.value instanceof Date)) {
                target = target.parentElement;
            }

            if (target) {
                that.displayMode !== 'month' ? that._displayModeHandler(target) : that._weeksDownHandler(event, target);
            }

            return;
        }

        if (target.closest('.jqx-calendar-month-element')) {
            return;
        }

        event.originalEvent.stopPropagation();

        if (that.displayModeView === 'list' && that.displayMode !== 'month') {
            target = (that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target).closest('jqx-list-item');

            if (target) {
                that._displayModeHandler(target);
            }

            return;
        }

        //Prevent window scrolling
        const scrollElement = document.scrollingElement || document.documentElement,
            x = scrollElement.scrollLeft,
            y = scrollElement.scrollTop;

        that.focus();

        //Prevent window scrolling
        window.scrollTo(x, y);
    }

    /**
     * Handles the dateViewSelection panels on caledarItem click
     * @param {any} target
     */
    _displayModeHandler(target, newDisplayMode) {
        const that = this;

        if (that._animationStarted) {
            that._animateNavigationCompleted();
        }

        if (target instanceof HTMLElement && target.parentElement.classList.contains('jqx-calendar-week') && target.otherMonth) {
            if (that.displayMode === 'decade' && (target.value.getFullYear() < that.min.getFullYear() || target.value.getFullYear() > that.max.getFullYear())) {
                return;
            }
            else if (that.displayMode === 'year' &&
                (((target.value.getFullYear() < that.min.getFullYear()) ||
                    (target.value.getFullYear() === that.min.getFullYear() && target.value.getMonth() < that.min.getMonth())) ||
                    ((target.value.getFullYear() > that.max.getFullYear()) ||
                        (target.value.getFullYear() === that.max.getFullYear() && target.value.getMonth() > that.max.getMonth())))) {
                return;
            }
        }

        newDisplayMode = newDisplayMode ? newDisplayMode : that.displayMode;

        switch (newDisplayMode) {
            case 'year':
                newDisplayMode = 'month';
                break;
            case 'decade':
                newDisplayMode = 'year';
                break;
        }

        if (that.displayMode === newDisplayMode) {
            return;
        }

        const isDisplayModeCHangeEventPrevented = that.$.fireEvent('displayModeChanging', {
            'oldDisplayMode': that.displayMode,
            'newDisplayMode': newDisplayMode
        }).defaultPrevented;

        if (isDisplayModeCHangeEventPrevented) {
            return;
        }

        that.displayMode = newDisplayMode;
        that.$nextMonthsContainer.removeClass('jqx-calendar-date-view-container');

        if (target.parentElement === that.$.dateViewContainer && !target.disabled && !target.restricted) {
            that._focusCell(target);
        }

        if (that.hasAnimation) {
            if (target instanceof JQX.ListItem || target.ownerListBox === that.$.listViewContainer) {
                if (target.offsetHeight) {
                    that.$.animationPanel.style.transformOrigin = (target.offsetLeft + target.offsetWidth / 2) + 'px ' +
                        (target.dataItem.top > 0 ? target.offsetTop - target.offsetHeight / 2 : target.offsetTop + target.offsetHeight / 2) + 'px';
                }
                else {
                    that.$.animationPanel.style.transformOrigin = (that.$.listViewContainer.offsetLeft + that.$.listViewContainer.offsetWidth / 2) + 'px ' +
                        (that.$.listViewContainer.offsetTop + that.$.listViewContainer.offsetHeight / 2) + 'px';
                }
            }
            else {
                target = that._focusedCell; //there should always be a focused item
                that.$.animationPanel.style.transformOrigin = (target.offsetLeft + target.offsetWidth / 2) + 'px ' + (target.offsetTop + target.offsetHeight / 2) + 'px';
            }

            that._animateView(1, target);
        }
        else {
            that._setDisplayModeContent(target.value instanceof Date ? target.value : new Date(target.value));
        }
    }

    /**
     * Animate the dateViewContainer
     * @param {any} direction
     * @param {any} target
     */
    _animateView(direction, target) {
        const that = this;

        let date = target instanceof Date ? target : new Date(target.value),
            endCondition = false,
            scale = 1,
            opacity = 1,
            animationTarget, backgroundContainer;

        if (that.displayModeView === 'list') {
            animationTarget = target instanceof JQX.ListItem || target.ownerListBox === that.$.listViewContainer ?
                that.$.listViewContainer : that.displayMode !== 'month' ? that.$.monthsContainer : that.$.listViewContainer;
            backgroundContainer = that.displayMode === 'month' ? that.$.monthsContainer : that.$.listViewContainer;
        }
        //else if (!(target instanceof JQX.cell)) {
        else if (!(target.value instanceof Date)) {
            target = that._focusedCell ? that._focusedCell : that._selectedCells.length > 0 ?
                that._selectedCells[that._selectedCells.length - 1] : that._getCellByDate(new Date());
        }

        if (!animationTarget) {
            animationTarget = target.parentElement === that.$.dateViewContainer ? that.$.dateViewContainer : that.$.monthsContainer;
        }

        if (!backgroundContainer) {
            backgroundContainer = that.displayMode === 'month' ? that.$.monthsContainer : that.$.dateViewContainer;
        }

        backgroundContainer.style.transformOrigin = that.$.animationPanel.style.transformOrigin;

        if (animationTarget instanceof JQX.ListBox) {
            that.$.animationPanel.innerHTML = '';
            that.$.animationPanel.appendChild(animationTarget.cloneNode(false));

            while (animationTarget.$.itemsInnerContainer.firstElementChild) {
                that.$.animationPanel.children[0].appendChild(animationTarget.$.itemsInnerContainer.firstElementChild);
            }
        }
        else {
            that.$.animationPanel.innerHTML = animationTarget.innerHTML;
        }

        that._setDisplayModeContent(date);

        that.$.animationPanel.style.width = that.$.body.offsetWidth + 'px';
        that.$.animationPanel.style.height = that.$.body.offsetHeight + 'px';
        that.$.animationPanel.style.transform = 'scale(1)';
        that.$.animationPanel.style.opacity = 1;

        that.$animationPanel.removeClass('jqx-hidden');

        backgroundContainer.style.opacity = '0';
        backgroundContainer.style.transform = 'scale(3.5)';

        //Use the style of the dateViewContainer
        if (animationTarget.$.hasClass('jqx-calendar-date-view-container')) {
            that.$animationPanel.addClass('jqx-calendar-date-view-container');
        }
        else {
            that.$animationPanel.removeClass('jqx-calendar-date-view-container');
        }

        // Refresh the scrollBars and ensure item is visible after the new view has been loaded
        if (animationTarget instanceof JQX.ListBox) {
            const listBox = that.$.animationPanel.children[0];

            listBox.whenReady(function () {
                listBox._refreshLayout();
                listBox.ensureVisible(listBox.selectedValues[0]);
            });
        }

        function animate() {
            if ((direction > 0 && scale >= 3.5) || (direction < 0 && scale <= 0)) {
                endCondition = true;
            }

            if (endCondition) {
                cancelAnimationFrame(that._animationId);
                that.$animationPanel.addClass('jqx-hidden');
                that.$.animationPanel.style.transform = '';
                that.$.animationPanel.style.opacity = '';

                backgroundContainer.style.transform = '';
                backgroundContainer.style.opacity = '';
                //that._animationStarted = false;

                if (that.displayMode === 'month') {
                    that.$.body.focus();
                }
                else if (that.displayModeView === 'list') {
                    that.focus();
                }

                return;
            }

            that.$.animationPanel.style.opacity = opacity;
            backgroundContainer.style.opacity = 1 - opacity;
            opacity -= 0.05;

            if (direction > 0) {
                that.$.animationPanel.style.transform = 'scale(' + scale + ')';
                backgroundContainer.style.transform = 'scale(' + Math.min((scale - 1) / 2, 1) + ')';
                scale += 0.125;
            }
            else {
                that.$.animationPanel.style.transform = 'scale(' + Math.max(scale, 0) + ')';
                backgroundContainer.style.transform = 'scale(' + Math.max(1 + scale, 1) + ')';
                scale -= 0.06;
            }

            that._animationId = requestAnimationFrame(animate);
        }

        cancelAnimationFrame(that._animationId);
        that._animationId = requestAnimationFrame(animate);
        //that._animationStarted = true;
    }

    /**
     * Document up handler
     * @param {any} event
     */
    _documentUpHandler(event) {
        const that = this;

        if (!JQX.Utilities.Core.isMobile || !that._dragStartDetails) {
            return;
        }

        const timeNow = Date.now();
        let target = event.originalEvent.target,
            dragging = {};

        if (that.scrollButtonsNavigationMode === 'portrait') {
            dragging.coordinate = 'y';
            dragging.direction = 'pageY';
        }
        else {
            dragging.coordinate = 'x';
            dragging.direction = 'pageX';
        }

        if (Math.abs(that._dragStartDetails[dragging.coordinate] - event[dragging.direction]) <= 10) {
            target = that.displayModeView === 'list' && that.displayMode !== 'month' ? target.closest('jqx-list-item') : target;

            if (!target) {
                that._dragStartDetails = undefined;
                return;
            }

            if (that.displayMode !== 'month') {
                that._displayModeHandler(target);

                //Reset scrolling if any occured
                that.scrollButtonsNavigationMode === 'portrait' ? that.$.body.scrollTop = 0 : that.$.body.scrollLeft = 0;
                that._dragStartDetails = undefined;
                return;
            }

            that._weeksDownHandler(event, target);

            if (!that.disableAutoNavigation && target.otherMonth) {
                return;
            }
        }
        else {
            const speed = Math.abs((event[dragging.direction] - that._dragStartDetails[dragging.coordinate]) / (timeNow - that._dragStartDetails.startTime));

            if (speed > 1) {
                const steps = parseInt(speed); //Determine the animation iterations

                for (let i = 0; i < steps; i++) {
                    that.navigate(that._dragStartDetails.step);
                }

                that._dragStartDetails = undefined;
                return;
            }
        }


        if (!that.hasAnimation) {
            that._dragStartDetails = undefined;
            return;
        }

        let scrollMax = (that.displayMode !== 'month' ? that.$.dateViewContainer[that._animationSettings.scrollMax] :
            that.$.monthsContainer[that._animationSettings.scrollMax]) + that.$.monthsSeparator[that._animationSettings.size];

        if ((that._dragStartDetails.step > 0 && that.$.body[that._animationSettings.scrollSize] > scrollMax * that._animationSettings.easeThreshold) ||
            (that._dragStartDetails.step < 0 && that.$.body[that._animationSettings.scrollSize] < scrollMax * that._animationSettings.easeThreshold)) {

            that._animateNavigation(that._dragStartDetails.navigationDate, that._dragStartDetails.step, true);
            that._dragStartDetails = undefined;
            return;
        }

        //Resets the touch scrolling to normal
        that._animateMonthRepositioning(undefined, that._dragStartDetails.step);
        that._dragStartDetails = undefined;
    }

    /**
     * Returns the month to its starting/ending position on touchUp.
     * @param {any} navigationDate - Date to navigate to
     * @param {any} step - animation step
     */
    _animateMonthRepositioning(navigationDate, step) {
        const that = this,
            animationTarget = that.displayMode !== 'month' ? that.$.dateViewContainer : that.$.monthsContainer;

        function scroll() {
            let endCondition = step < 0 ? that.$.body[that._animationSettings.scrollSize] >= scrollMax : that.$.body[that._animationSettings.scrollSize] === 0,
                coefficient = that._scrollStep / 2; //Used to slow down the animation after half of it has passed

            if (endCondition) {
                cancelAnimationFrame(that._animationId);
                animationTarget.style.order = 1;
                that.$.nextMonthsContainer.style.order = 3;
                that.$.body[that._animationSettings.scrollSize] = 0;
                that._animationStarted = false;
                return;
            }

            if (step > 0) {
                coefficient = Math.max(that.$.body[that._animationSettings.scrollMax] / that._animationSettings.stepEaseSize,
                    Math.abs(coefficient - that.$.body[that._animationSettings.scrollSize] * that._animationSettings.step));
                that._scrollStep = that._scrollStep * that._animationSettings.step + coefficient;
            }
            else {
                coefficient = Math.max(that.$.body[that._animationSettings.scrollMax] / that._animationSettings.stepEaseSize,
                    Math.abs(coefficient - (scrollMax - that.$.body[that._animationSettings.scrollSize]) * that._animationSettings.step));
                that._scrollStep = that._scrollStep * that._animationSettings.step + coefficient;
            }

            that.$.body[that._animationSettings.scrollSize] += step < 0 ? that._scrollStep : -that._scrollStep;
            that._animationId = requestAnimationFrame(scroll);
        }

        if (!that._animationSettings) {
            that._applyAnimationSettings();
        }

        const scrollMax = animationTarget[that._animationSettings.scrollMax] + that.$.monthsSeparator[that._animationSettings.size];

        that._scrollStep = that.$.body[that._animationSettings.size] * that._animationSettings.startSpeed; //Start speed

        cancelAnimationFrame(that._animationId);
        that._animationId = requestAnimationFrame(scroll);
        that._animationStarted = true;
    }

    /**
    * Focuses a Calendar day.
    */
    _focusCell(cell) {
        const that = this;

        if (that._focusedCell) {
            that._setCellState(that._focusedCell, 'focus', false);
        }

        if (that.disabled || that.readonly) {
            return;
        }

        if (cell) {
            if (that.displayMode !== 'month') {
                that._setCellState(cell, 'focus', true);
                that._focusedCell = cell;
                return;
            }

            if (cell.disabled || cell.restricted) {
                return;
            }

            that._setCellState(cell, 'focus', true);
            that._focusedCell = cell;
            that._updateWeeksVisibility();
            return;
        }

        if (that.displayMode !== 'month' && that.$.monthsContainer.offsetHeight === 0) {
            return;
        }

        if (that._selectedCells.length > 0) {
            const lastSelectedCell = that._selectedCells[that._selectedCells.length - 1];

            that._setCellState(lastSelectedCell, 'focus', true);

            that._focusedCell = lastSelectedCell;
        }
        else {
            const months = that.$.monthsContainer.children;

            if (that.min.getTime < months[0]._date.getTime()) {
                return;
            }

            const monthCells = that._getMonthCells(months[0], that.rightToLeft);

            for (let d = 0; d < monthCells.length; d++) {
                const cell = monthCells[d];

                if (!cell.otherMonth) {
                    if (cell.disabled || cell.restricted) {
                        continue;
                    }

                    that._focusedCell = cell;
                    break;
                }
            }
        }

        if (that._focusedCell) {
            that._setCellState(that._focusedCell, 'focus', true);

            that._updateWeeksVisibility();
        }
    }

    /**
    * Returns the selected days for a given month.
    */
    _getDays(date, datePool) {
        const datesCount = datePool.length;
        let days = [];

        if (datesCount > 0) {
            for (let d = 0; d < datesCount; d++) {
                if (datePool[d].getFullYear() === date.getFullYear() && datePool[d].getMonth() === date.getMonth()) {
                    days.push(datePool[d].getDate());
                }
            }
        }

        return days;
    }

    /**
    * Get the Calendar Date instance based on day number.
    */
    _getCellByDate(date, monthContainer) {
        const that = this;

        if (!(date instanceof Date)) {
            return;
        }

        if (!monthContainer) {
            monthContainer = that.$.monthsContainer;
        }

        if (that.displayMode !== 'month') {
            if (that.displayModeView === 'list') {
                return;
            }

            let items = arguments[1] ? that.$.nextMonthsContainer.children : that.$.dateViewContainer.children;

            for (let i = 0; i < items.length; i++) {
                if (that.displayMode === 'year') {
                    if (items[i].value.getMonth() === date.getMonth()) {
                        return items[i];
                    }

                    continue;
                }
                else if (items[i].value.getFullYear() === date.getFullYear()) {
                    return items[i];
                }
            }

            return;
        }

        let ownerMonth,
            monthCells,
            months = monthContainer.children;

        for (let i = 0; i < months.length; i++) {
            if (date.getFullYear() === months[i]._date.getFullYear() && date.getMonth() === months[i]._date.getMonth()) {
                ownerMonth = months[i];
                break;
            }
        }

        if (!ownerMonth) {
            return;
        }

        monthCells = that._getMonthCells(ownerMonth);

        for (let i = 0; i < monthCells.length; i++) {
            if (monthCells[i].otherMonth && !monthCells[i].hover) {
                continue;
            }

            if (monthCells[i].value.getMonth() === date.getMonth() && monthCells[i].value.getDate() === date.getDate()) {
                return monthCells[i];
            }
        }
    }

    /**
    * Returns the HTML elements for the days in a month.
    */
    _getMonthCells(month, rightToLeft) {
        const weeks = month.getElementsByClassName('jqx-calendar-week');
        let days = [];

        //Get days instances.
        if (rightToLeft) {
            for (let w = 0; w < weeks.length; w++) {
                let weekDays = weeks[w].children;

                for (let d = weekDays.length - 1; d > 0; d--) {
                    days.push(weekDays[d]);
                }
            }
        }
        else {
            for (let w = 0; w < weeks.length; w++) {
                let weekDays = weeks[w].children;

                for (let d = 1; d < weekDays.length; d++) {
                    days.push(weekDays[d]);
                }
            }
        }

        return days;
    }

    /**
    * Returns the number of the week.
    */
    _getWeekNumber(date) {
        //date = new Date(date.getTime());

        const that = this;
        let newYear = new Date(date.getFullYear(), 0, 1),
            dayNumber = Math.round((date.getTime() - newYear.getTime() - (date.getTimezoneOffset() - newYear.getTimezoneOffset()) * 60000) / 86400000) + 1,
            day = newYear.getDay() - that.firstDayOfWeek, //the day of week the year begins on
            weeknum;

        day = day >= 0 ? day : day + 7;

        //if the year starts before the middle of a week
        if (day < 4) {
            weeknum = Math.floor((dayNumber + day - 1) / 7) + 1;

            if (weeknum > 52) {
                newYear = new Date(date.getFullYear() + 1, 0, 1);
                day = newYear.getDay() - that.firstDayOfWeek;
                day = day >= 0 ? day : day + 7;

                //if the next year starts before the middle of the week, it is week #1 of that year
                weeknum = day < 4 ? 1 : 53;
            }
        }
        else {
            weeknum = Math.round((dayNumber + day - 1) / 7);
        }

        return weeknum;
    }

    /**
     * Handle the date selection according to the selectionMode.
     */
    _handleDateSelection(cell) {
        const that = this;

        if (typeof (cell) === 'undefined' || cell.disabled || cell.restricted) {
            return;
        }


        function selectMultipleDates(firstSelectedDate, date) {
            that._clearSelection(true);
            if (firstSelectedDate.getTime() < date.value.getTime()) {
                while (firstSelectedDate.getTime() <= date.value.getTime()) {
                    that._selectDate(firstSelectedDate, true);
                    firstSelectedDate.setDate(firstSelectedDate.getDate() + 1);
                }
            }
            else if (firstSelectedDate.getTime() > date.value.getTime()) {
                while (firstSelectedDate.getTime() >= date.value.getTime()) {
                    that._selectDate(firstSelectedDate, true);
                    firstSelectedDate.setDate(firstSelectedDate.getDate() - 1);
                }
            }
            else {
                that._selectDate(date, true);
            }

            //Update the hidden input
            that.$.hiddenInput.value = that.selectedDates.toString();

            that._refreshFooter();
            that.$.fireEvent('change', { 'value': that.selectedDates });
            that._refreshTitle();
        }

        switch (that.selectionMode) {
            case 'none':
                that._focusCell(cell);
                break;
            case 'one':
            case 'default':
                if (that._keysPressed['Control']) {
                    if (that.selectedDates.length > 1 || (that.selectedDates.length === 1 && !cell.selected)) {
                        that._selectDate(cell.value);
                        return;
                    }

                    that._focusCell(cell);
                    return;
                }

                if (that._keysPressed['Shift']) {
                    selectMultipleDates(new Date(that.selectedDates[0]), cell);
                    return;
                }

                that._clearSelection(true);

                that._selectDate(cell.value, that._selectedCells.indexOf(cell.value) > -1 ? true : false);
                break;
            case 'many': {
                if (that.selectedDates.length === 0) {
                    that._selectDate(cell.value);
                    return;
                }

                const lastSelectedDate = that.selectedDates[that.selectedDates.length - 1];
                let firstSelectedDate = new Date(that.selectedDates[0]);

                if (cell.value.getTime() === firstSelectedDate.getTime() || cell.value.getTime() === lastSelectedDate.getTime()) {
                    that._clearSelection();
                    that._focusCell(cell);
                    return;
                }

                if (that.selectedDates.length > 0) {
                    selectMultipleDates(firstSelectedDate, cell);
                }

                break;
            }
            case 'zeroOrMany':
                that._selectDate(cell.value);
                break;
            case 'oneOrMany':
                if (that.selectedDates.length === 1 && cell.selected) {
                    that._focusCell(cell);
                    return;
                }

                that._selectDate(cell.value);
                break;
            case 'zeroOrOne':
                if (that.selectedDates.length === 1 && cell.selected) {
                    that._selectDate(cell.value);
                    return;
                }

                that._clearSelection(true);
                that._selectDate(cell.value);
                break;
            case 'week': {
                if (cell.selected && (cell.value.getTime() === that.selectedDates[0].getTime() ||
                    cell.value.getTime() === that.selectedDates[that.selectedDates.length - 1].getTime())) {
                    that._clearSelection();
                    that._focusCell(cell);
                    return;
                }

                that._clearSelection(true);

                let date = new Date(cell.value);

                that._selectDate(date);

                for (let i = 1; i < 8; i++) {
                    date.setDate(date.getDate() + 1, i < 7);
                    that._selectDate(date);
                }

                if (!that._isDateInView(date)) {
                    that.navigate(1)
                }

                break;
            }
        }
    }

    /**
    * Set's the Template for Important days.
    */
    _handleImportantDateTemplate() {
        const that = this;

        that._importantDatesTemplate = that._validateTemplate('importantDatesTemplate', that.importantDatesTemplate);

        if (!that._importantDatesTemplate || !that._importantDatesTemplate.content) {
            return;
        }

        let content = that._importantDatesTemplate.content;
        const childrenCount = content.childNodes.length,
            regex = /{{\w+}}/g;
        let bindingString;

        that._bindingDetails = [];
        for (let i = 0; i < childrenCount; i++) {
            bindingString = regex.exec(content.childNodes[i].innerHTML);

            if (bindingString) {
                that._bindingDetails.push({ childNodeIndex: i, bindingString: bindingString[0] });
                return;
            }
        }
    }

    /**
    * Set's the Template for the footer/header.
    */
    _handleLayoutTemplate(selector, newTemplate) {
        const that = this,
            template = that._validateTemplate(selector.$.hasClass('jqx-header') ? 'headerTemplate' :
                selector.$.hasClass('jqx-calendar-footer') ? 'footerTemplate' : 'titleTemplate', newTemplate);

        if (!template || !template.content) {
            if (typeof newTemplate === 'function') {
                newTemplate(selector, {});
            }

            return;
        }

        if (!that._layoutTemplates) {
            that._layoutTemplates = [];
        }


        let clone = document.importNode(template.content, true);

        selector.innerHTML = '';

        const childrenCount = clone.childNodes.length,
            regex = /{{\w+}}/g;
        let bindingString,
            bindings = [];

        for (let i = 0; i < childrenCount; i++) {
            bindingString = regex.exec(clone.childNodes[i].innerHTML);

            if (bindingString) {
                bindings.push({ childNodeIndex: i, bindingString: bindingString[0] });
            }
        }

        that._layoutTemplates = that._layoutTemplates.filter(template => template.selector !== selector);
        that._layoutTemplates.push({ selector: selector, template: template, bindings: bindings });

        if (that.enableShadowDOM) {
            selector.innerHTML = '<slot></slot>'
            that.appendChild(clone);
            return;
        }

        selector.appendChild(clone);
    }

    /**
    * Handles the hover state of the Calendar items
    */
    _handleCalendarCellHover(event, cell) {
        const that = this;

        if (that._animationStarted) {
            return;
        }

        if (that.displayMode === 'month') {
            if (event.type === 'mouseover' && that.selectionMode === 'many' && that.selectedDates.length > 0) {
                const months = that.$.monthsContainer.children;

                for (let m = 0; m < months.length; m++) {
                    that._getMonthCells(months[m]).map(cell => {
                        that._setCellState(cell, 'hover', false);
                    });
                }

                let firstSelectedDate = new Date(that.selectedDates[0]),
                    targetDate = new Date(cell.value),
                    targetCell = cell;
                const nextCoeff = firstSelectedDate.getTime() > targetDate.getTime() ? -1 : 1,
                    hoverCell = function () {
                        targetCell = that._getCellByDate(firstSelectedDate, that.$.monthsContainer);

                        if (targetCell && !targetCell.selected && !targetCell.restricted) {
                            that._setCellState(targetCell, 'hover', true);
                        }
                    };

                if (firstSelectedDate.getTime() !== targetDate.getTime()) {
                    firstSelectedDate.setDate(firstSelectedDate.getDate() + nextCoeff);
                    while (firstSelectedDate.getTime() !== targetDate.getTime()) {
                        hoverCell();
                        firstSelectedDate.setDate(firstSelectedDate.getDate() + nextCoeff);
                    }

                    hoverCell();
                }
            }
            else {
                that._setCellState(cell, 'hover', false);
            }
        }

        if (event.type === 'mouseover' && !cell.otherMonth) {
            that._setCellState(cell, 'hover', true);
        }
        else {
            that._setCellState(cell, 'hover', false);
        }
    }

    /**
     * Handles the number of months to be drawn.
     */
    _handleMonths(date, monthsContainer) {
        const that = this;
        let months;

        if (!date) {
            date = that._viewDates && that._viewDates.length > 0 ? that._viewDates[0] : new Date();
        }

        date = new Date(Math.min(Math.max(that.min.getTime(), date.getTime()), that.max.getTime()));

        if (!monthsContainer) {
            monthsContainer = that.$.monthsContainer;
        }

        function initializeMonths(monthsContainer) {
            let nextMonth,
                count = monthsContainer.children.length,
                fragment = document.createDocumentFragment();

            for (count; count < that.months; count++) {
                nextMonth = that.$.month.cloneNode(false);
                nextMonth.innerHTML = that.$.month.innerHTML;
                fragment.appendChild(nextMonth);
            }

            return fragment;
        }

        function populateMonths(monthsContainer) {
            let months = monthsContainer.children;

            for (let i = 0; i < months.length; i++) {
                that._setMonth(date, months[i]);
                date.setMonth(date.getMonth() + 1);
            }

            that._setWeeksVisibility(monthsContainer);

            //Update the Header elements
            that._refreshHeaderElements();
            that._refreshHeaderTitle();

            if (that.tooltip) {
                that.$.tooltip.close();
            }

            if (that.$.body === document.activeElement) {
                that._focusCell();
            }
        }

        that._selectedCells = [];

        if (that.hasAnimation) {
            months = that.$.nextMonthsContainer.children;

            if (months.length > 0 && months[0].value instanceof Date) {
                that.$.nextMonthsContainer.innerHTML = '';
            }

            // FF v57/EDGE bug fix using that.$.monthsContainer.childElementCount. Scoping problem with FF and EDGE.
            while (that.$.nextMonthsContainer.childElementCount < that.months) {
                //if (months.length < that.months) {
                that.$.nextMonthsContainer.appendChild(initializeMonths(that.$.nextMonthsContainer));
            }

            // FF v57/EDGE bug fix using that.$.monthsContainer.childElementCount. Scoping problem with FF and EDGE.
            while (that.$.nextMonthsContainer.childElementCount > that.months) {
                //while (months.length > that.months) {
                that.$.nextMonthsContainer.removeChild(months[that.$.nextMonthsContainer.childElementCount - 1]);
            }

            if (arguments[1] === that.$.nextMonthsContainer) {
                populateMonths(that.$.nextMonthsContainer);
                return;
            }
        }

        months = that.$.monthsContainer.children;

        if (months.length > that.months) {
            // FF v57/EDGE bug fix using that.$.monthsContainer.childElementCount. Scoping problem with FF and EDGE.
            while (that.$.monthsContainer.childElementCount > that.months) {
                that.$.monthsContainer.removeChild(months[that.$.monthsContainer.childElementCount - 1]);
                that._viewDates.pop();
            }

            populateMonths(that.$.monthsContainer);
            return;
        }

        if (that.$.monthsContainer.children.length === that.months) {
            populateMonths(that.$.monthsContainer);
            return;
        }

        that._viewDates = [];
        that.$.monthsContainer.appendChild(initializeMonths(that.$.monthsContainer));
        populateMonths(that.$.monthsContainer);
    }

    /**
    * Header change handler.
    */
    _headerChangeHandler(event) {
        const that = this;

        event.stopPropagation();

        if (that.disabled || that.readonly) {
            return;
        }

        if (event.target.ownerElement === that.$.monthElement && that._changeEventFired !== 0) {
            that._changeEventFired--;
            return;
        }

        //Header elements
        if (event.target === that.$.yearElement) {
            that._viewDates[0].setFullYear(Math.min(Math.max(that.min.getFullYear(),
                isNaN(parseInt(that.$.yearElement.value)) ?
                    0 : parseInt(that.$.yearElement.value)), that.max.getFullYear()));
            that._handleMonths(that._viewDates[0]);
        }

        if (that.$.monthElement && (event.target === that.$.monthElement || event.target.ownerElement === that.$.monthElement)) {
            that._handleMonths(new Date(that.$.monthsContainer.children[0]._date.getFullYear(), that.$.monthElement.selectedIndexes[0], 1));
        }
    }

    /**
    * Header click handler.
    */
    _headerClickHandler(event) {
        const that = this;

        if (that.disabled || that.readonly) {
            return;
        }

        let target = event.target.closest('jqx-repeat-button');

        if (target && target.disabled) {
            return;
        }

        //Header elements
        switch (target) {
            case that.$.previousMonthButton:
                that._isInteractiveNavigation = true;
                that.navigate(-1 * that.months);
                return;
            case that.$.nextMonthButton:
                that._isInteractiveNavigation = true;
                that.navigate(1 * that.months);
                return;
            case that.$.previousYearButton:
                that.navigate(-12);
                return;
            case that.$.nextYearButton:
                that.navigate(12);
                return;
        }

        if (that.calendarMode === 'classic') {
            that.displayMode = 'month';
            return;
        }

        if (event.target.closest('.jqx-calendar-date-element')) {
            if (that._animationStarted) {
                that._animateNavigationCompleted();
            }

            that._isInteractiveNavigation = true;
            that._showDateView();
        }
    }

    /**
     * Sets the displayMode
     */
    _setDisplayMode(oldValue, newValue, animationTarget) {
        const that = this;

        that.$nextMonthsContainer.removeClass('jqx-calendar-date-view-container');

        if (arguments.length === 0 || !that.hasAnimation) {
            if (that.calendarMode === 'classic') {
                that.displayMode = 'month';
                return;
            }

            if (that.displayMode !== 'month') {
                that.$monthsContainer.addClass('jqx-hidden');

                if (that.$dateViewContainer.hasClass('jqx-hidden')) {
                    that.$dateViewContainer.removeClass('jqx-hidden');
                }
            }

            if (!that.isCompleted && that.displayMode === 'month') {
                return;
            }

            that._setDisplayModeContent();
            return;
        }

        if (that._animationStarted) {
            that.displayMode = oldValue;
            that._animateNavigationCompleted();
            that.displayMode = newValue;
        }

        if ((oldValue === 'month' && newValue === 'year') || (oldValue === 'year' && newValue === 'decade')) {
            that.displayMode = oldValue;
            that._showDateView(animationTarget ? undefined : that.displayMode);
        }
        else if ((oldValue === 'month' && newValue === 'decade')) {
            that._showDateView(that.displayMode = 'year');
        }
        else {
            let target;

            if (that.displayModeView === 'list') {
                // used because _focusedItem is not a JQX.ListItem but a plain Object 
                target = (that.$.listViewContainer.enableShadowDOM ? that.$.listViewContainer.shadowRoot : that.$.listViewContainer).querySelector('jqx-list-item[selected]');
                that.$.animationPanel.style.transformOrigin = (target.offsetLeft + target.offsetWidth / 2) + 'px ' +
                    (target.dataItem.top > 0 ? target.offsetTop - target.offsetHeight / 2 : target.offsetTop + target.offsetHeight / 2) + 'px';
            }
            else {
                target = that._focusedCell; //there should always be a focused item
                that.$.animationPanel.style.transformOrigin = (target.offsetLeft + target.offsetWidth / 2) + 'px ' + (target.offsetTop + target.offsetHeight / 2) + 'px';
            }

            that._animateView(1, target);
        }
    }

    /**
     * Set the content of the default dispalyMode date selection view
     * @param {any} newDate
     */
    _setDisplayModeContent(newDate, nextDateViewContainer) {
        const that = this;
        let selectedDate = !newDate || newDate.toString() === 'Invalid Date' ?
            (that.selectedDates.length > 0 ? that.selectedDates[that.selectedDates.length - 1] : new Date()) : newDate;

        selectedDate.setTime((Math.min(Math.max(selectedDate.getTime(), that.min.getTime()), that.max.getTime())));

        selectedDate.setHours(0, 0, 0, 0);

        const viewDetails = that._prepareView(selectedDate);

        if (!viewDetails) {
            return;
        }

        let dateViewContainer;

        if (nextDateViewContainer) {
            that.$.nextMonthsContainer.innerHTML = that.$.dateViewContainer.innerHTML;
            dateViewContainer = that.$.nextMonthsContainer;
        }
        else {
            dateViewContainer = that.$.dateViewContainer;
        }

        const cells = dateViewContainer.children;
        let selectedCell;

        for (let i = 0; i < cells.length; i++) {
            const cell = cells[i];

            cell.innerHTML = viewDetails.viewContent[i];
            cell.value = viewDetails.dates[i];

            if (that.displayMode === 'year') {
                if (((cell.value.getFullYear() < that.min.getFullYear()) || (cell.value.getFullYear() === that.min.getFullYear() &&
                    cell.value.getMonth() < that.min.getMonth())) ||
                    ((cell.value.getFullYear() > that.max.getFullYear()) || (cell.value.getFullYear() === that.max.getFullYear() &&
                        cell.value.getMonth() > that.max.getMonth()))) {

                    that._setCellState(cell, 'otherMonth', true);
                }
                else {
                    that._setCellState(cell, 'otherMonth', false);
                }

                if (selectedDate.getFullYear() === cell.value.getFullYear() && selectedDate.getMonth() === cell.value.getMonth()) {
                    selectedCell = cell;
                }
            }
            else if (that.displayMode === 'decade') {
                if ((i === 0 || i === cells.length - 1) || cell.value.getFullYear() < that.min.getFullYear() || cell.value.getFullYear() > that.max.getFullYear()) {
                    that._setCellState(cell, 'otherMonth', true);
                }
                else {
                    that._setCellState(cell, 'otherMonth', false);
                }

                if (selectedDate.getFullYear() === cell.value.getFullYear()) {
                    selectedCell = cell;
                }
            }

            that._setCellState(cell, 'hover', false);
        }

        if (selectedCell.otherMonth) {
            for (let i = 0; i < cells.length; i++) {
                if (!cells[i].otherMonth) {
                    selectedCell = cells[i];
                    break;
                }
            }
        }

        if (that._focusedCell) {
            that._setCellState(that._focusedCell, 'focus', false);
        }

        that._focusedCell = selectedCell;
        that._focusCell(that._focusedCell);

        that._refreshHeaderTitle();
        that._refreshHeaderElements();

        that.$.fireEvent('displayModeChange');

        if (that._isInteractiveNavigation) {
            that._isInteractiveNavigation = undefined;
            return;
        }

        that._setCellState(selectedCell, 'focus', true);

        //Need to be called after the new content is loaded completely
        setTimeout(function () {
            that.$.body.focus();
            that._focusCell(that._focusedCell);
        }, 0);
    }

    /**
     * Prepare the data for table displayMode view
     * @param {any} selectedDate
     */
    _prepareView(selectedDate) {
        const that = this;
        let viewContent = [],
            dates = [],
            startYear, offset;

        function getValidDate(year, month, day) {
            let date = new Date(year, month + 1, 0),
                daysInMonth = date.getDate();

            day > daysInMonth ? date.setDate(daysInMonth) : date.setDate(day);
            return date;
        }

        if (that.displayMode === 'month') {
            if (that.$nextMonthsContainer.hasClass('jqx-date-view-container')) {
                that.$nextMonthsContainer.removeClass('jqx-date-view-container');
            }

            that.$listViewContainer.addClass('jqx-hidden');

            if (that.$dateViewContainer.hasClass('jqx-visibility-hidden')) {
                that.$dateViewContainer.removeClass('jqx-visibility-hidden');
            }

            if (!that._isDateInView(selectedDate)) {
                that._handleMonths(selectedDate);
            }

            if (that.$header.hasClass('jqx-hidden')) {
                that.$header.removeClass('jqx-hidden');
            }

            if (that.$body.hasClass('jqx-calendar-list-view')) {
                that.$body.removeClass('jqx-calendar-list-view');
            }

            that.$dateContainer.addClass('jqx-calendar-selected');
            that.$yearContainer.removeClass('jqx-calendar-selected');

            that.$dateViewContainer.addClass('jqx-hidden');
            that.$monthsContainer.removeClass('jqx-hidden');

            that._refreshHeaderTitle();
            that.$.body.setAttribute('tabindex', that.tabIndex > 0 ? that.tabIndex : 0);
            that._refreshHeaderElements();
            that.$.body.focus();
            that._focusCell(that._getCellByDate(selectedDate));
            that.$.fireEvent('displayModeChange');
            return;
        }

        if (that.displayModeView === 'list') {
            that._setDisplayModeListContent(selectedDate);
            that.$.fireEvent('displayModeChange');
            return;
        }

        if (that.$header.hasClass('jqx-hidden')) {
            that.$header.removeClass('jqx-hidden');
        }

        if (that.$dateViewContainer.hasClass('jqx-visibility-hidden')) {
            that.$dateViewContainer.removeClass('jqx-visibility-hidden');
        }

        that.$listViewContainer.addClass('jqx-hidden');
        that.$.body.setAttribute('tabindex', that.tabIndex > 0 ? that.tabIndex : 0);

        if (that.displayMode === 'year') {
            let tempDate = new Date();

            for (let i = 0; i < 12; i++) {
                tempDate = getValidDate(tempDate.getFullYear(), i, tempDate.getDate());
                viewContent.push(tempDate.toLocaleDateString(that.locale, { month: 'short' }));
                dates.push(getValidDate(selectedDate.getFullYear(), i, selectedDate.getDate()));
            }
        }
        else {
            startYear = selectedDate ? selectedDate.getFullYear() : that._viewDates[0].getFullYear(),
                offset = startYear % 10;

            if (offset !== 0) {
                startYear -= offset;
            }

            startYear -= 1;

            for (let i = 0; i < 12; i++) {
                viewContent.push(startYear + '');
                dates.push(new Date(startYear, selectedDate.getMonth(), selectedDate.getDate()));
                ++startYear;
            }
        }

        return { viewContent: viewContent, dates: dates };
    }

    /**
     * Prepare the list DisplayMode view with data
     * @param {any} selectedDate
     */
    _setDisplayModeListContent(selectedDate) {
        const that = this;
        let dataSource = [];

        function getValidDate(year, month, day) {
            let date = new Date(year, month + 1, 0),
                daysInMonth = date.getDate();

            day > daysInMonth ? date.setDate(daysInMonth) : date.setDate(day);
            return date;
        }

        that.$dateViewContainer.addClass('jqx-visibility-hidden');

        if (that.$listViewContainer.hasClass('jqx-hidden')) {
            that.$body.addClass('jqx-calendar-list-view');
            that.$listViewContainer.removeClass('jqx-hidden');
            that.$.listViewContainer._setFocusable();
            that.$.body.removeAttribute('tabindex');
        }

        if (that.displayMode === 'year') {
            let tempDate = new Date();

            for (let i = 0; i < 12; i++) {
                tempDate = getValidDate(tempDate.getFullYear(), i, tempDate.getDate());
                dataSource.push({
                    label: tempDate.toLocaleDateString(that.locale, { month: 'short' }), value: getValidDate(selectedDate.getFullYear(), i, selectedDate.getDate()).toDateString()
                });
            }

            that.$yearContainer.removeClass('jqx-calendar-selected');
            that.$dateContainer.addClass('jqx-calendar-selected');
        }
        else {
            let startYear = that.min.getFullYear(),
                endYear = that.max.getFullYear();

            endYear = Math.min(that.max.getFullYear(), selectedDate.getFullYear() + 10);
            startYear = Math.max(that.min.getFullYear(), endYear - 10);

            for (let i = startYear; i < endYear; i++) {
                dataSource.push({ label: i.toString(), value: new Date(i, selectedDate.getMonth(), selectedDate.getDate()).toDateString() });
            }

            that.$yearContainer.addClass('jqx-calendar-selected');
            that.$dateContainer.removeClass('jqx-calendar-selected');
        }

        that.$.listViewContainer.dataSource = dataSource;
        that.$.listViewContainer.selectedValues = [selectedDate.toDateString()];
        that.$.listViewContainer.ensureVisible(that.$.listViewContainer.selectedValues[0]);

        that._refreshHeaderTitle();
        that._refreshHeaderElements();
        that.focus();
    }

    /**
    * Checks if date is in view.
    * @param {any} date - Date object
    */
    _isDateInView(date) {
        const that = this;

        if (!date) {
            return false;
        }

        for (let d = 0; d < that._viewDates.length; d++) {
            if (date.getFullYear() === that._viewDates[d].getFullYear() && date.getMonth() === that._viewDates[d].getMonth()) {
                let cell = that._getCellByDate(date, that._animationStarted ? that.$.nextMonthsContainer : that.$.monthsContainer);

                if (!cell) {
                    return;
                }

                return cell.otherMonth || cell.classList.contains('jqx-visibility-hidden') ? false : true;
            }
        }

        return false;
    }

    /**
    * Calendar keyDown event handler.
    */
    _keyDownHandler(event) {
        const that = this;

        if (that.disabled || that.readonly) {
            return;
        }

        //JQX.RepeatButton throws click event, so it's not necessary to handle them
        switch (that.enableShadowDOM ? (that.shadowRoot.activeElement || document.activeElement) : document.activeElement) {
            //Header elements
            case that.$.yearElement:
                if (event.key === 'Escape') {
                    that._refreshHeaderElements();
                }

                break;
            case that.$.dateElement:
                if (that.calendarMode === 'default' && event.key === ' ' || event.key === 'Enter') {
                    event.preventDefault();
                    that._isInteractiveNavigation = true;
                    that._showDateView();
                    return;
                }

                if (!that._focusedCell) {
                    that._focusCell();
                }

                if (event.key.indexOf('Arrow') > -1 && that.$.dateElement === document.activeElement) {
                    that.$.body.focus();
                }

                that._navigateDays(event);
                break;
            case that.$.body:
                if (event.key === ' '/* || event.key === 'Enter'*/) {
                    event.preventDefault();
                }

                that._navigateDays(event);
                break;
            case that.$.yearContainer:
                if ((event.key === ' ' || event.key === 'Enter') && that.displayMode !== 'decade') {
                    //Prevent window scrolling
                    event.preventDefault();
                    that._isInteractiveNavigation = true;
                    that._showDateView('year');
                }

                if (event.key.indexOf('Arrow') > -1) {

                    //Prevent window scrolling
                    event.preventDefault();
                    if (!that._focusedCell) {
                        that._focusCell();
                    }

                    if (that.displayMode !== 'month' && that.displayModeView === 'list') {
                        that.focus();
                        that.$.listViewContainer._handleKeyStrokes(event.key);
                        return;
                    }

                    that._navigateDays(event);
                }

                break;
            case that.$.dateContainer:
                if ((event.key === ' ' || event.key === 'Enter') && that.displayMode !== 'month') {

                    //Prevent window scrolling
                    event.preventDefault();
                    that._displayModeHandler(that.displayModeView === 'list' ?
                        that.$.listViewContainer.getItem(that.$.listViewContainer.selectedValues[0]) : that._focusedCell, 'month');
                }

                if (event.key.indexOf('Arrow') > -1) {
                    if (!that._focusedCell) {
                        that._focusCell();
                    }

                    if (that.displayMode !== 'month' && that.displayModeView === 'list') {
                        that.focus();
                        that.$.listViewContainer._handleKeyStrokes(event.key);
                        return;
                    }

                    that._navigateDays(event);
                }
                break;
            default:
                if (that.displayMode !== 'month' && that.displayModeView === 'list') {
                    if (['Arrow', 'End', 'Home', 'Page'].indexOf(event.key)) {
                        //Prevent window scrolling
                        event.preventDefault();
                    }

                    if (event.key === ' ' || event.key === 'Enter' || (event.ctrlKey && (event.key === 'ArrowUp' || event.key === 'ArrowDown'))) {
                        that._navigateDays(event);
                        return;
                    }

                    that.$.listViewContainer._handleKeyStrokes(event.key);
                    return;
                }

                if (event.key.indexOf('Arrow') > -1) {
                    if (!that._focusedCell) {
                        that._focusCell();
                    }

                    that._navigateDays(event);
                }

                break;
        }
    }

    /**
     * ListBox in the listViewContainer change event handler
     * @param {any} event
     */
    _listViewContainerChangeEventHandler(event) {
        event.stopPropagation();
    }

    /**
     * ListBox (listView) Key down event handler
     * @param {any} event
     */
    _listViewContainerKeyDownHandler(event) {
        const that = this;

        if (that.displayModeView !== 'list') {
            return;
        }

        if (event.key === ' ' || event.key === 'Enter') {
            that._navigateDays(event);
        }
    }

    /**
     * Show the month/year/decade selection view
     */
    _showDateView(newDisplayMode) {
        const that = this;

        newDisplayMode = newDisplayMode ? newDisplayMode : that.displayMode;

        switch (newDisplayMode) {
            case 'month':
                newDisplayMode = 'year';
                break;
            case 'year':
                newDisplayMode = 'decade';
                break;
        }

        if (that.displayMode === newDisplayMode) {
            return;
        }

        const isDisplayModeCHangeEventPrevented = that.$.fireEvent('displayModeChanging', {
            'oldDisplayMode': that.displayMode,
            'newDisplayMode': newDisplayMode
        }).defaultPrevented;

        if (isDisplayModeCHangeEventPrevented) {
            return;
        }

        that.displayMode = newDisplayMode;

        //Needed for animation, even if its not enabled
        let target;

        if (arguments[0] && that.displayModeView === 'list' && that.displayMode !== 'month' && that.$.listViewContainer.items.length > 0) {
            target = that.$.listViewContainer.getItem(that.$.listViewContainer.selectedValues[0]);
            if (target.offsetHeight) {
                that.$.animationPanel.style.transformOrigin = (target.offsetLeft + target.offsetWidth / 2) + 'px ' +
                    (target.dataItem.top > 0 ? target.offsetTop - target.offsetHeight / 2 : target.offsetTop + target.offsetHeight / 2) + 'px';
            }
            else {
                that.$.animationPanel.style.transformOrigin = (that.$.listViewContainer.offsetLeft + that.$.listViewContainer.offsetWidth / 2) + 'px ' +
                    (target.dataItem.top > 0 ? target.offsetTop - target.offsetHeight / 2 : that.$.listViewContainer.offsetTop + that.$.listViewContainer.offsetHeight / 2) + 'px';
            }
        }
        else {
            if (!that._focusedCell) {
                that._focusCell();
            }

            target = that._focusedCell;
            that.$.animationPanel.style.transformOrigin = (target.offsetLeft + target.offsetWidth / 2) + 'px ' + (target.offsetTop + target.offsetHeight / 2) + 'px';
        }

        that.$monthsContainer.addClass('jqx-hidden');
        if (that.$dateViewContainer.hasClass('jqx-hidden')) {
            that.$dateViewContainer.removeClass('jqx-hidden');
        }

        if (that.displayMode === 'decade') {
            that.$yearContainer.addClass('jqx-calendar-selected');
            that.$dateContainer.removeClass('jqx-calendar-selected');
        }

        if (that.hasAnimation) {
            that._animateView(-1, target);
            return;
        }

        that._setDisplayModeContent(that._focusedCell ? that._focusedCell.value : that._viewDates[0]);
    }

    /**
     * KeyUp event handler.
     */
    _keyUpHandler(event) {
        const that = this;

        if (that.disabled || that.readonly) {
            return;
        }

        if (that.selectionMode === 'default' && (event.key === 'Shift' || event.key === 'Control')) {
            that._keysPressed[event.key] = false;
        }
    }

    /**
    * Calendar mouse over/out events handler.
    */
    _mouseEventsHandler(event) {
        const that = this;

        if (that.disabled || that.readonly) {
            return;
        }

        if (event.type === 'mouseenter') {
            that.$.setAttributeValue('hover', true);
            return;
        }
        else if (event.type === 'mouseleave') {
            that.$.setAttributeValue('hover', false);

            if (that.tooltip) {
                that.$.tooltip.close();
            }

            return;
        }

        const target = that.enableShadowDOM ? event.composedPath()[0] : event.target;

        if (!target.closest('.jqx-calendar-week')) {
            if (that.tooltip) {
                that.$.tooltip.close();
            }

            return;
        }

        let cell = target, isItemChild;

        while (cell && !(cell.value instanceof Date)) {
            cell = cell.parentElement;
            isItemChild = true;
        }

        if (!cell) {
            return;
        }

        if (!JQX.Utilities.Core.isMobile) {
            that._handleCalendarCellHover(event, cell);
        }

        if (that.tooltip) {
            if (cell.hasAttribute('important')) {
                if (event.type === 'mouseover') {
                    that.$.tooltip.open();
                    that.tooltipTemplate ? that.$.tooltip.value = cell.value + '' :
                        that.$.tooltip.innerHTML = that.$.tooltip.innerHTML.trim().length === 0 ? 'Important day!' : that.$.tooltip.innerHTML;
                    that.$.tooltip.selector = cell;

                    if (that.$.tooltip.selector !== cell) {
                        that.$.tooltip.close();
                    }

                    return;
                }
            }

            if (isItemChild || that.$.tooltip.selector === cell) {
                return;
            }

            that.$.tooltip.close();
        }
    }

    /**
     * Calendar move event handler
     */
    _moveHandler(event) {
        const that = this;

        if (!JQX.Utilities.Core.isMobile || !that._dragStartDetails || (that.displayModeView === 'list' && that.displayMode !== 'month')) {
            return;
        }

        event.originalEvent.preventDefault();
        event.preventDefault();
        event.stopPropagation();

        const details = { x: Math.round(event.pageX), y: Math.round(event.pageY) };
        let step;

        if (that.scrollButtonsNavigationMode === 'portrait') {
            step = details.y > that._dragStartDetails.y ? -1 * that.months : 1 * that.months;
        }
        else {
            step = details.x < that._dragStartDetails.x ? 1 * that.months : -1 * that.months;
        }

        const navigationDate = that._getNextDate(step);

        if (!navigationDate) {
            return;
        }

        that._dragStartDetails.step = step;
        that._dragStartDetails.navigationDate = new Date(navigationDate);

        if (!that.hasAnimation) {
            return;
        }

        let animationTarget;

        if (that.displayMode !== 'month') {
            that.$nextMonthsContainer.addClass('jqx-calendar-date-view-container');
            animationTarget = that.$.dateViewContainer;
            if (!(that.$.nextMonthsContainer.children[0].value instanceof Date) ||
                that.$.nextMonthsContainer.children[1].value.getFullYear() !== navigationDate.getFullYear()) {
                that._setDisplayModeContent(navigationDate, that.$.nextMonthsContainer);
            }
        }
        else {
            if (that.$nextMonthsContainer.hasClass('jqx-calendar-date-view-container')) {
                that.$nextMonthsContainer.removeClass('jqx-calendar-date-view-container');
            }

            animationTarget = that.$.monthsContainer;
            if (!that.$.nextMonthsContainer.children[0]._date || that.$.nextMonthsContainer.children[0]._date.getTime() !== navigationDate.getTime()) {
                let nextMonths = that.$.nextMonthsContainer.children;

                for (let i = 0; i < nextMonths.length; i++) {
                    navigationDate.setMonth(that._dragStartDetails.navigationDate.getMonth() + i);
                    that._setMonth(navigationDate, nextMonths[i], true);
                }
            }
        }

        if (step < 0) {
            animationTarget.style.order = 3;
            that.$.nextMonthsContainer.style.order = 1;
            that.$.body[that._animationSettings.scrollSize] = that.$.body[that._animationSettings.scrollMax];
        }
        else {
            animationTarget.style.order = 1;
            that.$.nextMonthsContainer.style.order = 3;
            that.$.body[that._animationSettings.scrollSize] = 0;
        }

        const direction = that.scrollButtonsNavigationMode === 'portrait' ? 'y' : 'x';

        if (Math.abs(that._dragStartDetails[direction] - details[direction]) > 10) {
            that.$.body[that._animationSettings.scrollSize] += -(details[direction] - that._dragStartDetails[direction]) * 2;
        }
    }

    /**
     * Get next navigation date
     * @param {any} step
     */
    _getNextDate(step) {
        const that = this;
        let targetDate;

        if (that.displayMode !== 'month') {
            let coefficient;
            const focusedDateYear = that._focusedCell && that._focusedCell.value.getFullYear();

            if (that.displayModeView === 'list') {
                targetDate = new Date(that.$.listViewContainer.items[0].value);
            }
            else {
                let container = that._animationStarted ? that.$.nextMonthsContainer : that.$.dateViewContainer;

                targetDate = new Date(that.displayMode === 'year' ? container.children[0].value : container.children[1].value);
            }

            coefficient = that.displayMode === 'year' ? 1 : step !== 0 ? 10 : 1;
            targetDate.setFullYear(targetDate.getFullYear() + (step > 0 ? coefficient : -coefficient));

            if (targetDate.getTime() < that.min.getTime()) {
                targetDate = that.min;
            }

            if (targetDate.getTime() > that.max.getTime()) {
                targetDate = that.max;
            }

            if (that.displayMode === 'year') {
                if (targetDate.getFullYear() < that.min.getFullYear() || targetDate.getFullYear() > that.max.getFullYear() || focusedDateYear === targetDate.getFullYear()) {
                    return;
                }
            }
            else if (targetDate.getFullYear() < that.min.getFullYear() || targetDate.getFullYear() > that.max.getFullYear() || focusedDateYear === targetDate.getFullYear()) {
                return;
            }
        }
        else {
            let dateInView = that._viewDates[0];

            targetDate = new Date(dateInView);
            targetDate.setDate(1);
            targetDate.setMonth(targetDate.getMonth() + step);
            targetDate.setTime((Math.min(Math.max(targetDate.getTime(), that.min.getTime()), that.max.getTime())));

            if (dateInView.getMonth() === targetDate.getMonth() && dateInView.getFullYear() === targetDate.getFullYear()) {
                return;
            }
        }

        return targetDate;
    }

    /**
    * Keyboard navigation between days in a month.
    */
    _navigateDays(event) {
        const that = this;
        let iterations = event.key === 'ArrowUp' || event.key === 'ArrowDown' ? 7 : 1,
            coefficient = event.key === 'ArrowUp' || event.key === 'ArrowLeft' || event.key === 'PageUp' ? -1 : 1;

        switch (event.key) {
            case 'ArrowUp':
            case 'ArrowLeft':
            case 'ArrowDown':
            case 'ArrowRight':
                if (!that._handleArrowKeys(event, iterations, coefficient)) {
                    return;
                }

                break;
            case ' ':
            case 'Enter':
                if (that.displayMode !== 'month') {

                    that._displayModeHandler(that.displayModeView === 'list' ? that.$.listViewContainer.getItem(that.$.listViewContainer.selectedValues[0]) : that._focusedCell);
                    return;
                }

                break;
            case 'Control':
            case 'Shift':
                if (that.selectionMode === 'default') {
                    that._keysPressed[event.key] = true;
                }

                return;
            case 'Home':
            case 'End': {
                //Prevent window scrolling
                event.preventDefault();

                let targetDate,
                    getTargetMonthDay = function (days) {
                        if (event.key === 'Home') {
                            for (let d = 0; d < days.length; d++) {
                                if (!days[d].otherMonth && (!days[d].disabled || !days[d].restricted)) {
                                    return days[d];
                                }
                            }
                        }
                        else {
                            for (let d = days.length - 1; d >= 0; d--) {
                                if (!days[d].otherMonth && (!days[d].disabled || !days[d].restricted)) {
                                    return days[d];
                                }
                            }
                        }
                    };

                if (that.displayMode !== 'month') {
                    targetDate = getTargetMonthDay(that.$.dateViewContainer.children);
                }
                else {
                    targetDate = getTargetMonthDay(that._getMonthCells(that._focusedCell.closest('.jqx-calendar-month'), that.rightToLeft));
                }

                if (!targetDate) {
                    return;
                }

                that._focusCell(targetDate);

                if (that.displayMode !== 'month') {
                    return;
                }

                break;
            }
            case 'PageUp':
            case 'PageDown': {
                if (!that._handlePageUpDownKeys(event, coefficient)) {
                    return;
                }

                break;
            }
            default:
                return;
        }

        if (that._focusedCell) {
            that._handleDateSelection(that._focusedCell);
        }
    }

    /**
     * Handles the arrow keys
     * @param {any} event 
     * @param {any} iterations - number of days to iterate over
     * @param {any} coefficient - a flag indicating if the next date is in the future or in the past
     */
    _handleArrowKeys(event, iterations, coefficient) {
        const that = this;
        let targetDate;

        if (that.displayMode === 'month' && !that._animationStarted) {
            that.$.body.focus();
        }

        if (!that._focusedCell) {
            that._focusCell(that._getCellByDate(new Date()));
        }

        if (event.altKey) {
            return;
        }

        if (event.ctrlKey) {
            if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                let displayMode;

                switch (that.displayMode) {
                    case 'month':
                        displayMode = event.key === 'ArrowDown' ? 'month' : 'year';
                        break;
                    case 'year':
                        displayMode = event.key === 'ArrowDown' ? 'month' : 'decade';
                        break;
                    case 'decade':
                        displayMode = event.key === 'ArrowDown' ? 'year' : 'decade';
                        break;
                }

                if (displayMode !== that.displayMode) {
                    const oldValue = that.displayMode;

                    //Change displayMode 
                    that.displayMode = displayMode;
                    that._setDisplayMode(oldValue, displayMode, oldValue === 'month');

                    //KeyUpHandle isn't being thrown when displayModeView is 'list'
                    if (that._keysPressed) {
                        delete that._keysPressed['Control'];
                    }

                }
            }

            return;
        }

        //Prevent window scrolling
        event.preventDefault();

        if (that.rightToLeft && (event.key === 'ArrowLeft' || event.key === 'ArrowRight')) {
            coefficient *= -1;
        }

        if (that.displayMode !== 'month') {
            let items = that._animationStarted ? that.$.nextMonthsContainer.children : that.$.dateViewContainer.children;

            iterations = event.key === 'ArrowUp' || event.key === 'ArrowDown' ? 4 : 1;

            if (that.displayMode === 'year') {
                const targetMonth = that._focusedCell.value.getMonth() + coefficient * iterations;
                let lastDayOfMonth = new Date(that._focusedCell.value.getFullYear(), targetMonth + 1, 0);

                if (that._focusedCell.value.getDate() <= lastDayOfMonth.getDate()) {
                    lastDayOfMonth = that._focusedCell.value;
                }

                targetDate = new Date(that._focusedCell.value.getFullYear(), targetMonth, lastDayOfMonth.getDate());
            }
            else {
                targetDate = new Date(that._focusedCell.value.getFullYear() + coefficient * iterations,
                    that._focusedCell.value.getMonth(), that._focusedCell.value.getDate());
            }

            if (that.displayMode === 'year') {
                if (((targetDate.getFullYear() < that.min.getFullYear()) ||
                    (targetDate.getFullYear() === that.min.getFullYear() && targetDate.getMonth() < that.min.getMonth())) ||
                    ((targetDate.getFullYear() > that.max.getFullYear()) ||
                        (targetDate.getFullYear() === that.max.getFullYear() && targetDate.getMonth() > that.max.getMonth()))) {
                    return;
                }

                if (targetDate.getTime() > items[items.length - 1].value.getTime()) {
                    that.navigate(1);
                }
                else if (targetDate.getTime() < items[0].value.getTime()) {
                    that.navigate(-1);
                }
            }
            else {
                if (targetDate.getFullYear() < that.min.getFullYear() || targetDate.getFullYear() > that.max.getFullYear()) {
                    return;
                }

                if (targetDate.getFullYear() < items[1].value.getFullYear() || targetDate.getFullYear() > items[10].value.getFullYear()) {
                    let focusedDate = that._focusedCell;

                    that.navigate(coefficient);

                    if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                        if (focusedDate === items[3] || focusedDate === items[4] || focusedDate === items[7] || focusedDate === items[8]) {
                            targetDate.setFullYear(targetDate.getFullYear() + coefficient * 2);
                        }
                        else {
                            targetDate.setFullYear(targetDate.getFullYear() - coefficient * 2);
                        }
                    }
                }
            }

            that._focusCell(that._getCellByDate(targetDate, that._animationStarted ? that.$.nextMonthsContainer : undefined));
            return;
        }

        const restrictedDates = that.restrictedDates.map(Number);

        targetDate = new Date(that._focusedCell.value.getFullYear(), that._focusedCell.value.getMonth(),
            that._focusedCell.value.getDate() + coefficient * iterations, 0, 0, 0, 0);

        while (restrictedDates.indexOf(targetDate.getTime()) > -1) {
            targetDate.setDate(targetDate.getDate() + coefficient);
        }

        if (targetDate.getTime() < that.min.getTime() || targetDate.getTime() > that.max.getTime()) {
            return;
        }

        if (!that._isDateInView(targetDate)) {
            that.navigate(coefficient * that.months);
        }

        let cell = that._getCellByDate(targetDate, that._animationStarted ? that.$.nextMonthsContainer : undefined);

        that._focusCell(cell);

        if (['zeroOrMany', 'oneOrMany', 'none', 'many', 'week'].indexOf(that.selectionMode) > -1) {
            return;
        }

        return true;
    }

    _handlePageUpDownKeys(event, coefficient) {
        const that = this;

        //Prevent window scrolling
        event.preventDefault();

        let targetDate;

        if (that.displayMode !== 'month') {
            targetDate = that._focusedCell;

            if (!that.navigate(coefficient)) {
                return;
            }

            while (targetDate && targetDate.classList.contains('jqx-visibility-hidden')) {
                targetDate = targetDate.previousElementSibling === null ? targetDate.nextElementSibling : targetDate.previousElementSibling;
            }

            that._focusCell(targetDate);

            if (that.hasAnimation && that.displayMode === 'decade') {
                that._focusedCell.value.setFullYear(that._focusedCell.value.getFullYear() + 10 * coefficient);
            }

            return;
        }

        targetDate = new Date(that._focusedCell.value.getFullYear(), that._focusedCell.value.getMonth() + coefficient, 1, 0, 0, 0, 0);

        let daysInMonth = new Date(targetDate.getFullYear(), targetDate.getMonth() + 1, 0).getDate();

        if (that._focusedCell.value.getDate() > daysInMonth) {
            targetDate.setDate(daysInMonth);
        }
        else {
            targetDate.setDate(that._focusedCell.value.getDate());
        }

        if (!that._isDateInView(targetDate)) {
            that.navigate(coefficient * that.months);
        }

        if (that._animationStarted) {
            that._focusCell(that._getCellByDate(targetDate, that.$.nextMonthsContainer));
        }
        else {
            that._focusCell(that._getCellByDate(targetDate));
        }

        return true;
    }

    /**
    * Selects/Unselects a day. Accepts a JQX.cell/ Day number/ Date object.
    */
    _selectDate(date, eventPrevented, noPropSynch) {
        const that = this;

        if (typeof (that._viewDates) === 'undefined' || that.selectionMode === 'none') {
            return;
        }

        let selectedDates = that.selectedDates.slice(0);

        let cell = that._getCellByDate(date, that._animationStarted ? that.$.nextMonthsContainer : that.$.monthsContainer);

        if (cell) {
            that._selectCell(cell);
        }

        let index;

        date = new Date(date);
        date.setHours(0, 0, 0, 0);

        index = selectedDates.map(Number).indexOf(date.getTime());

        //Date selection
        if (that.restrictedDates.map(Number).indexOf(date.getTime()) > -1 || date.getTime() < that.min.getTime() || date.getTime() > that.max.getTime()) {
            return;
        }

        index > -1 ? selectedDates.splice(index, 1) : selectedDates.push(date);

        if (!noPropSynch) {
            that.selectedDates = selectedDates;
        }

        that._refreshFooter();

        // Update the hidden input
        that.$.hiddenInput.value = that.selectedDates.toString();

        if (!eventPrevented) {
            that.$.fireEvent('change', {
                'value': [date]
            });
        }

        that._refreshTitle();
    }

    /**
     * Selects a day from the current month
     * @param {any} day - JQX.cell instance
     */
    _selectCell(cell) {
        const that = this;

        if (!cell || that.restrictedDates.map(Number).indexOf(cell.value.getTime()) > -1 ||
            (that.disableAutoNavigation && false === cell.otherMonth) ||
            cell.value.getTime() < that.min.getTime() || cell.value.getTime() > that.max.getTime()) {
            return;
        }

        const index = that._selectedCells.indexOf(cell);

        if (index > -1) {
            that._setCellState(cell, 'selected', false);
            that._selectedCells.splice(index, 1);
        }
        else {
            that._setCellState(cell, 'selected', true);
            that._selectedCells.push(cell);
        }

        that._focusCell(cell);
    }

    /**
    * Sets the names of the weeks.
    */
    _refreshDayOfWeekTitles() {
        const that = this;
        let days = [],
            date = new Date(),
            dayObject;

        function formatDayName(date) {
            let result;

            if (that.dayNameFormat === 'firstTwoLetters') {
                result = new Intl.DateTimeFormat(that.locale, { weekday: 'long' }).format(date);
                result = result.charCodeAt(0) === 8206 ? result.substring(1, 3) : result.substring(0, 2);
            }
            else {
                result = new Intl.DateTimeFormat(that.locale, { weekday: that.dayNameFormat }).format(date);
            }

            return result;
        }

        for (let i = 1; i < 8; i++) {
            date.setDate(i);
            dayObject = { number: date.getDay(), name: formatDayName(date) };
            days.push(dayObject);
        }

        days.sort((a, b) => (a.number > b.number ? 1 : -1));

        const months = that.$.monthsContainer.children;
        let dayNameHolders, counter;

        for (let m = 0; m < months.length; m++) {
            dayNameHolders = months[m].getElementsByClassName('jqx-calendar-week-titles')[0].children;
            counter = that.firstDayOfWeek > 6 ? 0 : that.firstDayOfWeek;  //Validates firstDayOfWeek

            if (that.rightToLeft) {
                for (let d = dayNameHolders.length - 1; d >= 0; d--) {
                    dayNameHolders[d].textContent = days[counter++].name;
                    counter = counter > 6 ? 0 : counter;
                }
            }
            else {
                for (let d = 1; d < dayNameHolders.length; d++) {
                    dayNameHolders[d].textContent = days[counter++].name;
                    counter = counter > 6 ? 0 : counter;
                }
            }
        }

        //Update the weekTitles for nextMonths
        if (that.hasAnimation) {
            const weekTitles = that.$.monthsContainer.getElementsByClassName('jqx-calendar-week-titles')[0].innerHTML,
                nextMonthWeekTitleContainers = that.$.nextMonthsContainer.getElementsByClassName('jqx-calendar-week-titles');

            for (let i = 0; i < nextMonthWeekTitleContainers.length; i++) {
                nextMonthWeekTitleContainers[i].innerHTML = weekTitles;
            }
        }
    }

    /**
     * Sets the header mode
     */
    _refreshCalendarMode() {
        const that = this;

        if (that.headerTemplate) {
            return;
        }

        that._refreshMonthNames();

        if (that.calendarMode === 'default') {
            that.$classicHeaderDate.addClass('jqx-hidden');
            that.$defaultHeaderDate.removeClass('jqx-hidden');

            const sortedDates = that._viewDates.slice(0).sort((a, b) => a.getTime() - b.getTime()),
                firstDateInView = sortedDates[0],
                lastDateInView = sortedDates[sortedDates.length - 1];

            firstDateInView.setDate(2);

            let date = firstDateInView.toLocaleDateString(that.locale, { year: that.yearFormat, month: that.monthNameFormat });

            if (that.months > 1) {
                lastDateInView.setDate(2);
                date += ' - ' + lastDateInView.toLocaleDateString(that.locale, { year: that.yearFormat, month: that.monthNameFormat });
            }

            that.$.defaultHeaderDate.innerHTML = date;

            if (!that.unfocusable) {
                that.$.dateElement.setAttribute('tabindex', that.tabIndex > 0 ? that.tabIndex : 0);
            }
        }
        else {
            that.$defaultHeaderDate.addClass('jqx-hidden');
            that.$classicHeaderDate.removeClass('jqx-hidden');
            that.$.dateElement.removeAttribute('tabindex');
        }
    }

    /**
    * Updates the footer with the latest date selection
    */
    _refreshFooter() {
        const that = this;

        if ((that.viewSections.indexOf('footer') < 0 || that.$.footer.offsetHeight === 0)) {
            return;
        }

        function preFormatDateOutput() {
            if (that.selectedDates.length === 0) {
                return '';
            }

            if (that.selectedDates.length === 1) {
                return that.selectedDates[0].toLocaleDateString(that.locale, { year: that.yearFormat, weekday: 'short', month: 'short', day: 'numeric' });
            }
            else {
                let sortedDates = that.selectedDates.slice(0).sort((a, b) => a.getTime() - b.getTime());

                return sortedDates[0].toLocaleDateString(that.locale, { year: that.yearFormat, weekday: 'short', month: 'short', day: 'numeric' }) + ' - ' +
                    sortedDates[sortedDates.length - 1].toLocaleDateString(that.locale, { year: that.yearFormat, weekday: 'short', month: 'short', day: 'numeric' });
            }
        }

        if (that.footerTemplate) {
            if (typeof that.footerTemplate === 'function') {
                return;
            }

            let layoutTemplate = that._layoutTemplates.filter(template => template.selector === that.$.footer)[0],
                clone = document.importNode(layoutTemplate.template.content, true);

            if (layoutTemplate.bindings.length > 0) {
                let bindingHolderElement = clone.childNodes[layoutTemplate.bindings[0].childNodeIndex];

                layoutTemplate.selector.childNodes[layoutTemplate.bindings[0].childNodeIndex].innerHTML =
                    bindingHolderElement.innerHTML.replace(layoutTemplate.bindings[0].bindingString, preFormatDateOutput());
            }

            return;
        }

        that.$.selectedDatesRange.innerHTML = preFormatDateOutput();
    }

    /**
    * Sets important days.
    */
    _refreshImportantDates() {
        const that = this;

        if (that.displayMode !== 'month') {
            return;
        }

        that._clearImportantDates();

        for (let d = 0; d < that.importantDates.length; d++) {
            that._setImportantDate(that.importantDates[d]);
        }
    }

    _clearImportantDates() {
        const that = this;

        const months = that.$.monthsContainer.children;

        for (let m = 0; m < months.length; m++) {
            that._getMonthCells(months[m]).map(cell => {
                that._setCellState(cell, 'important', false);
            });
        }
    }

    _setImportantDate(date, cell) {
        const that = this;
        const cellByDate = that._getCellByDate(date);

        if (!cell) {
            cell = cellByDate;
        }

        if (cell) {
            that._setCellState(cell, 'important', true);

            that._applyImportantDateTemplate(cell);
        }
    }

    _applyImportantDateTemplate(cell) {
        const that = this;

        if (!that._importantDatesTemplate) {
            if (typeof that.importantDatesTemplate === 'function') {
                that.importantDatesTemplate(cell, { value: cell.value });
                return;
            }

            cell.innerHTML = cell.value.getDate() + '';
            return;
        }


        let clone = document.importNode(that._importantDatesTemplate.content, true);

        if (that._bindingDetails && that._bindingDetails.length > 0) {
            let bindingHolderElement = clone.childNodes[that._bindingDetails[0].childNodeIndex];
            bindingHolderElement.innerHTML = bindingHolderElement.innerHTML.replace(that._bindingDetails[0].bindingString, cell.value.getDate());
        }

        cell.innerHTML = '';

        for (let i = 0; i < clone.childNodes.length; i++) {
            if (clone.childNodes[i].outerHTML) {
                cell.innerHTML += clone.childNodes[i].outerHTML;
            }
        }
    }

    /**
    *  Fill's the month with dates and weeknubers.
    */
    _setMonth(date, monthSelector, updateDatesOnly) {
        const that = this,
            selectedDates = that._getDays(date, that.selectedDates),
            importantDates = that._getDays(date, that.importantDates),
            restrictedDates = that._getDays(date, that.restrictedDates);

        date.setDate(1);

        if (!monthSelector) {
            monthSelector = that.$.month;
        }

        monthSelector._date = new Date(date);

        if (!updateDatesOnly) {
            if (!that._viewDates || that._viewDates.length >= that.months) {
                that._viewDates = [];
            }

            that._viewDates.push(new Date(date));
        }

        date = new Date(date);

        //Correct the start day according to firstDayOfWeek property
        let firstDayOfWeek = (date.getDay() - that.firstDayOfWeek + 7) % 7;

        date.setDate(0);

        let previusMonthDays = date.getDate();

        date.setDate(32); // current month.
        date.setDate(1); // set to first day of month.
        date.setDate(32); // next month.

        if (that._selectedCells) {
            for (let i = 0; i < that._selectedCells.length; i++) {
                if (that._selectedCells[i].closest('.jqx-calendar-month') === monthSelector) {
                    that._setCellState(that._selectedCells[i], 'selected', false);
                }
            }
        }

        that._setMonthContent(date, monthSelector, {
            previusMonthDays: previusMonthDays,
            firstDayOfWeek: firstDayOfWeek,
            selectedDates: selectedDates,
            importantDates: importantDates,
            restrictedDates: restrictedDates
        });
    }

    /**
    * Populates the Calendar with days for the corresponding month and calculates week numbers.
    */
    _setMonthContent(date, month, details) {
        const that = this;
        const daysInMonth = 32 - date.getDate(),
            monthCells = that._getMonthCells(month, that.rightToLeft),
            monthNumber = month._date.getMonth(),
            monthYear = month._date.getFullYear(),
            today = new Date();

        let nextMonthDays = 1,
            day = 1,
            shouldItemBeHidden;

        today.setHours(0, 0, 0, 0);

        //reset all item properties
        monthCells.map(cell => {
            that._setCellState(cell, 'restricted', false);
            that._setCellState(cell, 'selected', false);
            that._setCellState(cell, 'otherMonth', false);
            that._setCellState(cell, 'focus', false);
            that._setCellState(cell, 'important', false);
            that._setCellState(cell, 'today', false);
            that._setCellState(cell, 'disabled', false);
            that._setCellState(cell, 'hover', false);
        });

        for (let d = 0; d < monthCells.length; d++) {
            const cell = monthCells[d];

            if (d === details.firstDayOfWeek && day <= daysInMonth) {
                cell.className = 'jqx-calendar-cell';
                cell.value = new Date(monthYear, monthNumber, day);
                cell.innerHTML = cell.value.getDate().toString();

                if (details.restrictedDates.indexOf(day) > -1 || cell.value.getTime() < that.min.getTime() || cell.value.getTime() > that.max.getTime()) {
                    that._setCellState(cell, 'restricted', true);
                }
                else if (details.selectedDates.indexOf(day) > -1) {
                    that._setCellState(cell, 'selected', true);

                    if (that._selectedCells.indexOf(cell) < 0) {
                        that._selectedCells.push(cell);
                    }
                }

                if (details.importantDates.indexOf(day) > -1) {
                    that._setImportantDate(cell.value, cell);
                    details.importantDates.splice(details.importantDates.indexOf(day), 1);
                }

                if (cell.value.getTime() === today.getTime()) {
                    that._setCellState(cell, 'today', true);
                }

                details.firstDayOfWeek++;
                day++;
            }
            else {
                if (day === 1) {
                    cell.value = new Date(monthYear, monthNumber - 1, ++details.previusMonthDays - details.firstDayOfWeek);
                    shouldItemBeHidden = cell.value.getTime() < that.min.getTime() || month.previousElementSibling ? true : false;
                }
                else {
                    cell.value = new Date(monthYear, monthNumber + 1, nextMonthDays++);
                    shouldItemBeHidden = cell.value.getTime() > that.max.getTime() || month.nextElementSibling ? true : false;
                }

                cell.innerHTML = cell.value.getDate().toString();

                if (shouldItemBeHidden) {
                    cell.classList.add('jqx-visibility-hidden');
                }
                else {
                    that._setCellState(cell, 'otherMonth', true);
                    cell.classList.remove('jqx-visibility-hidden');
                }
            }
        }

        //Set month name
        if (that.months > 1) {
            month.firstElementChild.innerHTML = that.dateFormatFunction ?
                that.dateFormatFunction(month._date) : that._monthsNames[monthNumber] + ' ' + month._date.toLocaleDateString(that.locale, { year: that.yearFormat });
        }

        // Set week numbers
        that._setMonthWeekNumbers(month);
    }

    /**
    * Sets the names of the months inside the dropDown, according to localization.
    */
    _refreshMonthNames() {
        const that = this;
        let date = new Date(),
            formatedMonth;

        date.setDate(1);
        that._monthsNames = [];

        function formatMonthName(date) {
            let result = new Intl.DateTimeFormat(that.locale, { month: that.monthNameFormat }).format(date);

            if (that.monthNameFormat === 'firstTwoLetters') {
                //EDGE bug fix
                result = result.charCodeAt(0) === 8206 ? result.substring(0, 2) : result.substring(1, 3);
            }

            return result;
        }

        //get formated month names
        for (let m = 0; m < 12; m++) {
            date.setMonth(m);
            formatedMonth = formatMonthName(date);
            that._monthsNames.push(formatedMonth);
        }

        if (that.calendarMode === 'classic' && that.$.monthElement) {
            let months = that.$.monthsContainer.children;

            if (that.$.monthElement.dataSource) {
                that._changeEventFired = 1; //ListBox change event fired
            }

            //NOTE: when shadowDOM is Enabled, sometimes the context of the ListBox inside the DropDownList is not document and propertyChangeHandler is not fired on the ListBox
            if (that.enableShadowDOM) {
                that._setMonthElementPropertyInShadowDOM('dataSource', that._monthsNames);
            }
            else {
                that.$.monthElement.dataSource = that._monthsNames;
            }

            if (that._viewDates) {
                for (let m = 0; m < months.length; m++) {
                    months[m].firstElementChild.textContent = that._monthsNames[months[m]._date.getMonth()] + ' ' + months[m]._date.getFullYear();
                }

                that._changeEventFired = 1; //ListBox change event fired, again

                if (that.enableShadowDOM) {
                    that._setMonthElementPropertyInShadowDOM('selectedIndexes', that._viewDates.map(date => date.getMonth()));
                }
                else {
                    that.$.monthElement.selectedIndexes = that._viewDates.map(date => date.getMonth());
                }
            }
        }
    }

    /**
    * Set weeks numbers.
    */
    _setMonthWeekNumbers(month) {
        const that = this,
            isWeekVisible = function (week) {
                for (let d = 1; d < week.children.length; d++) {
                    if (!week.children[d].classList.contains('jqx-visibility-hidden')) {
                        return true;
                    }
                }
            };

        let weeks = month.getElementsByClassName('jqx-calendar-week');

        weeks = [].slice.call(weeks);

        // Set week numbers
        for (let w = 0; w < weeks.length; w++) {
            if (!isWeekVisible(weeks[w])) {
                weeks[w].children[0].innerHTML = '';
                continue;
            }

            const cell = weeks[w].children[1];
            const monthOffset = cell.otherMonth ? (cell.value.getTime() > month._date.getTime() ? 1 : -1) : 0;

            weeks[w].children[0].innerHTML = that._getWeekNumber(new Date(month._date.getFullYear(),
                month._date.getMonth() + monthOffset, cell.value.getDate()));
        }
    }

    /**
    * Sets restricted dates.
    */
    _setRestrictedDates(restrictedDates) {
        const that = this;
        const months = that.$.monthsContainer.children;

        for (let m = 0; m < months.length; m++) {
            that._getMonthCells(months[m]).map(cell => {
                that._setCellState(cell, 'restricted', false);
            });
        }

        if (that._viewDates) {
            const isDateRestricted = function (date) {
                for (let i = 0; i < that._viewDates.length; i++) {
                    if (that._viewDates[i].getFullYear() === date.getFullYear() && that._viewDates[i].getMonth() === date.getMonth()) {
                        return true;
                    }
                }
            };

            for (let i = 0; i < restrictedDates.length; i++) {
                if (isDateRestricted(restrictedDates[i])) {
                    const cell = that._getCellByDate(restrictedDates[i]);

                    that._setCellState(cell, 'restricted', true);
                }
            }
        }
    }

    /**
     * Sets the arrow direction of the scrollButtons
     */
    _setScrollButtonsNavigationMode() {
        const that = this;

        if (that.scrollButtonsNavigationMode === 'landscape') {
            if (that.$.previousMonthButton) {
                that.$.previousMonthButton.$.button.firstElementChild.innerHTML = '&#xe809';
            }

            if (that.$.nextMonthButton) {
                that.$.nextMonthButton.$.button.firstElementChild.innerHTML = '&#xe810';
            }
        }
        else {
            if (that.$.previousMonthButton) {
                that.$.previousMonthButton.$.button.firstElementChild.innerHTML = '&#xe80b';
            }

            if (that.$.nextMonthButton) {
                that.$.nextMonthButton.$.button.firstElementChild.innerHTML = '&#xe80d';
            }
        }

        that._applyAnimationSettings(true);
    }

    /**
     * Fires Tooltip's events when shadowDOM is enabled, because it cant bubble out of Calendar's shadowDOM
     * @param {any} event
     */
    _tooltipEventHandler(event) {
        const that = this;

        if (that.enableShadowDOM) {
            that.$.fireEvent(event.type, event.detail);
        }
    }

    /**
     * Updates Calendar's title
     */
    _refreshTitle() {
        const that = this;

        let date = that.selectedDates.length > 0 ? that.selectedDates[that.selectedDates.length - 1] : new Date();

        if (that.titleTemplate) {
            if (typeof that.titleTemplate === 'function') {
                return;
            }

            let layoutTemplate = that._layoutTemplates.filter(template => template.selector === that.$.title)[0],
                clone = document.importNode(layoutTemplate.template.content, true);

            if (layoutTemplate.bindings.length > 0) {
                let bindingHolderElement = clone.childNodes[layoutTemplate.bindings[0].childNodeIndex];

                date = date.toLocaleDateString(that.locale, { year: that.yearFormat, weekday: 'short', month: 'short', day: 'numeric' });
                layoutTemplate.selector.childNodes[layoutTemplate.bindings[0].childNodeIndex].innerHTML =
                    bindingHolderElement.innerHTML.replace(layoutTemplate.bindings[0].bindingString, date);
                return;
            }
        }

        that.$.title.children[0].innerHTML = date.toLocaleDateString(that.locale, { year: that.yearFormat });
        that.$.title.children[1].innerHTML = that.view === 'landscape' ?
            date.toLocaleDateString(that.locale, { weekday: 'short' }) + ',' + '</br>' +
            date.toLocaleDateString(that.locale, { month: 'short', day: 'numeric' }) :
            date.toLocaleDateString(that.locale, { weekday: 'short' }) + ', ' +
            date.toLocaleDateString(that.locale, { month: 'short', day: 'numeric' });
    }

    /**
    * Set how many weeks will be visible.
    */
    _setWeeksVisibility(monthContainer) {
        const that = this,
            months = monthContainer.children;
        let counter;

        //NOTE: classlist is used because when months > 1(or animation is ON) all weeks need to extend JQX
        function setVisibility(week) {
            const shouldWeekBeHidden = function (week) {
                for (let d = 1; d < week.children.length; d++) {
                    if (!week.children[d].classList.contains('jqx-visibility-hidden')) {
                        return false;
                    }
                }

                return true;
            };

            if (shouldWeekBeHidden(week) || counter >= that.weeks) {
                week.classList.add('jqx-hidden');
                return;
            }

            if (counter < that.weeks) {
                week.classList.remove('jqx-hidden');
                counter++;
            }
        }

        for (let m = 0; m < months.length; m++) {
            const month = months[m];
            let weeks = month.getElementsByClassName('jqx-calendar-week');

            weeks = [].slice.call(weeks);

            let selectedDates = that._selectedCells.filter(date => date.closest('.jqx-calendar-month') === months[m]);

            if (that.weeks === 6) {
                weeks.map(week => week.classList.remove('jqx-hidden'));
                continue;
            }

            counter = 0;
            if (selectedDates.length > 0) {
                let selectedDay = selectedDates[selectedDates.length - 1],
                    selectedDayWeekIndex = weeks.indexOf(selectedDay.parentElement);

                // Weeks after the one with the last selectedDay.
                for (let i = selectedDayWeekIndex; i < weeks.length; i++) {
                    setVisibility(weeks[i]);
                }

                // Weeks before the one with the last selectedDay.
                for (let i = selectedDayWeekIndex - 1; i >= 0; i--) {
                    setVisibility(weeks[i]);
                }
            }
            else {
                //No selectedDay, start from 1st week
                for (let i = 0; i < weeks.length; i++) {
                    setVisibility(weeks[i]);
                }
            }
        }
    }

    /**
    * Updates the header elements if they haven't been changed.
    */
    _refreshHeaderElements() {
        const that = this,
            isCalendarFocused = document.activeElement.closest('jqx-calendar') === that,
            target = that._animationStarted ? that.$.nextMonthsContainer : that.$.dateViewContainer;
        let lastDateInView = that._viewDates[that._viewDates.length - 1],
            yearsInView = that._viewDates.map(date => date.getFullYear()), nextDate, nextYear;

        if (that.displayMode !== 'month' && that.displayModeView === 'list') {
            return;
        }

        //Previous month navigation element
        if (that.$.previousMonthButton && !that.disabled) {
            if (that.displayMode !== 'month' && that.$.dateViewContainer.children[0].value) {
                nextYear = that.displayMode === 'year' ? target.children[0].value.getFullYear() - 1 : target.children[1].value.getFullYear() - 1;
            }
            else if (that._viewDates[0].getMonth() - 1 < 0) {
                nextDate = 11;
                nextYear = that._viewDates[0].getFullYear() - 1;
            }
            else {
                nextDate = that._viewDates[0].getMonth() - 1;
                nextYear = that._viewDates[0].getFullYear();
            }

            that.$.previousMonthButton.disabled = nextYear < that.min.getFullYear() || nextYear === that.min.getFullYear() &&
                nextDate < that.min.getMonth() ? true : false;

            if (that.$.previousMonthButton.disabled && isCalendarFocused) {
                that.$.body.focus();
            }
        }

        //Next month navigation element
        if (that.$.nextMonthButton && !that.disabled) {
            if (that.displayMode !== 'month' && that.$.dateViewContainer.children[0].value) {
                nextYear = that.displayMode === 'year' ? target.children[0].value.getFullYear() + 1 : target.children[1].value.getFullYear() + 11;
            }
            else if (lastDateInView.getMonth() + 1 > 11) {
                nextDate = 0;
                nextYear = lastDateInView.getFullYear() + 1;
            }
            else {
                nextDate = lastDateInView.getMonth() + 1;
                nextYear = lastDateInView.getFullYear();
            }

            that.$.nextMonthButton.disabled = nextYear > that.max.getFullYear() || nextYear === that.max.getFullYear() &&
                nextDate > that.max.getMonth() ? true : false;

            if (that.$.nextMonthButton.disabled && isCalendarFocused) {
                that.$.body.focus();
            }
        }

        //Month selection element
        if (that.calendarMode === 'classic' && that.$.monthElement) {
            const items = that.$.monthElement.items;

            items.map(item => item.disabled = false);
            if (yearsInView.indexOf(that.min.getFullYear()) > -1) {
                for (let i = 0; i < that.min.getMonth(); i++) {
                    items[i].disabled = true;
                }
            }

            if (yearsInView.indexOf(that.max.getFullYear()) > -1) {
                for (let i = that.max.getMonth() + 1; i < items.length; i++) {
                    items[i].disabled = true;
                }
            }

            that._changeEventFired = that.$.monthElement.selectedIndexes.length;

            if (that.enableShadowDOM) {
                that._setMonthElementPropertyInShadowDOM('selectedIndexes', [that._viewDates[0].getMonth()]);
            }
            else {
                that.$.monthElement.selectedIndexes = [that._viewDates[0].getMonth()];
            }

            that._changeEventFired = 0;
        }

        //Previous year navigation element
        if (that.$.previousYearButton && !that.disabled) {
            nextYear = that._viewDates[0].getFullYear() - 1;
            that.$.previousYearButton.disabled = nextYear < that.min.getFullYear() ? true : false;

            if (that.$.previousYearButton.disabled && isCalendarFocused) {
                that.$.body.focus();
            }
        }

        //Next year navigation element
        if (that.$.nextYearButton && !that.disabled) {
            nextYear = lastDateInView.getFullYear() + 1;
            that.$.nextYearButton.disabled = nextYear > that.max.getFullYear() ? true : false;

            if (that.$.nextYearButton.disabled && isCalendarFocused) {
                that.$.body.focus();
            }
        }

        //Year element
        if (that.$.yearElement) {
            that.$.yearElement.value = yearsInView[0];
            that.$.yearElement.disabled =
                lastDateInView.getFullYear() + 1 > that.max.getFullYear() && that._viewDates[0].getFullYear() - 1 < that.min.getFullYear() ? true : false;
        }
    }

    /**
     * Fixes ShadowDOM Context issue
     * Note:
     * Since in ShadowDOM the context of the monthElement and it's listBox during element initializaion is not document this method is the solution
     * @param {any} propertyname
     * @param {any} value
     */
    _setMonthElementPropertyInShadowDOM(propertyname, value) {
        const that = this,
            monthElement = that.$.monthElement,
            monthElementListBox = that.$.monthElement.$ ? that.$.monthElement.$.listBox : undefined;

        const monthElementContext = monthElement.context;
        let monthElementListboxContext;

        monthElement.context = document;

        if (monthElementListBox) {
            monthElementListboxContext = monthElementListBox.context;
            monthElementListBox.context = document;
        }

        that.$.monthElement[propertyname] = value;

        monthElement.context = monthElementContext;

        if (monthElementListBox) {
            monthElementListBox.context = monthElementListboxContext;
        }
    }

    /**
    * Updates the header/footer section with the appropriate date
    */
    _refreshHeaderTitle() {
        const that = this;
        let date;

        function preFormatDate() {
            if (that.displayMode !== 'month') {
                if (that.displayModeView === 'list' && that.$.listViewContainer.selectedValues[0]) {
                    let items = that.$.listViewContainer.items;

                    date = that.displayMode === 'year' ?
                        new Date(that.$.listViewContainer.getItem(that.$.listViewContainer.selectedValues[0]).value).getFullYear() :
                        new Date(items[0].value).getFullYear() + ' - ' + new Date(items[items.length - 1].value).getFullYear();
                }
                else if (that.$.dateViewContainer.children[0].value) {
                    let dateViewItems = that._animationStarted ? that.$.nextMonthsContainer.children : that.$.dateViewContainer.children;

                    date = that.displayMode === 'year' ? dateViewItems[0].value.getFullYear() :
                        dateViewItems[1].value.getFullYear() + ' - ' + dateViewItems[dateViewItems.length - 2].value.getFullYear();
                }

                if (date) {
                    return date;
                }
            }

            const sortedDates = that._viewDates.slice(0).sort((a, b) => a.getTime() - b.getTime()),
                firstDateInView = sortedDates[0],
                lastDateInView = sortedDates[sortedDates.length - 1];

            firstDateInView.setDate(2);
            date = firstDateInView.toLocaleDateString(that.locale, { year: that.yearFormat, month: that.monthNameFormat });

            if (that.months > 1) {
                lastDateInView.setDate(2);
                date += ' - ' + lastDateInView.toLocaleDateString(that.locale, { year: that.yearFormat, month: that.monthNameFormat });
            }

            return date;
        }

        if (that.calendarMode === 'default') {
            that.$.defaultHeaderDate.innerHTML = preFormatDate();
        }

        if (typeof that.headerTemplate === 'function' || !that._layoutTemplates) {
            return;
        }

        let layoutTemplate = that._layoutTemplates.filter(template => template.selector === that.$.header)[0];

        if (!layoutTemplate) {
            return;
        }

        let clone = document.importNode(layoutTemplate.template.content, true);

        if (layoutTemplate.bindings.length > 0) {
            const bindingHolderElement = clone.childNodes[layoutTemplate.bindings[0].childNodeIndex];

            layoutTemplate.selector.childNodes[layoutTemplate.bindings[0].childNodeIndex].innerHTML =
                bindingHolderElement.innerHTML.replace(layoutTemplate.bindings[0].bindingString, that.dateFormatFunction ? that.dateFormatFunction(that._viewDates) : preFormatDate());
        }
    }

    /**
    * Shows/hides the target week
    */
    _updateWeeksVisibility() {
        const that = this
        const focusedWeek = that._focusedCell.parentElement;

        //NOTE: classlist is used because when months > 1(or animation is ON) all weeks need to extend JQX
        if (!focusedWeek.classList.contains('jqx-hidden')) {
            return;
        }

        const monthWeeks = [].slice.call(focusedWeek.parentElement.children),
            weekIndex = monthWeeks.indexOf(focusedWeek),
            shouldWeekBeHidden = function (week) {
                for (let d = 1; d < week.children.length; d++) {
                    if (!week.children[d].classList.contains('jqx-visibility-hidden')) {
                        return false;
                    }
                }

                return true;
            };
        let counter = 0;

        monthWeeks.map(week => week.classList.add('jqx-hidden'));

        for (let i = weekIndex; i < monthWeeks.length; i++) {
            if (shouldWeekBeHidden(monthWeeks[i])) {
                continue;
            }

            monthWeeks[i].classList.remove('jqx-hidden');
            counter++;

            if (counter === that.weeks) {
                return;
            }
        }

        if (counter < that.weeks) {
            for (let i = weekIndex - 1; i >= 0; --i) {
                monthWeeks[i].classList.remove('jqx-hidden');
                counter++;

                if (counter === that.weeks) {
                    return;
                }
            }
        }
    }

    /**
     * Validates potential date input and returns an Array of Date Objects.
    */
    _getValidDates(dateOrDates) {
        let result = [];

        function validate(date) {
            if (date instanceof Date) {
                return date;
            }
            else if (JQX.Utilities.DateTime && date instanceof JQX.Utilities.DateTime) {
                return date.toDate();
            }
            else if (typeof (date) === 'string') {
                if (date.trim() === 'new Date()' || date.trim() === 'new JQX.Utilities.DateTime()') {
                    return new Date();
                }

                let regex = /(\d+[,-.\/]{1}\s*\d+[,-.\/]{1}\s*\d+)/;

                const parseDateString = () => {
                    date = date.replace(/[,-.\/]/g, ',').split(',');
                    if (date.length > 2) {
                        date = new Date(parseInt(date[0]), parseInt(date[1]) - 1, parseInt(date[2]));
                    }
                    else {
                        return new Date();
                    }

                    return date;
                }

                if (regex.test(date)) {
                    date = regex.exec(date)[0].replace(/[,-.\/]/g, ',').split(',');
                    if (date) {
                        return new Date(parseInt(date[0]), parseInt(date[1]) - 1, parseInt(date[2]));
                    }
                    else {
                        return parseDateString();
                    }
                }
                else {
                    return parseDateString();

                }
            }
        }

        if (dateOrDates === undefined) {
            return null;
        }

        if (Array.isArray(dateOrDates)) {
            for (let i = 0; i < dateOrDates.length; i++) {
                result.push(validate(dateOrDates[i]));
            }
        }
        else {
            result.push(validate(dateOrDates));
        }

        result = result.filter(date => date && date.toDateString() !== 'Invalid Date'); //remove invalid dates
        result.map(date => date.setHours(0, 0, 0, 0)); //reset time, important for date comparing

        return result;
    }

    _getValidDate(date) {
        const that = this;
        const validDates = that._getValidDates(date);

        if (validDates.length > 0) {
            return validDates[0];
        }

        return null;
    }

    /**
     * Validates the selectedDates to be in range min>date<max.
     */
    _validateSelectedDates(dates) {
        const that = this;
        let outOfRangeDates = [];

        if (!dates) {
            dates = that.selectedDates;
        }

        let selectedDates = dates.slice(0),
            filter = function (date) {
                if (date.getTime() >= that.min.getTime() && date.getTime() <= that.max.getTime() && !isRestrictedDate(date)) {
                    return true;
                }

                outOfRangeDates.push(date);
                return;
            },
            isRestrictedDate = function (date) {
                for (let d = 0; d < that.restrictedDates.length; d++) {
                    if (that.restrictedDates[d].getTime() === date.getTime()) {
                        return true;
                    }
                }
            }

        //Synchronize the attribute.
        that.selectedDates = selectedDates.filter(filter);

        //Unselects dates that are out of range.
        if (that._viewDates) {
            outOfRangeDates.map(date => that._selectDate(date));
            that._focusCell();
        }
    }

    /**
    * min property validator
    */
    _validateMinMax(propertyName, newValue, oldValue) {
        const that = this;

        switch (propertyName) {
            case 'min':
                newValue = that._getValidDate(that[propertyName]);
                that.min = newValue ? newValue : oldValue ? oldValue : that.properties.min.defaultValue;
                break;
            case 'max':
                newValue = that._getValidDate(that[propertyName]);
                that.max = newValue ? newValue : oldValue ? oldValue : that.properties.max.defaultValue;
                break;
            default:
                newValue = that._getValidDate(that.min);
                that.min = newValue ? newValue : oldValue ? oldValue : that.properties.min.defaultValue;
                newValue = that._getValidDate(that.max);
                that.max = newValue ? newValue : oldValue ? oldValue : that.properties.max.defaultValue;
                break;
        }

        that.min = that.min.getTime() > that.max.getTime() ? that.max : that.min;

        //reset time, important when comparing dates.
        that.min.setHours(0, 0, 0, 0);
        that.max.setHours(0, 0, 0, 0);

        let months = that.$.monthsContainer.children,
            days;

        if (that._viewDates) {
            if (that._viewDates[0].getTime() > that.max.getTime() || that._viewDates[0].getTime() < that.min.getTime()) {
                that._handleMonths();
                return;
            }

            for (let i = 0; i < months.length; i++) {
                days = that._getMonthCells(months[i]);
                for (let d = 0; d < days.length; d++) {
                    const cell = days[d];

                    if (cell.value.getTime() >= that.min.getTime() && cell.value.getTime() <= that.max.getTime()) {
                        that._setCellState(cell, 'restricted', false);

                        if (cell.value.getMonth() === months[i]._date.getMonth()) {
                            cell.classList.remove('jqx-visibility-hidden');
                        }
                        else if (!that.hideOtherMonthDays) {
                            that._setCellState(cell, 'otherMonth', true);
                            cell.classList.remove('jqx-visibility-hidden');
                        }

                        if (that.displayMode !== 'month') {
                            that._setCellState(cell, 'otherMonth', false);
                        }
                    }
                    else {
                        if (!cell.otherMonth) {
                            that._setCellState(cell, 'restricted', true);

                        }
                        else if (cell.classList.contains('jqx-visibility-hidden')) {
                            that._setCellState(cell, 'restricted', false);

                            continue;
                        }

                        if (that.displayMode !== 'month') {
                            cell.classList.remove('jqx-visibility-hidden');
                            that._setCellState(cell, 'otherMonth', true);
                        }
                    }
                }
            }
        }
    }

    _setCellState(cell, propertyName, value) {
        cell[propertyName] = value;

        const attributeName = JQX.Utilities.Core.toDash(propertyName);

        if (value) {
            cell.setAttribute(attributeName, '');
        }
        else {
            cell.removeAttribute(attributeName);
        }
    }

    /**
    * Checks for HTMLTemplate support and returns it's content.
    */
    _validateTemplate(propertyName, template) {
        if (template === null || !template) {
            return;
        }

        if (typeof (template) === 'function') {
            return;
        }

        const that = this;

        if (!('content' in document.createElement('template'))) {
            that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() }));
            return;
        }

        if (typeof (template) === 'string') {
            template = document.getElementById(template);
        }


        if (template === null || !('content' in template)) {
            that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: propertyName }));
            return;
        }

        return template;
    }

    /**
    * Navigates to next/previous month when clicked on other month day.
    */
    _weeksDownHandler(event, cell) {
        const that = this,
            date = cell.value;
        let neighbourMonth;

        if (cell.otherMonth) {
            neighbourMonth = cell.value.getTime() > cell.closest('.jqx-calendar-month')._date.getTime() ? 1 : -1;
        }

        if (that.hasRippleAnimation) {
            JQX.Utilities.Animation.Ripple.animate(cell, event.pageX, event.pageY);
        }

        if (neighbourMonth) {
            if (that._isDateInView(cell.value)) {
                return;
            }

            if (!that.disableAutoNavigation) {
                that.navigate(neighbourMonth * that.months);
            }

            return;
        }

        cell = that._getCellByDate(date);

        if (cell && (cell.disabled || cell.restricted)) {
            return;
        }

        that._handleDateSelection(cell);
    }

    /**
    * firstDayOfweek property validator
    */
    _firstDayOfWeekValidator(oldValue, newValue) {
        return Math.min(Math.max(0, (isNaN(newValue) ? 6 : newValue)), 6);
    }

    /**
    * Weeks property validator.
    */
    _weeksValidator(oldValue, newValue) {
        return Math.min(Math.max(1, (isNaN(newValue) ? 6 : newValue)), 6);
    }

    /**
    * Months property validator.
    */
    _monthsValidator(oldValue, newValue) {
        return Math.min(Math.max(1, (isNaN(newValue) ? 1 : newValue)), 12);
    }
});
/**
 * Card item custom element.
 */
JQX('jqx-card', class Card extends JQX.ContentElement {
    // Card item's properties.
    static get properties() {
        return {
            'dataSource': {
                value: null,
                type: 'object?',
                reflectToAttribute: false
            },
            'itemTemplate': {
                value: null,
                type: 'any?',
                reflectToAttribute: false
            },
            'contentHandler': {
                value: null,
                type: 'function?',
                reflectToAttribute: false
            }
        };
    }

    /**
     * Card item's event listeners.
     */
    static get listeners() {
        return {
            'mouseenter': '_mouseEnterHandler',
            'mouseleave': '_mouseLeaveHandler',
            'container.swipeleft': '_swipeHandler',
            'container.swiperight': '_swipeHandler',
            'container.swipetop': '_swipeHandler',
            'container.swipebottom': '_swipeHandler'
        };
    }

    static get styleUrls() {
        return [
            'jqx.card.css'
        ]
    }

    /**
     * Card's HTML template.
     */
    template() {
        return `<div id="container" inner-h-t-m-l="[[innerHTML]]">
                <content></content>
            </div>`;
    }

    /**
    * Updates the Card when a property is changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value.
    * @param {number/string} newValue The new entered value.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);
        const that = this;

        switch (propertyName) {
            case 'itemTemplate':
                that._template = that._handleTemplate();
                that.innerHTML = that._processTemplate();
                if (that.contentHandler) {
                    that.contentHandler(that);
                }
                break;
            case 'dataSource':
                that.innerHTML = that._processTemplate();
                if (that.contentHandler) {
                    that.contentHandler(that);
                }
                break;
            case 'contentHandler':
                if (that.contentHandler) {
                    that.contentHandler(that);
                }
                break;
        }
    }

    /**
    * Called when the element is ready. Used for one-time configuration of the Accordion.
    */
    ready() {
        super.ready();
        const that = this;

        that._template = that._handleTemplate();

        if (that._template.hasBindings) {
            that.innerHTML = that._processTemplate();
        }
        else if (that.itemTemplate) {
            that.innerHTML = that._template.content;
        }

        if (that.contentHandler) {
            that.contentHandler(that);
        }
    }

    _handleTemplate() {
        const that = this;
        let template = that.itemTemplate,
            templateContent = '',
            hasBindings = false,
            regex = /{{\w+}}/g;

        if (that.itemTemplate) {
            if (template instanceof HTMLElement) {
                templateContent = template.innerHTML;
            }
            else {
                template = document.getElementById(template);
                templateContent = template ? template.innerHTML : '';
            }
        }
        else {
            templateContent = that.innerHTML;
        }

        if (regex.exec(templateContent)) {
            hasBindings = true;
        }

        return { content: templateContent, hasBindings: hasBindings };
    }

    _processTemplate() {
        const that = this,
            regex = /{{\w+}}/g,
            bindings = that._template.content.match(regex),
            dataSource = that.dataSource || {};
        let processedTemplate = that._template.content;

        if (!bindings || bindings.length === 0) {
            return processedTemplate;
        }

        bindings.forEach(function (binding) {
            const propertyName = binding.replace('{{', '').replace('}}', '');
            let data = dataSource[propertyName];

            if (data === undefined) {
                data = '';
            }

            processedTemplate = processedTemplate.replace(binding, data);
        });

        return processedTemplate;
    }

    /**
    * Swipe events handler.
    **/
    _swipeHandler() { }
});

/**
* jqxCarousel custom element.
*/
JQX('jqx-carousel', class Carousel extends JQX.ContentElement {
    /**
    * Element's properties
    */
    static get properties() {
        return {
            'autoPlay': {
                value: false,
                type: 'any'
            },
            'dataSource': {
                value: [],
                type: 'array',
                reflectToAttribute:false
            },
            'delay': {
                value: 200,
                type: 'number'
            },
            'displayMode': {
                allowedValues: ['default', 'multiple', '3d'],
                value: 'default',
                type: 'string'
            },
            'disableItemClick': {
                value: false,
                type: 'boolean'
            },
            'hideArrows': {
                value: false,
                type: 'boolean'
            },
            'hideIndicators': {
                value: false,
                type: 'boolean'
            },
            'indicatorTemplate': {
                value: null,
                type: 'any'
            },
            'interval': {
                value: 5000,
                type: 'number'
            },
            'itemTemplate': {
                value: null,
                type: 'any'
            },
            'keyboard': {
                value: false,
                type: 'boolean'
            },
            'loop': {
                value: false,
                type: 'boolean'
            },
            'messages': {
                value: {
                    'en': {
                        'htmlTemplateNotSuported': '{{elementType}}:  Browser doesn\'t support HTMLTemplate elements.'
                    }
                },
                type: 'object',
                extend: true
            },
            'slideShow': {
                value: false,
                type: 'boolean'
            },
            'swipe': {
                value: false,
                type: 'boolean'
            },
            'wheel': { 
                value: false,
                type: 'boolean'
            }
        }
    }

    /**
    * Element's event listeners.
    */
    static get listeners() {
        return {
            'arrowLeft.click': '_handleArrowClick',
            'arrowRight.click': '_handleArrowClick',
            'indicatorsContainer.click': '_handleIndicatorsContainerClick',
            'keydown': '_handleKeyDown',
            'swipeleft': '_handleSwipe',
            'swiperight': '_handleSwipe',
            'wheel': '_handleMouseWheel',
            'itemsContainer.click': '_handleItemClick',
            'itemsContainer.transitionend': '_handleTransitionEnd'
        }
    }

    /*
    * Checks for missing modules.
    */
    static get requires() {
        return {
            'JQX.RepeatButton': 'jqxbutton.js'
        }
    }

    static get styleUrls() {
        return [
            'jqx.button.css',
            'jqx.carousel.css'
        ]
    }

    /**
    * Element's HTML template.
    */
    template() {
        return `<div id="container">
                    <div id="itemsContainer" inner-h-t-m-l="[[innerHTML]]" class="jqx-items-container"><content></content></div>
                    <jqx-repeat-button initial-delay="0" delay="[[delay]]" id="arrowLeft" animation="[[animation]]" unfocusable class="jqx-arrow jqx-arrow-left"></jqx-repeat-button>
                    <jqx-repeat-button initial-delay="0" delay="[[delay]]" id="arrowRight" animation="[[animation]]" unfocusable class="jqx-arrow jqx-arrow-right"></jqx-repeat-button>
                    <div id="indicatorsContainer" class="jqx-indicators-container"></div>
                </div>`;
    }
 
    /**
    * Updates the element when a property is changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value.
    * @param {number/string} newValue The new entered value.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        super.propertyChangedHandler(propertyName, oldValue, newValue);

        switch (propertyName) {
            case 'disabled':
                that._setFocusable();
                break;
            case 'dataSource':
                that._generateIndicators();
                that._generateItems();
                that._handleIndicatorsState(0, 0);
                that._handleItemsState(0, 0);
                that._handle3dMode(0);

                if (that.autoPlay !== false) {
                    const interval = parseInt(that.autoPlay);
                    if(interval){
                        setTimeout(function () {
                            that.play();
                        }, interval);
                    }
                    else{
                        that.play();
                    }
                }

                that._animationTrigger(that._currentIndex);
                break;
            case 'itemTemplate':
                that._generateItems();
                that._handleItemsState(that._currentIndex, that._currentIndex + 1);
                break;
            case 'indicatorTemplate':
                that._generateIndicators();
                that._handleIndicatorsState(that._currentIndex, that._currentIndex + 1);
                break;
            case 'interval':
                that.pause();
                that.play();
                break;
            case 'loop':
                that._handleArrowsActiveState(that._currentIndex, that._currentIndex);
                break;
            case 'hideArrows':
                if (!newValue) {
                    that._handleArrowsActiveState(that._currentIndex, that._currentIndex);
                }
                break;
            case 'displayMode':
                if (oldValue === 'multiple') {
                    that.$.itemsContainer.removeAttribute('style');
                }
                break;
        }
    }

    /**
    * Element's ready method.
    */
    ready() {
        super.ready();
        const that = this;

        that._setInitialState();
        that._generateIndicators();
        that._generateItems();
        that._handleIndicatorsState(0, 0);
        that._handleItemsState(0, 0);
        that._handle3dMode(0);

        if (that.autoPlay!==false) {
            const interval = parseInt(that.autoPlay);
            interval ? setTimeout(function () {
                that.play()
            }, interval) : that.play();
        }

        that._setFocusable();
        that._animationTrigger(that._currentIndex);
    }

    /**
    * Moves to the slide with the next index. 
    * In loop mode if current is last index, carousel moves to the first slide.
    */
    next() {
        const that = this,
            availableItems = that.dataSource.length;
        
        if (that.disabled || availableItems === 0) {
            return;
        }

        let nextItem = that._currentIndex;

        if(that.loop){
            nextItem = nextItem >= availableItems-1 ? 0 : nextItem + 1;
        }
        else {
            nextItem = nextItem >= availableItems-1 ? nextItem : nextItem + 1;
        }

        that._goToItem(nextItem);
    }

    /**
    * Pauses slideShow.
    */
    pause() {
        const that = this;

        that._handleRotation();
        that._rotate = false;
    }

    /**
    * Slides to the element with the given index.
    */
    slideTo(index) {
        const that = this;

        index = index ? parseInt(index) : 0;

        if (that.disabled || index < 0 || index> that._items.length) {
            return;
        }

        that._goToItem(index);
    }

    /**
    * Moves to the slide with the previous index. 
    * In loop mode if current is first index, carousel moves to the last slide.
    */
    prev() {
        const that = this,
            availableItems = that.dataSource.length;
        
        if (that.disabled || availableItems === 0) {
            return;
        }

        let previousItem = that._currentIndex;

        if(that.loop){
            previousItem = previousItem <= 0 ? availableItems - 1 : previousItem - 1;
        }
        else {
            previousItem = previousItem <= 0 ? 0 : previousItem - 1;
        }

        that._goToItem(previousItem);
    }

    /**
    * Starts slideShow.
    */
    play() {
        const that = this;
        
        if (that.disabled || !that.slideShow) {
            return;
        }

        if (that._rotationInterval) {
            clearInterval(that._rotationInterval);
        }

        that._handleRotation(true);
        that._rotate = true;
    }

    /**
    * Prevents animation on the selected animation slide immediately after items initialization
    */
    _animationTrigger(skip) {
        const that = this;

        for (let i = 0; i < that._items.length; i++) {
            if (i === skip) {
                continue;
            }
            that._items[i].classList.add('jqx-animate-trigger');
        }
    }

    /**
    * In "3d" mode sets positions of carousel items in relation to the active slide.
    */
    _handle3dMode(newIndex) {
        const that = this,
            itemsCount = that.dataSource.length;

        if (that.disabled || !itemsCount || that.displayMode !== '3d') {
            return;
        }

        newIndex = newIndex || 0;

        for (let i = 0; i < itemsCount; i++) {
            const currentPosition = i - newIndex;

            currentPosition ? that._items[i].setAttribute('position', currentPosition) : that._items[i].removeAttribute('position');
        }
    }

    /**
    * Enables/disables arrows
    */
    _handleArrowsActiveState(newIndex, oldIndex) {
        const that = this,
            itemsCount = that.dataSource.length;

        if (!that.loop) {
            (oldIndex === 0) && (that.$.arrowLeft.disabled = false);
            (oldIndex === (itemsCount - 1)) && (that.$.arrowRight.disabled = false);
            (newIndex === 0) && (that.$.arrowLeft.disabled = true);
            (newIndex === (itemsCount - 1)) && (that.$.arrowRight.disabled = true);
        }
        else {
            that.$.arrowLeft.disabled = that.$.arrowRight.disabled = false;
        }
    }

    /**
    * Handles click on carousel's arrows.
    */
    _handleArrowClick(event) {
        const that = this,
            previousIndex = that._currentIndex;

        if (that.disabled) {
            return;
        }

        that.$.arrowLeft.contains(event.target) ? that.prev() : that.next();
        that._changeEvent(previousIndex, that._currentIndex);
    }

    /**
    * Handles slides, set via inner HTML as LI elements.
    */
    _handleDefaultInnerHTML() {
        const that = this;

        if (that.dataSource && that.dataSource.length > 0) {
            return;
        }

        if (that.$.itemsContainer.innerHTML.indexOf('<ul') >= 0) {
            const firstUl = that.$.itemsContainer.getElementsByTagName('ul')[0],
                items = firstUl.getElementsByTagName('li');

            for (let i = 0; i < items.length; i++) {
                const slide = { HTMLcontent: items[i].innerHTML };

                that.dataSource.push(slide);
            }
        }
    }

    /**
    * Handles indicator's state.
    */
    _handleIndicatorsState(from, to) {
        const that = this;

        if (that.disabled || that._indicators.length === 0 || (!from && from !== 0) || (!to && to !== 0)) {
            return;
        }

        if (from !== to) {
            that._indicators[from].classList.remove('jqx-active');
        }

        that._indicators[to].classList.add('jqx-active');
    }

    /**
    * On '3d' mode makes clicked item active
    */
    _handleItemClick(event) {
        const that = this,
            clickedItem = event.target.closest('.jqx-carousel-item');

        if (that.disabled || !clickedItem || that.displayMode!=='3d' || that.disableItemClick) {
            return;
        }

        const itemId = parseInt(clickedItem.getAttribute('item-id')),
            itemPosition = parseInt(clickedItem.getAttribute('position'));

        if (Math.abs(itemPosition) > 3){
            return;
        }

        that._goToItem(itemId);
    }

    /**
    * Handles items's state.
    */
    _handleItemsState(from, to) {
        const that = this;

        if (that.disabled || that._items.length === 0 || (!from && from !== 0) || (!to && to !== 0)) {
            return;
        }

        if (from !== to) {
            that._items[from].classList.remove('jqx-active');
            that._items[from].classList.add('jqx-out');
        }

        that._items[to].classList.add('jqx-active');
    }

    /**
    * Handles click on indicators.
    */
    _handleIndicatorsContainerClick(event) {
        const that = this,
            clickedItem = event.target.closest('.jqx-indicator'),
            previousIndex = that._currentIndex;

        if (that.disabled || !clickedItem) {
            return;
        }

        const itemId = parseInt(clickedItem.getAttribute('indicator-id'));

        if (previousIndex === itemId) {
            return;
        }

        that._goToItem(itemId);
        that._changeEvent(previousIndex, that._currentIndex);
    }

    /**
    * In "multiple" mode sets positions of carousel items in relation to the active slide.
    */
    _handleMultipleMode(newIndex) {
        const that = this;

        if (that.displayMode !== 'multiple') {
            return;
        }

        const item = that._items[newIndex],
                itemWidth = item.offsetWidth,
                containerWidth = that.$.container.offsetWidth,
                itemsContainerWidth = that.$.itemsContainer.offsetWidth;
        let itemOffset = 0;

        if (newIndex === 0) {
            that.$.itemsContainer.style.marginLeft = '0px';
            return;
        }
        else if (newIndex === (that._items.length - 1)) {
            that.$.itemsContainer.style.marginLeft = '-' + (itemsContainerWidth - containerWidth) + 'px';
            return;
        }

        for (let i = 0; i < newIndex; i++) {
            itemOffset = itemOffset + that._items[newIndex].offsetWidth;
        }

        if (((itemOffset + itemWidth / 2) >= containerWidth / 2) && ((itemOffset + itemWidth) < itemsContainerWidth)) {
            that.$.itemsContainer.style.marginLeft = '-' + ((itemOffset + itemWidth / 2) - containerWidth / 2) + 'px';
        }
    }

    /**
    * Fires change/changing events.
    */
    _changeEvent(from, to) {
        if (from === to) {
            return;
        }

        const that = this;

        that.$.fireEvent('changing', {
            'index': to,
            'previousIndex': from
        });

        if (!that.hasAnimation) {
            that.$.fireEvent('change', {
                'index': to,
                'previousIndex': from
            });
        }
    }

    /**
    * Handles keyboard navigation.
    */
    _handleKeyDown(event) {
        const that = this,
            key = event.key,
            previousIndex = that._currentIndex,
            allowedKeys = ['ArrowLeft', 'ArrowDown', 'ArrowRight', 'ArrowUp', 'Home', 'End', ' ', 'Enter'];

        if (that.disabled || !that.keyboard || allowedKeys.indexOf(key)===-1) {
            return;
        }

        switch (key) {
            case 'ArrowLeft':
            case 'ArrowDown':
                that.prev();
                break;
            case 'ArrowUp':
            case 'ArrowRight':
                that.next();
                break;
            case 'Home':
                that._goToItem(0);
                break;
            case 'End':
                that._goToItem(that.dataSource.length-1);
                break;
            case ' ':
                that._rotate ? that.pause() : that.play();
                break;
            case 'Enter':
                that.play();
                break;
        }

        that._changeEvent(previousIndex, that._currentIndex);
    }

    /**
    * Allows navigation between slides via mouse wheel.
    */
    _handleMouseWheel(event) {
        const that = this,
            previousIndex = that._currentIndex;

        if (that.disabled || !that.wheel || document.activeElement!== that) {
            return
        }

        event.stopPropagation();
        event.preventDefault();
        event.deltaY>0 ? that.next() : that.prev();
        that._changeEvent(previousIndex, that._currentIndex);
    }

    /**
    * Start/stop slideShow.
    */
    _handleRotation(on) {
        const that = this;

        if (on) {
            that._rotationInterval = setInterval(function () {
                if (!that.slideShow) {
                    return;
                }

                that.next();
            }, that.interval);
        }
        else {
            clearInterval(that._rotationInterval);
        }
    }

    /**
    * Slides to next/prev slide on swipeRight/swipeLeft.
    */
    _handleSwipe(event) {
        const that = this;

        if (that.disabled || !that.swipe) {
            return;
        }

        event.stopPropagation();
        event.preventDefault();
        event.type === 'swipeleft' ? that.prev() : that.next();
    }

    /**
    * Generates single indicator item
    */
    _generateIndicator(id) {
        const that = this,
            indicatorContainer = document.createElement('span'),
            indicatorId = id ? id : 0;

        if (that.indicatorTemplate) {
            const template = that._validateTemplate(that.indicatorTemplate);

            indicatorContainer.innerHTML = that._processItemTemplate(template.content, that.dataSource[indicatorId])
        }

        indicatorContainer.classList.add('jqx-indicator');
        indicatorContainer.setAttribute('indicator-id', indicatorId);

        return indicatorContainer;
    }

    /**
    * Fills indicators container by generating multiple indicators.
    */
    _generateIndicators() {
        const that = this,
            itemsCount = that.dataSource.length;
        let indicators = [],
            fragment = document.createDocumentFragment();

        for (let i = 0; i < itemsCount; i++) {
            const item = that._generateIndicator(i);

            indicators.push(item);
            fragment.appendChild(item);
        }

        that._indicators = indicators;

        const indicatorsContainer = that.$.indicatorsContainer;

        while (indicatorsContainer.firstChild) {
            indicatorsContainer.removeChild(indicatorsContainer.firstChild);
        }

        indicatorsContainer.appendChild(fragment);
    }

    /**
    * Generates single slide
    */
    _generateItem(id) {
        const that = this,
            itemContainer = document.createElement('div'),
            itemId = id ? id : 0;

        if (that.itemTemplate) {
            const template = that._validateTemplate(that.itemTemplate);

            itemContainer.innerHTML = that._processItemTemplate(template.content, that.dataSource[itemId]);
        }
        else {
            const item = that.dataSource[itemId];

            if (typeof item === 'string') {
                itemContainer.style.backgroundImage = 'url("' + item + '")';
            }
            else {
                itemContainer.innerHTML = `<div class="jqx-carousel-item-container" style="background-image:url('${item.image || ''}')">
                        <h2 class="jqx-carousel-item-label">${item.label || ''}</h2>
                        <p class="jqx-carousel-item-content">${item.content || ''}</p>
                    </div>
                    <div class="jqx-carousel-html-content">${item.HTMLcontent || ''}</div>
                </div>`;
            }
        }

        itemContainer.classList.add('jqx-carousel-item');
        itemContainer.setAttribute('item-id', itemId);

        return itemContainer;
    }

    /**
    * Binds template and data source item
    */
    _processItemTemplate(template, dataSource) {
        const regex = /{{\w+}}/g,
            bindings = template.match(regex);
        let processedTemplate = template;

        if (!bindings || bindings.length === 0) {
            return processedTemplate;
        }

        bindings.forEach(function(binding) {
            const propertyName = binding.replace('{{', '').replace('}}', '');

            processedTemplate = processedTemplate.replace(binding, (dataSource[propertyName] || ''));
        });

        return processedTemplate;
    }

    /**
    * Fills slides container by generating multiple items.
    */
    _generateItems() {
        const that = this,
            itemsCount = that.dataSource.length;
        let items = [],
            fragment = document.createDocumentFragment();

        for (let i = 0; i < itemsCount; i++) {
            const item = that._generateItem(i);

            items.push(item);
            fragment.appendChild(item);
        }

        that._items = items;

        const itemsContainer = that.$.itemsContainer;

        while (itemsContainer.firstChild) {
            itemsContainer.removeChild(itemsContainer.firstChild);
        }

        itemsContainer.appendChild(fragment);
    }

    /**
    * Moves slides to an item with particular index.
    */
    _goToItem(index, fireEvent) {
        const that = this,
            itemsCount = that.dataSource.length,
            oldIndex = that._currentIndex;
        let newIndex = index;

        if (index < 0) {
            newIndex = 0;
        }
        else if (index > (itemsCount - 1)) {
            newIndex = itemsCount - 1
        }

        that._removeFadeOut();
        that._animationTrigger();
        that._handleIndicatorsState(oldIndex, newIndex);
        that._handleItemsState(oldIndex, newIndex);
        that._currentIndex = newIndex;
        fireEvent && that._changeEvent(oldIndex, newIndex);
        that._handle3dMode(newIndex);
        that._handleMultipleMode(newIndex);
        that._handleArrowsActiveState(newIndex, oldIndex);
    }

    /**
    * Sets tab index 
    */
    _setFocusable() {
        const that = this;

        if (that.disabled || that.unfocusable) {
            that.removeAttribute('tabindex');
            that.tabIndex = -1;
            return;
        }

        let index = that.tabIndex > 0 ? that.tabIndex : 0;

        that.setAttribute('tabindex', index);
        that.tabIndex = index;
    }

    /**
    * Sets initial values to inner variables, used in latest stage.
    */
    _setInitialState() {
        const that = this;

        that._currentIndex = 0;
        that._indicators = [];
        that._items = [];
        that._rotate = false;
        that._handleDefaultInnerHTML();
    }

    /**
    * Sets initial values to inner variables, used in latest stage.
    */
    _validateTemplate(template) {
        const that = this;
        let templateContent = '',
                hasBindings = false,
                regex = /{{\w+}}/g;

        if (typeof template === 'function') {
            templateContent = template();
        }

        if (!('content' in document.createElement('template'))) {
            that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() }));
            that.itemTemplate = null;
            return;
        }

        if (template instanceof HTMLElement) {
            templateContent = template.innerHTML;
        }
        else {
            template = document.getElementById(template);
            templateContent = template ? template.innerHTML : '';
        }

        if (regex.exec(templateContent)) {
            hasBindings = true;
        }

        return { content: templateContent, hasBindings: hasBindings };
    }

    /**
    * Detect animation end and updates animated item's class list
    */
    _handleTransitionEnd(event) {
        if (!event.target.classList.contains('jqx-carousel-item') || event.target.getAttribute('position')) {
            return;
        }

        const that = this,
            currentTransitionEndId = event.target.getAttribute('item-id');

        if (that._lastTransitionEndId === currentTransitionEndId) {
            return;
        }

        that._removeFadeOut();
        this.$.fireEvent('change', {
            'index': currentTransitionEndId,
            'previousIndex': that._lastTransitionEndId
        });
        that._lastTransitionEndId = currentTransitionEndId;
    }

    /**
    * Removes the class related to items fade out effect 
    */
    _removeFadeOut() {
        const that = this,
            fadeOutItems = that.$.itemsContainer.getElementsByClassName('jqx-out');

        if (fadeOutItems.length) {
            for (let i = 0; i < fadeOutItems.length; i++) {
                fadeOutItems[i].classList.remove('jqx-out');
            }
        }
    }
});
/**
 * Chip item custom element.
 */
JQX('jqx-chip', class Chip extends JQX.ContentElement {
    // Chip item's properties.
    static get properties() {
        return {
            'avatar': {
                value: null,
                type: 'string?'
            },
            'closeButton': {
                value: false,
                type: 'boolean'
            },
            'itemTemplate': {
                value: null,
                type: 'any?',
                reflectToAttribute: false
            },
            'value': {
                value: '',
                type: 'string'
            }
        };
    }

    /**
     * Chip item's event listeners.
     */
    static get listeners() {
        return {
            'click': '_clickHandler',
            'keydown': '_keyDownHandler'
        };
    }

   /**
   * CSS files needed for the element (ShadowDOM)
   */
    static get styleUrls() {
        return [
            'jqx.chip.css'
        ]
    }

    /**
     * Chip's HTML template.
     */
    template() {
        return `<div id="container">
                    <span id="avatar" class ="jqx-avatar">[[avatar]]</span><!--
                --><span id="value" class ="jqx-value" inner-h-t-m-l="[[innerHTML]]"><content></content></span><!--
                --><span id="closeButton" class ="jqx-close-button"></span>
            </div>`;
    }

    /**
    * Updates the Chip when a property is changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value.
    * @param {number/string} newValue The new entered value.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);
        const that = this;

        switch (propertyName) {
            case 'disabled':
            case 'unfocusable':
                that._setFocusable();
                break;
            case 'avatar':
                that.itemTemplate ? that._setAvatar(that._customAvatar) : that._setAvatar(that.$.avatar);
                break;
            case 'itemTemplate':
                that._applyTemplate();
                break;
            case 'value':
                if (that.itemTemplate) {
                    that._applyTemplate();
                }
                else {
                    that.$.value.innerHTML = newValue || '';
                }
                break;
        }
    }

    ready() {
        super.ready();
        const that = this;

        that.value = that.value ? that.value : that.innerHTML;
        that._applyTemplate();
        that._setFocusable();
    }

    close() {
        const that = this;

        that.$.fireEvent('close', { 'value': that.value });
        that.parentElement.removeChild(that);
    }

    _applyTemplate() {
        const that = this;
        let template = that.itemTemplate;
        

        if(!template){
            that.$.value.innerHTML = that.value;
            that._setAvatar(that.$.avatar);

            return;
        }

        if (!('content' in document.createElement('template'))) {
            that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() }));
            return;
        }

        if (!(template instanceof HTMLTemplateElement)) {
            template = document.getElementById(template);
        }

        if (template === null || !('content' in template)) {
            that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase() }));
            return;
        }

        let templateContent = template.innerHTML;

        that.$.container.innerHTML = templateContent.replace(/{{\s*value\s*}}/g, that.value);
        that._customAvatar = that.$.container.querySelector('.jqx-avatar');
        that._setAvatar(that._customAvatar);
    }

    _clickHandler(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        const target = that.enableShadowDOM ? that.shadowRoot.elementFromPoint(event.pageX, event.pageY) : event.target;

        if (!target.closest || !target.closest('.jqx-close-button')) {
            return;
        }

        that.close();
    }

    /**
     * KeyDown handler.
     */
    _keyDownHandler(event) {
        const that = this;

        let key = event.key;

        if (that.disabled || that.readonly || key !== 'Delete') {
            return;
        }

        that.close();
    }

    _setAvatar(element) {
        if(!element){
            return;
        }

        const that = this,
            isAvatarImage = (/\.(gif|jpg|jpeg|tiff|png)$/i).test(that.avatar);

        element.innerHTML = isAvatarImage ? '<img src="' + that.avatar + '" />' : (that.avatar || '');
    }

    /**
    * Set tabIndex.
    */
    _setFocusable() {
        const that = this;

        if (that.disabled || that.unfocusable) {
            that.removeAttribute('tabindex');
            return;
        }

        that.tabIndex = that.tabIndex > 0 ? that.tabIndex : 0;
    }
});
/**
 * DateTimePicker custom element.
 */
JQX('jqx-date-time-picker', class DateTimePicker extends JQX.BaseElement {
    /**
     * DateTimePicker's properties.
     */
    static get properties() {
        return {
            'animationSettings': {
                value: null,
                type: 'object'
            },
            'autoClose': {
                value: false,
                type: 'boolean'
            },
            'autoCloseDelay': {
                value: 0,
                type: 'number'
            },
            'calendarButton': {
                value: false,
                type: 'boolean'
            },
            'calendarButtonPosition': {
                value: 'right',
                allowedValues: ['left', 'right'],
                type: 'string'
            },
            'calendarMode': {
                value: 'default',
                allowedValues: ['default', 'classic'],
                type: 'string'
            },
            'dayNameFormat': {
                value: 'firstTwoLetters',
                allowedValues: ['narrow', 'firstTwoLetters', 'long', 'short'],
                type: 'string'
            },
            'disableAutoNavigation': {
                value: false,
                type: 'boolean'
            },
            'displayKind': {
                value: 'unspecified',
                allowedValues: ['UTC', 'local', 'unspecified'],
                type: 'string'
            },
            'displayModeView': {
                value: 'table',
                allowedValues: ['table', 'list'],
                type: 'string'
            },
            'dropDownAppendTo': {
                value: null,
                type: 'any'
            },
            'dropDownDisplayMode': {
                value: 'default',
                allowedValues: ['default', 'classic', 'calendar', 'timePicker', 'auto'],
                type: 'string'
            },
            'dropDownOverlay': {
                value: false,
                type: 'boolean'
            },
            'dropDownPosition': {
                value: 'auto',
                allowedValues: ['auto', 'bottom', 'overlay-top', 'overlay-center', 'overlay-bottom', 'top', 'center-bottom', 'center-top'],
                type: 'string'
            },
            'editMode': {
                value: 'default',
                allowedValues: ['default', 'full', 'partial'],
                type: 'string'
            },
            'enableMouseWheelAction': {
                value: false,
                type: 'boolean'
            },
            'firstDayOfWeek': {
                value: 0,
                type: 'number'
            },
            'footerTemplate': {
                value: null,
                type: 'any'
            },
            'formatString': {
                value: 'dd-MMM-yy HH:mm:ss.fff',
                type: 'string'
            },
            'headerTemplate': {
                value: null,
                type: 'any'
            },
            'hideDayNames': {
                value: false,
                type: 'boolean'
            },
            'hideOtherMonthDays': {
                value: false,
                type: 'boolean'
            },
            'hideTooltipArrow': {
                value: false,
                type: 'boolean'
            },
            'hint': {
                value: '',
                type: 'string'
            },
            'importantDates': {
                value: [],
                type: 'array'
            },
            'importantDatesTemplate': {
                value: null,
                type: 'any'
            },
            'interval': {
                value: new JQX.Utilities.TimeSpan(0, 0, 1),
                type: 'any'
            },
            'label': {
                value: '',
                type: 'string'
            },
            'max': {
                value: new JQX.Utilities.DateTime(3001, 1, 1),
                type: 'any'
            },
            'messages': {
                value: {
                    'en': {
                        'now': 'Now',
                        'dateTabLabel': 'DATE',
                        'timeTabLabel': 'TIME'
                    }
                },
                type: 'object',
                extend: true
            },
            'min': {
                value: new JQX.Utilities.DateTime(1600, 1, 1),
                type: 'any'
            },
            'name': {
                value: '',
                type: 'string'
            },
            'nullable': {
                value: false,
                type: 'boolean'
            },
            'opened': {
                value: false,
                type: 'boolean'
            },
            'placeholder': {
                value: 'Enter date',
                type: 'string'
            },
            'renderMode': {
                allowedValues: ['outlined', 'filled', 'underlined'],
                value: 'outlined',
                type: 'string'
            },
            'restrictedDates': {
                value: [],
                type: 'array'
            },
            'spinButtons': {
                value: false,
                type: 'boolean'
            },
            'spinButtonsDelay': {
                value: 75,
                type: 'number'
            },
            'spinButtonsInitialDelay': {
                value: 0,
                type: 'number'
            },
            'spinButtonsPosition': {
                value: 'right',
                allowedValues: ['left', 'right'],
                type: 'string'
            },
            'tooltip': {
                value: false,
                type: 'boolean'
            },
            'tooltipDelay': {
                value: 100,
                type: 'number'
            },
            'tooltipPosition': {
                value: 'top',
                allowedValues: ['bottom', 'top', 'left', 'right', 'absolute'],
                type: 'string'
            },
            'tooltipTemplate': {
                value: null,
                type: 'any'
            },
            'validation': {
                value: 'strict',
                allowedValues: ['strict', 'interaction'],
                type: 'string'
            },
            'value': {
                defaultReflectToAttribute: true,
                value: new JQX.Utilities.DateTime(),
                type: 'any'
            },
            'weekNumbers': {
                value: false,
                type: 'boolean'
            },
            'weeks': {
                value: 6,
                type: 'number'
            },
            'yearCutoff': {
                value: 1926,
                type: 'number'
            }
        };
    }

    /**
     * DateTimePicker's event listeners.
     */
    static get listeners() {
        return {
            'container.mouseout': '_mouseoutHandler',
            'container.mouseover': '_mouseoverHandler',
            'calendarButton.click': '_calendarButtonClickHandler',
            'calendarDropDown.change': '_calendarDropDownChangeHandler',
            'calendarDropDown.click': '_calendarDropDownClickHandler',
            'downButton.click': '_spinButtonsClickHandler',
            'input.blur': '_inputBlurHandler',
            'input.change': '_inputChangeHandler',
            'input.dragstart': '_inputDragstartHandler',
            'input.focus': '_inputFocusHandler',
            'input.keydown': '_inputKeydownHandler',
            'input.down': '_inputDownHandler',
            'input.paste': '_inputPasteHandler',
            'input.select': '_inputSelectHandler',
            'input.up': '_inputUpHandler',
            'input.wheel': '_inputWheelHandler',
            'dropDownContainer.keydown': '_dropDownKeydownHandler',
            'dropDownContainer.transitionend': '_dropDownTransitionendHandler',
            'dropDownHeader.click': '_dropDownHeaderClickHandler',
            'upButton.click': '_spinButtonsClickHandler',
            'document.up': '_documentUpHandler'
        };
    }

    /**
     * DateTimePicker's required files.
     */
    static get requires() {
        return {
            'JQX.Utilities.DateTime': 'jqxdate.js',
            'JQX.Utilities.Draw': 'jqxdraw.js',
            'JQX.Utilities.BigNumber': 'jqxmath.js',
            'JQX.Utilities.NumericProcessor': 'jqxnumeric.js',
            'JQX.RepeatButton': 'jqxbutton.js',
            'JQX.Calendar': 'jqxcalendar.js',
            'JQX.TimePicker': 'jqxtimepicker.js'
        }
    }

    /**
     * CSS files needed for the element (ShadowDOM)
     */
    static get styleUrls() {
        return [
            'jqx.button.css',
            'jqx.timepicker.css',
            'jqx.dropdown.css',
            'jqx.calendar.css',
            'jqx.datetimepicker.css'
        ]
    }

    /**
     * DateTimePicker's HTML template.
     */
    template() {
        return `<div id="container">
                    <span id="label" class="jqx-label">[[label]]</span>
                    <div id="content" class="jqx-content">
                        <input id="input" class="jqx-input jqx-date-time-input" type="text" readonly="[[readonly]]" disabled="[[disabled]]" placeholder="[[placeholder]]" name="[[name]]">
                        <div id="spinButtonsContainer" class="jqx-spin-buttons-container">
                            <jqx-repeat-button initial-delay="[[spinButtonsInitialDelay]]" animation="[[animation]]" delay="[[spinButtonsDelay]]" readonly="[[readonly]]" unfocusable id="upButton" class="jqx-spin-button">
                                <div class="jqx-arrow jqx-arrow-up"></div>
                            </jqx-repeat-button>
                            <jqx-repeat-button initial-delay="[[spinButtonsInitialDelay]]" animation="[[animation]]" delay="[[spinButtonsDelay]]" readonly="[[readonly]]" unfocusable id="downButton" class="jqx-spin-button">
                                <div class="jqx-arrow jqx-arrow-down"></div>
                            </jqx-repeat-button>
                        </div>
                        <div id="calendarButton" class="jqx-drop-down-button jqx-calendar-button"></div>
                        <div id="dropDownContainer" class="jqx-drop-down jqx-date-time-drop-down jqx-visibility-hidden">
                            <div id="dropDownHeader" class="jqx-drop-down-header jqx-hidden">
                                <div id="selectDate" class="jqx-selected"></div>
                                <div id="selectTime"></div>
                            </div>
                            <div id="dropDownContent" class="jqx-drop-down-content">
                                <jqx-calendar id="calendarDropDown" class="jqx-hidden"
                                              animation="[[animation]]"
                                              animation-settings="[[animationSettings]]"
                                              calendar-mode="[[calendarMode]]"
                                              day-name-format="[[dayNameFormat]]"
                                              disable-auto-navigation="[[disableAutoNavigation]]"
                                              display-mode-view="[[displayModeView]]"
                                              first-day-of-week="[[firstDayOfWeek]]"
                                              header-template="[[headerTemplate]]"
                                              hide-day-names="[[hideDayNames]]"
                                              hide-other-month-days="[[hideOtherMonthDays]]"
                                              hide-tooltip-arrow="[[hideTooltipArrow]]"
                                              important-dates="[[importantDates]]"
                                              important-dates-template="[[importantDatesTemplate]]"
                                              locale="[[locale]]"
                                              selection-mode="one"
                                              spin-buttons-delay="[[spinButtonsDelay]]"
                                              spin-buttons-initial-delay="[[spinButtonsInitialDelay]]"
                                              theme="[[theme]]"
                                              tooltip="[[tooltip]]"
                                              tooltip-delay="[[tooltipDelay]]"
                                              tooltip-position="[[tooltipPosition]]"
                                              tooltip-template="[[tooltipTemplate]]"
                                              unfocusable="[[unfocusable]]"
                                              view-sections='["header", "footer"]'
                                              week-numbers="[[weekNumbers]]"
                                              weeks="[[weeks]]"></jqx-calendar>
                            </div>
                        </div>
                    </div>
                    <span id="hint" class="jqx-hint">[[hint]]</span>
                </div>`;
    }

    /**
     * Called when the element is attached to the DOM.
     */
    attached() {
        const that = this;

        super.attached();

        if (!that.isCompleted) {
            return;
        }

        if (that._defaultFooterTemplateApplied) {
            that._addCalendarFooterListeners();
        }

        if (that.$.timePickerDropDown) {
            that._addTimePickerListener();
        }

        that._positionDetection.dropDownAttached();
    }

    /**
     * Called when the element is detached from the DOM.
     */
    detached() {
        const that = this;

        super.detached();

        that.close();

        if (that._defaultFooterTemplateApplied) {
            const footer = that.$.calendarDropDown.$footer;

            footer.unlisten('change');
            footer.unlisten('click');
            footer.unlisten('wheel');
        }

        if (that.$.timePickerDropDown) {
            that.$.timePickerDropDown.$.unlisten('change');
        }

        that._positionDetection.dropDownDetached();
    }

    /**
     * Called when the element is ready. Used for one-time configuration of the DateTimePicker.
     */
    ready() {
        super.ready();

        const that = this;

        that._edgeMacFF = JQX.Utilities.Core.Browser.Edge ||
            JQX.Utilities.Core.Browser.Firefox && navigator.platform.toLowerCase().indexOf('mac') !== -1;
        that._iOS = !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);

        if (that._edgeMacFF) {
            that.$dropDownContainer.addClass('not-in-view');
        }

        that._defaultFooterTemplate = document.createElement('template');

        that._defaultFooterTemplate.innerHTML =
            `<div class="jqx-date-time-picker-footer">
                <div class="jqx-footer-component jqx-footer-component-hour">
                    <input type="text" class="jqx-hour-element" />
                    <span>
                        <jqx-repeat-button initial-delay="0" delay="75">
                            <span class="jqx-arrow jqx-arrow-up"></span>
                        </jqx-repeat-button>
                        <jqx-repeat-button  initial-delay="0" delay="75">
                            <span class="jqx-arrow jqx-arrow-down"></span>
                        </jqx-repeat-button>
                    </span>
                </div>
                <div class="jqx-footer-component jqx-footer-component-minute">
                    <input class="jqx-minute-element" />
                    <span>
                        <jqx-repeat-button initial-delay="0" delay="75">
                            <span class="jqx-arrow jqx-arrow-up"></span>
                        </jqx-repeat-button>
                        <jqx-repeat-button initial-delay="0" delay="75">
                            <span class="jqx-arrow jqx-arrow-down"></span>
                        </jqx-repeat-button>
                    </span>
                </div>
                <div class="jqx-footer-component jqx-footer-component-ampm">
                    <input type="text" class="jqx-am-pm-element" />
                </div>
                <div class="jqx-footer-component jqx-footer-component-today">
                    <div tabindex="-1" class="jqx-today-element" title="Now"></div>
                </div>
            </div>`;

        that._codeToMethod = {
            'y': 'addYears', 'yy': 'addYears', 'yyyy': 'addYears', 'yyyyy': 'addYears',
            'M': 'addMonths', 'MM': 'addMonths', 'MMM': 'addMonths', 'MMMM': 'addMonths',
            'd': 'addDays', 'dd': 'addDays', 'ddd': 'addDays', 'dddd': 'addDays',
            'H': 'addHours', 'HH': 'addHours', 'h': 'addHours', 'hh': 'addHours',
            'm': 'addMinutes', 'mm': 'addMinutes',
            's': 'addSeconds', 'ss': 'addSeconds',
            'f': 'addDeciseconds',
            'ff': 'addCentiseconds',
            'fff': 'addMilliseconds',
            'u': 'addMicroseconds', 'uu': 'addMicroseconds',
            'n': 'addNanoseconds', 'nn': 'addNanoseconds',
            'p': 'addPicoseconds', 'pp': 'addPicoseconds',
            'e': 'addFemtoseconds', 'ee': 'addFemtoseconds',
            'a': 'addAttoseconds', 'aa': 'addAttoseconds',
            'x': 'addZeptoseconds', 'xx': 'addZeptoseconds',
            'o': 'addYoctoseconds', 'oo': 'addYoctoseconds'
        };

        that._codeToIndex = {
            'y': 0, 'yy': 0, 'yyyy': 0, 'yyyyy': 0, 'M': 1, 'MM': 1, 'MMM': 1, 'MMMM': 1, 'd': 2, 'dd': 2, 'ddd': 2, 'dddd': 2,
            'H': 3, 'HH': 3, 'h': 3, 'hh': 3, 'm': 4, 'mm': 4, 's': 5, 'ss': 5, 'f': 6, 'ff': 6, 'fff': 6,
            'u': 7, 'uu': 7, 'n': 8, 'nn': 8, 'p': 9, 'pp': 9, 'e': 10, 'ee': 10,
            'a': 11, 'aa': 11, 'x': 12, 'xx': 12, 'o': 13, 'oo': 13
        };

        that._getLocalizedNames();

        that._validateInitialPropertyValues();

        that._setFocusable();

        that._positionDetection = new JQX.Utilities.PositionDetection(that, that.$.dropDownContainer, that.$.content, 'close');
        that._positionDetection.customPositionDropDown = that._positionExternalDropDown;
        that._positionDetection.getDropDownParent(true);
        that._positionDetection.setDropDownPosition();
        that._positionDetection.handleAutoPositioning();

        that.$.dropDownContainer.setAttribute('animation', that.animation);
        that.$.dropDownContainer.setAttribute('drop-down-display-mode', that.dropDownDisplayMode);
    }

    /**
     * Closes the calendar dropdown.
     */
    close() {
        const that = this;

        if (!that.opened) {
            return;
        }

        that._close();
    }

    /**
     * Focuses the input.
     */
    focus() {
        this.$.input.focus();
    }

    select() {
        this.$.input.select();
    }

    /**
     * Opens the calendar dropdown.
     */
    open() {
        const that = this;

        if (that.opened) {
            return;
        }

        that._open();
    }

    /**
     * Called when a property is changed.
     */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this;

        switch (propertyName) {
            case 'animation':
            case 'theme':
                if (that.$.timePickerDropDown) {
                    that.$.timePickerDropDown[propertyName] = newValue;
                }

                if (propertyName === 'animation') {
                    that.$.dropDownContainer.setAttribute('animation', that.animation);

                    if (that._defaultFooterTemplateApplied) {
                        Array.from(that.$.calendarDropDown.$.footer.getElementsByTagName('jqx-repeat-button')).forEach(function (button) {
                            button.animation = newValue;
                        });
                    }
                }

                break;
            case 'calendarButton':
                that.$.dropDownContainer.style.transition = 'none';

                if (!newValue) {
                    that.close();
                }
                break;
            case 'calendarButtonPosition':
                that.$.dropDownContainer.style.transition = 'none';
                that.close();

                if (newValue === 'left') {
                    that.$.content.insertBefore(that.$.calendarButton, that.$.content.firstElementChild);
                }
                else if (that._dropDownParent === null) {
                    that.$.content.insertBefore(that.$.calendarButton, that.$.dropDownContainer);
                }
                else {
                    that.$.content.appendChild(that.$.calendarButton);
                }

                break;
            case 'disabled':
                if (newValue) {
                    that.close();
                    that.$.upButton.disabled = true;
                    that.$.downButton.disabled = true;
                }
                else {
                    that._disableSpinButtons();
                }

                that._setFocusable();
                that._positionDetection.handleAutoPositioning();
                break;
            case 'displayKind': {
                const oldOutputTimeZone = that._outputTimeZone;

                switch (newValue) {
                    case 'unspecified':
                        that._outputTimeZone = that._inputTimeZone;
                        break;
                    case 'UTC':
                        that._outputTimeZone = 'UTC';
                        break;
                    case 'local':
                        that._outputTimeZone = 'Local';
                        break;
                }

                if (that._outputTimeZone === oldOutputTimeZone) {
                    return;
                }

                if (that._value !== null) {
                    that.close();
                    that._toSync = true;

                    that._value = that._value.toTimeZone(that._outputTimeZone);
                    that._applyFormatString();
                }

                that.min = that.min.toTimeZone(that._outputTimeZone);
                that.max = that.max.toTimeZone(that._outputTimeZone);

                for (let i = 0; i < that.restrictedDates.length; i++) {
                    let currentRestrictedDate = that.restrictedDates[i];

                    currentRestrictedDate = currentRestrictedDate.toTimeZone(that._outputTimeZone);
                }

                break;
            }
            case 'dropDownAppendTo':
                that._positionDetection.dropDownAppendToChangedHandler();
                break;
            case 'dropDownDisplayMode':
                that._changeDropDownDisplayMode();
                break;
            case 'dropDownOverlay':
                if (!newValue) {
                    that._positionDetection.removeOverlay();
                }

                break;
            case 'dropDownPosition':
                that._positionDetection.dropDownPositionChangedHandler();
                break;
            case 'footerTemplate':
                if (newValue !== null) {
                    that._defaultFooterTemplateApplied = false;

                    const footer = that.$.calendarDropDown.$footer;

                    footer.unlisten('change');
                    footer.unlisten('click');
                    footer.unlisten('wheel');

                    that.$.calendarDropDown.footerTemplate = newValue;
                }
                else {
                    that._setDefaultFooterTemplate();

                    const value = that._value;

                    that._hourElement.value = value.toString('hh');
                    that._minuteElement.value = value.toString('mm');
                    that._ampmElement.value = value.toString('tt');
                }

                break;
            case 'formatString':
                if (newValue === '') {
                    that.formatString = 'dd-MMM-yy HH:mm:ss.fff';
                }

                that._getFormatStringRegExp();
                that._applyFormatString();

                if (that.dropDownDisplayMode === 'auto') {
                    that._changeDropDownDisplayMode();
                }

                break;
            case 'interval':
                that._validateInterval(oldValue);
                break;
            case 'locale':
            case 'messages':
                that.$.selectDate.innerHTML = that.localize('dateTabLabel');
                that.$.selectTime.innerHTML = that.localize('timeTabLabel');

                if (that._defaultFooterTemplateApplied) {
                    that._todayElement.title = that.localize('now');
                }

                if (propertyName === 'messages') {
                    return;
                }

                that._getLocalizedNames();
                that.min.calendar.days = that._localizedDays;
                that.min.calendar.months = that._localizedMonths;
                that.min.calendar.locale = that.locale;
                that.max.calendar.days = that._localizedDays;
                that.max.calendar.months = that._localizedMonths;
                that.max.calendar.locale = that.locale;

                if (that.value !== null) {
                    that._value.calendar.days = that._localizedDays;
                    that._value.calendar.months = that._localizedMonths;
                    that._value.calendar.locale = that.locale;
                    that.value.calendar.days = that._localizedDays;
                    that.value.calendar.months = that._localizedMonths;
                    that.value.calendar.locale = that.locale;
                }

                JQX.Utilities.DateTime.cache = [];
                that._applyFormatString();
                break;
            case 'max':
            case 'min':
                that._validateMinMax(propertyName, oldValue);

                if (that.validation === 'strict') {
                    that._validateValue();
                }
                else {
                    that._minMaxChanged = true;
                }

                break;
            case 'nullable':
                if (oldValue === true && that._value === null) {
                    that._validateValue(that._now(), null);
                }

                break;
            case 'opened':
                if (newValue) {
                    that._open();
                }
                else {
                    that._close();
                }

                break;
            case 'readonly':
            case 'unfocusable':
                if (newValue) {
                    that.close();
                }

                if (propertyName === 'unfocusable') {
                    that._setFocusable();
                }

                break;
            case 'restrictedDates':
                that._validateRestrictedDates();
                that._validateValue();
                break;
            case 'spinButtonsPosition':
                if (newValue === 'right') {
                    that.$.content.insertBefore(that.$.spinButtonsContainer, that.$.input.nextElementSibling);
                }
                else {
                    that.$.content.insertBefore(that.$.spinButtonsContainer, that.$.input);
                }
                break;
            case 'validation':
                if (newValue === 'strict') {
                    delete that._minMaxChanged;
                    that._validateValue();
                }

                break;
            case 'value': {
                let parsedValue;

                if (newValue !== null) {
                    parsedValue = JQX.Utilities.DateTime.validateDate(newValue, that._now(), that.formatString);
                    parsedValue = parsedValue.toTimeZone(that._outputTimeZone);
                }
                else {
                    parsedValue = null;
                }

                that._validateValue(parsedValue, that._value, undefined, true);
                break;
            }
        }
    }

    /**
     * Adds calendar footer listeners.
     */
    _addCalendarFooterListeners() {
        const that = this,
            footer = that.$.calendarDropDown.$footer;

        footer.listen('change', that._footerChangeHandler.bind(that));
        footer.listen('click', that._footerClickHandler.bind(that));
        footer.listen('wheel', that._footerWheelHandler.bind(that));
    }

    /**
     * Adds time picker change event listener.
     */
    _addTimePickerListener() {
        const that = this;

        that.$.timePickerDropDown.$.listen('change', function (event) {
            const oldContext = that.context,
                newTimePickerValue = event.detail.value,
                updatedValueConstructorParameters = JQX.Utilities.DateTime.getConstructorParameters(that._value !== null ? that._value : that._now());

            that.context = that;
            updatedValueConstructorParameters[3] = newTimePickerValue.getHours();
            updatedValueConstructorParameters[4] = newTimePickerValue.getMinutes();
            that._timePickerInitiatedChange = true;
            updatedValueConstructorParameters.unshift(null);
            that._validateValue(new (Function.prototype.bind.apply(JQX.Utilities.DateTime, updatedValueConstructorParameters)));
            that._timePickerInitiatedChange = false;
            that.context = oldContext;
        });
    }

    /**
     * Applies format string.
     */
    _applyFormatString() {
        const that = this;

        if (that.value !== null) {
            that.$.input.value = that._value.toString(that.formatString);
        }
    }

    _calendarButtonMouseEnterHandler() {
        const that = this;

        that.$.calendarButton.setAttribute('hover', '');
    }

    _calendarButtonMouseLeaveHandler() {
        const that = this;

        that.$.calendarButton.removeAttribute('hover');
    }

    /**
     * Calendar button click handler.
     */
    _calendarButtonClickHandler(event) {
        const that = this;

        that._highlightedTimePart = undefined;

        if (that.disabled || that.readonly) {
            return;
        }

        if (that.hasRippleAnimation) {
            JQX.Utilities.Animation.Ripple.animate(that.$.calendarButton, event.pageX, event.pageY);
        }

        if (that.opened) {
            that._close();
        }
        else {
            that._open();
        }
    }

    /**
     * Calendar dropdown change handler.
     */
    _calendarDropDownChangeHandler(event) {
        const that = this;

        event.stopPropagation();

        if (that._disregardCalendarChangeEvent) {
            that._disregardCalendarChangeEvent = false;
            return;
        }

        if (this.$.calendarDropDown.selectedDates.length > 0) {
            const newCalendarValue = event.detail.value[0],
                oldValue = that._value !== null ? that._value : that._now(),
                updatedValueConstructorParameters = JQX.Utilities.DateTime.getConstructorParameters(oldValue);

            updatedValueConstructorParameters[0] = newCalendarValue.getFullYear();
            updatedValueConstructorParameters[1] = newCalendarValue.getMonth() + 1;
            updatedValueConstructorParameters[2] = newCalendarValue.getDate();
            that._calendarInitiatedChange = true;

            updatedValueConstructorParameters.unshift(null);
            that._validateValue(new (Function.prototype.bind.apply(JQX.Utilities.DateTime, updatedValueConstructorParameters)));

            if (that._defaultFooterTemplateApplied) {
                const value = that._value;

                if (that._hourElement.value === '') {
                    that._hourElement.value = value.toString('hh');
                }

                if (that._ampmElement.value === '') {
                    that._ampmElement.value = value.toString('tt');
                }

                if (that._minuteElement.value === '') {
                    that._minuteElement.value = value.toString('mm');
                }
            }

            that._calendarInitiatedChange = false;
        }
        else {
            that._setNullValue();
        }
    }

    /**
     * Calendar dropdown click handler.
     */
    _calendarDropDownClickHandler(event) {
        const that = this;

        if (that.autoClose && event.target.closest('.jqx-calendar-cell')) {
            clearTimeout(that._autoCloseTimeout);
            that._autoCloseTimeout = setTimeout(function () {
                that.close();
            }, that.autoCloseDelay);
        }
    }

    /**
     * Changes dropdown display mode.
     */
    _changeDropDownDisplayMode() {
        function toggleVisibility(dropDownHeader, calendarDropDown, timePickerDropDown, sync) {
            that.$dropDownHeader[dropDownHeader]('jqx-hidden');
            that.$calendarDropDown[calendarDropDown]('jqx-hidden');

            if (that._timePickerInitialized) {
                that.$.timePickerDropDown.$[timePickerDropDown]('jqx-hidden');
            }

            if (sync) {
                if (that.opened) {
                    that.$.calendarDropDown._refreshTitle();
                }
                else {
                    that._toSync = true;
                }
            }
        }

        const that = this,
            oldDropDownDisplayMode = that._dropDownDisplayMode;

        that._detectDisplayMode();

        if (that._dropDownDisplayMode === oldDropDownDisplayMode) {
            return;
        }

        if (that._dropDownDisplayMode === 'default') {
            that.$.calendarDropDown.viewSections = ['title', 'header'];
            that.$selectDate.addClass('jqx-selected');
            that.$selectTime.removeClass('jqx-selected');
            toggleVisibility('removeClass', 'removeClass', 'addClass', true);
        }
        else if (that._dropDownDisplayMode === 'classic') {
            that.$.calendarDropDown.viewSections = ['header', 'footer'];
            toggleVisibility('addClass', 'removeClass', 'addClass');
        }
        else if (that._dropDownDisplayMode === 'calendar') {
            that.$.calendarDropDown.viewSections = ['title', 'header'];
            toggleVisibility('addClass', 'removeClass', 'addClass', true);
        }
        else {
            toggleVisibility('addClass', 'addClass', 'removeClass');

            if (!that._timePickerInitialized) {
                that._initializeTimePicker();
            }
        }

        that.$.dropDownContainer.setAttribute('drop-down-display-mode', that.dropDownDisplayMode);
    }

    /**
     * Clones the value object.
     */
    _cloneValue() {
        const that = this;

        if (that._value !== null) {
            return that._value.clone();
        }
        else {
            return null;
        }
    }

    /**
     * Closes the calendar dropdown.
     */
    _close() {
        const that = this,
            closingEvent = that.$.fireEvent('closing');

        if (!closingEvent.defaultPrevented) {
            that.$.calendarDropDown.disabled = true;

            that.$calendarButton.removeClass('jqx-calendar-button-pressed');
            that.$.calendarButton.removeAttribute('active');
            that.$dropDownContainer.addClass('jqx-visibility-hidden');
            that.opened = false;
            that._positionDetection.removeOverlay(true);

            that.$.fireEvent('close');

            if (that._edgeMacFF && !that.hasAnimation) {
                that.$.dropDownContainer.style.top = null;
                that.$.dropDownContainer.style.left = null;
                that.$dropDownContainer.addClass('not-in-view');
            }
        }
        else {
            that.opened = true;
        }
    }

    /**
     * Detects dropdown display mode.
     */
    _detectDisplayMode() {
        const that = this;

        if (that.dropDownDisplayMode !== 'auto') {
            that._dropDownDisplayMode = that.dropDownDisplayMode;
        }
        else {
            that._dropDownDisplayMode = JQX.Utilities.DateTime.detectDisplayMode(that.value || that.min, that.formatString, that._formatStringRegExp);
        }

        if (that._dropDownDisplayMode === 'timePicker') {
            that.$calendarButton.addClass('time');

            if (that.placeholder === 'Enter date') {
                that.placeholder = 'Enter time';
            }
        }
        else {
            that.$calendarButton.removeClass('time');

            if (that.placeholder === 'Enter time') {
                that.placeholder = 'Enter date';
            }
        }

        if (that._dropDownDisplayMode === 'default') {
            that.$dropDownContent.removeClass('partial');
        }
        else {
            that.$dropDownContent.addClass('partial');
        }
    }

    /**
     * Disables or enables spin buttons.
     */
    _disableSpinButtons() {
        const that = this;

        if (that.disabled) {
            return;
        }

        const disabled = that._value === null;

        that.$.upButton.disabled = disabled;
        that.$.downButton.disabled = disabled;
    }

    /**
     * Document up handler.
     */
    _documentUpHandler(event) {
        const that = this,
            activeElement = that.enableShadowDOM ? (that.shadowRoot.activeElement || document.activeElement) : document.activeElement,
            target = that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target;

        if (!JQX.Utilities.Core.isMobile &&
            activeElement === that.$.input &&
            that.editMode === 'partial' &&
            that._value !== null &&
            (target !== that.$.input || that.$.input.selectionStart === that.$.input.selectionEnd)) {
            that._highlightedTimePartEdit = false;
            that._validateValue(that.$.input.value, that._cloneValue(), false);
            that._highlightTimePartBasedOnCursor();
        }
        else {
            if (target !== that.$.calendarButton && (!that.$.dropDownContainer.contains(target) && !that.$.dropDownContainer.contains(that._getRootShadowHost(target)))) {
                that.close();

                if (activeElement !== that.$.input && !that.contains(target)) {
                    that._highlightedTimePart = undefined;
                }
            }
        }

        that._mouseFocus = false;
    }

    /**
     * Returns the root node of an element inside the shadowDOM of a child element
     * @param {any} target
     */
    _getRootShadowHost(target) {
        const that = this;

        if (!that.enableShadowDOM) {
            return;
        }

        let host = target.getRootNode().host,
            rootHost;

        while (host && host !== that && host !== document) {
            rootHost = host;
            host = host.getRootNode().host;
        }

        return rootHost;
    }

    /**
     * Dropdown header click handler
     */
    _dropDownHeaderClickHandler(event) {
        const that = this;

        if (event.target === that.$.selectDate) {
            if (that.$selectDate.hasClass('jqx-selected')) {
                return;
            }

            that.$selectDate.addClass('jqx-selected');
            that.$selectTime.removeClass('jqx-selected');
            that.$.timePickerDropDown.$.addClass('jqx-hidden');
            that.$calendarDropDown.removeClass('jqx-hidden');
        }
        else {
            if (that.$selectTime.hasClass('jqx-selected')) {
                return;
            }

            that.$selectDate.removeClass('jqx-selected');
            that.$selectTime.addClass('jqx-selected');
            that.$calendarDropDown.addClass('jqx-hidden');

            if (that._timePickerInitialized) {
                that.$.timePickerDropDown.$.removeClass('jqx-hidden');
            }
            else {
                that._initializeTimePicker();
            }
        }
    }

    /**
     * Dropdown keydown handler.
     */
    _dropDownKeydownHandler(event) {
        const that = this,
            key = event.key,
            activeElement = that.enableShadowDOM ? that.shadowRoot.activeElement : document.activeElement;

        if (that.$.dropDownHeader.contains(activeElement) && (key === 'Enter' || key === ' ')) {
            event.preventDefault();
            that._dropDownHeaderClickHandler({ target: activeElement });
        }
        else if (key === 'Escape' || event.altKey && key === 'ArrowUp') {
            event.preventDefault();
            that.close();
            that.$.input.focus();
        }
        else if ((key === 'Enter' || key === ' ') && activeElement.classList.contains('jqx-footer-component-today')) {
            event.preventDefault();
            that._validateValue(that._now());
            that.close();
        }
        else if (key === 'Enter' &&
            (activeElement === that.$.calendarDropDown.$.body && that.$.calendarDropDown.querySelectorAll('.jqx-calendar-cell[selected][focus]').length > 0 ||
                that._timePickerInitialized && activeElement === that.$.timePickerDropDown.$.picker)) {
            event.preventDefault();
            that.close();
        }
    }

    /**
     * Dropdown transitionend handler.
     */
    _dropDownTransitionendHandler() {
        const that = this;

        if (!that.hasAnimation) {
            return;
        }

        if (that.opened && that._toFocus) {
            that._toFocus.focus();
            delete that._toFocus;

            if (that._timePickerInitialized &&
                !that.$.timePickerDropDown.classList.contains('jqx-hidden')) {
                requestAnimationFrame(() => that.$.timePickerDropDown._highlightLabel());
            }

            return;
        }

        if (that._edgeMacFF && !that.opened) {
            that.$.dropDownContainer.style.top = null;
            that.$.dropDownContainer.style.left = null;
            that.$dropDownContainer.addClass('not-in-view');
            return;
        }
    }

    /**
     * Footer change handler.
     */
    _footerChangeHandler(event) {
        const that = this,
            oldContext = that.context,
            target = event.target,
            dateTimePickerValue = that._value !== null ? that._value : that._now();
        let value = target.value,
            timePartCode;

        that.context = that;

        event.stopPropagation();

        if (target.classList.contains('jqx-hour-element')) {
            value = parseInt(value, 10);

            if (isNaN(value) || value < 0 || value > 12) {
                target.value = dateTimePickerValue.toString('hh');
                return;
            }

            if (value > 0 && value < 12 && dateTimePickerValue.toString('tt') === 'PM') {
                value += 12;
            }

            timePartCode = 'hh';
        }
        else if (target.classList.contains('jqx-minute-element')) {
            value = parseInt(value, 10);

            if (isNaN(value) || value < 0 || value > 59) {
                target.value = dateTimePickerValue.toString('mm');
                return;
            }

            timePartCode = 'mm';
        }
        else {
            if (that._value === null) {
                target.value = '';
                return;
            }

            const oldValue = dateTimePickerValue.toString('tt');

            value = value.toLowerCase();

            if ((oldValue === 'PM' && (value === 'a' || value === 'am')) ||
                (oldValue === 'AM' && (value === 'p' || value === 'pm'))) {
                that._incrementDecrement(undefined, 'tt');
                target.value = that._value.toString('tt');
            }
            else {
                target.value = oldValue;
            }

            return;
        }

        const newValueConstructorParameters = JQX.Utilities.DateTime.getConstructorParameters(dateTimePickerValue);

        newValueConstructorParameters[that._codeToIndex[timePartCode]] = value;
        newValueConstructorParameters.unshift(null);

        that._validateValue(new (Function.prototype.bind.apply(JQX.Utilities.DateTime, newValueConstructorParameters)));

        target.value = that._value.toString(timePartCode);

        that.context = oldContext;
    }

    /**
     * Footer click handler.
     */
    _footerClickHandler(event) {
        const that = this,
            oldContext = that.context,
            target = event.target;

        that.context = that;

        if (target.classList.contains('jqx-today-element')) {
            // "Now" icon is clicked
            that._validateValue(that._now());

            if (that.autoClose) {
                clearTimeout(that._autoCloseTimeout);
                that._autoCloseTimeout = setTimeout(function () {
                    that.close();
                }, that.autoCloseDelay);
            }
        }
        else {
            const closestRepeatButton = target.closest('jqx-repeat-button');

            if (closestRepeatButton !== null) {
                const decrement = closestRepeatButton === closestRepeatButton.parentElement.children[1],
                    timePartCode = closestRepeatButton.closest('.jqx-footer-component').classList.contains('jqx-footer-component-hour') ?
                        'hh' : 'mm';

                that._incrementDecrement(decrement, timePartCode);
            }
        }

        that.context = oldContext;
    }

    /**
     * Footer wheel handler.
     */
    _footerWheelHandler(event) {
        const that = this,
            activeElement = that.enableShadowDOM ? that.shadowRoot.activeElement : document.activeElement;

        if (that.enableMouseWheelAction && event.target instanceof HTMLInputElement && activeElement === event.target) {
            const oldContext = that.context,
                target = event.target;

            that.context = that;

            if (target.classList.contains('jqx-hour-element')) {
                that._incrementDecrement(event.deltaY > 0, 'hh');
            }
            else if (target.classList.contains('jqx-minute-element')) {
                that._incrementDecrement(event.deltaY > 0, 'mm');
            }
            else {
                that._incrementDecrement(undefined, 'tt');
            }

            that.context = oldContext;

            event.stopPropagation();
        }
    }

    /**
     * Gets and highlights a time part.
     */
    _getAndHighlightTimePart(matchIndex, regExpIndex, index) {
        const that = this;

        that._programmaticSelection = true;

        if (that.$.input.selectionStart !== matchIndex || that.$.input.selectionEnd !== regExpIndex) {
            that.$.input.setSelectionRange(matchIndex, regExpIndex);
        }
        else {
            setTimeout(function () {
                that.$.input.setSelectionRange(matchIndex, regExpIndex);
            }, 200);
        }

        that._highlightedTimePart = {
            code: that._formatStringRegExp.groups[index],
            index: index,
            from: matchIndex,
            to: regExpIndex
        };
    }

    /**
     * Gets format string regular expression.
     */
    _getFormatStringRegExp() {
        const that = this;

        that._formatStringRegExp = that.min.getParseRegExp(that.min.calendar, that.formatString.replace(/y+/g, 'yyyyy'));
        that._formatStringRegExp.regExp = new RegExp(that._formatStringRegExp.regExp);
    }

    /**
     * Gets and stores month and day names based on locale.
     */
    _getLocalizedNames() {
        const that = this,
            localizedNames = JQX.Utilities.DateTime.getLocalizedNames(that.locale);

        that._localizedDays = localizedNames.days;
        that._localizedMonths = localizedNames.months;

        that.$.selectDate.innerHTML = that.localize('dateTabLabel');
        that.$.selectTime.innerHTML = that.localize('timeTabLabel');
    }

    /**
     * Handles manual time part edit.
     */
    _handleManualTimePartEdit(newTimePartValue) {
        const that = this,
            newValueConstructorParameters = JQX.Utilities.DateTime.getConstructorParameters(that._value);

        newTimePartValue = newTimePartValue[that._highlightedTimePart.index + 1];

        if (!isNaN(newTimePartValue)) {
            if (that._highlightedTimePart.code === 'f') {
                newTimePartValue = parseInt(newTimePartValue, 10) * 100;
            }
            else if (that._highlightedTimePart.code === 'ff') {
                newTimePartValue = parseInt(newTimePartValue, 10) * 10;
            }
            else if (that._highlightedTimePart.code.indexOf('y') !== -1 && newTimePartValue.length < 3) {
                const yearCutoff = that.yearCutoff.toString(),
                    threshold = parseInt(yearCutoff.slice(2), 10);
                let decade = parseInt(yearCutoff.slice(0, 2), 10);

                newTimePartValue = parseInt(newTimePartValue, 10);

                if (newTimePartValue < threshold) {
                    decade++;
                }

                newTimePartValue = newTimePartValue.toString();
                newTimePartValue = decade + '' + '0'.repeat(2 - newTimePartValue.length) + newTimePartValue;
            }
            else if (that._highlightedTimePart.code.indexOf('h') !== -1) {
                const previousHours = that._value.hour();

                newTimePartValue = parseInt(newTimePartValue, 10);

                if (previousHours > 11 && newTimePartValue <= 11) {
                    newTimePartValue += 12;
                }
            }

            newValueConstructorParameters[that._codeToIndex[that._highlightedTimePart.code]] = parseInt(newTimePartValue, 10);
        }
        else if (that._codeToIndex[that._highlightedTimePart.code] === 1) {
            // month name has been entered
            let index = -1;

            if (newTimePartValue.length > 1) {
                that._localizedMonths.names.some(function (element, i) {
                    if (element.toLowerCase().indexOf(newTimePartValue.toLowerCase()) !== -1) {
                        index = i;
                        return true;
                    }
                });
            }

            if (index !== -1) {
                newValueConstructorParameters[1] = index + 1;
            }
            else {
                that._applyFormatString();
                return;
            }
        }

        try {
            newValueConstructorParameters.unshift(null);
            that._validateValue(new (Function.prototype.bind.apply(JQX.Utilities.DateTime, newValueConstructorParameters)));
        }
        catch (error) {
            that._applyFormatString();
        }
    }

    /**
     * Highlights a time part based on the cursor's position in the input.
     */
    _highlightTimePartBasedOnCursor(caretPosition) {
        const that = this,
            inputValue = that.$.input.value,
            matches = that._formatStringRegExp.regExp.exec(inputValue);

        function getCaretPosition() {
            if (caretPosition === undefined) {
                return that.$.input.selectionStart;
            }

            return caretPosition;
        }

        if (matches === null) {
            that._highlightedTimePart = undefined;
            return;
        }

        if (!that._iOS && caretPosition === undefined) {
            caretPosition = that.$.input.selectionStart;
        }

        let regExpIndex = matches.index,
            matchIndex;

        for (let i = 1; i < matches.length; i++) {
            const match = matches[i];

            matchIndex = inputValue.indexOf(match, regExpIndex);
            regExpIndex = matchIndex + match.length;

            if (i === 1 && getCaretPosition() < matchIndex) {
                that._getAndHighlightTimePart(matchIndex, regExpIndex, 0);
                break;
            }

            if (getCaretPosition() >= matchIndex && getCaretPosition() <= regExpIndex) {
                that._getAndHighlightTimePart(matchIndex, regExpIndex, i - 1);
                break;
            }

            const nextMatch = matches[i + 1];

            if (nextMatch) {
                const indexOfNextMatch = inputValue.indexOf(nextMatch, regExpIndex);

                if (getCaretPosition() > regExpIndex && getCaretPosition() < indexOfNextMatch) {
                    if (getCaretPosition() - regExpIndex <= indexOfNextMatch - getCaretPosition()) {
                        that._getAndHighlightTimePart(matchIndex, regExpIndex, i - 1);
                    }
                    else {
                        that._formatStringRegExp.groups[i];
                        that._programmaticSelection = true;
                        that.$.input.setSelectionRange(indexOfNextMatch, indexOfNextMatch + nextMatch.length);
                    }
                    break;
                }
            }
            else {
                that._programmaticSelection = true;
                that.$.input.setSelectionRange(matchIndex, regExpIndex);
                that._highlightedTimePart = {
                    code: that._formatStringRegExp.groups[i - 1],
                    index: i - 1,
                    from: matchIndex,
                    to: regExpIndex
                };
                break;
            }
        }
    }

    /**
     * Highlights a time part based on its index in the format string.
     */
    _highlightTimePartBasedOnIndex(index) {
        const that = this,
            inputValue = that.$.input.value,
            matches = that._formatStringRegExp.regExp.exec(inputValue);

        if (matches === null) {
            that._validateValue(undefined, that._cloneValue(), false);
            that._highlightTimePartBasedOnIndex(index);
            return;
        }

        let regExpIndex = matches.index,
            matchIndex;
        const activeElement = that.enableShadowDOM ? that.shadowRoot.activeElement : document.activeElement;

        if (index < 0 || index >= matches.length) {
            return;
        }

        if (that.$.input !== activeElement) {
            that.$.input.focus();
        }

        for (let i = 1; i < matches.length; i++) {
            const match = matches[i];

            matchIndex = inputValue.indexOf(match, regExpIndex);
            regExpIndex = matchIndex + match.length;

            if (index === i - 1) {
                that._getAndHighlightTimePart(matchIndex, regExpIndex, index);
                break;
            }
        }
    }

    /**
     * Increments or decrements the value.
     */
    _incrementDecrement(decrement, timePartCode) {
        const that = this,
            oldValue = that._cloneValue();

        if (that._minMaxChanged) {
            that._value = that._rangeValidation(that._value);
            delete that._minMaxChanged;
        }

        if (timePartCode === undefined && that._highlightedTimePart) {
            timePartCode = that._highlightedTimePart.code;
        }

        if (timePartCode !== undefined) {
            if (timePartCode === 'z' || timePartCode === 'zz' || timePartCode === 'zzz') {
                that._highlightTimePartBasedOnIndex(that._highlightedTimePart.index);
                return;
            }

            if (timePartCode === 't' || timePartCode === 'tt') {
                that._value = that._value.addHours(that._value.hour() < 12 ? 12 : -12, true);
            }
            else {
                that._value = that._value[that._codeToMethod[timePartCode]](decrement ? -1 : 1, true);
            }

            that._validateValue(undefined, oldValue, false);

            if (that._highlightedTimePart) {
                that._highlightTimePartBasedOnIndex(that._highlightedTimePart.index);
            }
        }
        else {
            that._value = that._value.add(decrement ? that.interval.negate() : that.interval, undefined, true);
            that._validateValue(undefined, oldValue, false);
        }

        if (oldValue.compare(that._value) !== 0) {
            that.$.fireEvent('change', { 'oldValue': oldValue.toTimeZone(that._inputTimeZone), 'value': that.value });
        }
    }

    /**
     * Initializes TimePicker instance.
     */
    _initializeTimePicker() {
        const that = this;

        const timePickerDropDown = document.createElement('jqx-time-picker');

        timePickerDropDown.animation = that.animation;
        timePickerDropDown.theme = that.theme;
        timePickerDropDown.value = that._value !== null ? that._value.toDate() : that._now();
        that.$.timePickerDropDown = timePickerDropDown;
        timePickerDropDown.$ = JQX.Utilities.Extend(timePickerDropDown);
        that.$.dropDownContent.appendChild(timePickerDropDown);
        that._timePickerInitialized = true;

        that._addTimePickerListener();
    }

    /**
     * Input blur handler.
     */
    _inputBlurHandler() {
        const that = this;

        that.removeAttribute('focus');
        that._fullEdit = false;
        that._highlightedTimePartEdit = false;
    }

    /**
     * Input change handler.
     */
    _inputChangeHandler(event) {
        const that = this;

        if (event) {
            event.stopPropagation();
        }

        if (that.$.input.value === '') {
            that._setNullValue();
            return;
        }

        if (that._fullEdit || that._value === null) {
            that._fullEdit = false;
            that._validateValue(that.$.input.value);
            that._highlightTimePartBasedOnCursor();
        }
        else if (that._highlightedTimePartEdit) {
            that._highlightedTimePartEdit = false;

            let newTimePartValue = that._formatStringRegExp.regExp.exec(that.$.input.value);

            if (newTimePartValue !== null) {
                that._handleManualTimePartEdit(newTimePartValue);
            }
            else {
                that._applyFormatString();
            }
        }
    }

    /**
     * Input dragstart handler.
     */
    _inputDragstartHandler(event) {
        event.preventDefault();
    }

    /**
     * Input focus handler.
     */
    _inputFocusHandler() {
        const that = this;

        that.setAttribute('focus', '');

        if (that.editMode !== 'full') {
            const timeout = JQX.Utilities.Core.isMobile ? 10 : 0;

            // Timeout is necessary due to an issue in Chrome (https://bugs.chromium.org/p/chromium/issues/detail?id=526516)
            setTimeout(function () {
                if (that._iOS) {
                    that._highlightTimePartBasedOnCursor();
                }
                else if (that._mouseFocus !== true) {
                    if (that._highlightedTimePart === undefined) {
                        that._highlightTimePartBasedOnCursor(that._iOS ? undefined : 0);
                    }
                    else {
                        that._highlightTimePartBasedOnIndex(that._highlightedTimePart.index);
                    }
                }
            }, timeout);
        }
    }

    /**
     * Input keydown handler.
     */
    _inputKeydownHandler(event) {
        const that = this,
            editMode = that.editMode,
            key = event.key;

        if (key === 'Tab') {
            return;
        }

        if (event.altKey && key === 'ArrowDown') {
            event.preventDefault();
            that.open();
            return;
        }

        if (key === 'Escape' || event.altKey && key === 'ArrowUp') {
            event.preventDefault();
            that.close();
            return;
        }

        if (editMode === 'full') {
            that._fullEdit = true;
            return;
        }
        else if (editMode === 'partial') {
            if (key === 'Delete') {
                if (that._value !== null) {
                    that._setNullValue();
                    event.preventDefault();
                }

                return;
            }

            if (that._value === null) {
                that._validateValue(that._now(), null, false);
                that._highlightTimePartBasedOnIndex(0);
            }

            if (['/', '.', '-', ',', ' '].indexOf(key) !== -1) {
                that._inputChangeHandler();
                that._navigateToNextTimePart();
                event.preventDefault();
                return;
            }
            else if (key === 'Backspace') {
                that._resetTimePart();

                if (that._highlightedTimePart.index > 0) {
                    that._navigateToPreviousTimePart();
                }
                else {
                    that._highlightTimePartBasedOnIndex(0);
                }

                event.preventDefault();
                return;
            }
        }
        else if (that._fullEdit || that._highlightedTimePartEdit || that.readonly ||
            ['Alt', 'Control', 'Shift'].indexOf(key) !== -1 ||
            event.altKey || event.ctrlKey) {
            return;
        }

        if (['End', 'Home', 'ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown'].indexOf(key) === -1) {
            if (that._highlightedTimePart) {
                if (editMode !== 'partial' &&
                    (that._highlightedTimePart.to - that._highlightedTimePart.from !==
                        that.$.input.selectionEnd - that.$.input.selectionStart)) {

                    that._fullEdit = true;
                    return;
                }

                const code = that._highlightedTimePart.code;

                if (code === 'ddd' || code === 'dddd' ||
                    code === 'z' || code === 'zz' || code === 'zzz' ||
                    code === 't' || code === 'tt') {
                    // weekday name, time zone offset and a.m./p.m. cannot be edited
                    event.preventDefault();
                    return;
                }
                else if (editMode === 'partial' &&
                    code !== 'MMM' && code !== 'MMMM' &&
                    new RegExp(/^\d+$/).test(key) === false) {
                    if (key.length < 2 || key.charAt(0) !== 'F') {
                        event.preventDefault();
                    }

                    return;
                }

                that._highlightedTimePartEdit = true;
            }

            return;
        }

        event.preventDefault();

        if (editMode === 'partial' && that._highlightedTimePartEdit) {
            that._inputChangeHandler();
        }

        if (that._value === null) {
            return;
        }

        switch (key) {
            case 'End':
                that._highlightTimePartBasedOnIndex(that._formatStringRegExp.groups.length - 1);
                break;
            case 'Home':
                that._highlightTimePartBasedOnIndex(0);
                break;
            case 'ArrowLeft':
                that._navigateToPreviousTimePart();
                break;
            case 'ArrowUp':
                that._incrementDecrement();
                break;
            case 'ArrowRight':
                that._navigateToNextTimePart();
                break;
            case 'ArrowDown':
                that._incrementDecrement(true);
                break;
        }
    }

    /**
     * Input mousedown handler.
     */
    _inputDownHandler() {
        const that = this;

        if (that._fullEdit || that._highlightedTimePartEdit || that.editMode === 'full' || JQX.Utilities.Core.isMobile) {
            return;
        }

        // Timeout is necessary due to an issue in Chrome (https://bugs.chromium.org/p/chromium/issues/detail?id=526516)
        setTimeout(function () {
            that._mouseFocus = true;
            that._highlightTimePartBasedOnCursor();
        }, 0);
    }

    /**
     * Input paste handler.
     */
    _inputPasteHandler(event) {
        const that = this;

        if (that.editMode === 'partial') {
            event.preventDefault();
        }
        else {
            this._fullEdit = true;
        }
    }

    /**
     * Input select handler.
     */
    _inputSelectHandler() {
        const that = this,
            activeElement = that.enableShadowDOM ? that.shadowRoot.activeElement : document.activeElement;

        if (that.editMode !== 'partial' || activeElement !== that.$.input) {
            return;
        }

        if (that._programmaticSelection === true) {
            that._programmaticSelection = false;
        }
        else {
            if (that._highlightedTimePart) {
                that._highlightTimePartBasedOnIndex(that._highlightedTimePart.index);
            }
            else {
                that._highlightTimePartBasedOnIndex(0);
            }
        }
    }

    /**
     * Input up handler.
     */
    _inputUpHandler() {
        const that = this;

        if (JQX.Utilities.Core.isMobile) {
            if (that._iOS) {
                that._mouseFocus = true;
                setTimeout(function () {
                    if (document.activeElement === that.$.input) {
                        that._highlightTimePartBasedOnCursor();
                    }
                }, 50);
            }
            else {
                // Timeout is necessary due to an issue in Chrome (https://bugs.chromium.org/p/chromium/issues/detail?id=526516)
                setTimeout(function () {
                    that._mouseFocus = true;
                    that._highlightTimePartBasedOnCursor();
                }, 10);
            }
        }
    }

    /**
     * Input wheel handler.
     */
    _inputWheelHandler(event) {
        const that = this,
            activeElement = that.enableShadowDOM ? that.shadowRoot.activeElement : document.activeElement;

        if (activeElement === that.$.input && that.enableMouseWheelAction && !that.disabled && !that.readonly) {
            event.preventDefault();
            that._incrementDecrement(event.deltaY > 0);
        }
    }

    /**
     * Checks if a date is restricted.
     */
    _isRestricted(date) {
        const restrictedDates = this.restrictedDates;
        let isRestricted = false;

        for (let i = 0; i < restrictedDates.length; i++) {
            if (date.equalDateParts(restrictedDates[i])) {
                isRestricted = true;
                break;
            }
        }

        return isRestricted;
    }

    /**
     * Mouseout handler.
     */
    _mouseoutHandler(event) {
        const that = this,
            target = event.target;

        if (!that.disabled && (target === that.$.input || target === that.$.calendarButton)) {
            target.removeAttribute('hover');
            that.removeAttribute('hover');
        }
    }

    /**
     * Mouseover handler.
     */
    _mouseoverHandler(event) {
        const that = this,
            target = event.target;

        if (!that.disabled && (target === that.$.input || target === that.$.calendarButton)) {
            target.setAttribute('hover', '');
            that.setAttribute('hover', '');
        }
    }

    /**
     * Navigates to next time part (if any).
     */
    _navigateToNextTimePart() {
        const that = this;

        that._highlightTimePartBasedOnIndex(that._highlightedTimePart.index + 1);
    }

    /**
     * Navigates to previous time part (if any).
     */
    _navigateToPreviousTimePart() {
        const that = this;

        that._highlightTimePartBasedOnIndex(that._highlightedTimePart.index - 1);
    }

    /**
     * Returns a new DateTime object with the current time.
     */
    _now() {
        const that = this,
            now = new JQX.Utilities.DateTime('today', 'Local');

        if (that._outputTimeZone !== 'Local') {
            return now.toTimeZone(that._outputTimeZone);
        }

        return now;
    }

    /**
     * Opens the calendar dropdown.
     */
    _open() {
        const that = this;

        if (that.disabled || that.readonly) {
            that.opened = false;
            return;
        }

        const openingEvent = that.$.fireEvent('opening');

        if (openingEvent.defaultPrevented) {
            that.opened = false;
            return;
        }

        if (that._edgeMacFF) {
            that.$dropDownContainer.removeClass('not-in-view');
        }

        that.$.dropDownContainer.style.transition = '';
        that.$.calendarDropDown.disabled = false;

        that.$calendarButton.addClass('jqx-calendar-button-pressed');
        that.$.calendarButton.setAttribute('active', '');

        if (that._dropDownDisplayMode !== 'default' && that._dropDownDisplayMode !== 'timePicker' ||
            !that._timePickerInitialized || (that._timePickerInitialized && that.$.timePickerDropDown.$.hasClass('jqx-hidden'))) {
            that.$calendarDropDown.removeClass('jqx-hidden');
        }

        that.opened = true;

        that._positionDetection.placeOverlay();
        that._positionDetection.checkBrowserBounds('vertically');
        that._positionDetection.positionDropDown();
        that._positionDetection.checkBrowserBounds('horizontally');

        that.$dropDownContainer.removeClass('jqx-visibility-hidden');

        that.$.fireEvent('open');

        if (that._toSync) {
            const value = that._value;

            if (value !== null) {
                that._disregardCalendarChangeEvent = true;
                that.$.calendarDropDown.selectedDates = [value.toDate()];

                if (that._defaultFooterTemplateApplied) {
                    that._hourElement.value = value.toString('hh');
                    that._minuteElement.value = value.toString('mm');
                    that._ampmElement.value = value.toString('tt');
                }

                if (that._timePickerInitialized) {
                    that.$.timePickerDropDown.value = value.toDate();
                }
            }
            else {
                const oldContext = that.$.calendarDropDown.context;

                that.$.calendarDropDown.context = that.$.calendarDropDown;
                that.$.calendarDropDown._clearSelection(true);
                that.$.calendarDropDown.context = oldContext;

                if (that._defaultFooterTemplateApplied) {
                    that._hourElement.value = '';
                    that._minuteElement.value = '';
                    that._ampmElement.value = '';
                }
            }

            that._toSync = false;
        }

        let toFocus;

        switch (that._dropDownDisplayMode) {
            case 'default':
                if (that.$selectDate.hasClass('jqx-selected')) {
                    toFocus = that.$.calendarDropDown;
                }
                else {
                    toFocus = that.$.timePickerDropDown.$.picker;
                }

                break;
            case 'classic':
            case 'calendar':
                toFocus = that.$.calendarDropDown;
                break;
            case 'timePicker':
                toFocus = that.$.timePickerDropDown.$.picker;
                break;
        }

        if (that.hasAnimation) {
            that._toFocus = toFocus;
        }
        else {
            toFocus.focus();
        }
    }

    /**
     * Positions external dropdown.
     */
    _positionExternalDropDown(elementRect) {
        const that = this.context,
            buttonOnTheRight = !that.calendarButton || that.calendarButtonPosition === 'right',
            dropDownPosition = that._dropDownListPosition,
            dropDown = that.$.dropDownContainer;
        let left = buttonOnTheRight ? elementRect.right - dropDown.offsetWidth : elementRect.left,
            top;

        switch (dropDownPosition) {
            case 'bottom':
                top = elementRect.bottom;
                break;
            case 'overlay-top':
                top = elementRect.bottom - dropDown.offsetHeight;
                break;
            case 'overlay-center':
                top = elementRect.top + elementRect.height / 2 - dropDown.offsetHeight / 2;
                break;
            case 'overlay-bottom':
                top = elementRect.top;
                break;
            case 'top':
                top = elementRect.top - dropDown.offsetHeight;
                break;
            case 'center-bottom':
            case 'center-top':
                if (dropDownPosition === 'center-bottom') {
                    top = elementRect.bottom + 5;
                }
                else {
                    top = elementRect.top - 5 - dropDown.offsetHeight;
                }

                if (buttonOnTheRight) {
                    left = elementRect.right - dropDown.offsetWidth / 2 - that.$.calendarButton.offsetWidth / 2;
                }
                else {
                    left = elementRect.left - dropDown.offsetWidth / 2 + that.$.calendarButton.offsetWidth / 2;
                }

                break;
        }

        return { left: left, top: top };
    }

    /**
     * Returns a date in the range between "min" and "max"
     */
    _rangeValidation(initialDate) {
        const that = this;

        if (initialDate.compare(that.min) === -1) {
            return that.min.clone();
        }
        else if (initialDate.compare(that.max) === 1) {
            return that.max.clone();
        }
        else {
            return initialDate;
        }
    }

    /**
     * Resets a time part
     */
    _resetTimePart() {
        const that = this,
            code = that._highlightedTimePart.code,
            index = that._codeToIndex[code],
            newValueConstructorParameters = JQX.Utilities.DateTime.getConstructorParameters(that._value);
        let value;

        if (index > 2) {
            value = 0;
        }
        else if (index > 0) {
            value = 1;
        }
        else {
            value = that.min.year();
        }

        newValueConstructorParameters[index] = value;
        newValueConstructorParameters.unshift(null);

        that._validateValue(new (Function.prototype.bind.apply(JQX.Utilities.DateTime, newValueConstructorParameters)));
    }

    /**
     * Sets default footer template
     */
    _setDefaultFooterTemplate(initialization) {
        const that = this;

        that.$.calendarDropDown.footerTemplate = that._defaultFooterTemplate;

        if (initialization) {
            that.$.calendarDropDown._handleLayoutTemplate(that.$.calendarDropDown.$.footer, that._defaultFooterTemplate);
        }

        that._hourElement = that.$.calendarDropDown.getElementsByClassName('jqx-hour-element')[0];
        that._minuteElement = that.$.calendarDropDown.getElementsByClassName('jqx-minute-element')[0];
        that._ampmElement = that.$.calendarDropDown.getElementsByClassName('jqx-am-pm-element')[0];
        that._todayElement = that.$.calendarDropDown.getElementsByClassName('jqx-today-element')[0];

        that._todayElement.title = that.localize('now');

        Array.from(that.$.calendarDropDown.$.footer.getElementsByTagName('jqx-repeat-button')).forEach(function (button) {
            button.animation = that.animation;
        });

        that._addCalendarFooterListeners();

        that._defaultFooterTemplateApplied = true;
    }

    /**
     * Sets whether the element can be focused.
     */
    _setFocusable() {
        const that = this;

        if (that.disabled || that.unfocusable) {
            that.$.input.tabIndex = -1;
            that.$.selectDate.removeAttribute('tabindex');
            that.$.selectTime.removeAttribute('tabindex');

            if (that._defaultFooterTemplateApplied) {
                that._hourElement.tabIndex = -1;
                that._ampmElement.tabIndex = -1;
                that._minuteElement.tabIndex = -1;
            }

            return;
        }

        const index = that.tabIndex > 0 ? that.tabIndex : 0;

        that.$.input.removeAttribute('tabindex');
        that.$.selectDate.tabIndex = index;
        that.$.selectTime.tabIndex = index;

        if (that._defaultFooterTemplateApplied) {
            that._hourElement.removeAttribute('tabindex');
            that._ampmElement.removeAttribute('tabindex');
            that._minuteElement.removeAttribute('tabindex');
            that.$.calendarDropDown.getElementsByClassName('jqx-footer-component-today')[0].tabIndex = index;
        }
    }

    /**
     * Sets the value to null and updates the input.
     */
    _setNullValue(oldValue) {
        const that = this;

        if (oldValue === undefined) {
            oldValue = that._cloneValue();
        }

        if (that.nullable) {
            that._value = null;
            that.value = null;
            that._highlightedTimePart = undefined;

            that.$.input.value = '';

            if (oldValue !== null) {
                if (that.opened) {
                    if (!that._calendarInitiatedChange) {
                        const oldContext = that.$.calendarDropDown.context;

                        that.$.calendarDropDown.context = that.$.calendarDropDown;
                        that.$.calendarDropDown._clearSelection(true);
                        that.$.calendarDropDown.context = oldContext;
                    }

                    if (that._defaultFooterTemplateApplied) {
                        that._hourElement.value = '';
                        that._ampmElement.value = '';
                        that._minuteElement.value = '';
                    }

                    that._toSync = false;
                }
                else {
                    that._toSync = true;
                }

                that.$.fireEvent('change', { 'oldValue': oldValue.toTimeZone(that._inputTimeZone), 'value': null });
            }

            that._disableSpinButtons();
        }
        else {
            that._validateValue(that._now(), oldValue);
        }
    }

    /**
     * Spin buttons click handler.
     */
    _spinButtonsClickHandler(event) {
        const that = this;

        if (that._value !== null && !that.disabled && !that.readonly) {
            that._incrementDecrement(that.$.downButton.contains(event.target));
        }
    }

    /**
     * Validates initial property values.
     */
    _validateInitialPropertyValues() {
        const that = this,
            calendar = that.$.calendarDropDown;

        if (that.calendarButtonPosition === 'left') {
            that.$.content.insertBefore(that.$.calendarButton, that.$.input);
        }

        if (that.spinButtonsPosition === 'left') {
            that.$.content.insertBefore(that.$.spinButtonsContainer, that.$.input);
        }

        if (that.disabled) {
            that.$.upButton.disabled = true;
            that.$.downButton.disabled = true;
        }

        if (that.opened) {
            if (!that.disabled && !that.readonly) {
                calendar.disabled = false;
                that.$calendarButton.addClass('jqx-calendar-button-pressed');
                that.$.calendarButton.setAttribute('active', '');
                that.$calendarDropDown.removeClass('jqx-hidden');
                that.$dropDownContainer.removeClass('jqx-visibility-hidden');
            }
            else {
                that.opened = false;
            }
        }

        if (that.footerTemplate === null) {
            that._setDefaultFooterTemplate(true);
        }
        else {
            calendar.footerTemplate = that.footerTemplate;
            calendar._handleLayoutTemplate(calendar.$.footer, that.footerTemplate);
        }

        if (that.formatString === '') {
            that.formatString = 'dd-MMM-yy HH:mm:ss.fff';
        }

        const displayKind = that.displayKind;

        if (displayKind === 'UTC') {
            that._outputTimeZone = 'UTC';
        }
        else if (displayKind === 'local') {
            that._outputTimeZone = 'Local';
        }

        let parsedValue;

        if (that.value !== null) {
            parsedValue = JQX.Utilities.DateTime.validateDate(that.value, new JQX.Utilities.DateTime(), that.formatString);
            that._inputTimeZone = parsedValue.timeZone;

            if (displayKind !== 'unspecified' && that._inputTimeZone !== that._outputTimeZone) {
                parsedValue = parsedValue.toTimeZone(that._outputTimeZone);
            }
            else if (displayKind === 'unspecified') {
                that._outputTimeZone = that._inputTimeZone;
            }
        }
        else {
            parsedValue = null;
            that._inputTimeZone = 'Local';
        }

        that._validateRestrictedDates();
        that._validateMinMax('both');
        that._validateValue(parsedValue, that._now(), false, true);
        that._validateInterval(new JQX.Utilities.TimeSpan(0, 0, 1));

        that._getFormatStringRegExp();

        if (that._defaultFooterTemplateApplied && that._hourElement.value === '' && that.value !== null) {
            const value = that.value;

            that._hourElement.value = value.toString('hh');
            that._ampmElement.value = value.toString('tt');
            that._minuteElement.value = value.toString('mm');
        }

        that._detectDisplayMode();

        const dropDownDisplayMode = that._dropDownDisplayMode;

        if (dropDownDisplayMode === 'default' || dropDownDisplayMode === 'calendar') {
            calendar.viewSections = ['title', 'header'];

            if (calendar.$title.hasClass('jqx-hidden')) {
                calendar.propertyChangedHandler('viewSections', ['header', 'footer'], ['title', 'header']);
            }

            if (dropDownDisplayMode === 'default') {
                that.$dropDownHeader.removeClass('jqx-hidden');
            }
        }
        else if (dropDownDisplayMode === 'timePicker') {
            that.$calendarDropDown.addClass('jqx-hidden');
            that._initializeTimePicker();
        }
    }

    /**
     * Validates "interval"
     */
    _validateInterval(referenceValue) {
        const that = this,
            interval = that.interval;
        let validValue = interval;

        if (interval instanceof JQX.Utilities.TimeSpan) {
            validValue = interval;
        }
        else if (typeof interval === 'string') {
            const indexOfTimeSpan = interval.indexOf('TimeSpan('),
                indexOfBracket = interval.indexOf(')');

            if (indexOfTimeSpan !== -1 && indexOfBracket !== -1) {
                validValue = interval.slice(indexOfTimeSpan + 9, indexOfBracket);

                validValue = validValue.replace(/'/g, '').replace(/"/g, '').replace(/^\s+|\s+$|\s+(?=\s)/g, '');

                if (new RegExp(/(^(\d+)(,\s*\d+)*$)/g).test(validValue)) {
                    validValue = validValue.replace(/\s/g, '');
                    validValue = validValue.split(',');

                    validValue.map(function (argument, index) {
                        validValue[index] = parseInt(argument);
                    });

                    validValue.unshift(null);
                    validValue = new (Function.prototype.bind.apply(JQX.Utilities.TimeSpan, validValue));
                }
            }

            if (validValue instanceof JQX.Utilities.TimeSpan === false) {
                if (validValue.trim() === '') {
                    that.interval = referenceValue;
                    return;
                }

                if (!isNaN(validValue)) {
                    validValue = parseInt(validValue, 10) * 10000;
                }

                try {
                    validValue = new JQX.Utilities.TimeSpan(validValue);
                }
                catch (error) {
                    that.interval = referenceValue;
                    return;
                }
            }
        }
        else if (typeof interval === 'number') {
            validValue = new JQX.Utilities.TimeSpan(interval);
        }
        else {
            that.interval = referenceValue;
            return;
        }

        if (validValue._ticks === 0) {
            that.interval = referenceValue;
        }
        else {
            that.interval = validValue;
        }
    }

    /**
     * Validates "min" and "max"
     */
    _validateMinMax(which, referenceValue) {
        const that = this;
        let minChanged = false;

        if (which !== 'max') {
            that.min = JQX.Utilities.DateTime.validateDate(that.min, referenceValue || new JQX.Utilities.DateTime(1600, 1, 1), that.formatString);
            that.min = that.min.toTimeZone(that._outputTimeZone);
            minChanged = true;
        }

        if (which !== 'min') {
            that.max = JQX.Utilities.DateTime.validateDate(that.max, referenceValue || new JQX.Utilities.DateTime(3001, 1, 1), that.formatString);
            that.max = that.max.toTimeZone(that._outputTimeZone);

            that.max.calendar.days = that._localizedDays;
            that.max.calendar.months = that._localizedMonths;
            that.max.calendar.locale = that.locale;

            that.$.calendarDropDown.max = that.max.toDate();
        }

        if (that.min.compare(that.max) > 0) {
            that.min = that.max.clone();
            minChanged = true;
        }

        if (minChanged) {
            that.min.calendar.days = that._localizedDays;
            that.min.calendar.months = that._localizedMonths;
            that.min.calendar.locale = that.locale;

            that.$.calendarDropDown.min = that.min.toDate();
        }
    }

    /**
     * Validates "restrictedDates".
     */
    _validateRestrictedDates() {
        const that = this,
            dateTimeInputRestrictedDates = [],
            calendarRestrictedDates = [];

        for (let i = 0; i < that.restrictedDates.length; i++) {
            const currentRestrictedDate = that.restrictedDates[i];
            let validRestrictedDate = JQX.Utilities.DateTime.validateDate(currentRestrictedDate, 'invalid', that.formatString);

            if (validRestrictedDate !== 'invalid') {
                validRestrictedDate = validRestrictedDate.toTimeZone(that._outputTimeZone);
                dateTimeInputRestrictedDates.push(validRestrictedDate);
                calendarRestrictedDates.push(validRestrictedDate.toDate());
            }
        }

        that.restrictedDates = dateTimeInputRestrictedDates;
        that.$.calendarDropDown.restrictedDates = calendarRestrictedDates;
    }

    /**
     * Validates the value and updates the input.
     */
    _validateValue(value, referenceValue, fireEvent, programmatic) {
        const that = this,
            oldValue = referenceValue !== undefined ? referenceValue : that._cloneValue();

        if (value === null || value === '') {
            that._setNullValue(oldValue);
            return;
        }

        if (value !== undefined) {
            that._value = JQX.Utilities.DateTime.validateDate(value, oldValue, that.formatString);
        }

        if (that._value === null) {
            that._setNullValue(oldValue);
            return;
        }

        let valueNotRestricted = that._value;

        while (that._isRestricted(valueNotRestricted) === true) {
            valueNotRestricted.addDays(1, false);
        }

        const valueInRange = that._rangeValidation(valueNotRestricted);

        if (!programmatic || that.validation === 'strict') {
            that._value = valueInRange;
            delete that._minMaxChanged;
        }
        else if (valueNotRestricted.equals(valueInRange) === false) {
            that._minMaxChanged = true;
        }

        that.value = that._value.toTimeZone(that._inputTimeZone);

        const validValue = that._value;

        validValue.calendar.days = that._localizedDays;
        validValue.calendar.months = that._localizedMonths;
        validValue.calendar.locale = that.locale;

        that._applyFormatString();
        that._disableSpinButtons();

        if (((oldValue === null || validValue === null) && oldValue !== validValue) ||
            ((oldValue !== null && validValue !== null) && oldValue.compare(validValue) !== 0)) {
            if (fireEvent !== false) {
                that.$.fireEvent('change', { 'oldValue': oldValue !== null ? oldValue.toTimeZone(that._inputTimeZone) : null, 'value': that.value });
            }

            if (that._calendarInitiatedChange) {
                return;
            }

            if (that.opened) {
                if (oldValue === null ||
                    that.$.calendarDropDown.selectedDates.length === 0 ||
                    oldValue.year() !== validValue.year() ||
                    oldValue.month() !== validValue.month() ||
                    oldValue.day() !== validValue.day() ||
                    !that.$.calendarDropDown._isDateInView(validValue.toDate())) {
                    that._disregardCalendarChangeEvent = true;
                    that.$.calendarDropDown.selectedDates = [validValue.toDate()];
                }

                if (that._defaultFooterTemplateApplied) {
                    if (oldValue === null || oldValue.hour() !== validValue.hour()) {
                        that._hourElement.value = validValue.toString('hh');
                        that._ampmElement.value = validValue.toString('tt');
                    }

                    if (oldValue === null || oldValue.minute() !== validValue.minute()) {
                        that._minuteElement.value = validValue.toString('mm');
                    }
                }

                if (that._timePickerInitialized && !that._timePickerInitiatedChange) {
                    that.$.timePickerDropDown.value = validValue.toDate();
                }

                that._toSync = false;
            }
            else {
                that._toSync = true;
            }
        }
    }
});

/**
* jqxDockingLayout custom element.
*/
JQX('jqx-docking-layout', class DockingLayout extends JQX.ContentElement {

    /**
    * Element's properties
    */
    static get properties() {
        return {
            'autoLoadState': {
                value: false,
                type: 'boolean'
            },
            'autoSaveState': {
                value: false,
                type: 'boolean'
            },
            'draggable': {
                value: true,
                type: 'boolean'
            },
            'floatable': {
                value: true,
                type: 'boolean'
            },
            'hideSplitterBars': {
                value: false,
                type: 'boolean'
            },
            'layout': {
                value: [],
                type: 'array',
                reflectToAttribute: false
            },
            'liveResize': {
                value: false,
                type: 'boolean'
            },
            'messages': {
                value: {
                    'en': {
                        'invalidNode': '{{elementType}}: "{{method}}" method accepts an instance of JQX.TabsWindow',
                        'invalidNodeRemove': '{{elementType}}: "{{method}}" method accepts an instance of JQX.TabsWindow that is a child of the DockingLayout.',
                        'invalidNodeType': '{{elementType}}: The method "{{method}}" requires a "jqx-tabs-window" element to be passed as an argument.',
                        'invalidTargetNode': '{{elementType}}: The method "{{method}}" requires an index of an item that is not hidden/closed. Only visible items that are part of the Layout are valid.',
                        'invalidIndex': '{{elementType}}: "{{method}}" method accepts an index of type number.',
                        'noId': 'jqxDockingLayout requires an id in order to save/load a state.'
                    }
                },
                type: 'object',
                extend: true
            },
            'resizeStep': {
                value: 5,
                type: 'number'
            },
            'snapMode': {
                value: 'advanced',
                allowedValues: ['simple', 'advanced'],
                type: 'string'
            }
        }
    }

    /**
    * Element's event listeners.
    */
    static get listeners() {
        return {
            'autoHideWindow.close': '_autoHideWindowCloseHandler',
            'autoHideWindow.resizeEnd': '_autoHideWindowResizeEndHandler',
            'dock': '_dockEventHandler',
            'move': '_moveHandler',
            'document.down': '_documentDownHandler',
            'document.move': '_documentMoveHandler',
            'document.up': '_documentUpHandler',
            'document.selectstart': '_documentSelectStartHandler',
            'document.dragstart': '_documentDragStartHandler',
            'container.tabStripResize': '_containerTabStripResizeHandler',
            'itemsContainer.close': '_itemsContainerCloseHandler',
            'itemsContainer.autoHide': '_itemsContainerAutoHideHandler',
            'itemsContainer.resizeEnd': '_itemsContainerResizeHandler',
            'keydown': '_keyDownHandler',
            'keyup': '_keyUpHandler',
            'mouseleave': '_mouseLeaveHandler'
        }
    }

    /**
    * iOS Safari bug fix. (iOS Safari doesn't support 'touch-action: none')
    */
    _moveHandler() {
        if (this.hasAttribute('dragged') && event.originalEvent.type === 'touchmove') {
            event.originalEvent.preventDefault();
        }
    }

    /**
    * Element's HTML template.
    */
    template() {
        return `<div id="container">
                    <jqx-splitter id="horizontalHiddenItemsContainer" class="jqx-horizontal-hidden-items-container" orientation="horizontal">
                        <jqx-splitter-item class="jqx-docking-layout-item-holder">
                            <jqx-splitter id="verticalHiddenItemsContainer" class="jqx-vertical-hidden-items-container">
                                <jqx-splitter-item class="jqx-docking-layout-item-holder">
                                    <jqx-splitter id="itemsContainer" class="jqx-items-container">
                                        <content></content>
                                        <jqx-splitter-item id="placeholderItem" class="jqx-placeholder" pinned>
                                            <jqx-tabs-window tab-position="hidden" opened header-buttons='[]'>
                                                <jqx-tab-item></jqx-tab-item>
                                            </jqx-tabs-window>
                                        </jqx-splitter-item>
                                    </jqx-splitter>
                                </jqx-splitter-item>
                            </jqx-splitter>
                        </jqx-splitter-item>
                    </jqx-splitter>
                    <jqx-tabs-window id="tabsWindowFeedback" class="jqx-tabs-window-feedback jqx-hidden"></jqx-tabs-window>
                    <jqx-tabs-window id="autoHideWindow" class="jqx-docking-layout-auto-hide-window" pinned header-buttons='["close", "dock"]' tab-position="hidden">
                        <jqx-tab-item></jqx-tab-item>
                    </jqx-tabs-window>
                </div>`;
    }

    /**
    * Updates the element when a property is changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
    * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        switch (propertyName) {
            case 'autoSaveState':
                that._handleAutoSave();
                break;
            case 'layout':
                that._handleLayout();
                break;
            case 'liveResize':
            case 'resizeStep': {
                const allSplitters = that.getElementsByTagName('jqx-splitter');

                for (let i = 0; i < allSplitters.length; i++) {
                    allSplitters[i][propertyName] = newValue;
                }

                if (propertyName === 'liveResize') {
                    that.$.autoHideWindow[propertyName] = newValue;
                }

                break;
            }
            case 'snapMode':
                that._handleSnapping();
                that._snapFeedback = undefined;
                break;
            case 'hideSplitterBars':
                that._setSplitterBarVisibility();
                break;
            default:
                super.propertyChangedHandler(propertyName, oldValue, newValue);
                break;
        }
    }

    /**
    * Element's ready method.
    */
    ready() {
        super.ready();

        const that = this;

        //AutoLoadState
        if (that.autoLoadState) {
            const previousState = that.loadState();

            if (previousState) {
                that.layout = previousState;
            }
        }

        that.$.itemsContainer.liveResize = that.liveResize;
        that.$.itemsContainer.resizeStep = that.resizeStep;

        that._handleLayout();

        //Prevents visual redraw on element initialization
        that.$tabsWindowFeedback.removeClass('jqx-hidden');
        that._setFocusable();
    }

    /**
    * Checks for missing modules.
    */
    static get requires() {
        return {
            'JQX.TabsWindow': 'jqxwindow.js',
            'JQX.Splitter': 'jqxsplitter.js'
        }
    }

    /**
    * Appends an HTML element content section of the Window.
    */
    appendChild(node) {
        const that = this;

        if (!that.isCompleted) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!node) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'appendChild' }));
            return
        }

        if (!(node instanceof JQX.TabsWindow)) {
            that.error(that.localize('invalidNodeType', { elementType: that.nodeName.toLowerCase(), method: 'appendChild' }));
            return;
        }

        that.insertBefore(node, null);
    }

    /**
     * AutoHides and item to the bottom side
     * @param {any} item
     */
    autoHideBottom(item) {
        this._autoHide(item, 'bottom');
    }

    /**
     * AutoHides and item to the left side
     * @param {any} item
     */
    autoHideLeft(item) {
        this._autoHide(item, 'left');
    }

    /**
     * AutoHides and item to the right side
     * @param {any} item
     */
    autoHideRight(item) {
        this._autoHide(item, 'right');
    }

    /**
     * AutoHides and item to the top side
     * @param {any} item
     */
    autoHideTop(item) {
        this._autoHide(item, 'top');
    }

    /**
     * Clears the previously saved state
     */
    clearState() {
        const that = this;

        if (!that.id) {
            that.warn(that.localize('noId'));
            return;
        }

        window.localStorage.removeItem('jqxDockingLayout' + that.id);
    }

    /**
     * Docks an autoHidden item/ Inserts an external window into the Layout
     * @param {any} item
     */
    dock(item) {
        this._dock(item);
    }

    /**
     * Undocks a tabsWindow or TabItem if it was docked( inside the Layout )
     */
    undock(tabsWindow) {
        const that = this;

        if (typeof tabsWindow === 'number') {
            tabsWindow = that._items[tabsWindow];
        }
        else if (typeof tabsWindow === 'string') {
            tabsWindow = document.getElementById(tabsWindow);
        }

        if (!tabsWindow) {
            return;
        }

        if (!that.contains(tabsWindow)) {
            return;
        }

        const splitterItem = tabsWindow.closest('jqx-splitter-item');

        if (!splitterItem) {
            return;
        }

        const splitterItemRect = splitterItem.getBoundingClientRect();
        let targetWindow;

        if (tabsWindow instanceof JQX.TabsWindow) {
            if (tabsWindow.autoHide) {

                //Close the autoHideWindow
                that.$.autoHideWindow.close();

                if (tabsWindow._autoHideWindow) {
                    tabsWindow.style.width = tabsWindow._autoHideWindow.offsetWidth + 'px';
                    tabsWindow.style.height = tabsWindow._autoHideWindow.offsetHeight + 'px';
                }

                if (tabsWindow.tabPosition === 'left' || tabsWindow.tabPosition === 'right') {
                    tabsWindow.style.height = that.offsetHeight + 'px';
                }
                else {
                    tabsWindow.style.width = that.offsetWidth + 'px';
                }
            }
            else {
                tabsWindow.style.width = tabsWindow.offsetWidth + 'px';
                tabsWindow.style.height = tabsWindow.offsetHeight + 'px';
            }

            tabsWindow.windowParent = 'body';

            //Reset window properties
            tabsWindow.opened = true;

            if (tabsWindow.autoHide) {
                tabsWindow.tabPosition = 'top';
            }

            //Reset the proeprties of the Window
            tabsWindow.autoHide = tabsWindow.allowToggle = tabsWindow.pinned = false;
            tabsWindow.style.maxWidth = tabsWindow.style.maxHeight = '';
            targetWindow = tabsWindow;

            const splitterParent = splitterItem.closest('jqx-splitter');

            splitterParent.removeChild(splitterItem);
            that._removeUnneccessaryItems(splitterParent);
        }
        else if (tabsWindow instanceof JQX.TabItem) {
            const parentTabsWindow = tabsWindow.closest('jqx-tabs-window');
            let newTabsWindow;

            if (parentTabsWindow.items.length === 1) {
                newTabsWindow = parentTabsWindow;
                splitterItem.closest('jqx-splitter').removeChild(splitterItem);
            }
            else {
                newTabsWindow = that._createTabsWindowFromObject({ label: tabsWindow.label });
                newTabsWindow.appendChild(tabsWindow);
            }

            if (newTabsWindow.windowParent !== 'body') {
                newTabsWindow.windowParent = 'body';
            }
            else if (newTabsWindow.parentElement !== document.body) {
                document.body.appendChild(newTabsWindow);
            }

            newTabsWindow.allowToggle = newTabsWindow.autoHide = newTabsWindow.pinned = false;
            newTabsWindow.label = tabsWindow.label;
            newTabsWindow.opened = true;

            //Remember the previous item
            newTabsWindow._parentInfo = {
                closestItem: parentTabsWindow,
                position: tabsWindow.index
            };

            targetWindow = newTabsWindow;
            tabsWindow = parentTabsWindow;
        }
        else {
            return;
        }

        if (tabsWindow._originalTabPosition) {
            targetWindow.tabPosition = tabsWindow._originalTabPosition;
        }
        else if (tabsWindow.autoHide) {
            targetWindow.tabPosition = 'top';
        }

        targetWindow.tabTextOrientation = tabsWindow._originalTextOrientation || 'horizontal';

        if (targetWindow === tabsWindow) {
            delete targetWindow._originalTabPosition;
            delete targetWindow._originalTextOrientation;
        }

        that._setFloatingItemsHeaderButtons(targetWindow);

        //Position on the same place
        targetWindow.style.left = splitterItemRect.left + 'px';
        targetWindow.style.top = splitterItemRect.top + 'px';

        targetWindow.resizeMode = 'both';

        const itemIndex = that._items.indexOf(tabsWindow);

        targetWindow.layout = that;

        if (itemIndex > -1) {
            that._items.splice(itemIndex, 1);

            if (targetWindow.position) {
                targetWindow.style.top = targetWindow.position.top;
                targetWindow.style.left = targetWindow.position.left;
                delete targetWindow.position;
            }
        }

        if (that._items.filter(item => item.opened).length === 0 && !that.$.placeholderItem.parentElement) {
            that.$.itemsContainer.appendChild(that.$.placeholderItem);
        }

        that._validateWindowPosition(targetWindow);
        that._setAutoHidePaddings();

        if (!that._noStateChangeFiring) {
            that._handleAutoSave();
            that.$.fireEvent('stateChange', { type: 'float', item: targetWindow });
        }

        if (document.activeElement !== targetWindow) {
            const scrollElement = document.scrollingElement || document.documentElement,
                x = scrollElement.scrollLeft,
                y = scrollElement.scrollTop;

            targetWindow.focus();
            targetWindow.bringToFront();
            window.scrollTo(x, y);
        }
    }

    /**
     * Inserts a TabsWindow element before another inside the Layout
     */
    insertBefore(newNode, node, topLevelInsert) {
        const that = this;

        if (!that.isCompleted) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        let newTabsWindow = newNode;

        if (newTabsWindow instanceof JQX.TabsWindow) {
            newNode = document.createElement('jqx-splitter-item');

            newNode.size = newTabsWindow.size || '';
            newNode.max = newTabsWindow.max || '';
            newNode.min = newTabsWindow.min || '';
            newNode.locked = newTabsWindow.locked || false;
            newNode.collapsible = newTabsWindow.collapsible || false;
            newNode.collapsed = newTabsWindow.collapsed || false;

            newNode.appendChild(newTabsWindow);
        }
        else if (newTabsWindow instanceof JQX.SplitterItem) {
            newTabsWindow = newTabsWindow.querySelector('jqx-tabs-window');
        }
        else {
            that.error(that.localize('invalidNodeType', { elementType: that.nodeName.toLowerCase(), method: 'insertBefore' }));
        }

        newTabsWindow.opened = newTabsWindow.pinned = true;
        newTabsWindow.style.width = newTabsWindow.style.height = '';
        newTabsWindow.style.top = newTabsWindow.style.left = '';
        newTabsWindow.style.paddingTop = newTabsWindow.style.paddingBottom = '';
        newTabsWindow.style.paddingLeft = newTabsWindow.style.paddingRight = '';
        newNode.style.top = newNode.style.left = '';

        let parentSplitter;

        if (node) {
            parentSplitter = node.closest('jqx-splitter');

            if (parentSplitter === that.$.verticalHiddenItemsContainer || parentSplitter === that.$.horizontalHiddenItemsContainer) {
                parentSplitter = that.$.itemsContainer;

                if (that._items.length === 0) {
                    node = null;
                }
                else if (node.tabPosition === 'top' || node.tabPosition === 'left') {
                    node = that._items[0];
                }
                else {
                    node = that._items[that._items.length - 1];
                }
            }
            else if (topLevelInsert) {
                parentSplitter = that.$.itemsContainer;
            }

            if (!(node instanceof JQX.TabsWindow)) {
                that.error(that.localize('invalidNodeType', { elementType: that.nodeName.toLowerCase(), method: 'insertBefore' }));
                return;
            }

            parentSplitter.autoFitMode = 'end';

            parentSplitter.insertBefore(newNode, parentSplitter._items.filter(item => item.contains(node))[0]);

            that._items.splice(that._items.indexOf(node), 0, newTabsWindow);
        }
        else {
            parentSplitter = that.$.itemsContainer;

            if (that._dockingAutoHideTabItem) {
                parentSplitter.autoFitMode = 'end';
            }

            that._items.push(newTabsWindow);
            that.$.itemsContainer.insertBefore(newNode);
        }

        parentSplitter.autoFitMode = 'proportional';

        if (newTabsWindow.autoHide) {
            that._autoHide(newTabsWindow, newTabsWindow.autoHidePosition);
        }
        else {
            //Reset the TabsWindow if it's been an autoHidden one
            newTabsWindow.autoHide = newTabsWindow.allowToggle = false;

            if (newTabsWindow._originalTabPosition) {
                newTabsWindow.tabPosition = newTabsWindow._originalTabPosition;
                delete newTabsWindow._originalTabPosition;
            }

            if (newTabsWindow._originalTextOrientation) {
                newTabsWindow.tabTextOrientation = newTabsWindow._originalTextOrientation;
                delete newTabsWindow._originalTextOrientation;
            }

            that._setDockedItemsHeaderButtons(newTabsWindow);

            const scrollElement = document.scrollingElement || document.documentElement,
                x = scrollElement.scrollLeft,
                y = scrollElement.scrollTop;

            newTabsWindow.focus();
            window.scrollTo(x, y);
        }

        if (that._items.filter(item => item.opened).length > 0 && that.$.placeholderItem.parentElement) {
            that.$.itemsContainer.removeChild(that.$.placeholderItem);
        }

        newTabsWindow.layout = that;
        newTabsWindow.minimized = false;
        newTabsWindow.maximized = false;
        newTabsWindow.locked = false;
        newTabsWindow.resizeMode = 'none';

        that._handleAutoHiddenSplitterBars();
        that._setSplitterBarVisibility();
        that._handleAutoSave();
        that.$.fireEvent('stateChange', { type: 'dock', item: newTabsWindow });
    }

    /**
     * Inserts a new item before the targetItem that corresponds to the index
     * @param {any} index - the index of the target item
     * @param {any} item - the new item to be inserted
     */
    insertBeforeItem(index, item) {
        this._insert(index, item, 'top', 'insertBeforeItem');
    }

    /**
     * Inserts a new item after the targetItem that corresponds to the index
     * @param {any} index - the index of the target item
     * @param {any} item - the new item to be inserted
     */
    insertAfterItem(index, item) {
        this._insert(index, item, 'bottom', 'insertAfterItem');
    }

    /**
     * Inserts a new item inside the target item at it's left side
     * @param {any} index - the index of the target Layout item
     * @param {any} item - an instance of JQX.TabsWindow or an object defining a TabsWindow.
     */
    insertIntoLeft(index, item) {
        this._insert(index, item, 'inside-left', 'insertIntoLeft');
    }

    /**
     * Inserts a new item inside the target item at it's right side
     * @param {any} index - the index of the target Layout item
     * @param {any} item - an instance of JQX.TabsWindow or an object defining a TabsWindow.
     */
    insertIntoRight(index, item) {
        this._insert(index, item, 'inside-right', 'insertIntoRight');
    }

    /**
     * Inserts a new item inside the target item at it's top side
     * @param {any} index - the index of the target Layout item
     * @param {any} item - an instance of JQX.TabsWindow or an object defining a TabsWindow.
     */
    insertIntoTop(index, item) {
        this._insert(index, item, 'inside-top', 'insertIntoTop');
    }

    /**
     * Inserts a new item inside the target item at it's top side
     * @param {any} index - the index of the target Layout item
     * @param {any} item - an instance of JQX.TabsWindow or an object defining a TabsWindow.
     */
    insertIntoBottom(index, item) {
        this._insert(index, item, 'inside-bottom', 'insertIntoBottom');
    }

    /**
     * Inserts a new item at top level of hierarchy inside the layout at position top
     */
    insertLayoutTop(item) {
        this._insert(0, item, 'layout-top', 'insertLayoutTop');
    }

    /**
     * Inserts a new item at top level of hierarchy inside the layout at position bottom
     * @param {any} index - the index of the target Layout item
     * @param {any} item - an instance of JQX.TabsWindow or an object defining a TabsWindow.
     */
    insertLayoutBottom(item) {
        this._insert(0, item, 'layout-bottom', 'insertLayoutBottom');
    }

    /**
     * Inserts a new item at top level of hierarchy inside the layout at position left
     */
    insertLayoutLeft(item) {
        this._insert(0, item, 'layout-left', 'insertLayoutLeft');
    }

    /**
     * Inserts a new item at top level of hierarchy inside the layout at position left
     * @param {any} index - the index of the target Layout item
     * @param {any} item - an instance of JQX.TabsWindow or an object defining a TabsWindow.
     */
    insertLayoutRight(item) {
        this._insert(0, item, 'layout-right', 'insertLayoutRight');
    }

    /**
     * Inserts a new item at position top by creating a new splitter with two items. One is the new item and the other is the Splitter parent of the target item.
     * @param {any} index - the index of the target Layout item
     * @param {any} item - an instance of JQX.TabsWindow or an object defining a TabsWindow.
     */
    insertOutsideTargetGroupTop(index, item) {
        this._insert(index, item, 'outside-top', 'insertOutsideTargetGroupTop');
    }

    /**
    * Inserts a new item at position bottom by creating a new splitter with two items. One is the new item and the other is the Splitter parent of the target item.
    * @param {any} index - the index of the target Layout item
    * @param {any} item - an instance of JQX.TabsWindow or an object defining a TabsWindow.
    */
    insertOutsideTargetGroupBottom(index, item) {
        this._insert(index, item, 'outside-bottom', 'insertOutsideTargetGroupBottom');
    }

    /**
    * Inserts a new item at position left by creating a new splitter with two items. One is the new item and the other is the Splitter parent of the target item.
    * @param {any} index - the index of the target Layout item
    * @param {any} item - an instance of JQX.TabsWindow or an object defining a TabsWindow.
    */
    insertOutsideTargetGroupLeft(index, item) {
        this._insert(index, item, 'outside-left', 'insertOutsideTargetGroupLeft');
    }

    /**
    * Inserts a new item at position right by creating a new splitter with two items. One is the new item and the other is the Splitter parent of the target item.
    * @param {any} index - the index of the target Layout item
    * @param {any} item - an instance of JQX.TabsWindow or an object defining a TabsWindow.
    */
    insertOutsideTargetGroupRight(index, item) {
        this._insert(index, item, 'outside-right', 'insertOutsideTargetGroupRight');
    }

    /**
    * Returns an array of auto-hide items that are available inside the Layout
    * @param {any} orientation
    */
    getAutoHideItems(orientation) {
        const that = this;

        function getItems(splitter) {
            let items = [];

            if (!splitter._items) {
                return items;
            }

            for (let i = 0; i < splitter._items.length; i++) {
                if (!splitter._items[i].$.hasClass('jqx-docking-layout-item-holder')) {
                    items.push(splitter._items[i].getElementsByTagName('jqx-tabs-window')[0]);
                }
            }

            return items;
        }

        if (!orientation) {
            return getItems(that.$.horizontalHiddenItemsContainer).concat(getItems(that.$.verticalHiddenItemsContainer));
        }

        if (orientation === 'horizontal') {
            return getItems(that.$.horizontalHiddenItemsContainer);
        }

        return getItems(that.$.verticalHiddenItemsContainer);
    }

    /**
     * Returns the index of the item
     * @param {any} item
     */
    getIndex(item) {
        const that = this;

        if (!that.isReady) {
            return;
        }

        if (!that._items.length) {
            return;
        }

        return that._items.indexOf(item);
    }

    /**
    * Returns an array of Splitter items that are auto hidden inside the element
    */
    get autoHideItems() {
        const that = this;

        if (that.isReady) {
            return that.getAutoHideItems();
        }
    }

    /**
     * Returns an array of Splitter items that are inside the element
     */
    get items() {
        const that = this;

        if (that.isReady) {
            return that._items.filter(item => item.opened).concat(that.getAutoHideItems());
        }
    }

    /**
    * Returns all closed TabsWindow items
    */
    get closedItems() {
        const that = this;

        if (that.isReady) {
            return that._items.filter(item => !item.opened);
        }
    }

    /**
     * Returns all items of the DockingLayout that have been undocked
     */
    get undockedItems() {
        const that = this;

        if (!that.isReady) {
            return;
        }

        const tabsWindows = document.getElementsByTagName('jqx-tabs-window');
        let undockedWindows = [];

        for (let i = 0; i < tabsWindows.length; i++) {
            if (!tabsWindows[i].closest('jqx-docking-layout') && tabsWindows[i].layout === that) {
                tabsWindows[i].undocked = true;
                undockedWindows.push(tabsWindows[i]);
            }
        }

        return undockedWindows;
    }

    /**
     * Returns the Splitter parent of a Layout item
     */
    getItemGroupElement(item) {
        const that = this;

        if (!that.isReady || !item || !(item instanceof JQX.TabsWindow) || !that.contains(item)) {
            return;
        }

        return item.closest('jqx-splitter');
    }

    /**
    * Returns the current Layout structure as an array of objects. Contains HTML references.
    */
    getState(noInstances) {
        const that = this,
            autoHideItems = that.getAutoHideItems(),
            undockedItems = that.undockedItems,
            structure = [];

        for (let i = 0; i < autoHideItems.length; i++) {
            structure.push(that._createTabsWindowStructure(autoHideItems[i], noInstances));
        }

        for (let i = 0; i < undockedItems.length; i++) {
            structure.push(that._createTabsWindowStructure(undockedItems[i], noInstances));
        }

        return [{
            type: 'LayoutGroup',
            items: structure.concat(that._createLayoutStructure(that.$.itemsContainer, noInstances)),
            orientation: that.$.itemsContainer.orientation
        }];
    }

    /**
    * Returns the nearest splitter bars of an item
    * @param {any} item - a jqxTabsWindow item or it's index or id
    */
    getClosestSplitterBars(item) {
        const that = this;

        if (!that._items || !that._items.length) {
            return;
        }

        if (typeof item === 'string') {
            item = document.getElementById(item);
        }
        else if (typeof item === 'number') {
            item = that._items[parseInt(item)];
        }

        if (!(item instanceof JQX.TabsWindow) || !that._items.find(i => i === item)) {
            return
        }

        let closestSplitter = item.closest('jqx-splitter');

        while (closestSplitter) {
            if (closestSplitter.bars.length) {
                break;
            }

            closestSplitter = closestSplitter.closest('jqx-splitter');
        }

        if (closestSplitter) {
            return closestSplitter.bars;
        }
    }

    /**
     * Returns a JSON structure of the current Layout state. Does not contain any HTML references. Used for local storaging.
     */
    getJSONStructure() {
        return this.getState(true);
    }

    /**
     * Load the previously saved state of the Layout
     */
    loadState(previousState) {
        const that = this;

        if (!previousState) {
            if (!that.id) {
                that.warn(that.localize('noId'));
                return;
            }

            previousState = JSON.parse(window.localStorage.getItem('jqxDockingLayout' + that.id));
        }

        if (previousState) {
            that._loadState(previousState);
            return previousState;
        }
    }

    /**
   * Removes a TabsWindow element from the Layout.
   */
    remove(item) {
        const that = this;

        if (typeof (item) === 'number') {
            item = that._items[item];
        }
        else if (typeof item === 'string') {
            item = document.getElementById(item);
        }

        if (!(item instanceof JQX.TabsWindow)) {
            that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'remove' }));
            return;
        }

        if (item.closest('jqx-docking-layout') !== that) {
            that.error(that.localize('invalidNodeRemove', { elementType: that.nodeName.toLowerCase(), method: 'remove' }));
            return;
        }

        that.removeChild(item);
    }

    /**
     * Removes all items from the Layout
     */
    removeAll() {
        this._removeAll();
    }

    /**
    * Removes a jqxTabsWindow item from the Layout
    */
    removeChild(node) {
        const that = this;

        if (!node) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'removeChild' }));
            return
        }

        if (!(node instanceof JQX.TabsWindow)) {
            that.error(that.localize('invalidNodeType', { elementType: that.nodeName.toLowerCase(), method: 'removeChild' }));
            return;
        }

        if (!that.isCompleted) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        const splitterItem = node.closest('jqx-splitter-item');

        if (!splitterItem) {
            return;
        }

        const splitter = splitterItem.closest('jqx-splitter');

        if (!splitter) {
            return;
        }

        splitterItem.closest('jqx-splitter').removeChild(splitterItem);

        that._items.splice(that._items.indexOf(node), 1);

        that._removeUnneccessaryItems(splitter);

        if (that._items.filter(item => item.opened).length === 0 && !that.$.placeholderItem.parentElement) {
            that.$.itemsContainer.appendChild(that.$.placeholderItem);
        }

        node.layout = that;
        that._handleAutoSave();
        that.$.fireEvent('stateChange', { type: 'remove', item: node });
    }

    /**
    * Saves the current state of the Layout
    */
    saveState() {
        const that = this;

        if (!that.id) {
            that.warn(that.localize('noId'));
            return;
        }

        //Save to LocalStorage
        window.localStorage.setItem('jqxDockingLayout' + that.id, JSON.stringify(that.getJSONStructure()));
    }

    /**
     * Updates the content of a TabsWindow item
     * @param {any} index
     * @param {any} item
     * @param {any} position
     */
    update(item, settings) {
        const that = this;

        if (typeof item === 'number') {
            item = that._items[parseInt(item)];
        }
        else if (typeof item === 'string') {
            item = document.getElementById(item);
        }

        if (!item || !(item instanceof JQX.TabsWindow)) {
            that.error(that.localize('invalidNodeType', { elementType: that.nodeName.toLowerCase(), method: 'update' }));
            return;
        }

        if (!that.contains(item)) {
            return;
        }

        if (!settings || typeof settings !== 'object') {
            return;
        }

        if (settings.items) {
            for (let i = 0; i < settings.items.length; i++) {
                item.update(settings.items[i].index, settings.items[i].label, settings.items[i].content);
            }
        }

        if (settings.id) {
            item.id = settings.id;
        }

        if (settings.label) {
            item.label = settings.label;
        }

        item.tabCloseButtons = settings.tabCloseButtons || false;

        if (settings.headerButtons && Array.isArray(settings.headerButtons)) {
            item.headerButtons = settings.headerButtons.length === 0 ? ['close', 'autoHide'] : settings.headerButtons;
        }

        const parentSplitterItem = item.closest('jqx-splitter-item');

        if (!parentSplitterItem) {
            return;
        }

        if (item.autoHide) {
            that._autoHide(item);
        }
        else {
            parentSplitterItem.size = settings.size !== undefined ? settings.size : parentSplitterItem.size;
            parentSplitterItem.min = settings.min !== undefined ? settings.min : parentSplitterItem.min;
            parentSplitterItem.max = settings.max !== undefined ? settings.max : parentSplitterItem.max;
            parentSplitterItem.locked = settings.locked !== undefined ? settings.locked : parentSplitterItem.locked;
            parentSplitterItem.collapsible = settings.collapsible !== undefined ? settings.collapsible : parentSplitterItem.collapsible;
            parentSplitterItem.collapsed = settings.collapsed !== undefined ? settings.collapsed : parentSplitterItem.collapsed;
        }
    }

    /**
    * Autohides a TabsWindow
    */
    _autoHide(tabsWindow, position) {
        const that = this;

        if (typeof tabsWindow === 'number') {
            tabsWindow = that._items[tabsWindow];
        }
        else if (typeof tabsWindow === 'string') {
            tabsWindow = document.getElementById(tabsWindow);
        }

        if (!tabsWindow) {
            return;
        }

        if (tabsWindow instanceof JQX.TabItem) {
            const parentTabsWindow = tabsWindow.closest('jqx-tabs-window');

            if (parentTabsWindow && parentTabsWindow.items.length < 2) {
                tabsWindow = parentTabsWindow;
            }
            else {
                const tabItem = tabsWindow;

                if (parentTabsWindow) {
                    if (parentTabsWindow.autoHide && parentTabsWindow.tabPosition === position) {
                        return;
                    }

                    parentTabsWindow.removeChild(tabsWindow);
                }

                tabsWindow = that._createTabsWindowFromObject({ label: tabsWindow.label });
                tabsWindow.appendChild(tabItem);
            }
        }

        if (!(tabsWindow instanceof JQX.TabsWindow)) {
            that.error(that.localize('invalidNodeType', { elementType: that.nodeName.toLowerCase(), method: 'appendChild' }));
            return;
        }

        let splitterItem = tabsWindow.closest('jqx-splitter-item'), tabsWindowSize;
        const splitterContainer = tabsWindow.closest('jqx-splitter') || that.$.itemsContainer,
            positionDetails = that._getAutoHidePositionDetails(position, tabsWindow, splitterItem),
            autoHideSplitter = positionDetails.autoHideSplitter;

        position = positionDetails.position;

        if (tabsWindow.offsetHeight) {
            tabsWindowSize = position === 'left' || position === 'right' ? tabsWindow.offsetWidth : tabsWindow.offsetHeight;
        }

        if (!splitterItem) {
            splitterItem = document.createElement('jqx-splitter-item');
            splitterItem.appendChild(tabsWindow);
        }

        splitterItem.min = 30;

        const autoHideName = 'auto-hide-' + position;

        //Check if it's already autoHidden
        if (tabsWindow.autoHide && splitterItem.$.hasClass(autoHideName)) {
            return;
        }

        const tabsWindowIndex = that._items.indexOf(tabsWindow);

        that._items.splice(tabsWindowIndex, tabsWindowIndex > -1 ? 1 : 0);

        if (that._items.filter(item => item.opened).length === 0 && !that.$.placeholderItem.parentElement) {
            position === 'left' ? that.$.itemsContainer.insert(1, that.$.placeholderItem) : that.$.itemsContainer.appendChild(that.$.placeholderItem);
        }

        that._handleAutoHideWindow({
            position: position,
            tabsWindow: tabsWindow,
            splitterItem: splitterItem,
            autoHideName: autoHideName,
            splitterContainer: splitterContainer,
            autoHideSplitter: autoHideSplitter
        });

        autoHideSplitter.bars.map(bar => bar.hide());

        that._setAutoHidePaddings();

        const tabsWindowItems = tabsWindow.items;

        if (tabsWindowItems) {
            for (let i = 0; i < tabsWindowItems.length; i++) {
                if (!tabsWindowItems[i]._autoHideWindowSize) {
                    tabsWindowItems[i]._autoHideWindowSize = tabsWindowSize;
                }
            }
        }

        if (that.$.autoHideWindow.opened && that.$.autoHideWindow._tabsWindow) {
            that.$.autoHideWindow._tabsWindow._setAutoHideWindowSize(that.$.autoHideWindow._tabsWindow.selectedIndex);
        }

        if (that.isCompleted) {
            that._handleAutoSave();
            that.$.fireEvent('stateChange', { type: 'autoHide', item: tabsWindow });
        }
    }

    /**
     * Returns the position and the autoHideSplitter according to the position
     * @param {any} position
     */
    _getAutoHidePositionDetails(position, tabsWindow, splitterItem) {
        const that = this,
            splitterContainer = tabsWindow.closest('jqx-splitter') || that.$.itemsContainer,
            index = splitterContainer ? splitterContainer._items.indexOf(splitterItem) : 0;
        let autoHideSplitter;

        switch (position) {
            case 'top':
            case 'bottom':
                autoHideSplitter = that.$.horizontalHiddenItemsContainer;
                break;
            case 'left':
            case 'right':
                autoHideSplitter = that.$.verticalHiddenItemsContainer;
                break;
            default:
                if (splitterContainer.orientation === 'vertical') {
                    autoHideSplitter = that.$.verticalHiddenItemsContainer;

                    const autoHiddenItems = autoHideSplitter.items.filter(item => item.className.indexOf('auto-hide-') > -1);

                    if (autoHiddenItems.length === 1 && that._items.length === 1) {
                        position = autoHiddenItems[0].$.hasClass('auto-hide-right') ? 'right' : 'left';
                    }
                    else {
                        position = index >= splitterContainer.items.length / 2 ? 'right' : 'left';
                    }

                }
                else {
                    autoHideSplitter = that.$.horizontalHiddenItemsContainer;

                    const autoHiddenItems = autoHideSplitter.items.filter(item => item.className.indexOf('auto-hide-') > -1);

                    if (autoHiddenItems.length === 1 && that._items.length === 1) {
                        position = autoHiddenItems[0].$.hasClass('auto-hide-bottom') ? 'bottom' : 'top';
                    }
                    else {
                        position = index >= splitterContainer.items.length / 2 ? 'bottom' : 'top';
                    }
                }

                break;
        }

        return { autoHideSplitter: autoHideSplitter, position: position };
    }

    /**
     * Places the target Window in a new AutoHideWindow or an already existing one
     * @param {any} details
     */
    _handleAutoHideWindow(details) {
        const that = this,
            autoHideName = details.autoHideName,
            splitterItem = details.splitterItem,
            splitterContainer = details.splitterContainer,
            position = details.position,
            autoHideSplitter = details.autoHideSplitter;
        let tabsWindow = details.tabsWindow,
            autoHiddenItem = that.getElementsByClassName(autoHideName)[0],
            size = 'offset' + (position === 'left' || position === 'right' ? 'Width' : 'Height');

        splitterItem.locked = false;

        if (autoHiddenItem) {
            const tabItems = [].slice.call(tabsWindow.isCompleted ? tabsWindow.items : tabsWindow.children),
                autoHideTabsWindow = autoHiddenItem.querySelector('jqx-tabs-window'),
                autoHiddenItemsCount = autoHideTabsWindow.items.length;

            for (let i = 0; i < tabItems.length; i++) {
                autoHideTabsWindow.insert(autoHiddenItemsCount, { node: tabItems[i] });
                tabItems[i]._autoHideWindowSize = tabsWindow[size];
            }

            if (splitterItem.parentElement) {
                splitterContainer.removeChild(splitterItem);
            }

            that._removeUnneccessaryItems(splitterContainer);
            tabsWindow = autoHideTabsWindow;
        }
        else {
            if (splitterContainer && splitterContainer.contains(splitterItem)) {
                splitterContainer.removeChild(splitterItem);
            }

            //Remembers the tabPosition before autoHidding
            if (that._initializingItems || !tabsWindow.autoHide) {
                tabsWindow._originalTabPosition = tabsWindow.tabPosition;
                tabsWindow._originalTextOrientation = tabsWindow.tabTextOrientation;
                tabsWindow._originalLocked = tabsWindow.locked;
            }

            tabsWindow.autoHideWindow = that.$.autoHideWindow;
            tabsWindow.autoHide = tabsWindow.allowToggle = true;

            tabsWindow.selectedIndex = null;

            if (tabsWindow.$.tabsElement && tabsWindow.$.tabsElement.selectedIndex !== tabsWindow.selectedIndex) {
                tabsWindow.$.tabsElement.selectedIndex = tabsWindow.selectedIndex;
            }

            tabsWindow.tabTextOrientation = position === 'right' || position === 'left' ? 'vertical' : 'horizontal';
            tabsWindow.tabPosition = position;
            tabsWindow.style.top = tabsWindow.style.left = '';
            tabsWindow.style.width = tabsWindow.style.height = '';
            tabsWindow.opened = true;

            tabsWindow.resizeMode = 'none';

            //Make sure no other auto-hide classes are added
            for (let c = 0; c < splitterItem.classList.length; c++) {
                if (splitterItem.classList[c].indexOf('auto-hide-') > -1) {
                    splitterItem.$.removeClass(splitterItem.classList[c]);
                }
            }

            splitterItem.$.addClass(autoHideName);
            splitterItem.style.paddingLeft = splitterItem.style.paddingRight = splitterItem.style.paddingTop = splitterItem.style.paddingBottom = '';

            if (splitterItem.min) {
                splitterItem.min = '';
            }

            that._removeUnneccessaryItems(splitterContainer);

            if (position === 'top' || position === 'left') {
                autoHideSplitter.insert(0, splitterItem);
            }
            else {
                autoHideSplitter.appendChild(splitterItem);
            }

            autoHideSplitter.autoFitMode = 'proportional';

            //Specific browser bug fixes with height: auto and textOrientation: vertical
            if (JQX.Utilities.Core.Browser.Safari && (position === 'left' || position === 'right')) {
                const tabStrip = tabsWindow.querySelector('.jqx-tab-strip');

                tabsWindow.size = tabStrip.offsetWidth;
            }
            else {
                if (JQX.Utilities.Core.Browser.Firefox && (position === 'top' || position === 'bottom')) {
                    const tabStrip = tabsWindow.querySelector('.jqx-tab-strip');

                    tabsWindow.size = tabStrip.offsetHeight;
                }

                tabsWindow.size = 'auto';
            }

            //Refreshes the min property
            if (tabsWindow.min) {
                tabsWindow.min = '';
            }

            tabsWindow.min = 30;

            tabsWindow.locked = true;
            autoHideSplitter.autoFitMode = 'end';
        }
    }

    /**
    * AutoHideContainer Close event handler
    */
    _autoHideWindowCloseHandler() {
        const that = this,
            targetTabsWindow = that.$.autoHideWindow._tabsWindow,
            scrollElement = document.scrollingElement || document.documentElement,
            x = scrollElement.scrollLeft,
            y = scrollElement.scrollTop;

        targetTabsWindow._moveContent(targetTabsWindow._autoHideWindow.items[0], targetTabsWindow._autoHideWindow._tab);

        if (!that.$.autoHideWindow.opened) {
            targetTabsWindow.selectedIndex = null;

            if (document.activeElement !== targetTabsWindow.$.tabsElement) {
                targetTabsWindow.$.tabsElement.focus();
                window.scrollTo(x, y);
            }

            return;
        }

        if (!targetTabsWindow.allowToggle) {
            return;
        }

        if (targetTabsWindow.$.tabsElement.selectedIndex !== null) {
            targetTabsWindow.select(targetTabsWindow.$.tabsElement.selectedIndex);

            if (document.activeElement !== targetTabsWindow.$.tabsElement) {
                targetTabsWindow.$.tabsElement.focus();
                window.scrollTo(x, y);
            }
        }
    }

    /**
     * AutoHideWindow ResizeEnd event handler
     */
    _autoHideWindowResizeEndHandler(event) {
        const autoHideWindow = event.target,
            dimension = autoHideWindow.resizeMode === 'left' || autoHideWindow.resizeMode === 'right' ? 'width' : 'height';

        if (autoHideWindow._tab) {
            autoHideWindow._tab._autoHideWindowSize = event.detail[dimension];
        }
    }

    /**
     * Cancels a drag operation and returns the item ot it's initial position. Used when dragging operation is interupted
     */
    _cancelDragOperation(noEndDrag) {
        const that = this;

        that.removeAttribute('dragged');
        that._dragDetails.windowFeedback.removeAttribute('tabs-window-dragged');
        that._dragDetails.windowFeedback.removeAttribute('ontop');
        that._returnItemToOrigin(that._dragDetails.windowFeedback);
        that._noStateChangeFiring = true;

        if (!noEndDrag) {
            that._endDrag();
        }
    }

    /**
    * Creates a new TabsWindow from an Object
    */
    _createTabsWindowFromObject(settings, retrieveContent) {
        const tabsWindow = document.createElement('jqx-tabs-window');
        let item, headerButtons = ['close', 'autoHide'];

        tabsWindow.layout = this;

        if (settings.id) {
            tabsWindow.id = settings.id;
        }

        if (settings.disabled) {
            tabsWindow.disabled = settings.disabled;
        }

        if (settings.label) {
            tabsWindow.label = settings.label;
        }

        if (settings.headerPosition) {
            tabsWindow.headerPosition = settings.headerPosition;
        }

        if (settings.tabCloseButtons) {
            tabsWindow.tabCloseButtons = settings.tabCloseButtons;
        }

        if (settings.dropPosition) {
            tabsWindow.dropPosition = settings.dropPosition;
        }

        if (settings.resizeMode) {
            tabsWindow.resizeMode = settings.resizeMode;
        }

        if (!this.hasAnimation) {
            tabsWindow.animation = 'none';
        }

        tabsWindow.draggable = settings.draggable !== undefined ? settings.draggable : true;
        tabsWindow.floatable = settings.floatable !== undefined ? settings.floatable : true;
        tabsWindow.tabCloseButtons = settings.tabCloseButtons ? settings.tabCloseButtons : tabsWindow.tabCloseButtons;

        if (settings.autoHide) {
            tabsWindow.autoHideWindow = this.$.autoHideWindow;
            tabsWindow.autoHide = tabsWindow.allowToggle = settings.autoHide;
            tabsWindow.autoHidePosition = settings.autoHidePosition;
        }
        else if (settings.undocked) {
            headerButtons = ['close', 'maximize', 'minimize'];
            tabsWindow.undocked = settings.undocked;
            tabsWindow.position = {
                top: settings.top ? ((settings.top + '').indexOf('%') > -1 ? settings.top : parseFloat(settings.top) + 'px') : undefined,
                left: settings.left ? ((settings.left + '').indexOf('%') > -1 ? settings.left : parseFloat(settings.left) + 'px') : undefined,
                width: settings.width,
                height: settings.height
            };
        }

        tabsWindow.tabPosition = settings.tabPosition || tabsWindow.tabPosition;
        tabsWindow.opened = tabsWindow.pinned = true;

        if (settings.headerButtons) {
            headerButtons = settings.headerButtons;
        }

        if (!settings.headerButtons || Array.isArray(settings.headerButtons) && settings.headerButtons.length === 0) {
            headerButtons = ['close', 'autoHide'];
        }

        tabsWindow.headerButtons = headerButtons;
        tabsWindow.size = settings.size || '';
        tabsWindow.max = settings.max || '';
        tabsWindow.min = settings.min ? settings.min : 30;
        tabsWindow.locked = settings.locked || false;
        tabsWindow.collapsible = settings.collapsible || false;
        tabsWindow.collapsed = settings.collapsed || false;

        if (settings.items && Array.isArray(settings.items)) {
            for (let i = 0; i < settings.items.length; i++) {
                if (retrieveContent && settings.items[i].instance) {
                    item = settings.items[i].instance;
                    item.index = null;
                    item.id = settings.items[i].id || '';
                }
                else {
                    item = document.createElement('jqx-tab-item');
                    item.label = settings.items[i].label ? settings.items[i].label : '';
                    item.id = settings.items[i].id || '';

                    //Get Content from that.layout property
                    item.content = settings.items[i].content ? settings.items[i].content : '';
                    item.selected = settings.items[i].selected ? settings.items[i].selected : false;
                    tabsWindow._isItemSelected = true;
                }

                item.draggable = settings.items[i].draggable !== undefined ? settings.items[i].draggable : true;
                item.floatable = settings.items[i].floatable !== undefined ? settings.items[i].floatable : true;
                if (settings.items[i].id) {
                    item.id = settings.items[i].id;
                }

                tabsWindow.appendChild(item);
            }
        }

        return tabsWindow;
    }

    /**
     * Creates Layout items from Array
     * @param {any} source
     * @param {any} retrieveContenent
     */
    _createItemsFromArray(source, retrieveContenent) {
        const that = this;
        let layoutConfig = source;
        const layoutLength = layoutConfig.length;

        that._removeAll(true);

        that._initializingItems = true;

        //Remove all undocked windows
        const undockedItems = that.undockedItems;

        for (let i = 0; i < undockedItems.length; i++) {
            undockedItems[i].layout = null;
            undockedItems[i].parentElement.removeChild(undockedItems[i]);
        }

        //Check if itemContainer settings are applied
        if (layoutLength === 1 && layoutConfig[0].type && layoutConfig[0].type.toLowerCase() === 'layoutgroup') {
            that.$.itemsContainer.orientation = layoutConfig[0].orientation || that.$.itemsContainer.orientation;
            that.$.itemsContainer.liveResize = layoutConfig[0].liveResize || that.$.itemsContainer.liveResize;
            that.$.itemsContainer.resizeMode = layoutConfig[0].resizeMode || that.$.itemsContainer.resizeMode;
            layoutConfig = layoutConfig[0].items;
        }

        let item;

        //Allows to style the items through CSS on element initialization
        that.$.itemsContainer.autoFitMode = 'end';

        for (let i = 0; i < layoutConfig.length; i++) {
            item = that._createLayoutItem(layoutConfig[i], retrieveContenent);

            if (item) {
                if (that.$.placeholderItem.parentElement) {
                    that.$.itemsContainer.removeChild(that.$.placeholderItem);
                }

                that.$.itemsContainer.appendChild(item);
            }
        }

        if (that._items.filter(item => item.opened).length === 0) {
            if (!that.$.placeholderItem.parentElement) {
                that.$.itemsContainer.appendChild(that.$.placeholderItem);
            }
        }
        else if (that.$.placeholderItem.parentElement) {
            that.$.itemsContainer.removeChild(that.$.placeholderItem);
        }

        //Restore the desired autoFitMode
        that.$.itemsContainer.autoFitMode = 'proportional';

        delete that._initializingItems;
    }

    /**
     * Creates the Layout items
     * @param {any} settings
     * @param {any} retrieveContent
     */
    _createLayoutItem(settings, retrieveContent) {
        if (!settings) {
            return;
        }

        const that = this,
            splitteritem = document.createElement('jqx-splitter-item');
        let item;

        if (settings.type && settings.type.toLowerCase() === 'layoutgroup') {
            //Create a splitter
            item = document.createElement('jqx-splitter');
            item.autoFitMode = 'proportional';

            if (settings.id) {
                item.id = settings.id;
            }

            if (settings.orientation) {
                item.orientation = settings.orientation;
            }

            if (settings.resizeMode) {
                item.resizeMode = settings.resizeMode;
            }

            item.liveResize = that.liveResize;
            item.resizeStep = that.resizeStep;

            let newItem;

            for (let i = 0; i < settings.items.length; i++) {
                newItem = that._createLayoutItem(settings.items[i], retrieveContent);

                if (newItem) {
                    item.appendChild(newItem);
                }
            }

            if (!item.querySelector('jqx-splitter-item')) {
                return;
            }
        }
        else {
            //Create a TabsWindow item
            item = that._createTabsWindowFromObject(settings.type && settings.type.toLowerCase() === 'layoutgroup' ? settings.items[0] : settings, retrieveContent);

            if (item.autoHide) {
                that._autoHide(item, item.autoHidePosition);
                delete item.autoHidePosition;
                return;
            }
            else if (item.undocked) {
                that.undock(item);
                document.body.appendChild(item);
                item.opened = true;
                item.pinned = false;
                item.layout = that;

                if (item.position) {
                    item.style.left = item.position.left;
                    item.style.top = item.position.top;
                    item.style.width = item.position.width;
                    item.style.height = item.position.height;
                    delete item.position;
                }

                if (item.size) {
                    item.style.left = item.position.left;
                    item.style.top = item.position.top;
                }
                return;
            }

            that._items.push(item);
        }

        splitteritem.size = settings.size || '';
        splitteritem.max = settings.max || '';
        splitteritem.min = settings.min || 30;
        splitteritem.locked = settings.locked || false;
        splitteritem.collapsible = settings.collapsible || false;
        splitteritem.collapsed = settings.collapsed || false;

        splitteritem.appendChild(item);
        return splitteritem;
    }

    /**
     * Creates a JSON Array with the item structure of the Layout
     * @param {any} splitter
     */
    _createLayoutStructure(splitter, noInstance) {
        const that = this,
            structure = [];
        let items = splitter._items,
            item, splitterItem;
        const firstItemChild = items[0].$.content.children[0];

        function getItem(container) {
            let item = container.firstElementChild;

            while (item) {
                if (item instanceof JQX.Splitter) {
                    return item;
                }
                else if (item instanceof JQX.TabsWindow) {
                    return item;
                }

                item = item.nextElementSibling;
            }
        }

        if (items.length === 1 && firstItemChild instanceof JQX.Splitter) {
            items = firstItemChild._items;

            if (splitter === that.$.itemsContainer) {
                that.$.itemsContainer.orientation = firstItemChild.orientation;
            }
        }

        for (let i = 0; i < items.length; i++) {
            if (items[i] === that.$.placeholderItem) {
                continue;
            }

            splitterItem = getItem(items[i].$.content);

            if (splitterItem instanceof JQX.TabsWindow) {
                item = that._createTabsWindowStructure(splitterItem, noInstance);
            }
            else if (splitterItem instanceof JQX.Splitter) {

                //Avoids unneccessarly complex structures like a single splitter in a splitter parent
                while (splitterItem._items.length === 1 && splitterItem._items[0].$.content.children[0] instanceof JQX.Splitter) {
                    splitterItem = splitterItem._items[0].$.content.children[0];
                }

                //Avoids unnecesssary splitter creations with only 1 item inside
                if (splitterItem._items.length === 1) {
                    item = that._createTabsWindowStructure(splitterItem._items[0].$.content.children[0], noInstance);
                }
                else {
                    item = {
                        type: 'LayoutGroup',
                        items: that._createLayoutStructure(splitterItem, noInstance),
                        orientation: splitterItem.orientation
                    };
                }

                if (splitterItem.id) {
                    item.id = splitterItem.id
                }

                //Splitter settings
                if (splitterItem.resizeMode !== 'adjacent') {
                    item.resizeMode = splitterItem.resizeMode;
                }

                if (splitterItem.resizeStep !== 5) {
                    item.resizeStep = splitterItem.resizeStep;
                }

                if (splitterItem.liveResize) {
                    item.resizeStep = splitterItem.liveResize;
                }
            }

            //SplitterItem settings
            item.size = items[i][splitter._measurements.size];

            if (items[i].locked) {
                item.locked = true;
            }

            if (items[i].min) {
                item.min = items[i].min;
            }

            if (items[i].max) {
                item.max = items[i].max;
            }

            structure.push(item);
        }

        return structure;
    }

    /**
     * Cretes the JSON structure for a TabsWindow
     * @param {any} tabsWindow
     */
    _createTabsWindowStructure(tabsWindow, noInstance) {
        function createTabItemStructure(tabItem) {
            const tabItemStructure = {};

            tabItemStructure.type = 'LayoutPanelItem';
            tabItemStructure.label = tabItem.label || '';

            if (tabItem.selected) {
                tabItemStructure.selected = tabItem.selected;
            }

            if (tabItem.disabled) {
                tabItemStructure.disabled = tabItem.disabled;
            }

            tabItemStructure.draggable = tabItem.draggable !== undefined ? tabItem.draggable : true;
            tabItemStructure.floatable = tabItem.floatable !== undefined ? tabItem.floatable : true;

            if (!noInstance) {
                tabItemStructure.instance = tabItem;
            }

            if (tabItem.id) {
                tabItemStructure.id = tabItem.id;
            }

            return tabItemStructure;
        }

        const item = { type: 'LayoutPanel' };

        if (tabsWindow.id) {
            item.id = tabsWindow.id;
        }

        if (tabsWindow.disabled) {
            item.disabled = tabsWindow.disabled;
        }

        if (tabsWindow.label) {
            item.label = tabsWindow.label;
        }

        if (tabsWindow.autoHide) {
            item.autoHide = tabsWindow.autoHide;
            item.autoHidePosition = tabsWindow.tabPosition;
        }
        else if (tabsWindow.tabPosition !== 'top') {
            item.tabPosition = tabsWindow.tabPosition;
        }

        if (!tabsWindow.closest('jqx-docking-layout')) {
            item.undocked = true;
            item.top = tabsWindow.style.top;
            item.left = tabsWindow.style.left;
            item.width = tabsWindow.style.width;
            item.height = tabsWindow.style.height;
        }

        if (tabsWindow.dropPosition && tabsWindow.dropPosition[0] !== 'all') {
            item.dropPosition = tabsWindow.dropPosition;
        }

        item.draggable = tabsWindow.draggable !== undefined ? tabsWindow.draggable : true;
        item.floatable = tabsWindow.floatable !== undefined ? tabsWindow.floatable : true;

        if (tabsWindow.floatable !== undefined) {
            item.floatable = tabsWindow.floatable;
        }

        if (tabsWindow.resizeMode !== 'none') {
            item.resizeMode = tabsWindow.resizeMode;
        }

        if (tabsWindow.items) {
            item.items = [];

            for (let i = 0; i < tabsWindow.items.length; i++) {
                item.items.push(createTabItemStructure(tabsWindow.items[i]));
            }
        }

        return item;
    }

    /**
    * Called when the tab strip of the Tab has been resized via inline JS. Check function called _fixTabStripNotChrome() in jqxtabs.js
    */
    _containerTabStripResizeHandler(event) {
        const that = this,
            splitter = event.target.closest('jqx-splitter');

        if (splitter === that.$.horizontalHiddenItemsContainer || splitter === that.$.verticalHiddenItemsContainer) {
            splitter._resizeEventHandler();
            that._setAutoHidePaddings();
        }
    }

    /**
    * Docks a TabsWindow
    */
    _dock(tabsWindow, position) {
        const that = this;

        if (typeof tabsWindow === 'number') {
            tabsWindow = that._items[tabsWindow];
        }
        else if (typeof tabsWindow === 'string') {
            tabsWindow = document.getElementById(tabsWindow);
        }

        if (!tabsWindow) {
            return;
        }

        let newTabsWindow;

        if (tabsWindow instanceof JQX.TabItem) {
            const tabItemDockingDetails = that._handleTabItemDocking(tabsWindow);

            tabsWindow = tabItemDockingDetails.tabsWindow;
            newTabsWindow = tabItemDockingDetails.newTabsWindow;
        }
        else if (typeof tabsWindow === 'object' && !(tabsWindow instanceof HTMLElement)) {
            tabsWindow = that._createTabsWindowFromObject(tabsWindow);
        }
        if (!(tabsWindow instanceof JQX.TabsWindow) || !tabsWindow.autoHide) {
            if (that._items.indexOf(tabsWindow) < 0) {
                newTabsWindow.autoHide = false;

                //TODO: Check if lastItem and if it is used the tabsWindow instead
                if (tabsWindow.items.length === 0 && that.snapMode === 'simple') {
                    tabsWindow.parentElement.removeChild(tabsWindow);
                }

                //Dock inside the Layout
                if (!position) {
                    that.appendChild(newTabsWindow);
                }
                else {
                    that._insert(-1, newTabsWindow, position ? 'layout-' + position : undefined);
                }
            }

            return;
        }

        if (!that.contains(tabsWindow)) {
            return;
        }

        const splitterItem = tabsWindow.closest('jqx-splitter-item'),
            splitter = tabsWindow.closest('jqx-splitter'),
            isLastItem = splitterItem.nextElementSibling ? false : true;

        if (!position) {
            if (splitter.orientation === 'horizontal') {
                position = isLastItem ? 'bottom' : 'top';
            }
            else {
                position = isLastItem ? 'right' : 'left';
            }
        }

        if (tabsWindow.items.length === 0) {
            splitterItem.closest('jqx-splitter').removeChild(splitterItem);
        }

        if (newTabsWindow) {
            tabsWindow = newTabsWindow;
        }

        if (tabsWindow.autoHide) {
            if (that.$.verticalHiddenItemsContainer.contains(tabsWindow)) {
                that.$.verticalHiddenItemsContainer.removeChild(tabsWindow.closest('jqx-splitter-item'))
            }
            else if (that.$.horizontalHiddenItemsContainer.contains(tabsWindow)) {
                that.$.horizontalHiddenItemsContainer.removeChild(tabsWindow.closest('jqx-splitter-item'))
            }

            tabsWindow.tabPosition = tabsWindow._originalTabPosition || 'top';
            delete tabsWindow._originalTabPosition;
        }

        that._setDockedItemsHeaderButtons(tabsWindow);

        //Reset the proeprties of the Window
        tabsWindow.autoHide = tabsWindow.allowToggle = tabsWindow.maximized = tabsWindow.minimized = tabsWindow.collapsed = tabsWindow.locked = false;
        tabsWindow.tabTextOrientation = 'horizontal';

        that.$.autoHideWindow.close();
        that._insert(-1, tabsWindow, 'layout-' + position);
        that._setAutoHidePaddings();
        delete that._dockingAutoHideTabItem;
    }

    /**
     * Handles the dokcing of TabItems. Called in _dock method.
     * @param {any} tabsWindow
     */
    _handleTabItemDocking(tabsWindow) {
        const that = this,
            parentTabsWindow = tabsWindow.closest('jqx-tabs-window');
        let newTabsWindow;

        if (parentTabsWindow) {
            const autoHideWindow = that.$.autoHideWindow;

            if (!parentTabsWindow.autoHide) {
                return { tabsWindow: parentTabsWindow, newTabsWindow: parentTabsWindow };
            }

            that._dockingAutoHideTabItem = true;

            newTabsWindow = parentTabsWindow.items.length === 1 ? parentTabsWindow : document.createElement('jqx-tabs-window');

            delete tabsWindow._autoHideWindowSize;

            newTabsWindow.size = autoHideWindow.resizeMode === 'left' || autoHideWindow.resizeMode === 'right' ? autoHideWindow.offsetWidth : autoHideWindow.offsetHeight;
            parentTabsWindow.removeChild(tabsWindow);

            if (parentTabsWindow.items.length === 0 && !newTabsWindow.id) {

                if (!that.contains(parentTabsWindow)) {
                    parentTabsWindow.parentElement.removeChild(parentTabsWindow);
                }
            }

            //Copy settings to the new Window
            newTabsWindow.tabCloseButtons = parentTabsWindow.tabCloseButtons;
            newTabsWindow.dropPosition = parentTabsWindow.dropPosition;
            newTabsWindow.draggable = newTabsWindow.draggable;
            newTabsWindow.floatable = newTabsWindow.floatable;
        }

        if (!newTabsWindow) {
            newTabsWindow = document.createElement('jqx-tabs-window');
        }

        if (!that.hasAnimation) {
            newTabsWindow.animation = 'none';
        }

        newTabsWindow.min = 30;
        newTabsWindow.opened = newTabsWindow.pinned = newTabsWindow.autoHide = true;
        newTabsWindow.style.maxWidth = newTabsWindow.style.maxHeight = '';
        newTabsWindow._originalTabPosition = parentTabsWindow._originalTabPosition || undefined;
        newTabsWindow._originalTextOrientation = parentTabsWindow._originalTextOrientation || undefined;

        if (newTabsWindow !== parentTabsWindow) {
            delete parentTabsWindow._originalTabPosition;
            delete parentTabsWindow._originalTextOrientation;
        }

        newTabsWindow.label = tabsWindow.label;
        newTabsWindow.appendChild(tabsWindow);
        tabsWindow = parentTabsWindow;

        return { tabsWindow: tabsWindow, newTabsWindow: newTabsWindow };
    }

    /**
    * jqxTabsWindow Dock event handler
    * @param {any} event
    */
    _dockEventHandler(event) {
        const that = this;
        let tabsWindow = event.target;

        if (tabsWindow._tabsWindow) {
            tabsWindow = tabsWindow._tabsWindow;
        }

        if (tabsWindow.autoHide) {
            that._dock(tabsWindow.items[tabsWindow.selectedIndex]);
        }
        else {
            that._autoHide(tabsWindow, that._items.indexOf(tabsWindow) < (that._items.length - 1) / 2);
        }
    }

    /**
     * Down Event Handler
     * @param {any} event
     */
    _documentDownHandler(event) {
        const that = this;
        let target;

        target = event.originalEvent.target.closest('.jqx-window');

        if (that.$.autoHideWindow._tabsWindow && (!target || (target !== that.$.autoHideWindow && target !== that.$.autoHideWindow._tabsWindow))) {
            that.$.autoHideWindow._tabsWindow.selectedIndex = null;
        }

        if (that._dragDetails) {
            that._cancelDragOperation();
            return;
        }

        //Check for TabsWindow because all TabsWindows should be abble to be inserted into the Layout
        if (!(target instanceof JQX.TabsWindow) || !that.draggable || that.disabled) {
            return;
        }

        if (that._dragDetails || target.maximized || target.minimized || (!JQX.Utilities.Core.isMobile && event.which !== 1) ||
            (target._dragDetails && target._dragDetails.type === 'resize' && target._dragDetails.started)) {
            return;
        }

        that._dragDetails = {};

        target = event.originalEvent.target.closest('.jqx-header-section') || event.originalEvent.target.closest('.jqx-tab-label-container');

        if (target && that.snapMode === 'simple' && target.classList.contains('jqx-header-section')) {
            target = undefined;
        }

        that._dragDetails.windowFeedback = that.$.tabsWindowFeedback;

        if (target) {
            that._dragDetails.selectedTabsWindow = target.closest('jqx-tabs-window');

            if (that._dragDetails.selectedTabsWindow === that.$.autoHideWindow) {
                that._dragDetails.selectedItem = that.$.autoHideWindow._tabsWindow.closest('jqx-splitter-item');
            }
            else {
                that._dragDetails.selectedItem = target.closest('jqx-splitter-item');
            }

            if (!that._dragDetails.selectedTabsWindow || !that._dragDetails.selectedTabsWindow.draggable || that._dragDetails.selectedTabsWindow.layout !== that) {
                that._dragDetails = undefined;
                return;
            }

            that._dragDetails.offset = { x: 0, y: 0 };

            that._dragDetails.selectedTabLabel = target;
            that._dragDetails.x = event.pageX;
            that._dragDetails.y = event.pageY;

            if (that._dragDetails.selectedTabLabel.$.hasClass('jqx-header-section')) {
                if (!that._dragDetails.selectedItem && that._dragDetails.selectedTabsWindow.pinned) {
                    that._dragDetails = undefined;
                    return;
                }

                that._dragDetails.windowFeedback = that._dragDetails.selectedTabsWindow;

                const targetRect = target.getBoundingClientRect();

                that._dragDetails.offset.x = event.clientX - targetRect.left;
                that._dragDetails.offset.y = event.clientY - targetRect.top;
            }
            else {
                if (!that._dragDetails.selectedTabLabel.tab || (that._dragDetails.selectedTabLabel.tab.draggable !== undefined && !that._dragDetails.selectedTabLabel.tab.draggable)) {
                    that._dragDetails = undefined;
                    return;
                }

                if (that._dragDetails.selectedTabsWindow.items.length === 1) {
                    that._dragDetails.windowFeedback = that._dragDetails.selectedTabsWindow;
                    that._dragDetails.windowFeedback.floatable = that._dragDetails.selectedTabsWindow.items[0].floatable;
                }
            }
        }

        that._items.map(item => item.removeAttribute('ontop'));


        if (that._dragDetails.windowFeedback !== that.$.autoHideWindow) {
            that._dragDetails.windowFeedback.setAttribute('ontop', '');
        }
    }

    /**
    * Document Move Event Handler
    * @param {any} event
    */
    _documentMoveHandler(event) {
        const that = this,
            target = JQX.Utilities.Core.isMobile ? document.elementFromPoint(event.pageX - window.pageXOffset, event.pageY - window.pageYOffset) : event.originalEvent.target;

        if (that.disabled || !that._dragDetails || (that._dragDetails && !that._dragDetails.selectedTabsWindow) || !target) {
            return;
        }

        if (Math.abs(event.pageX - that._dragDetails.x) <= 5 && Math.abs(event.pageY - that._dragDetails.y) <= 5) {
            return;
        }

        //Keep starting x,y scoll cordinates
        const scrollElement = document.scrollingElement || document.documentElement,
            x = scrollElement.scrollLeft,
            y = scrollElement.scrollTop,
            selectedTabsWindow = that._dragDetails.selectedTabsWindow;

        that._dragDetails.isInsideTheLayout = target.closest && target.closest('jqx-docking-layout') === that;
        that._dragDetails.started = true;

        if (that._dragDetails.windowFeedback === that.$.autoHideWindow) {
            const selectedTabsWindowRect = that._dragDetails.selectedTabsWindow.getBoundingClientRect();
            let newTabsWindow;

            if (that.$.autoHideWindow._tabsWindow.items.length === 1) {
                newTabsWindow = that.$.autoHideWindow._tabsWindow;
            }
            else {
                newTabsWindow = document.createElement('jqx-tabs-window');
                newTabsWindow.min = 30;
                newTabsWindow.layout = that;
            }

            newTabsWindow.style.width = selectedTabsWindowRect.width + 'px';
            newTabsWindow.style.height = selectedTabsWindowRect.height + 'px';
            newTabsWindow.style.left = selectedTabsWindowRect.left + 'px';
            newTabsWindow.style.top = selectedTabsWindowRect.top + 'px';

            newTabsWindow.setAttribute('ontop', '');
            that._dragDetails.windowFeedback = newTabsWindow;
            that.$.autoHideWindow.$.addClass('no-transition');
            that.$.autoHideWindow.close();
            that.$.autoHideWindow.$.removeClass('no-transition');
        }

        that._setDragDetailsOnMove(target);

        that.$.autoHideWindow.close();

        if (!that._dragDetails.windowFeedback.classList.contains('jqx-tabs-window-feedback')) {
            that._handleWindowOnDrag();
        }
        else {
            if (!that._dragDetails._parentInfo) {
                that._dragDetails._parentInfo = {
                    closestItem: selectedTabsWindow,
                    position: that._originalTabIndex || that._dragDetails.selectedTabLabel.tab.index
                };

                that._originalTabIndex = undefined;
            }

            if (that._dragDetails.windowFeedback.parentElement !== document.body) {
                document.body.appendChild(that._dragDetails.windowFeedback);
            }

            if (that._dragDetails.selectedItem) {
                const closestSplitter = that._dragDetails.selectedItem.closest('jqx-splitter');

                if (!that._dragDetails.windowFeedback.size && closestSplitter) {
                    that._dragDetails.windowFeedback.size = that._dragDetails.selectedTabsWindow[closestSplitter._measurements.size];
                }
            }
        }

        if (!that._dragDetails.selectedTabLabel.classList.contains('jqx-header-section')) {
            that._dragDetails.windowFeedback.setAttribute('tabs-window-dragged', '');
        }

        if (that._dragDetails.windowFeedback.hasAttribute('tabs-window-dragged') || that._dragDetails.selectedTabsWindow === that.$.autoHideWindow ||
            (that._dragDetails._parentInfo && typeof (that._dragDetails._parentInfo.position) === 'string')) {
            that._dragDetails.windowFeedback.style.left = (event.pageX - that._dragDetails.offset.x) + 'px';
            that._dragDetails.windowFeedback.style.top = (event.pageY - that._dragDetails.offset.y) + 'px';
            that._setWindowFeedbackSize();
        }

        that._dragDetails.windowFeedback.opened = true;

        if (document.activeElement !== that) {
            that.focus();
            window.scrollTo(x, y);
        }

        const tabHeader = that._dragDetails.hoveredTabsWindow ? target.closest('.jqx-tabs-header-section') : undefined;

        if (tabHeader) {
            that._dragDetails.hoveredTabArea = tabHeader;
        }
        else {
            that._dragDetails.hoveredTabArea = that._dragDetails.hoveredTabsWindow && target.closest('.jqx-tabs-content-section') ?
                that._dragDetails.hoveredTabsWindow.$.tabsElement.$.tabContentSection : that._dragDetails.hoveredTabsWindow;
        }

        //Snapping handler
        that._setSnappingMarkers(event, tabHeader);
    }

    /**
     * Sets additional dragDetails on DocumentMove. Used in _documentMoveHandler
     * @param {any} target
     */
    _setDragDetailsOnMove(target) {
        const that = this;

        if (!that.hasAttribute('dragged')) {
            //Avoid page scrollbar appearing
            that._originalBodyOverflow = { overflowX: document.body.style.overflowX, overflowY: document.body.style.overflowY, overflow: document.body.style.overflow };

            const isVerticalScrollable = (document.scrollingElement || document.documentElement).scrollHeight > document.documentElement.clientHeight,
                isHorizontalScrollable = (document.scrollingElement || document.documentElement).scrollWidth > document.documentElement.clientWidth;
            let selectedTabsWindow = that._dragDetails.selectedTabsWindow;

            document.body.style.overflow = document.body.style.overflowX = document.body.style.overflowY = '';

            if (isVerticalScrollable && !isHorizontalScrollable) {
                document.body.style.overflowX = 'hidden';
            }
            else if (isHorizontalScrollable && !isVerticalScrollable) {
                document.body.style.overflowY = 'hidden';
            }
            else if (!isHorizontalScrollable && !isVerticalScrollable) {
                document.body.style.overflow = 'hidden';
            }

            if (that._dragDetails.windowFeedback.$.hasClass('jqx-tabs-window-feedback') || selectedTabsWindow === that.$.autoHideWindow) {
                const tabItem = that._dragDetails.selectedTabLabel.tab || that.$.autoHideWindow._tab;
                let feedbackWindow = that.$.tabsWindowFeedback

                if (selectedTabsWindow === that.$.autoHideWindow) {
                    selectedTabsWindow = that.$.autoHideWindow._tabsWindow;
                    feedbackWindow = that._dragDetails.windowFeedback;
                    feedbackWindow.label = tabItem.label;
                    feedbackWindow.floatable = tabItem.floatable;
                }

                //Prevents touchmove event from braking on iOS
                if (JQX.Utilities.Core.isMobile && !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform)) {
                    that._dragDetails.selectedTabLabel._lazyRemove = true;
                }

                if (tabItem.parentElement) {
                    selectedTabsWindow.removeChild(tabItem);
                }

                that._originalTabIndex = tabItem.index;

                feedbackWindow.appendChild(tabItem);

                const draggedWindow = that._dragDetails.selectedTabsWindow;

                if (draggedWindow === that.$.autoHideWindow) {
                    if (draggedWindow._tabsWindow.items.length > 1) {
                        feedbackWindow.tabPosition = draggedWindow.tabPosition;
                        feedbackWindow.tabTextOrientation = draggedWindow._originalTextOrientation || draggedWindow.tabTextOrientation;
                    }
                }
                else {
                    const isAutoHide = draggedWindow.autoHide;

                    feedbackWindow.tabPosition = draggedWindow._originalTabPosition || (isAutoHide ? 'top' : draggedWindow.tabPosition);
                    feedbackWindow.tabTextOrientation = draggedWindow._originalTextOrientation || (isAutoHide ? 'horizontal' : draggedWindow.tabTextOrientation);
                }

                if (tabItem._autoHideWindowSize) {
                    feedbackWindow.size = tabItem._autoHideWindowSize;
                }
                else if (selectedTabsWindow.autoHide) {
                    const sizeName = 'offset' + (selectedTabsWindow.tabPosition === 'top' || selectedTabsWindow.tabPosition === 'bottom' ? 'Height' : 'Width');

                    feedbackWindow.size = (selectedTabsWindow._autoHideWindow || selectedTabsWindow)[sizeName];
                }
            }

            if (!that._dragDetails.selectedTabsWindow.closest('jqx-docking-layout') && !that._dragDetails.windowFeedback._originalPinnedState) {
                that._dragDetails.windowFeedback._originalPinnedState = that._dragDetails.windowFeedback.pinned;
            }

            that._dragDetails.windowFeedback.pinned = false;
            that.setAttribute('dragged', '');
        }

        that._dragDetails.hoveredItem = target.closest('jqx-splitter-item');

        if (that._dragDetails.hoveredItem) {
            const closestLayout = that._dragDetails.hoveredItem.closest('jqx-docking-layout');

            if (closestLayout && closestLayout === that) {
                that._dragDetails.hoveredTabsWindow = that._dragDetails.hoveredItem.getElementsByTagName('jqx-tabs-window')[0];
            }
            else {
                that._dragDetails.hoveredItem = that._dragDetails.hoveredTabsWindow = undefined;
            }
        }
        else {
            that._dragDetails.hoveredTabsWindow = target.closest('jqx-tabs-window');
        }

        if (that._dragDetails.hoveredTabsWindow) {
            const closestLayout = that._dragDetails.hoveredTabsWindow.closest('jqx-docking-layout');

            if (closestLayout && closestLayout !== that) {
                that._dragDetails.hoveredTabsWindow = undefined;
            }
            else {
                that._dragDetails.hoveredTabsWindow.bringToFront();
            }
        }
    }

    /**
     * Document Drag Start event handler
     * @param {any} event
     */
    _documentDragStartHandler(event) {
        const that = this;

        if (that._dragDetails) {
            event.preventDefault();
        }
    }

    /**
     * Document Select Start event handler
     */
    _documentSelectStartHandler(event) {
        const that = this;

        if (that._dragDetails && that._dragDetails.started) {
            event.preventDefault();
        }
    }

    /**
     * Document Up Event Handler
     */
    _documentUpHandler(event) {
        const that = this,
            target = (event.originalEvent || event).target;

        if (!that._dragDetails || (that._dragDetails && !that._dragDetails.started) || that.disabled) {
            delete that._dragDetails;
            return;
        }

        that._noStateChangeFiring = true;
        that.removeAttribute('dragged');
        that._dragDetails.windowFeedback.removeAttribute('tabs-window-dragged');
        that._dragDetails.windowFeedback.removeAttribute('ontop');

        let isInsideTheLayout = target.closest && target.closest('jqx-docking-layout');

        if (event.ctrlKey) {
            that._snapFeedback._position = isInsideTheLayout = undefined;
        }

        const snapFeedbackPosition = that._snapFeedback ? that._snapFeedback._position : undefined;

        if ((!isInsideTheLayout && !snapFeedbackPosition) || (isInsideTheLayout && !that._dragDetails.hoveredTabArea && !snapFeedbackPosition)) {
            that._dropWindowOutsideLayout(event, snapFeedbackPosition, isInsideTheLayout);
        }
        else if (that._dragDetails.hoveredTabsWindow && snapFeedbackPosition) {
            if (that._dragDetails.hoveredTabArea && that._dragDetails.hoveredTabArea.classList.contains('jqx-tabs-header-section')) {
                let tabLabelCount = that._dragDetails.hoveredTabsWindow.itemLabels.length;

                let hoveredTabLabel = target.closest('.jqx-tab-label-container'), addToEnd;

                if (!hoveredTabLabel || hoveredTabLabel.$.hasClass('jqx-add-new-tab') || !hoveredTabLabel.tab) {
                    hoveredTabLabel = that._dragDetails.hoveredTabsWindow.itemLabels[tabLabelCount - 1];
                    addToEnd = true;
                }
                let items;

                if (that._dragDetails.selectedTabLabel.$.hasClass('jqx-tab-label-container') && that._dragDetails.windowFeedback.$.hasClass('jqx-tabs-window-feedback')) {
                    items = [that._dragDetails.selectedTabLabel.tab];
                }
                else {
                    items = [].slice.call(that._dragDetails.windowFeedback.items);
                }

                let size;

                if (that._dragDetails.hoveredTabsWindow.autoHide) {
                    const autoHidePosition = that._dragDetails.hoveredTabsWindow.tabPosition;

                    size = that._dragDetails.windowFeedback['offset' + (autoHidePosition === 'top' || autoHidePosition === 'bottom' ? 'Height' : 'Width')];
                }

                for (let i = 0; i < items.length; i++) {
                    items[i]._autoHideWindowSize = size || that._dragDetails.windowFeedback.size;
                    that._dragDetails.windowFeedback.removeChild(items[i]);
                    that._dragDetails.hoveredTabsWindow.insert(addToEnd ? tabLabelCount : hoveredTabLabel.tab.index, { node: items[i] });
                    tabLabelCount = that._dragDetails.hoveredTabsWindow.items.length;
                }

                that._dragDetails.targetWindow = that._dragDetails.hoveredTabsWindow;
            }
            else {
                that._dragDetails.targetWindow = that._handleItemNesting();
                that._eventAlreadyFired = true;
            }

            //Close the autoHideWindow
            that.$.autoHideWindow.close();
            that._noStateChangeFiring = false;
        }

        that._endDrag();
    }

    /**
     * Drops a dragged window outside of the Layout. A possible outcome from _documentUpHandler
     * @param {any} event
     * @param {any} snapFeedbackPosition
     */
    _dropWindowOutsideLayout(event, snapFeedbackPosition, isInsideTheLayout) {
        const that = this;
        let targetWindow;

        if (!that.floatable || (that._dragDetails.windowFeedback.floatable !== undefined && !that._dragDetails.windowFeedback.floatable)) {
            that._cancelDragOperation(true);
            return;
        }

        if (that._dragDetails.windowFeedback.classList.contains('jqx-tabs-window-feedback')) {
            const tabItem = that._dragDetails.windowFeedback.items[0];

            if (tabItem && tabItem.floatable !== undefined && !tabItem.floatable) {
                that._cancelDragOperation(true);
                return;
            }

            //Leave outside the Layout
            const selectedTabItem = that._dragDetails.selectedTabLabel.tab;
            let newWindow = document.createElement('jqx-tabs-window');

            if (!that.hasAnimation) {
                newWindow.animation = 'none';
            }

            newWindow.opened = true;
            newWindow.label = selectedTabItem.label;

            that._dragDetails.windowFeedback.removeChild(selectedTabItem);
            that._dragDetails.selectedTabLabel.tab.$.removeClass('jqx-visibility-hidden');
            newWindow.appendChild(that._dragDetails.selectedTabLabel.tab);
            newWindow.style.left = event.pageX + 'px';
            newWindow.style.top = event.pageY + 'px';
            newWindow.style.maxWidth = newWindow.style.maxHeight = '';
            newWindow.resizeMode = that._dragDetails.selectedTabsWindow.resizeMode;
            newWindow.tabTextOrientation = that._dragDetails.windowFeedback.tabTextOrientation;
            newWindow.tabPosition = that._dragDetails.windowFeedback.tabPosition;
            newWindow.min = 30;
            newWindow.style.width = that._dragDetails.windowFeedback.style.width;
            newWindow.style.height = that._dragDetails.windowFeedback.style.height
            newWindow.draggable = selectedTabItem.draggable !== undefined ? selectedTabItem.draggable : true;
            newWindow.floatable = selectedTabItem.floatable !== undefined ? selectedTabItem.floatable : true;

            document.body.appendChild(newWindow);

            newWindow.pinned = newWindow.autoHide = newWindow.allowToggle = false;
            that._noStateChangeFiring = false;
            targetWindow = newWindow;
        }
        else {
            if (that._dragDetails._parentInfo && that._dragDetails._parentInfo.closestItem) {
                if (that._dragDetails.windowFeedback.parentElement !== document.body) {
                    that._dragDetails.windowFeedback.windowParent = 'body';
                    document.body.appendChild(that._dragDetails.windowFeedback);
                }

                //Reset window properties
                that._dragDetails.windowFeedback.style.maxWidth = that._dragDetails.windowFeedback.style.maxHeight = '';
                that._dragDetails.windowFeedback.pinned = that._dragDetails.windowFeedback.allowToggle = that._dragDetails.windowFeedback.autoHide = false;

                if (that._dragDetails.selectedTabLabel.$.hasClass('jqx-tab-label-container')) {
                    that._dragDetails.windowFeedback.label = that._dragDetails.selectedTabLabel.tab.label;
                }
            }
            else if (!snapFeedbackPosition && !(that._dragDetails.selectedItem instanceof JQX.SplitterItem) &&
                that._dragDetails.selectedTabLabel.$.hasClass('jqx-tab-label-container')) {
                that._returnItemToOrigin(that._dragDetails.windowFeedback);
            }

            targetWindow = that._dragDetails.windowFeedback;
            targetWindow.locked = false;

            if (that._dragDetails.selectedItem) {
                that._noStateChangeFiring = false;
            }
        }

        //Close the autoHideWindow
        that.$.autoHideWindow.close();

        if (!isInsideTheLayout) {
            that._dragDetails.windowFeedback.pinned = false;
        }

        that._validateWindowPosition(targetWindow);

        //Remember the previous item
        if (that._dragDetails._parentInfo) {
            targetWindow._parentInfo = {
                closestItem: that._dragDetails._parentInfo.closestItem,
                position: that._dragDetails._parentInfo.position
            };
        }

        targetWindow.layout = that;
        that._dragDetails.targetWindow = targetWindow;

        //Reset the tabPosition of floating windows
        targetWindow.resizeMode = 'both';
        that._setFloatingItemsHeaderButtons(targetWindow);
    }

    /**
    * Resets the position of a dragged item if the destination is invalid
    */
    _endDrag() {
        const that = this,
            windowFeedback = that._dragDetails.windowFeedback;

        that.$.tabsWindowFeedback.close();

        if (windowFeedback.$.tabsElement._tabs.length === 0 &&
            windowFeedback.parentElement && !windowFeedback.$.hasClass('jqx-tabs-window-feedback')) {
            windowFeedback.parentElement.removeChild(windowFeedback);
        }

        if (!that.contains(that._dragDetails.windowFeedback) && that._dragDetails.windowFeedback._originalPinnedState !== undefined) {
            that._dragDetails.windowFeedback.pinned = that._dragDetails.windowFeedback._originalPinnedState;
            delete that._dragDetails.windowFeedback._originalPinnedState;
        }

        if (that._originalBodyOverflow) {
            document.body.style.overflow = that._originalBodyOverflow.overflow;
            document.body.style.eoverflowX = that._originalBodyOverflow.overflowX;
            document.body.style.overflowY = that._originalBodyOverflow.overflowY;
            delete that._originalBodyOverflow;
        }

        if (that._dragDetails.targetWindow) {
            that._dragDetails.targetWindow.focus();
            that._dragDetails.selectedTabsWindow.removeAttribute('active');
        }
        else {
            that._dragDetails.windowFeedback.bringToFront();
        }

        //Ends the dragging
        that._dragDetails.started = false;
        that._dragDetails.hoveredItem = that._dragDetails.hoveredTabsWindow = that._dragDetails.isInsideTheLayout = undefined;
        windowFeedback.removeAttribute('dragged');
        that._handleSnapping();

        delete that._dragDetails.selectedTabsWindow._ownerLayout;

        if (windowFeedback.items.length === 0) {
            if (that.contains(windowFeedback)) {
                windowFeedback.opened = false;
            }

            if (windowFeedback.$.hasClass('jqx-tabs-window-feedback')) {
                that.$.container.appendChild(windowFeedback);
            }
        }

        if (!that._eventAlreadyFired && !that._noStateChangeFiring) {
            that._handleAutoSave();

            let eventDetail = { item: that._dragDetails.targetWindow };

            eventDetail.type = that._items.indexOf(that._dragDetails.targetWindow) > -1 ? 'dock' : 'float';

            that.$.fireEvent('stateChange', eventDetail);
        }

        that._noStateChangeFiring = that._eventAlreadyFired = undefined;

        if (that._dragDetails._parentInfo && that._dragDetails._parentInfo.closestItem) {
            that._removeUnneccessaryItems(that._dragDetails._parentInfo.closestItem.closest('jqx-splitter'));
        }

        if (windowFeedback.closest('jqx-docking-layout')) {
            windowFeedback.style.top = windowFeedback.style.left = '';
            delete that._dragDetails;
            return;
        }

        if (windowFeedback.top) {
            windowFeedback.style.top = windowFeedback.top;
        }

        if (windowFeedback.left) {
            windowFeedback.style.left = windowFeedback.left;
        }

        //iOS Safari bug. Can't remove the HTMLElement that is being dragged on 'move' event
        if (that._dragDetails.selectedTabLabel && that._dragDetails.selectedTabLabel._lazyRemove) {
            if (that._dragDetails.selectedTabLabel.parentElement) {
                that._dragDetails.selectedTabLabel.parentElement.removeChild(that._dragDetails.selectedTabLabel);
            }

            delete that._dragDetails.selectedTabLabel._lazyRemove;
        }

        windowFeedback._cancelDragging();

        delete that._dragDetails;
    }

    /**
     * Returns the contents of a TabItem as a DocumentFragment
     * @param {any} tabItem
     */
    _getTabItemContent(tabItem) {
        const content = tabItem.isCompleted ? tabItem.$.content : tabItem,
            fragment = document.createDocumentFragment();

        while (content.firstChild) {
            fragment.appendChild(content.firstChild);
        }

        return fragment;
    }

    /**
     * Returns the dimension of the header label that hovered 
     */
    _getHeaderLabelDimensions() {
        const that = this;

        if (!that._dragDetails || !that._dragDetails.hoveredTabsWindow) {
            return;
        }

        const tabsElement = that._dragDetails.hoveredTabsWindow.$.tabsElement,
            isTabPositionVertical = tabsElement.tabPosition === 'left' || tabsElement.tabPosition === 'right';

        let lastTabItemOffsetLeft = 0,
            lastTabItemOffsetTop = 0,
            width, height;

        //Tab header item
        if (that._dragDetails.hoveredTabArea) {
            width = that._dragDetails.hoveredTabArea.offsetWidth;
            height = that._dragDetails.hoveredTabArea.offsetHeight;
            lastTabItemOffsetLeft = that._dragDetails.hoveredTabArea.offsetLeft;
            lastTabItemOffsetTop = that._dragDetails.hoveredTabArea.offsetTop;
        }
        else {
            if (tabsElement.$.tabStrip.children.length > 0) {
                const lastTabItem = tabsElement.$.tabStrip.children[tabsElement.$.tabStrip.children.length - 1];

                lastTabItemOffsetLeft = lastTabItem.offsetLeft + (!isTabPositionVertical ? lastTabItem.offsetWidth : 0);
                lastTabItemOffsetTop = lastTabItem.offsetTop + (isTabPositionVertical ? lastTabItem.offsetHeight : 0);
                width = lastTabItem.offsetWidth;
                height = lastTabItem.offsetHeight;
            }
        }

        //In case no item is hovered, use the whole tabHeaderSection offsets
        that._dragDetails.hoveredTabArea = tabsElement.$.tabsHeaderSection;

        let nearTabStripScrollButtonOffsetLeft = 0,
            nearTabStripScrollButtonOffsetTop = 0;

        if (tabsElement.tabTextOrientation === 'horizontal') {
            nearTabStripScrollButtonOffsetLeft = tabsElement.$.scrollButtonNear.offsetWidth;
        }
        else {
            nearTabStripScrollButtonOffsetTop = tabsElement.$.scrollButtonNear.offsetHeight;
        }

        const hoveredAreaRect = that._dragDetails.hoveredTabArea.getBoundingClientRect(),
            tabStrip = that._dragDetails.hoveredTabsWindow.$.tabsElement.$.tabStrip,
            tabStripRect = tabStrip.getBoundingClientRect(),
            left = (tabStripRect.left - hoveredAreaRect.left) + hoveredAreaRect.left + lastTabItemOffsetLeft - tabStrip.scrollLeft - nearTabStripScrollButtonOffsetLeft,
            top = (tabStripRect.top - hoveredAreaRect.top) + hoveredAreaRect.top + lastTabItemOffsetTop - tabStrip.scrollTop - nearTabStripScrollButtonOffsetTop,
            leftHiddenSize = Math.min(lastTabItemOffsetLeft - tabStrip.scrollLeft - nearTabStripScrollButtonOffsetLeft, 0),
            topHiddenSize = Math.min(lastTabItemOffsetTop - tabStrip.scrollTop - nearTabStripScrollButtonOffsetTop, 0);

        return {
            width: Math.min(tabStripRect.width, Math.max(0, width + leftHiddenSize), Math.max(0, tabStripRect.left + tabStripRect.width - left)),
            height: Math.min(tabStripRect.height, Math.max(0, height + topHiddenSize), Math.max(0, tabStripRect.top + tabStripRect.height - top)),
            top: top + window.pageYOffset - topHiddenSize,
            left: left + window.pageXOffset - leftHiddenSize
        };
    }

    /**
    * Handles AutoSaveState property
    */
    _handleAutoSave() {
        const that = this;

        if (!that.autoSaveState) {
            return;
        }

        that.saveState();
    }

    /**
     * Hides the Splitter Bars that are before or after a locked auto-hidden item
     */
    _handleAutoHiddenSplitterBars() {
        const that = this,
            autoHiddenItems = that.$.itemsContainer.querySelectorAll('.auto-hide-left,.auto-hide-right, .auto-hide-top, .auto-hide-bottom');

        for (let i = 0; i < autoHiddenItems.length; i++) {
            if (autoHiddenItems[i].previousElementSibling instanceof JQX.SplitterBar) {
                autoHiddenItems[i].previousElementSibling.hide();
            }
            else if (autoHiddenItems[i].nextElementSibling instanceof JQX.SplitterBar) {
                autoHiddenItems[i].nextElementSibling.hide();
            }
        }
    }

    /**
     * Handle item insertion with position
     */
    _handleItemPositionInserting(item, targetItem, position) {
        const that = this;

        if (item.autoHide || position.indexOf('layout') > -1) {
            that._handleLayoutItemInserting(targetItem, item, position);
        }
        else if (position.indexOf('outside-') > -1) {
            that._handleOutsideItemInserting(targetItem, item, position);
        }
        else {
            if (position.indexOf('inside-') > -1) {
                that._handleInsideItemInserting(targetItem, item, position)
            }
            else {
                that._handleNormalItemInserting(targetItem, item, position);
            }

            that._handleAutoSave();
            that.$.fireEvent('stateChange', { type: 'dock', item: item });
            that._setSplitterBarVisibility();
        }
    }

    /**
    * Creates a new Splitter when nesting items
    * @param {any} targetItem
    */
    _handleInsideItemInserting(targetItem, item, position) {
        const that = this,
            newItem = document.createElement('jqx-splitter-item'),
            newHostItem = document.createElement('jqx-splitter-item');
        let targetSplitterItem = targetItem.closest('jqx-splitter-item'),
            targetSplitter = targetItem.closest('jqx-splitter'),
            targetItemIndex = that._items.indexOf(targetItem), newSplitter;

        if (targetSplitter && targetSplitter._items.length === 1) {
            newSplitter = targetSplitter;
        }
        else {
            newSplitter = document.createElement('jqx-splitter');
        }

        newSplitter.autoFitMode = 'proportional';
        newSplitter.liveResize = that.liveResize;
        newSplitter.resizeStep = that.resizeStep;

        item.windowParent = null;

        newItem.appendChild(item);

        targetItem.windowParent = null;

        position = position.replace('inside-', '');
        newSplitter.orientation = position === 'top' || position === 'bottom' ? 'horizontal' : 'vertical';

        const newItemMaxSize = targetSplitterItem[newSplitter.orientation === 'horizontal' ? 'offsetHeight' : 'offsetWidth'] / 2;

        if (newSplitter.parentElement) {
            newSplitter.insertBefore(newItem, position === 'top' || position === 'left' ? targetSplitterItem : null);
        }
        else {
            newHostItem.appendChild(targetItem);

            if (targetItem.min) {
                newHostItem.min = targetItem.min;
            }

            if (position === 'top' || position === 'left') {
                newSplitter.appendChild(newItem);
                newSplitter.appendChild(newHostItem);
            }
            else {
                newSplitter.appendChild(newHostItem);
                newSplitter.appendChild(newItem);
            }

            targetSplitterItem.appendChild(newSplitter);
        }


        if (item.size) {
            const isInPercentages = typeof (item.size) === 'string' && item.size.indexOf('%') > -1;

            newItem.size = isInPercentages ? item.size : Math.min(newItemMaxSize, parseFloat(item.size));
        }

        newItem.max = item.max || '';
        newItem.min = item.min ? item.min : 30;
        newItem.locked = item.locked || false;
        newItem.collapsible = item.collapsible || false;
        newItem.collapsed = item.collapsed || false;

        if (position === 'bottom' || position === 'right') {
            targetItemIndex = Math.min(targetItemIndex + 1, that._items.length);
        }

        item.pinned = true;
        item.autoHide = item.allowToggle = item.maximized = item.minimized = item.collapsed = false;

        if (item._originalTabPosition) {
            item.tabPosition = item._originalTabPosition;
            delete item._originalTabPosition;
        }
        else {
            item.tabPosition = 'top';
        }

        if (item._originalTextOrientation) {
            item.tabTextOrientation = item._originalTextOrientation;
            delete item._originalTextOrientation;
        }
        else {
            item.tabTextOrientation = 'horizontal';
        }

        that._items.splice(targetItemIndex, 0, item);
        that._handleAutoHiddenSplitterBars();
    }

    /**
     * Creates a new Splitter inside the main layout
     * @param {any} targetItem
     */
    _handleLayoutItemInserting(targetItem, item, position) {
        const that = this,
            newSplitterItem = document.createElement('jqx-splitter-item'),
            size = position === 'bottom' || position === 'top' ? 'offsetHeight' : 'offsetWidth';

        if (!item.size) {
            item.size = item[size];
        }

        position = position.replace('layout-', '');

        newSplitterItem.size = item.size || '';
        newSplitterItem.max = item.max || '';
        newSplitterItem.min = item.min || '';
        newSplitterItem.locked = item.locked || false;
        newSplitterItem.collapsible = item.collapsible || false;
        newSplitterItem.collapsed = item.collapsed || false;

        if (newSplitterItem.size && !that._dockingAutoHideTabItem) {
            newSplitterItem.size = Math.min(that[size] / 2, parseFloat(item.size));
        }

        if (that.$.itemsContainer.orientation === 'horizontal' && (position === 'right' || position === 'left') ||
            that.$.itemsContainer.orientation === 'vertical' && (position === 'top' || position === 'bottom')) {
            let newSplitterItemWithCurrentItems,
                currentItemsContainerOrientation = that.$.itemsContainer.orientation;
            const mainSplitter = that.$.itemsContainer,
                currentItems = [].slice.call(mainSplitter._items),
                appendItemsToMainSplitter = function (currentItem, newItem) {
                    mainSplitter.appendChild(currentItem);
                    mainSplitter.insertBefore(newItem, position === 'right' || position === 'bottom' ? null : currentItem);
                };

            item.windowParent = null;
            newSplitterItem.appendChild(item);
            currentItems.map(item => item.size = item[mainSplitter._measurements.size]);

            const isLastItem = position === 'right' || position === 'bottom';

            isLastItem ? that._items.push(item) : that._items.splice(0, 0, item);
            mainSplitter.removeAll();
            mainSplitter.orientation = position === 'top' || position === 'bottom' ? 'horizontal' : 'vertical';

            const newSplitterItemWithCurrentItemsSize = mainSplitter[mainSplitter._measurements.size] - newSplitterItem.size;

            if (currentItems.length > 1) {
                const currentItemsSplitter = document.createElement('jqx-splitter');

                //The insert item logic of 'end' mode is needed
                currentItemsSplitter.autoFitMode = 'end';
                currentItemsSplitter.orientation = currentItemsContainerOrientation;
                currentItemsSplitter.liveResize = that.liveResize;
                currentItemsSplitter.resizeStep = that.resizeStep;

                newSplitterItemWithCurrentItems = document.createElement('jqx-splitter-item');

                //Setting a default min 
                newSplitterItemWithCurrentItems.min = 30;
                newSplitterItemWithCurrentItems.appendChild(currentItemsSplitter);
                newSplitterItemWithCurrentItems.size = newSplitterItemWithCurrentItemsSize;

                appendItemsToMainSplitter(newSplitterItemWithCurrentItems, newSplitterItem);

                //Append the items in the approriate order so their size can be calculated properly
                for (let i = 0; i < currentItems.length; i++) {
                    currentItemsSplitter.appendChild(currentItems[i]);
                }

                currentItemsSplitter.autoFitMode = 'proportional';
            }
            else {
                currentItems[0].size = newSplitterItemWithCurrentItemsSize;

                if (that._dockingAutoHideTabItem) {
                    mainSplitter.autoFitMode = 'end';
                }

                appendItemsToMainSplitter(currentItems[0], newSplitterItem);
                mainSplitter.autoFitMode = 'proportional';
            }

            that._handleAutoHiddenSplitterBars();
            that._handleAutoSave();
            that.$.fireEvent('stateChange', { type: 'dock', item: item });
            that._setSplitterBarVisibility();
        }
        else {
            const itemToBeInsertedBefore = position.indexOf('left') > -1 || position.indexOf('top') > -1 ? that._items.filter(item => item.opened)[0] : undefined;

            item.windowParent = null;
            newSplitterItem.appendChild(item);
            that.insertBefore(newSplitterItem, itemToBeInsertedBefore, that.$.itemsContainer);
            return true;
        }
    }

    /**
    * Inserts a new item in the same splitter as the target item at a specified position
    * @param {any} targetItem
    * @param {any} item
    * @param {any} position
    */
    _handleNormalItemInserting(targetItem, item, position) {
        let targetSplitterItem = targetItem.closest('jqx-splitter-item');
        const that = this,
            targetSplitter = targetItem.closest('jqx-splitter'),
            newItem = document.createElement('jqx-splitter-item'),
            targetSplitterItemIndex = position === 'right' || position === 'bottom' ?
                targetSplitter._items.indexOf(targetSplitterItem) + 1 : targetSplitter._items.indexOf(targetSplitterItem);
        let targetItemIndex = that._items.indexOf(targetItem);

        item.windowParent = null;

        newItem.appendChild(item);
        newItem.size = item.size || '';
        newItem.min = item.min || '';
        targetSplitter.insert(targetSplitterItemIndex, newItem);

        if (position === 'bottom' || position === 'right') {
            targetItemIndex = Math.min(targetItemIndex + 1, that._items.length);
        }

        item.pinned = true;
        item.locked = false;
        item.autoHide = item.allowToggle = item.maximized = item.minimized = item.collapsed = false;

        if (item._originalTabPosition) {
            item.tabPosition = item._originalTabPosition;
            delete that._originalTabPosition;
        }
        else {
            item.tabPosition = 'top';
        }

        if (item._originalTextOrientation) {
            item.tabTextOrientation = item._originalTextOrientation;
            delete item._originalTextOrientation;
        }
        else {
            item.tabTextOrientation = 'horizontal';
        }

        that._items.splice(targetItemIndex, 0, item);
        that._handleAutoHiddenSplitterBars();
    }

    /**
     * Inserts the new item outside of the target by nesting the target and it's splitter ( if possible) inside a new splitter item
     * @param {any} targetItem
     * @param {any} item
     * @param {any} position
     */
    _handleOutsideItemInserting(targetItem, item, position) {
        const that = this,
            newSplitterItem = document.createElement('jqx-splitter-item');
        let targetSplitter = targetItem.closest('jqx-splitter');

        if (!targetSplitter) {
            targetSplitter = that.$.itemsContainer;
        }

        newSplitterItem.size = item.size || '';
        newSplitterItem.max = item.max || '';
        newSplitterItem.min = item.min || '';
        newSplitterItem.locked = item.locked || false;
        newSplitterItem.collapsible = item.collapsible || false;
        newSplitterItem.collapsed = item.collapsed || false;

        if (targetSplitter !== that.$.itemsContainer) {
            let targetSplitterItem = targetSplitter.closest('jqx-splitter-item');
            const newSplitter = document.createElement('jqx-splitter'),
                newSplitterItemWithCurrentItems = document.createElement('jqx-splitter-item');

            position = position.replace('outside-', '');
            newSplitter.autoFitMode = 'proportional';
            newSplitter.liveResize = that.liveResize;
            newSplitter.resizeStep = that.resizeStep;

            item.windowParent = null;
            newSplitterItem.appendChild(item);

            //Setting a default min for the item
            newSplitterItemWithCurrentItems.min = 30;
            newSplitterItemWithCurrentItems.appendChild(targetSplitter);

            newSplitter.orientation = position === 'top' || position === 'bottom' ? 'horizontal' : 'vertical';
            targetSplitterItem.appendChild(newSplitter);

            if (position === 'right' || position === 'bottom') {
                newSplitter.appendChild(newSplitterItemWithCurrentItems);
                newSplitter.appendChild(newSplitterItem);
                that._items.splice(that._items.indexOf(targetItem) + 1, 0, item);
            }
            else {
                newSplitter.appendChild(newSplitterItem);
                newSplitter.appendChild(newSplitterItemWithCurrentItems);
                that._items.splice(that._items.indexOf(targetItem), 0, item);
            }

            if (!newSplitterItem.size) {
                newSplitterItem.size = newSplitter[newSplitter._measurements.size] / 2;
            }
            else {
                const newSize = newSplitterItem.size;

                newSplitterItem.size = '';
                newSplitterItem.size = newSize;
            }

            that._handleAutoHiddenSplitterBars();
            that._handleAutoSave();
            that.$.fireEvent('stateChange', { type: 'dock', item: item });
            that._setSplitterBarVisibility();
        }
        else {
            item.windowParent = null;
            newSplitterItem.appendChild(item);
            that.insertBefore(newSplitterItem, position.indexOf('left') > -1 || position.indexOf('top') > -1 ? that._items[0] : undefined, that.$.itemsContainer);
            return true;
        }
    }

    /**
     * Apply the layout
     */
    _handleLayout() {
        const that = this;

        that._items = [];

        if (typeof that.layout === 'string') {
            that.layout = JSON.parse(that.layout);
        }

        if (that.layout !== null && Array.isArray(that.layout)) {
            that._createItemsFromArray(that.layout);
            return;
        }

        const initialItems = Array.from(that.$.itemsContainer.children);

        that.$.itemsContainer.innerHTML = '';

        for (let i = 0; i < initialItems.length; i++) {
            if (initialItems[i].tagName !== 'JQX-TABS-WINDOW') {
                initialItems[i].parentElement.removeChild(initialItems[i]);
            }

            initialItems[i].layout = that;

            const splitterItem = document.createElement('jqx-splitter-item');

            splitterItem.appendChild(initialItems[i]);

            that.$.itemsContainer.appendChild(splitterItem);
            that._items.push(initialItems[i]);
        }
    }

    /**
    * Handles the snapping feedback
    * @param {any} position
    */
    _handleSnapping(position) {
        const that = this;

        if (that.snapMode === 'simple') {
            that._handleSimpleSnapping(position);
        }
        else {
            that._handleAdvancedSnapping();
        }
    }

    /**
     * Handles Advanced snapping mode
     */
    _handleAdvancedSnapping() {
        const that = this;

        if (!that._dragDetails) {
            return;
        }

        if (that._snapFeedback && !that._dragDetails.hoveredTabsWindow) {
            that._snapFeedback._position = undefined;

            if (that._snapFeedback.areaHighlighter && that._snapFeedback.areaHighlighter.parentElement) {
                that._snapFeedback.areaHighlighter.parentElement.removeChild(that._snapFeedback.areaHighlighter);
            }

            if (that._snapFeedback.headerHighlighter && that._snapFeedback.headerHighlighter.parentElement) {
                that._snapFeedback.headerHighlighter.parentElement.removeChild(that._snapFeedback.headerHighlighter);
            }

            if (!that._dragDetails.hoveredItem) {
                if (that._snapFeedback.innerSnapElement && that._snapFeedback.innerSnapElement.parentElement) {
                    that._snapFeedback.innerSnapElement.parentElement.removeChild(that._snapFeedback.innerSnapElement);
                }

                if (that._snapFeedback.outherSnapElement && !that._dragDetails.isInsideTheLayout) {
                    const outherElements = [].slice.call(that.$.container.children);

                    for (let i = 0; i < outherElements.length; i++) {
                        if (outherElements[i].className.indexOf('jqx-docking-layout-snap') > -1) {
                            that._snapFeedback.outherSnapElement.appendChild(outherElements[i]);
                        }
                    }
                }

                return;
            }
        }

        if (!that._snapFeedback) {
            that._snapFeedback = {
                innerSnapElement: document.createElement('div'),
                outherSnapElement: document.createElement('div'),
                areaHighlighter: document.createElement('div'),
                headerHighlighter: document.createElement('div')
            };

            that._snapFeedback.innerSnapElement.classList.add('jqx-docking-layout-snap');
            that._snapFeedback.areaHighlighter.classList.add('jqx-docking-layout-snap-highlighter');
            that._snapFeedback.headerHighlighter.classList.add('jqx-docking-layout-snap-highlighter-header');

            that._snapFeedback.innerSnapElement.innerHTML = `
                            <div>
                                <div class="top">
                                    <div><div></div></div>
                                </div>
                            </div>
                            <div>
                                <div class="left">
                                    <div><div></div></div>
                                </div>
                                <div class="center">
                                    <div><div></div></div>
                                </div>
                                <div class="right">
                                    <div><div></div></div>
                                </div>
                            </div>
                            <div>
                                <div class="bottom">
                                    <div><div></div></div>
                                </div>
                            </div>`;

            that._snapFeedback.outherSnapElement.innerHTML = `
                            <div class="jqx-docking-layout-snap layout-top">
                                <div><div></div></div>
                            </div>
                            <div class="jqx-docking-layout-snap layout-left">
                                <div><div></div></div>
                            </div>
                            <div class="jqx-docking-layout-snap layout-right">
                                <div><div></div></div>
                            </div>
                            <div class="jqx-docking-layout-snap layout-bottom">
                                <div><div></div></div>
                            </div>`;
        }

        if (that._snapFeedback.areaHighlighter.parentElement) {
            that._snapFeedback.areaHighlighter.removeAttribute('position');
            that._snapFeedback.areaHighlighter.classList.remove('jqx-hidden');
        }

        that._snapFeedback.areaHighlighter.style.width = '';
        that._snapFeedback.areaHighlighter.style.height = '';

        that._snapFeedback._position = that._dragDetails.hoveredItem && !(that._dragDetails.hoveredItem instanceof JQX.SplitterItem) ? that._dragDetails.hoveredItem.className : '';

        if (that._dragDetails.hoveredItem && that._dragDetails.hoveredItem.className.indexOf('layout-') > -1) {
            that._snapFeedback._position = that._snapFeedback._position.replace('jqx-docking-layout-snap ', '');
            that._snapFeedback.areaHighlighter.setAttribute('position', that._snapFeedback._position);

            const selectedTabsWindow = that._dragDetails.selectedTabsWindow;

            if (selectedTabsWindow.dropPosition.indexOf('all') > -1 || selectedTabsWindow.dropPosition.indexOf(that._snapFeedback._position) > -1) {
                that._dragDetails.hoveredItem.setAttribute('show', '');
                that.$.container.appendChild(that._snapFeedback.areaHighlighter);
                that._dragDetails.hoveredTabsWindow = true;

                //Sets the size of the outher(layout) highlighters
                if (['layout-left', 'layout-right'].indexOf(that._snapFeedback._position) > -1) {
                    that._snapFeedback.areaHighlighter.style.width = that._dragDetails.windowFeedback.style.width || (that._dragDetails.windowFeedback.offsetWidth + 'px');
                }
                else if (['layout-top', 'layout-bottom'].indexOf(that._snapFeedback._position) > -1) {
                    that._snapFeedback.areaHighlighter.style.height = that._dragDetails.windowFeedback.style.height || (that._dragDetails.windowFeedback.offsetHeight + 'px');
                }
            }
            else {
                that._dragDetails.hoveredItem.removeAttribute('show');
                that._snapFeedback._position = undefined;
            }

            return;
        }

        let dropPosition = that._dragDetails.hoveredTabsWindow ? that._dragDetails.hoveredTabsWindow.dropPosition : ['all'];

        if (dropPosition.length === 0) {
            dropPosition = ['all'];
        }

        if (that._dragDetails.hoveredTabsWindow instanceof JQX.TabsWindow && that._dragDetails.hoveredTabArea &&
            that._dragDetails.hoveredTabArea.closest('.jqx-tabs-header-section') && (dropPosition.indexOf('all') > -1 || dropPosition.indexOf('header') > -1)) {
            that._dragDetails.hoveredTabArea = that._dragDetails.hoveredTabArea.classList.contains('jqx-tab-label-container') ? that._dragDetails.hoveredTabArea : undefined;

            const dimensions = that._getHeaderLabelDimensions(),
                headerHighLighter = that._snapFeedback.headerHighlighter;

            headerHighLighter.style.width = dimensions.width + 'px';
            headerHighLighter.style.height = dimensions.height + 'px';
            headerHighLighter.style.top = dimensions.top + 'px';
            headerHighLighter.style.left = dimensions.left + 'px';
            headerHighLighter.classList.remove('jqx-hidden');

            if (headerHighLighter.parentElement !== document.body) {
                document.body.appendChild(headerHighLighter);
            }

            that._snapFeedback._position = 'header';
        }
        else {
            that._snapFeedback.headerHighlighter.style.width = that._snapFeedback.headerHighlighter.style.height = 0;
        }

        const innerSnapElementParent = that._snapFeedback.innerSnapElement.closest('jqx-splitter-item');

        if (that._dragDetails.hoveredItem instanceof JQX.SplitterItem) {
            if (innerSnapElementParent && that._dragDetails.hoveredItem !== innerSnapElementParent) {
                innerSnapElementParent.removeChild(that._snapFeedback.innerSnapElement);
            }

            if (that._dragDetails.hoveredItem.className.indexOf('auto-hide') < 0) {
                const highlighSections = that._snapFeedback.innerSnapElement.querySelectorAll('.top, .bottom, .left, .right, .center');

                for (let i = 0; i < highlighSections.length; i++) {

                    if (dropPosition.indexOf(highlighSections[i].className) > -1 || dropPosition.indexOf('all') === 0) {
                        highlighSections[i].setAttribute('show', '');
                    }
                    else {
                        highlighSections[i].removeAttribute('show');
                    }
                }

                that._snapFeedback.innerSnapElement.classList.remove('jqx-hidden');
                that._dragDetails.hoveredItem.appendChild(that._snapFeedback.innerSnapElement);
            }

            const outherElements = [].slice.call(that._snapFeedback.outherSnapElement.children),
                selectedTabsWindow = that._dragDetails.selectedTabsWindow;
            let position;

            for (let i = 0; i < outherElements.length; i++) {
                position = outherElements[i].className.replace('jqx-docking-layout-snap ', '');
                outherElements[i].classList.remove('jqx-hidden');

                if (selectedTabsWindow.dropPosition.indexOf('all') > -1 || selectedTabsWindow.dropPosition.indexOf(position) > -1) {
                    outherElements[i].setAttribute('show', '');
                }
                else {
                    outherElements[i].removeAttribute('show');
                }

                that.$.container.appendChild(outherElements[i]);
            }
        }

        if (!that._snapFeedback._position || dropPosition.indexOf('all') < 0 && dropPosition.indexOf(that._snapFeedback._position) < 0) {
            that._snapFeedback._position = that._dragDetails.hoveredTabArea = undefined;
            return;
        }

        if (that._snapFeedback._position === 'center' && that._items.filter(item => item.opened).length > 0) {
            that._dragDetails.hoveredTabArea = that._dragDetails.hoveredTabsWindow.$.tabsElement.$.tabsHeaderSection;
        }

        //Sets the size of the inner highlighters
        if (['left', 'right'].indexOf(that._snapFeedback._position) > -1) {
            that._snapFeedback.areaHighlighter.style.width = that._dragDetails.windowFeedback.style.width || (that._dragDetails.windowFeedback.offsetWidth + 'px');
        }
        else if (['top', 'bottom'].indexOf(that._snapFeedback._position) > -1) {
            that._snapFeedback.areaHighlighter.style.height = that._dragDetails.windowFeedback.style.height || (that._dragDetails.windowFeedback.offsetHeight + 'px');
        }

        that._snapFeedback.areaHighlighter.setAttribute('position', that._snapFeedback._position);

        if (that._snapFeedback._position === 'header') {
            that._dragDetails.hoveredTabsWindow.$.tabsElement.$.tabContentSection.appendChild(that._snapFeedback.areaHighlighter);
        }
        else {
            const orientation = that._dragDetails.hoveredTabsWindow.closest('jqx-splitter').orientation;

            if (((that._snapFeedback._position === 'left' || that._snapFeedback._position === 'right') && orientation === 'horizontal') ||
                ((that._snapFeedback._position === 'top' || that._snapFeedback._position === 'bottom') && orientation === 'vertical')) {
                that._snapFeedback._position = 'inside-' + that._snapFeedback._position;
            }

            that._dragDetails.hoveredItem.closest('jqx-splitter-item').appendChild(that._snapFeedback.areaHighlighter);
        }
    }

    /**
     * Handles Simple snapping mode
     * @param {any} position
     */
    _handleSimpleSnapping(position) {
        const that = this;

        function transitionEndHandler() {
            if (that._snapFeedback.classList.contains('jqx-visibility-hidden') && that._snapFeedback.parentElement) {
                that._snapFeedback.parentElement.removeChild(that._snapFeedback);
            }
        }

        if (!position) {
            if (that._dragDetails) {
                that._dragDetails.hoveredTabsWindow = that._dragDetails.hoveredTabArea = undefined;
            }

            if (that._snapFeedback) {
                that._snapFeedback._position = undefined;

                if (that._snapFeedback.parentElement) {
                    that._snapFeedback.classList.add('jqx-visibility-hidden');
                }
            }

            return;
        }

        if (!that._snapFeedback) {
            that._snapFeedback = document.createElement('div');
            that._snapFeedback.addEventListener('transitionend', transitionEndHandler);
        }

        for (let i = 0; i < that._snapFeedback.classList.length; i++) {
            if (that._snapFeedback.classList[i].indexOf('jqx-docking-snap-') > -1) {
                that._snapFeedback.classList.remove(that._snapFeedback.classList[i]);
            }
        }

        that._snapFeedback._position = position;

        position = position.replace('inside-', '');

        that._snapFeedback.classList.add('jqx-docking-snap-' + position + '-feedback');
        that._snapFeedback.classList.remove('jqx-visibility-hidden');

        let dropPosition = position.indexOf('layout') === 0 ? that._dragDetails.selectedTabsWindow.dropPosition : that._dragDetails.hoveredTabsWindow.dropPosition;

        if (dropPosition.length === 0) {
            dropPosition = ['all'];
        }

        if (dropPosition.indexOf('all') > -1 || dropPosition.indexOf(position) > -1) {
            that._snapFeedback.removeAttribute('disabled');
        }
        else {
            that._snapFeedback.setAttribute('disabled', '');
            that._snapFeedback._position = undefined;
        }

        let width, height, top, left, hoveredAreaRect;
        const layoutRect = that.getBoundingClientRect(),
            tabsWindowStyles = getComputedStyle(that._dragDetails.hoveredTabsWindow.$.contentSection),
            paddingLeft = parseFloat(tabsWindowStyles.getPropertyValue('padding-left') || 0),
            paddingRight = parseFloat(tabsWindowStyles.getPropertyValue('padding-right') || 0),
            paddingTop = parseFloat(tabsWindowStyles.getPropertyValue('padding-top') || 0),
            paddingBottom = parseFloat(tabsWindowStyles.getPropertyValue('padding-bottom') || 0),
            leftHiddenItem = that.$.verticalHiddenItemsContainer.getElementsByClassName('auto-hide-left')[0],
            topHiddenItem = that.$.horizontalHiddenItemsContainer.getElementsByClassName('auto-hide-top')[0];

        //Resets the highlighter
        that._snapFeedback.style.display = '';

        switch (position) {
            case 'header': {
                const dimensions = that._getHeaderLabelDimensions();

                width = dimensions.width;
                height = dimensions.height;
                top = dimensions.top;
                left = dimensions.left;

                //Hides the highlighter if it's overflowing
                if (!width || !height) {
                    that._snapFeedback.style.display = 'none';
                }

                break;
            }
            case 'left':
            case 'right':
                hoveredAreaRect = that._dragDetails.hoveredTabArea.getBoundingClientRect();

                height = that._dragDetails.hoveredTabArea.offsetHeight;
                width = that._dragDetails.hoveredTabArea.offsetWidth / 2;
                top = hoveredAreaRect.top + window.pageYOffset;
                left = hoveredAreaRect.left + (position === 'right' ? that._dragDetails.hoveredTabArea.offsetWidth / 2 : 0) + window.pageXOffset;
                break;
            case 'top':
            case 'bottom':
                hoveredAreaRect = that._dragDetails.hoveredTabArea.getBoundingClientRect();

                height = that._dragDetails.hoveredTabArea.offsetHeight / 2;
                width = that._dragDetails.hoveredTabArea.offsetWidth;
                top = hoveredAreaRect.top + window.pageYOffset + (position === 'bottom' ? that._dragDetails.hoveredTabArea.offsetHeight / 2 : 0);
                left = hoveredAreaRect.left + window.pageXOffset;
                break;
            case 'layout-left':
            case 'layout-right': {
                if (that._snapFeedback.parentElement && that._snapFeedback.maxWidth === undefined) {
                    that._snapFeedback.maxWidth = parseFloat(getComputedStyle(that._snapFeedback).getPropertyValue('max-width')) || 0;
                }

                width = that.$.itemsContainer.offsetWidth * 0.07 - (paddingLeft + paddingRight);

                if (that._snapFeedback.maxWidth) {
                    width = Math.min(that._snapFeedback.maxWidth, width);
                }

                height = that.$.itemsContainer.offsetHeight - (paddingTop + paddingBottom);
                top = layoutRect.top + window.pageYOffset + paddingTop + (topHiddenItem ? topHiddenItem.offsetHeight : 0);
                left = layoutRect.left + window.pageXOffset + (position === 'layout-left' ? paddingLeft : 0) + (leftHiddenItem ? leftHiddenItem.offsetWidth : 0) +
                    (position === 'layout-right' ? that.$.itemsContainer.offsetWidth - width - paddingRight : 0);
                break;
            }
            case 'layout-top':
            case 'layout-bottom':
                if (that._snapFeedback.parentElement && that._snapFeedback.maxHeight === undefined) {
                    that._snapFeedback.maxHeight = parseFloat(getComputedStyle(that._snapFeedback).getPropertyValue('max-height')) || 0;
                }

                height = that.$.itemsContainer.offsetHeight * 0.07 - (paddingTop + paddingBottom);

                if (that._snapFeedback.maxHeight) {
                    height = Math.min(that._snapFeedback.maxHeight, height);
                }

                width = that.$.itemsContainer.offsetWidth - (paddingLeft + paddingRight);
                top = layoutRect.top + window.pageYOffset + (topHiddenItem ? topHiddenItem.offsetHeight : 0) +
                    (position === 'layout-bottom' ? that.$.itemsContainer.offsetHeight - height + paddingTop : paddingTop);
                left = layoutRect.left + window.pageXOffset + paddingLeft + (leftHiddenItem ? leftHiddenItem.offsetWidth : 0);
                break;
        }

        that._snapFeedback.style.height = height + 'px';
        that._snapFeedback.style.width = width + 'px';
        that._snapFeedback.style.left = left + 'px';
        that._snapFeedback.style.top = top + 'px';

        if (!that._snapFeedback._position) {
            that._dragDetails.hoveredTabArea = undefined;
        }

        if (!that._snapFeedback.parentElement) {
            document.body.appendChild(that._snapFeedback);
        }
    }

    /**
    * Nest item inside another item.
    **/
    _handleItemNesting() {
        const that = this;
        let targetWindow = that._dragDetails.windowFeedback;

        if (targetWindow.classList.contains('jqx-tabs-window-feedback')) {
            let newWindow = document.createElement('jqx-tabs-window');
            const selectedTabItem = that._dragDetails.selectedTabLabel.tab;

            newWindow.min = 30;
            newWindow.opened = newWindow.pinned = true;
            newWindow.headerPosition = that._dragDetails.selectedTabsWindow.headerPosition;


            if (that._dragDetails.selectedTabsWindow.autoHide) {
                newWindow.tabTextOrientation = that._dragDetails.selectedTabsWindow._originalTextOrientation || 'horizontal';
                newWindow.tabPosition = that._dragDetails.selectedTabsWindow._originalTabPosition || 'top';
            }
            else {
                newWindow.tabPosition = that._dragDetails.selectedTabsWindow.tabPosition;
                newWindow.tabTextOrientation = that._dragDetails.selectedTabsWindow.tabTextOrientation;
            }

            if (!that.hasAnimation) {
                newWindow.animation = 'none';
            }

            if (that._snapFeedback._position.indexOf('top') > -1 || that._snapFeedback._position.indexOf('bottom') > -1) {
                newWindow.size = parseFloat(targetWindow.style.height) || targetWindow.offsetHeight;
            }
            else {
                newWindow.size = parseFloat(targetWindow.style.width) || targetWindow.offsetWidth;
            }

            newWindow.label = selectedTabItem.label;
            newWindow.id = '';

            that._dragDetails.windowFeedback.removeChild(selectedTabItem);
            newWindow.appendChild(selectedTabItem);
            newWindow.style.left = newWindow.style.top = '';
            newWindow.draggable = selectedTabItem.draggable !== undefined ? selectedTabItem.draggable : true;
            newWindow.floatable = selectedTabItem.floatable !== undefined ? selectedTabItem.floatable : true;
            targetWindow = newWindow;
        }
        else {
            //Returns the window to it's initial position
            const context = targetWindow.context;

            targetWindow.context = targetWindow;
            targetWindow.windowParent = null;
            targetWindow.context = context;

            if (that._snapFeedback._position.indexOf('top') > -1 || that._snapFeedback._position.indexOf('bottom') > -1) {
                targetWindow.size = parseFloat(targetWindow.style.height) || targetWindow.offsetHeight;
            }
            else {
                targetWindow.size = parseFloat(targetWindow.style.width) || targetWindow.offsetWidth;
            }

            targetWindow.style.top = targetWindow.style.left = targetWindow.style.width = targetWindow.style.height = '';
            targetWindow.pinned = true;
            //targetWindow.locked = false;

            if (!targetWindow._originalTabPosition) {
                targetWindow._originalTabPosition = targetWindow.tabPosition;
            }
        }

        that._insert(that._items.indexOf(that._dragDetails.hoveredTabsWindow), targetWindow, that._snapFeedback._position);
        return targetWindow;
    }

    /**
    * Handles windows that are not dummies while dragging. Applies settings and caches data related to them.
    */
    _handleWindowOnDrag() {
        const that = this;

        //Avoids unnecessary calls
        if (that._dragDetails.windowFeedback.hasAttribute('dragged')) {
            return;
        }

        let selectedItem = that._dragDetails.selectedItem,
            selectedTabsWindow = that._dragDetails.selectedTabsWindow,
            closestSplitter = selectedTabsWindow.closest('jqx-splitter');

        that._setWindowFeedbackSize();

        if (selectedTabsWindow === that.$.autoHideWindow && !that._dragDetails._parentInfo) {
            that._dragDetails._parentInfo = {};

            if (selectedTabsWindow._tabsWindow.items.length > 1) {
                that._dragDetails._parentInfo.closestItem = selectedTabsWindow._tabsWindow;
                that._dragDetails._parentInfo.position = that.$.autoHideWindow._tab.index;
            }
            else {
                that._dragDetails._parentInfo.closestItem = that.$.itemsContainer;
                that._dragDetails._parentInfo.position = selectedTabsWindow._tabsWindow.tabPosition;
                that._dragDetails.windowFeedback.headerButtons = that.$.autoHideWindow._tabsWindow.headerButtons;
                that._noStateChangeFiring = true;
                that.undock(that._dragDetails.windowFeedback);
            }

            that._originalTabIndex = undefined;
        }
        else {
            if (closestSplitter && closestSplitter !== that.$.itemsContainer && closestSplitter._items.length === 1) {
                while (closestSplitter._items.length === 1 && closestSplitter !== that.$.itemsContainer) {
                    closestSplitter = closestSplitter.parentElement.closest('jqx-splitter');
                    selectedItem = selectedItem.parentElement.closest('jqx-splitter-item');
                }
            }

            if (!that._dragDetails._parentInfo) {
                that._dragDetails._parentInfo = {};

                if (selectedTabsWindow.closest('jqx-docking-layout') === that) {
                    if (selectedTabsWindow.autoHide) {
                        that._dragDetails._parentInfo.closestItem = that.$.itemsContainer;
                        that._dragDetails._parentInfo.position = selectedTabsWindow.tabPosition;

                        if (selectedTabsWindow._originalTabPosition) {
                            selectedTabsWindow.tabPosition = selectedTabsWindow._originalTabPosition;
                        }

                        if (selectedTabsWindow._originalTextOrientation) {
                            selectedTabsWindow.tabTextOrientation = selectedTabsWindow._originalTextOrientation;
                        }
                    }
                    else {
                        const selectedItemIndex = closestSplitter._items.indexOf(selectedItem),
                            itemsCount = closestSplitter._items.length;

                        if (itemsCount === 1) {
                            that._dragDetails._parentInfo.position = closestSplitter.orientation === 'horizontal' ? 'top' : 'left';
                            that._dragDetails._parentInfo.closestItem = undefined;
                        }
                        else {
                            if (selectedItemIndex === 0) {
                                that._dragDetails._parentInfo.position = closestSplitter.orientation === 'horizontal' ? 'top' : 'left';
                                that._dragDetails._parentInfo.closestItem = closestSplitter._items[selectedItemIndex + 1].getElementsByTagName('jqx-tabs-window')[0];
                            }
                            else {
                                that._dragDetails._parentInfo.position = closestSplitter.orientation === 'horizontal' ? 'bottom' : 'right';
                                that._dragDetails._parentInfo.closestItem = closestSplitter._items[selectedItemIndex - 1].getElementsByTagName('jqx-tabs-window')[0];
                            }

                            that._dragDetails._parentInfo.closestItemSize = that._dragDetails._parentInfo.closestItem[closestSplitter._measurements.size];

                            if (closestSplitter !== that._dragDetails._parentInfo.closestItem.closest('jqx-splitter')) {
                                if (closestSplitter === that.$.itemsContainer) {
                                    that._dragDetails._parentInfo.position = 'layout-' + that._dragDetails._parentInfo.position;
                                }
                                else {
                                    that._dragDetails._parentInfo.position = 'outside-' + that._dragDetails._parentInfo.position;
                                }
                            }
                            else if (closestSplitter._items.length === 2) {
                                that._dragDetails._parentInfo.position = 'inside-' + that._dragDetails._parentInfo.position;
                            }
                        }
                    }
                }
                else {
                    that._dragDetails._parentInfo.position = {
                        top: selectedTabsWindow.offsetTop,
                        left: selectedTabsWindow.offsetLeft
                    };
                }
            }
        }

        if (closestSplitter) {
            that._dragDetails.windowFeedback.size = that._dragDetails.windowFeedback[closestSplitter._measurements.size];
        }
        else if (selectedTabsWindow === that.$.autoHideWindow) {
            const autoHidePosition = that.$.autoHideWindow._tabsWindow.tabPosition;

            that._dragDetails.windowFeedback.size = that.$.autoHideWindow['offset' + (autoHidePosition === 'top' || autoHidePosition === 'bottom' ? 'Height' : 'Width')];
        }

        that._dragDetails.windowFeedback.setAttribute('dragged', '');

        if (that._dragDetails.windowFeedback.parentElement !== document.body) {
            that._dragDetails.windowFeedback.windowParent = 'body';
            document.body.appendChild(that._dragDetails.windowFeedback);
        }

        //Reset the proeprties of the Window
        that._dragDetails.windowFeedback.autoHide = false;
        that._dragDetails.windowFeedback.allowToggle = false;

        //Reset tabPosition
        if (that.snapMode !== 'advanced' && that._dragDetails.windowFeedback.tabPosition === 'none') {
            that._dragDetails.windowFeedback.tabPosition = 'top';
        }

        const itemIndex = that._items.indexOf(that._dragDetails.windowFeedback);

        if (itemIndex > -1) {
            that._items.splice(itemIndex, 1);
        }

        if (selectedItem && selectedItem.parentElement) {
            if (that._items.filter(item => item.opened).length === 0 && !that.$.placeholderItem.parentElement) {
                that.$.itemsContainer._items[0].className.indexOf('auto-hide') > -1 ?
                    that.$.itemsContainer.insert(1, that.$.placeholderItem) : that.$.itemsContainer.insert(0, that.$.placeholderItem);
            }

            if (closestSplitter) {
                closestSplitter.removeChild(selectedItem);
                that._dragDetails.initialSplitterOrientation = closestSplitter.orientation === 'horizontal';
                that._removeUnneccessaryItems(closestSplitter);
            }
            else if (selectedTabsWindow === that.$.autoHideWindow && that.$.autoHideWindow._tabsWindow.items.length === 0) {
                that.$.autoHideWindow._tabsWindow.closest('jqx-splitter').removeChild(selectedItem);
            }

            that._setAutoHidePaddings();
        }
    }

    /**
     * Sets the size of the window feedback on documentMove
     */
    _setWindowFeedbackSize() {
        const that = this,
            selectedTabsWindow = that._dragDetails.selectedTabsWindow;

        if (!that._dragDetails._isWindowFeedbackSizeSet) {
            let width, height;

            if (selectedTabsWindow.autoHide && selectedTabsWindow._autoHideWindow) {
                if (selectedTabsWindow.tabPosition === 'top' || selectedTabsWindow.tabPosition === 'bottom') {
                    width = selectedTabsWindow.offsetWidth + 'px';
                    height = selectedTabsWindow._autoHideWindow.offsetHeight + 'px';
                }
                else {
                    width = selectedTabsWindow._autoHideWindow.offsetWidth + 'px';
                    height = selectedTabsWindow.offsetHeight + 'px';
                }
            }
            else {
                width = selectedTabsWindow.style.width || (selectedTabsWindow.offsetWidth + 'px');
                height = selectedTabsWindow.style.height || (selectedTabsWindow.offsetHeight + 'px');
            }

            that._dragDetails.windowFeedback.style.width = width;
            that._dragDetails.windowFeedback.style.height = height;
            that._dragDetails._isWindowFeedbackSizeSet = true;
        }
    }

    /**
    * Inserts a TabsWindow element inside the Layout.
    * index - jqxTabsWindow index or it's instance
    * item - a jqxTabsWindow instance to be inserted
    * position - defines the position ( top, bottom, left, right ) if the item should be nested
    */
    _insert(index, item, position) {
        const that = this;

        if (typeof index !== 'number') {
            that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: arguments[3] || 'insert' }));
            return;
        }

        if (typeof item === 'object' && !(item instanceof HTMLElement)) {
            item = that._createTabsWindowFromObject(item);
        }
        else if (typeof item === 'string') {
            item = document.getElementById(item);
        }
        else if (item instanceof JQX.TabItem) {
            const parentTabsWindow = item.closest('jqx-tabs-window');

            if (parentTabsWindow && parentTabsWindow.autoHide) {
                that._dock(parentTabsWindow, position);
                return;
            }

            item = that._createTabsWindowFromObject({ label: item.label, items: [{ label: item.label, content: item.content }] });
        }

        if (!item || !(item instanceof JQX.TabsWindow)) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: arguments[3] || 'insert' }));
            return;
        }

        if (that.contains(item) && item.autoHide) {
            that._dock(item, position);
            return;
        }

        if (position && position.indexOf('layout') > -1) {
            const openedItems = that._items.filter(item => item.opened);

            if (openedItems > 0) {
                index = position.indexOf('left') > -1 || position.indexOf('top') > -1 ? 0 : openedItems[openedItems.length - 1];
            }
            else {
                index = 0;
            }
        }

        let targetItem = that._items[index];

        if (that._items[index] && !that._items[index].opened) {
            targetItem = that._items.filter(item => item.opened)[0];
        }

        if (that._items.length === 0) {
            that.$.itemsContainer.orientation = position.indexOf('left') > -1 || position.indexOf('right') > -1 ? 'vertical' : 'horizontal';
        }

        item.style.top = item.style.left = '';
        item.style.width = item.style.height = '';
        item.opened = true;
        item.pinned = true;

        const parentSplitterItem = item.closest('jqx-splitter-item');

        if (!targetItem) {
            that.insertBefore(item, targetItem || null);

            if (parentSplitterItem) {
                parentSplitterItem.closest('jqx-splitter').removeChild(parentSplitterItem);
            }
            return;
        }

        delete item._parentInfo;

        if (item.autoHide) {
            if (that.$.verticalHiddenItemsContainer.contains(item)) {
                that.$.verticalHiddenItemsContainer.removeChild(item.closest('jqx-splitter-item'))
            }
            else if (that.$.horizontalHiddenItemsContainer.contains(item)) {
                that.$.horizontalHiddenItemsContainer.removeChild(item.closest('jqx-splitter-item'))
            }
        }

        if (position) {
            that._handleItemPositionInserting(item, targetItem, position);
        }
        else {
            that.insertBefore(item, targetItem || null);
        }

        if (parentSplitterItem) {
            const closestSplitter = parentSplitterItem.closest('jqx-splitter');

            if (closestSplitter) {
                closestSplitter.removeChild(parentSplitterItem);
            }
        }

        if (item.autoHide) {
            that._autoHide(item, position);
        }
        else {
            const scrollElement = document.scrollingElement || document.documentElement,
                x = scrollElement.scrollLeft,
                y = scrollElement.scrollTop;

            item.focus(); //Note: Applying focus sometimes breaks the style
            window.scrollTo(x, y);
        }

        if (that._items.filter(item => item.opened).length > 0 && that.$.placeholderItem.parentElement) {
            that.$.itemsContainer.removeChild(that.$.placeholderItem);
        }

        item.layout = that;
        item.resizeMode = 'none';
        item.minimized = false;
        item.maximized = false;
        that._setDockedItemsHeaderButtons(item);
    }

    /**
     * Tabs Windows(inside itemsContainer) Close Event Handler
     * @param {any} event
     */
    _itemsContainerCloseHandler(event) {
        const that = this;

        if (event.target instanceof JQX.Tabs) {
            const targetTabs = event.target;

            if (targetTabs._tabs.length === 0) {
                that.removeChild(targetTabs.closest('jqx-tabs-window'));
            }

            return;
        }

        if (!(event.target instanceof JQX.TabsWindow)) {
            return;
        }

        const splitterItem = event.target.closest('jqx-splitter-item'),
            splitter = splitterItem.closest('jqx-splitter');

        if (splitter) {
            splitter.removeChild(splitterItem);
            that._removeUnneccessaryItems(splitter);
        }

        event.target.close();

        if (that._items.filter(item => item.opened).length === 0 && !that.$.placeholderItem.parentElement) {
            that.$.itemsContainer.appendChild(that.$.placeholderItem);
        }
    }

    /**
     * Menu autoHide event handler
     */
    _itemsContainerAutoHideHandler(event) {
        const that = this,
            button = event.detail.button,
            tabsWindow = button.closest('jqx-tabs-window');

        if (!tabsWindow) {
            return;
        }

        const closestSplitterItem = tabsWindow.closest('jqx-splitter-item');

        if (!closestSplitterItem) {
            return;
        }

        const closestSplitter = tabsWindow.closest('jqx-splitter');

        if (!closestSplitter) {
            return;
        }

        const closestSplitterItems = closestSplitter.items,
            isHorizontal = closestSplitter.orientation === 'horizontal',
            isFarItem = closestSplitterItems.indexOf(closestSplitterItem) >= closestSplitterItems.length / 2;

        if (isHorizontal) {
            isFarItem ? that.autoHideBottom(tabsWindow) : that.autoHideTop(tabsWindow);
        }
        else {
            isFarItem ? that.autoHideRight(tabsWindow) : that.autoHideLeft(tabsWindow);
        }

    }

    /**
     * Menu open/close event handler
     */
    _itemsContainerMenuHandler(event) {
        const that = this,
            menu = that.$.menu,
            layoutRect = that.getBoundingClientRect(),
            menuButtonRect = event.detail.button.getBoundingClientRect();

        menu.open(menuButtonRect.left - layoutRect.left, menuButtonRect.top - layoutRect.top);
        that._menuOpenButton = event.detail.button;
    }

    /**
     * ItemsContainer resizeEnd event handler. Called when a splitter item inside the Layout has been resized
     */
    _itemsContainerResizeHandler() {
        const that = this,
            targetItem = event.target._items ? event.target._items[event.detail.firstItem.index] : undefined;

        that._handleAutoSave();
        that.$.fireEvent('stateChange', { type: 'resize', item: targetItem });
    }

    /**
     * Key down event handler
     * @param {any} event
     */
    _keyDownHandler(event) {
        const that = this;

        if (that.disabled || !that.hasAttribute('dragged') || !that._snapFeedback) {
            return;
        }

        event.preventDefault();

        if (event.key === 'Control') {
            //Hide the snap feedback
            if (that.snapMode === 'advanced') {
                for (let el in that._snapFeedback) {
                    if (that._snapFeedback[el] instanceof HTMLElement) {
                        if (el === 'outherSnapElement') {
                            const outherElements = that.$.container.children;

                            for (let i = 0; i < outherElements.length; i++) {
                                if (outherElements[i].className.indexOf('jqx-docking-layout-snap') > -1) {
                                    outherElements[i].classList.add('jqx-hidden');
                                }
                            }

                            continue;
                        }

                        that._snapFeedback[el].classList.add('jqx-hidden');
                    }
                }
            }
            else {
                that._snapFeedback.classList.add('jqx-hidden');
            }
        }
        else if (event.key === 'Escape') {
            that._cancelDragOperation();
        }
    }

    /**
    * Key up event handler
    * @param {any} event
    */
    _keyUpHandler(event) {
        const that = this;

        if (that.disabled || event.key !== 'Control' || !that.hasAttribute('dragged') || !that._snapFeedback) {
            return;
        }

        event.preventDefault();

        //Show that._snapFeedback
        if (that.snapMode === 'advanced') {
            for (let el in that._snapFeedback) {
                if (that._snapFeedback[el] instanceof HTMLElement) {
                    if (el === 'outherSnapElement') {
                        const outherElements = that.$.container.children;

                        for (let i = 0; i < outherElements.length; i++) {
                            if (outherElements[i].className.indexOf('jqx-docking-layout-snap') > -1) {
                                outherElements[i].classList.remove('jqx-hidden');
                            }
                        }

                        continue;
                    }

                    that._snapFeedback[el].classList.remove('jqx-hidden');
                }
            }

            that._handleSnapping();
        }
        else {
            that._snapFeedback.classList.remove('jqx-hidden');
        }
    }

    /**
     * Loads the previously saved state to the element
     * @param {any} state 
     */
    _loadState(state) {
        const that = this;

        that._createItemsFromArray(state, true);
    }

    /**
    * Removes all Layout items
    */
    _removeAll(noPlaceholder) {
        const that = this;

        function removeAutoHideItems(splitter) {
            const items = splitter._items;

            for (let i = 0; i < items.length; i++) {
                if (!items[i].$.hasClass('jqx-docking-layout-item-holder')) {
                    splitter.removeChild(items[i]);
                }
            }
        }

        that.$.itemsContainer.removeAll();

        //Remove auto-hidden-items
        removeAutoHideItems(that.$.horizontalHiddenItemsContainer);
        removeAutoHideItems(that.$.verticalHiddenItemsContainer);

        that._items = [];

        if (!noPlaceholder) {
            that.$.itemsContainer.appendChild(that.$.placeholderItem);
        }
    }

    /**
     * Removes unneccessary splitter elements when moving or removing items
     * @param {any} splitterContainer
     * @param {any} splitterItemForRemoval
     */
    _removeUnneccessaryItems(splitterContainer) {
        if (!splitterContainer) {
            return;
        }

        const that = this;
        let parentItem;

        while (splitterContainer._items.length === 0 && splitterContainer !== that.$.itemsContainer) {
            (parentItem = splitterContainer.closest('jqx-splitter-item')).removeChild(splitterContainer);
            splitterContainer = parentItem.closest('jqx-splitter');
            splitterContainer.removeChild(parentItem);
        }
    }

    /**
    * Return item to original position
    * @param {any} item
    */
    _returnItemToOrigin(item) {
        const that = this;

        if (!item || !that._dragDetails) {
            return;
        }

        let parentInfo = that._dragDetails._parentInfo;

        if (!parentInfo) {
            return;
        }

        if (typeof (parentInfo.position) === 'number') {
            const tabItems = [].slice.call(item.items);

            for (let i = 0; i < tabItems.length; i++) {
                item.removeChild(tabItems[i]);
                parentInfo.closestItem.insert(parentInfo.position, { node: tabItems[i] });
            }
        }
        else if (typeof parentInfo.position === 'object') {
            item.style.top = parentInfo.position.top + 'px';
            item.style.left = parentInfo.position.left + 'px';
        }
        else {
            if (!parentInfo.closestItem) {
                that.appendChild(item);
            }
            else {
                if (parentInfo.closestItem === that.$.itemsContainer) {
                    that._autoHide(item, parentInfo.position);
                }
                else {
                    that._insert(that._items.indexOf(parentInfo.closestItem), item, parentInfo.position);
                }
            }
        }
    }

    /**
     * Calculates the paddings if the horizontal autoHidden items if vertical auto hiden items are present.
     */
    _setAutoHidePaddings() {
        const that = this,
            leftAutoHiddenItem = that.$.verticalHiddenItemsContainer.getElementsByClassName('auto-hide-left')[0],
            rightAutoHiddenItem = that.$.verticalHiddenItemsContainer.getElementsByClassName('auto-hide-right')[0],
            topAutoHiddenitem = that.$.horizontalHiddenItemsContainer.getElementsByClassName('auto-hide-top')[0],
            bottomAutoHiddenitem = that.$.horizontalHiddenItemsContainer.getElementsByClassName('auto-hide-bottom')[0];

        if (topAutoHiddenitem) {
            topAutoHiddenitem.style.paddingLeft = leftAutoHiddenItem ? leftAutoHiddenItem.offsetWidth + 'px' : '';
            topAutoHiddenitem.style.paddingRight = rightAutoHiddenItem ? rightAutoHiddenItem.offsetWidth + 'px' : '';
        }

        if (bottomAutoHiddenitem) {
            bottomAutoHiddenitem.style.paddingLeft = leftAutoHiddenItem ? leftAutoHiddenItem.offsetWidth + 'px' : '';
            bottomAutoHiddenitem.style.paddingRight = rightAutoHiddenItem ? rightAutoHiddenItem.offsetWidth + 'px' : '';
        }
    }

    /**
     * Sets the header buttons for all docked items
     * @param {any} tabsWindow
     */
    _setDockedItemsHeaderButtons(tabsWindow) {
        let headerButtons = tabsWindow.headerButtons,
            reservedButtons = ['close', 'maximize', 'minimize'];

        let dockedItemHeaderButtons = headerButtons.filter(buttonName => reservedButtons.indexOf(buttonName) < 0);

        if (dockedItemHeaderButtons.length === 0) {
            dockedItemHeaderButtons = ['close', 'autoHide'];
        }
        else {
            dockedItemHeaderButtons = headerButtons;
        }

        tabsWindow.headerButtons = dockedItemHeaderButtons;
    }

    /**
     * Sets the header buttons for the Floating Items
     * @param {any} tabsWindow
     */
    _setFloatingItemsHeaderButtons(tabsWindow) {
        const defaultButtons = ['close', 'autoHide']; // ['dock', 'autoHide']

        tabsWindow._originalTabPosition = tabsWindow.tabPosition;

        let floatingItemButtons = tabsWindow.headerButtons.filter(buttonName => defaultButtons.indexOf(buttonName) < 0);

        //Default FloatingItems buttons
        if (floatingItemButtons.length === 0) {
            floatingItemButtons = ['close', 'maximize', 'minimize'];
        }
        else {
            floatingItemButtons = tabsWindow.headerButtons;
        }

        tabsWindow.headerButtons = floatingItemButtons;
    }

    /**
    * Sets tab index
    */
    _setFocusable() {
        const that = this;

        if (!that.disabled && !that.unfocusable) {
            let index = that.tabIndex > 0 ? that.tabIndex : 0;

            that.setAttribute('tabindex', index);
        }
        else {
            that.removeAttribute('tabindex');
        }
    }

    /**
     * Checks if snapping highlighters/markers should appear or not
     */
    _setSnappingMarkers(event, tabHeader) {
        const that = this,
            target = JQX.Utilities.Core.isMobile ? document.elementFromPoint(event.pageX - window.pageXOffset, event.pageY - window.pageYOffset) : event.originalEvent.target,
            isInsideLayout = target.closest && target.closest('jqx-docking-layout');

        if (that.snapMode === 'advanced') {
            if (event.ctrlKey) {
                return;
            }

            that._dragDetails.hoveredItem = target.closest('.jqx-docking-layout-snap') ? target :
                (that._dragDetails.hoveredItem && that._dragDetails.hoveredItem.getElementsByTagName('jqx-splitter').length > 0 ? undefined : that._dragDetails.hoveredItem);
            that._dragDetails.hoveredTabArea = tabHeader ? (target.closest('.jqx-tab-label-container') || tabHeader) : that._dragDetails.hoveredTabArea;
            that._handleSnapping();
            return;
        }

        if (!isInsideLayout || isInsideLayout !== that) {
            that._handleSnapping();
            return;
        }

        if (!that._dragDetails.hoveredTabsWindow || (that._dragDetails.windowFeedback !== that.$.tabsWindowFeedback &&
            that._dragDetails.hoveredTabsWindow === that._dragDetails.selectedTabsWindow)) {
            that._dragDetails.hoveredItem = target.closest('.jqx-docking-layout-snap') ? target :
                (that._dragDetails.hoveredItem && that._dragDetails.hoveredItem.getElementsByTagName('jqx-splitter').length > 0 ? undefined : that._dragDetails.hoveredItem);
            that._handleSnapping();
            return;
        }

        let hoveredTabOffset = {};

        if (that._dragDetails.hoveredItem) {
            const hoveredItemRect = that._dragDetails.hoveredItem.getBoundingClientRect(),
                mainSplitterRect = that.$.itemsContainer.getBoundingClientRect();

            hoveredTabOffset.left = that._dragDetails.hoveredItem ? hoveredItemRect.left - mainSplitterRect.left : 0;
            hoveredTabOffset.top = that._dragDetails.hoveredItem ? hoveredItemRect.top - mainSplitterRect.top : 0;
        }
        else {
            hoveredTabOffset.left = hoveredTabOffset.top = 0;
        }

        const layoutRect = that.getBoundingClientRect(),
            itemsContainerRect = that.$.itemsContainer.getBoundingClientRect(),
            left = Math.max(0, event.pageX - window.pageXOffset - layoutRect.left - (itemsContainerRect.left - layoutRect.left)),
            top = Math.max(0, event.pageY - window.pageYOffset - layoutRect.top - (itemsContainerRect.top - layoutRect.top));

        if (that._dragDetails.hoveredTabArea === tabHeader) {
            that._dragDetails.hoveredTabArea = target.closest('.jqx-tab-label-container');
            that._handleSnapping('header');
        }
        else if (that._dragDetails.hoveredItem && !that._dragDetails.hoveredTabsWindow.autoHide) {
            if (left < that.$.itemsContainer.offsetWidth * 0.05 && left < that._dragDetails.hoveredItem.offsetWidth * 0.15) {
                that._handleSnapping('layout-left', event);
            }
            else if (left > that.$.itemsContainer.offsetWidth * 0.95 && left > that._dragDetails.hoveredItem.offsetWidth * 0.85 + that._dragDetails.hoveredItem.offsetLeft) {
                that._handleSnapping('layout-right');
            }
            else if (top < that.$.itemsContainer.offsetHeight * 0.05) {
                that._handleSnapping('layout-top');
            }
            else if (top > that.$.itemsContainer.offsetHeight * 0.95) {
                that._handleSnapping('layout-bottom');
            }
            else if (target.closest('.jqx-tabs-content-section')) {
                const orientation = that._dragDetails.hoveredItem.closest('jqx-splitter').orientation;

                if (left < hoveredTabOffset.left + that._dragDetails.hoveredTabArea.offsetWidth * 0.3) {
                    that._handleSnapping(orientation === 'horizontal' ? 'inside-left' : 'left');
                }
                else if (left > hoveredTabOffset.left + that._dragDetails.hoveredTabArea.offsetWidth * 0.7) {
                    that._handleSnapping(orientation === 'horizontal' ? 'inside-right' : 'right');
                }
                else if (top < hoveredTabOffset.top + that._dragDetails.hoveredTabArea.offsetTop + that._dragDetails.hoveredTabArea.offsetHeight * 0.5 +
                    that._dragDetails.hoveredTabsWindow.$.headerSection.offsetHeight) {
                    that._handleSnapping(orientation === 'vertical' ? 'inside-top' : 'top');
                }
                else {
                    that._handleSnapping(orientation === 'vertical' ? 'inside-bottom' : 'bottom');
                }
            }
            else {
                that._handleSnapping();
            }
        }
        else {
            that._handleSnapping();
        }
    }

    /**
     * Handles the hideSplitterBars property
     */
    _setSplitterBarVisibility() {
        const that = this,
            splitterBars = that.$.itemsContainer.getElementsByTagName('jqx-splitter-bar');

        for (let i = 0; i < splitterBars.length; i++) {
            that.hideSplitterBars ? splitterBars[i].hide() : splitterBars[i].show();
        }
    }

    /**
     * Keeps the window in the browser viewport
     * @param {any} targetWindow
     */
    _validateWindowPosition(targetWindow) {
        //Keeps the target inside view if possible. documentElement.clientSize !== scrollElement.clientSize in EDGE and Safari !

        targetWindow.$.addClass('no-transition', '');

        const scrollElement = document.scrollingElement || document.documentElement;

        if (scrollElement.scrollTop > 0) {
            targetWindow.style.top = (parseFloat(targetWindow.style.top) || targetWindow.offsetTop) + 'px';
        }
        else {
            //Keeps the window in the available ( window ) drop zone
            targetWindow.style.top = Math.max(0, Math.min(targetWindow.offsetTop, document.documentElement.clientHeight - targetWindow.offsetHeight)) + 'px';
        }

        if (scrollElement.scrollLeft > 0) {
            targetWindow.style.left = (parseFloat(targetWindow.style.left) || targetWindow.offsetTop) + 'px';
        }
        else {
            //Keeps the window in the available ( window ) drop zone
            targetWindow.style.left = Math.max(0, Math.min(targetWindow.offsetLeft, document.documentElement.clientWidth - targetWindow.offsetWidth)) + 'px';
        }

        //Avoid transitions
        requestAnimationFrame(() => targetWindow.$.removeClass('no-transition'));
    }
});
/**
* jqxFileUpload custom element.
*/
JQX('jqx-file-upload', class FileUpload extends JQX.BaseElement {
    /**
    * Element's properties
    */
    static get properties() {
        return {
            'accept': {
                value: null,
                type: 'string?'
            },
            'appendTo': {
                value: null,
                type: 'any'
            },
            'autoUpload': {
                value: false,
                type: 'boolean'
            },
            'directory': {
                value: false,
                type: 'boolean'
            },
            'dropZone': {
                value: null,
                type: 'any'
            },
            'hideFooter': {
                value: false,
                type: 'boolean'
            },
            'itemTemplate': {
                value: null,
                type: 'any'
            },
            'messages': {
                value: {
                    'en': {
                        'browse': 'Browse',
                        'uploadFile': 'Upload File',
                        'cancelFile': 'Cancel File',
                        'pauseFile': 'Pause File',
                        'uploadAll': 'Upload All',
                        'cancelAll': 'Cancel All',
                        'pauseAll': 'Pause All',
                        'totalFiles': 'Total files: ',
                        'connectionError': '{{elementType}}: File Upload requires connection to the server.',
                        'wrongItemIndex': '{{elementType}}: There is no file with such an index in the list of uploaded files.',
                        'tooLongFileName': '{{elementType}}: File name is too long.'
                    }
                },
                type: 'object',
                extend: true
            },
            'multiple': {
                value: false,
                type: 'boolean'
            },
            'name': {
                value: '',
                type: 'string'
            },
            'responseHandler': {
                value: null,
                type: 'function?',
                reflectToAttribute: false
            },
            'setHeaders': {
                value: null,
                type: 'function?',
                reflectToAttribute: false
            },
            'showProgress': {
                value: false,
                type: 'boolean'
            },
            'validateFile': {
                value: null,
                type: 'function?',
                reflectToAttribute: false
            },
            'uploadUrl': {
                value: '',
                type: 'string',
                reflectToAttribute: false
            }
        }
    }

    /**
    * Element's event listeners.
    */
    static get listeners() {
        return {
            'browseButton.click': 'browse',
            'browseInput.change': '_browseInputChangeHandler',
            'selectedFiles.click': '_selectedFilesClickHandler',
            'uploadAllButton.click': 'uploadAll',
            'cancelAllButton.click': 'cancelAll',
            'pauseAllButton.click': 'pauseAll',
            'dropZone.dragenter': '_dropZoneHandler',
            'dropZone.dragleave': '_dropZoneHandler',
            'dropZone.dragover': '_dropZoneHandler',
            'dropZone.drop': '_dropZoneHandler',

            'resize': '_handleComponentsByAvailableHeight'
        }
    }

    /**
    * Checks for missing modules.
    */
    static get requires() {
        return {
            'JQX.Button': 'jqxbutton.js',
            'JQX.ProgressBar': 'jqxprogressbar.js'
        }
    }

    /**
    * Element's HTML template.
    */
    template() {
        return `<div id="container">
                    <div id="fileUploadHeader" class ="jqx-file-upload-header">
                        <jqx-button class ="jqx-browse-button" id="browseButton" disabled="[[disabled]]" theme="[[theme]]"></jqx-button>
                        <input type="file" class ="jqx-browse-input" id="browseInput" name="[[name]]" animation="[[animation]]" disabled="[[disabled]]" unfocusable="[[unfocusable]]" multiple="[[multiple]]" webkitdirectory="[[directory]]" mozdirectory="[[directory]]" />
                    </div>
                    <div id="fileUploadContainer" class ="jqx-file-upload-container">
                        <div id="dropZone" class ="jqx-drop-zone"></div>
                        <div id="selectedFiles" class ="jqx-selected-files"></div>
                    </div>
                    <div id="totalFiles" class ="jqx-total-files jqx-hidden">Total flies: 0</div>
                    <div id="fileUploadFooter" class ="jqx-file-upload-footer jqx-hidden">
                        <jqx-button class ="jqx-upload-all-button success" id="uploadAllButton" animation="[[animation]]" disabled="[[disabled]]" unfocusable="[[unfocusable]]"" theme="[[theme]]"></jqx-button>
                        <jqx-button class ="jqx-cancel-all-button error" id="cancelAllButton" animation="[[animation]]" disabled="[[disabled]]" unfocusable="[[unfocusable]]" theme="[[theme]]"></jqx-button>
                        <jqx-button class ="jqx-pause-all-button primary" id="pauseAllButton" animation="[[animation]]" disabled="[[disabled]]" unfocusable="[[unfocusable]]" theme="[[theme]]"></jqx-button>
                    </div>
                </div>`;
    }

    /**
    * Updates the element when a property is changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
    * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        super.propertyChangedHandler(propertyName, oldValue, newValue);

        switch (propertyName) {
            case 'accept':
                that.$.browseInput.accept = newValue;
                break;
            case 'dropZone':
            case 'appendTo':
                that._handleContainers();
                break;
            case 'messages':
            case 'locale':
                that._updateTextValues();
                break;
            case 'multiple':
                that.$.browseButton.disabled = (!that.multiple && that._selectedFiles.length > 0) || that.disabled ? true : false;

                if (!newValue && that._selectedFiles.length > 1) {
                    that._selectedFiles.splice(1);
                    that._renderSelectedFiles();
                }
                break;
            case 'itemTemplate':
                if (that._items.length > 0) {
                    that._renderSelectedFiles();

                    that._handleComponentsByAvailableHeight();
                }
                break;
        }
    }

    /**
    * Called when the element is attached to the DOM.
    */
    attached() {
        super.attached();
        const that = this;

        that._handleContainers();
    }

    /**
    * Called when the element is detached from the DOM.
    */
    detached() {
        super.detached();
        const that = this;

        if (!that.$.fileUploadContainer.contains(that.$.dropZone)) {
            that.$.fileUploadContainer.insertBefore(that.$.dropZone, that.$.fileUploadContainer.firstChild);
        }

        if (!that.$.fileUploadContainer.contains(that.$.selectedFiles)) {
            that.$.fileUploadContainer.appendChild(that.$.selectedFiles);
        }
    }

    /**
    * Element's ready method.
    */
    ready() {
        super.ready();
        const that = this;

        that._setInitialValues();
        that._updateTextValues();
        that._handleContainers();
        that._handleComponentsByAvailableHeight();
    }

    /**
    * Browses for a file
    */
    browse() {
        const that = this;

        if (that.disabled || (!that.multiple && that._selectedFiles.length > 0)) {
            return;
        }

        that.$.browseInput.click();
    }

    /**
    * Cancels all selected files
    */
    cancelAll() {
        const that = this;

        if (that.disabled || that._items.length === 0) {
            return;
        }

        for (let i = that._items.length - 1; i >= 0; i--) {
            that.cancelFile(that._items[i].index);
        }

        that.$.browseButton.disabled = (!that.multiple && that._selectedFiles.length > 0) || that.disabled ? true : false;
    }

    /**
    * Cancels single file.
    * @param {number/string} index - File index.
    */
    cancelFile(index) {
        const that = this;

        if (!(typeof index === 'number') || that.disabled || that._selectedFiles.length === 0) {
            return;
        }

        const item = that._getFileItem(index, true);

        if (!item) {
            that.error(that.localize('wrongItemIndex', { elementType: that.nodeName.toLowerCase() }));
            return;
        }

        const itemIndexInArray = that._items.indexOf(item);

        that.$.selectedFiles.removeChild(item);

        if (item && item.xhr) {
            item.xhr.abort();
        }

        that._selectedFiles.splice(itemIndexInArray, 1);
        that._items.splice(itemIndexInArray, 1);

        that.$.fireEvent('uploadCanceled', {
            'filename': item.file.name,
            'type': item.file.type,
            'size': item.file.size,
            'index': item.index
        });

        that.$.browseButton.disabled = (!that.multiple && that._selectedFiles.length > 0) || that.disabled ? true : false;

        if (that._selectedFiles.length === 0) {
            that.$.fileUploadFooter.classList.add('jqx-hidden');
        }

        that._handleComponentsByAvailableHeight();
    }

    /**
    * Pauses upload of all files
    */
    pauseAll() {
        const that = this;

        if (that.disabled || that._items.length === 0) {
            return;
        }

        for (let i = that._items.length - 1; i >= 0; i--) {
            let item = that._items[i];

            if (item.xhr) {
                item.xhr.abort();
            }
        }
    }

    /**
    * Pauses particular file upload
    * @param {number/string} index - File index.
    */
    pauseFile(index) {
        const that = this;

        if ((typeof index !== 'number' && typeof index !== 'string') || that.disabled || that._items.length === 0) {
            return;
        }

        const item = that._getFileItem(index, true);

        if (!item) {
            that.error(that.localize('wrongItemIndex', { elementType: that.nodeName.toLowerCase() }));
            return;
        }

        item.classList.remove('jqx-uploading-start');

        if (item && item.xhr) {
            item.xhr.abort();
        }

        that.$.fireEvent('uploadPaused', {
            'filename': item.file.name,
            'type': item.file.type,
            'size': item.file.size,
            'index': item.index
        });
    }

    /**
    * Uploads all selected files
    */
    uploadAll() {
        const that = this;

        if (that.disabled || that._items.length === 0) {
            return;
        }

        for (let i = that._items.length - 1; i >= 0; i--) {
            if (!that._items[i].uploading) {
                that.uploadFile(that._items[i].index);
            }
        }
    }

    /**
    * Uploads single file. Selection by index
    * @param {number/string} index - File index.
    */
    uploadFile(index) {
        const that = this;
        let isOnProgress = false;

        if (!(typeof index === 'number') || that.disabled || that._selectedFiles.length === 0) {
            return;
        }

        const selectedItem = that._getFileItem(index, true);

        if (!selectedItem) {
            return;
        }

        let formData = new FormData(),
            progressBar = that.showProgress ? selectedItem.getElementsByTagName('jqx-progress-bar')[0] : null, // to be handled case with custom template
            selectedFile = selectedItem.file;

        selectedItem.classList.remove('jqx-pause', 'jqx-error');
        selectedItem.classList.add('jqx-uploading-start');
        formData.append('userfile[]', selectedFile);

        let request = new XMLHttpRequest();

        request.open('POST', that.uploadUrl);

        if (that.setHeaders && typeof that.setHeaders === 'function') {
            that.setHeaders(request, selectedFile);
        }

        that.$.fireEvent('uploadStarted', {
            'filename': selectedItem.file.name,
            'type': selectedItem.file.type,
            'size': selectedItem.file.size,
            'index': selectedItem.index
        });

        request.upload.onprogress = function (event) {
            if (!isOnProgress) {
                isOnProgress = true;
                selectedItem.classList.remove('jqx-uploading-start');
                selectedItem.classList.add('jqx-uploading');
                selectedItem.uploading = true;
                selectedItem.xhr = request;
            }

            if (progressBar) {
                progressBar.value = Math.round((event.loaded / event.total) * 100);
            }

            selectedItem.classList.remove('jqx-pause', 'jqx-error');
        };

        request.onabort = function () {
            selectedItem.classList.remove('jqx-uploading-start', 'jqx-uploading');
            selectedItem.classList.add('jqx-pause');

            selectedItem.addEventListener('animationend', function () {
                selectedItem.classList.remove('jqx-pause', 'jqx-error');
            });
        };

        request.onerror = function () {
            selectedItem.classList.remove('jqx-uploading-start', 'jqx-uploading');
            selectedItem.classList.add('jqx-error');

            selectedItem.addEventListener('animationend', function () {
                selectedItem.classList.remove('jqx-pause', 'jqx-error');
            });
        };

        request.onload = function () {
            isOnProgress = false;
            selectedItem.classList.remove('jqx-uploading-start', 'jqx-uploading');

            if (request.status >= 200 && request.status <= 299) {
                let actualIndex = that._items.indexOf(selectedItem);

                that.$.selectedFiles.removeChild(selectedItem);
                that._selectedFiles.splice(that._selectedFiles.indexOf(selectedFile), 1);
                that._items.splice(actualIndex, 1);
                that.$.browseButton.disabled = (!that.multiple && that._selectedFiles.length > 0) || that.disabled ? true : false;

                that.$.fireEvent('uploadCompleted', {
                    'filename': selectedItem.file.name,
                    'type': selectedItem.file.type,
                    'size': selectedItem.file.size,
                    'status': request.status,
                    'index': selectedItem.index
                });

                if (that._selectedFiles.length === 0) {
                    that.$.fileUploadFooter.classList.add('jqx-hidden');
                }
            }
            else {
                selectedItem.classList.add('jqx-error');
                selectedItem.classList.remove('jqx-uploading');

                that.$.fireEvent('uploadError', {
                    'filename': selectedItem.file.name,
                    'type': selectedItem.file.type,
                    'size': selectedItem.file.size,
                    'status': request.status,
                    'index': selectedItem.index
                });
            }
        };

        request.onreadystatechange = function () {
            if (!that.responseHandler || typeof that.responseHandler !== 'function') {
                return;
            }

            that.responseHandler(request);
        };

        request.send(formData);
    }

    /**
     * Click handler about "selectedFiles" container
     */
    _selectedFilesClickHandler(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        const target = event.target,
            isItemUploadClicked = target.closest('.jqx-item-upload-button'),
            isItemCancelClicked = target.closest('.jqx-item-cancel-button'),
            isItemAbortClicked = target.closest('.jqx-item-pause-button'),
            clickedItem = target.closest('.jqx-file');

        if (isItemUploadClicked) {
            that.uploadFile(clickedItem.index);
        }
        else if (isItemCancelClicked) {
            that.cancelFile(clickedItem.index);
        }
        else if (isItemAbortClicked) {
            that.pauseFile(clickedItem.index);
        }
    }

    /**
    * Change handler of the browse input. When files are selected, they are updated into files array and rendered in the file list
    **/
    _browseInputChangeHandler() {
        const that = this,
            selectedFiles = that._filterNewFiles(Array.from(that.$.browseInput.files));
        let validNewFiles = [];

        if (that.disabled || selectedFiles.length === 0) {
            return;
        }

        if (that.validateFile && typeof that.validateFile === 'function') {
            validNewFiles = selectedFiles.filter(file => {
                if (that.validateFile(file)) {
                    return true;
                }

                that.$.fireEvent('validationError', {
                    'filename': file.name,
                    'type': file.type,
                    'size': file.size
                });

                return false;
            });
        }
        else {
            validNewFiles = selectedFiles;
        }

        that._selectedFiles = that._selectedFiles.concat(validNewFiles);

        if (that._selectedFiles.length === 0) {
            return;
        }

        that._renderSelectedFiles(validNewFiles);
        that.$.browseButton.disabled = (!that.multiple && that._selectedFiles.length > 0) || that.disabled ? true : false;
        that.$.browseInput.value = '';

        if (that.autoUpload) {
            that.uploadAll();
        }
    }

    /**
    * Returns the default item template
    * @param {string} fileName
    */
    _defaultItemTemplate(fileName) {
        const that = this,
            uploadString = that.localize('uploadFile'),
            cancelString = that.localize('cancelFile'),
            pauseString = that.localize('pauseFile');

        return `<span class ="jqx-item-name">${fileName}</span>
                <span class ="jqx-item-upload-button" title="${uploadString}"></span>
                <span class ="jqx-item-cancel-button" title="${cancelString}"></span>
                <span class ="jqx-item-pause-button" title="${pauseString}"></span>
                <jqx-progress-bar></jqx-progress-bar>`;
    }

    /**
     * dropZone event handler
     */
    _dropZoneHandler(event) {
        const that = this;

        event.preventDefault();
        event.stopPropagation();

        if (that.disabled) {
            return;
        }

        if (event.type === 'dragenter' || event.type === 'dragleave') {
            event.type === 'dragenter' ? that.$.dropZone.classList.add('jqx-drag-over') : that.$.dropZone.classList.remove('jqx-drag-over');
            return;
        }

        if (event.type === 'drop') {
            that.$.dropZone.classList.remove('jqx-drag-over');

            if (!that.multiple && that._selectedFiles.length > 0) {
                return;
            }

            if (event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files.length) {
                const droppedFiles = that._filterNewFiles(Array.from(event.dataTransfer.files));

                if (droppedFiles.length === 0) {
                    return;
                }

                if (!that.multiple) {
                    droppedFiles.splice(1);
                }

                that._selectedFiles = that._selectedFiles.concat(droppedFiles);
                that._renderSelectedFiles(droppedFiles);
            }

            that.$.browseButton.disabled = (!that.multiple && that._selectedFiles.length > 0) || that.disabled ? true : false;
        }
    }

    /**
    * Check for duplicated items during selection and add only new items in the selection list
    * @param {array} newSelection - an array with selected files
    **/
    _filterNewFiles(newSelection) {
        const that = this;
        let newFiles = [];

        for (let i = 0; i < newSelection.length; i++) {
            let notYetSelected = true;

            for (let j = 0; j < that._selectedFiles.length; j++) {
                const oldFile = that._selectedFiles[j],
                    newFile = newSelection[i];

                if (newFile.name === oldFile.name && newFile.size === oldFile.size && newFile.type === oldFile.type && newFile.lastModified === oldFile.lastModified) {
                    notYetSelected = false;
                    break;
                }
            }

            if (notYetSelected) {
                newFiles.push(newSelection[i]);
            }
        }

        return newFiles;
    }

    /**
     * Gets an item from the array with files if it matches particular file name or index
     */
    _getFileItem(value, byIndex) {
        const that = this;
        let match = null;

        if (!value || (typeof value !== 'string' && typeof value !== 'number')) {
            return;
        }

        if (!that._items || that._items.length === 0) {
            return null;
        }

        for (let i = 0; i < that._items.length; i++) {
            const item = that._items[i];

            if ((byIndex && item.index === parseInt(value)) || (item.file.name === value)) {
                match = item;
            }
        }

        return match;
    }

    /**
     * Handles "dropZone" and "selectedFiles" contaners if they are append to external elements
     */
    _handleContainers() {
        const that = this,
            dropZone = that._validateDOMElement(that.dropZone),
            appendTo = that._validateDOMElement(that.appendTo);

        if (dropZone) {
            dropZone.appendChild(that.$.dropZone);
        }
        else {
            that.$.fileUploadContainer.insertBefore(that.$.dropZone, that.$.fileUploadContainer.firstChild);
        }

        if (appendTo) {
            appendTo.appendChild(that.$.selectedFiles);
        }
        else {
            that.$.fileUploadContainer.appendChild(that.$.selectedFiles);
        }
    }

    /**
    * Applies the item template
    * @param {string} fileName
    */
    _handleItemTemplate(filename) {
        const that = this;
        let template = that.itemTemplate;

        if (!('content' in document.createElement('template'))) {
            that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() }));
            return;
        }

        if (!template) {
            return that._defaultItemTemplate(filename);
        }

        if (typeof template === 'string') {
            template = document.getElementById(template);
        }

        if (template === null || !('content' in template)) {
            that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: 'template' }));
            return;
        }

        const content = template.innerHTML,
            regex = /{{\w+}}/g;

        return content.replace(regex, filename);
    }

    /**
    * Renders selected files - by defauld file name, upload button, cancel button
    * @param {array} files - Array with all selected files.
    **/
    _renderSelectedFiles(files) {
        const that = this,
            itemsFragment = document.createDocumentFragment(),
            filesToRender = files || that._selectedFiles;

        if (!files) {
            that._items = [];
            that.$.selectedFiles.innerHTML = '';
        }

        for (let i = 0; i < filesToRender.length; i++) {
            const fileName = that.directory ? filesToRender[i].webkitRelativePath : filesToRender[i].name,
                item = document.createElement('div');

            that._incrementIndex++;
            item.className = 'jqx-file';
            item.index = that._incrementIndex;
            item.setAttribute('item-id', that._incrementIndex);
            item.innerHTML = that.itemTemplate ? that._handleItemTemplate(fileName) : that._defaultItemTemplate(fileName);
            item.file = filesToRender[i];
            item.uploading = false;
            item.xhr = null;

            itemsFragment.appendChild(item);
            that._items.push(item);

            that.$.fireEvent('fileSelected', {
                'filename': filesToRender[i].name,
                'type': filesToRender[i].type,
                'size': filesToRender[i].size,
                'index': item.index
            });
        }

        that.$.selectedFiles.appendChild(itemsFragment);
        that.$.fileUploadFooter.classList.remove('jqx-hidden');

        that._handleComponentsByAvailableHeight(); // flag about cancel all to prevent recalculations every time when file is canceled
    }

    /**
    * Sets values on initialization
    **/
    _setInitialValues() {
        const that = this;

        that.$.browseInput.accept = that.accept;
        that._selectedFiles = [];
        that._items = [];
        that._incrementIndex = 0;
    }

    /**
    * Updates the values of all file uploads buttons an popups
    **/
    _updateTextValues() {
        const that = this,
            buttons = ['browse', 'uploadAll', 'cancelAll', 'pauseAll'];

        for (let i = 0; i < buttons.length; i++) {
            const localizationString = buttons[i],
                buttonName = localizationString + 'Button';

            that.$[buttonName].innerHTML = that.localize(localizationString);
        }

        for (let i = 0; i < that._selectedFiles.length; i++) {
            const item = that._items[i];

            item.querySelector('.jqx-item-upload-button').title = that.localize('uploadFile');
            item.querySelector('.jqx-item-cancel-button').title = that.localize('cancelFile');
            item.querySelector('.jqx-item-pause-button').title = that.localize('pauseFile');
        }
    }

    /**
    * Validates if an element exists in DOM
    * @param {string} fileName
    **/
    _validateDOMElement(element) {
        if (!element) {
            return;
        }

        if (typeof element === 'string') {
            return document.getElementById(element);
        }
        else if (element instanceof HTMLElement) {
            return element;
        }
    }


    /**
    * Validates element's height
    **/
    _handleComponentsByAvailableHeight() {
        const that = this;

        that._calculateAvailableContainerHeight();

        if (that._elementsAutoHeight > that.offsetHeight) {
            that.$.container.classList.add('jqx-overflow');
            that._containerOverflows = true;

            if (that._rowHeight) {
                const remainingFiles = parseInt(that._availableHeight / that._rowHeight);

                for (let i = 0; i < that._items.length; i++) {
                    const item = that._items[i];
                    i < remainingFiles ? item.classList.remove('jqx-hidden') : item.classList.add('jqx-hidden');
                }

                if (that._items.length > remainingFiles) {
                    that.$.totalFiles.innerHTML = that.localize('totalFiles') + that._items.length;
                    that.$.totalFiles.classList.remove('jqx-hidden');
                }
                else {
                    that.$.totalFiles.classList.add('jqx-hidden');
                }
            }
        }
        else if (that.dropZone === '' && that._elementsAutoHeight < that.offsetHeight) {
            that.$.container.classList.remove('jqx-overflow');
            that._containerOverflows = false;
        }

    }

    /**
    * Calculates available container height
    **/
    _calculateAvailableContainerHeight() {
        const that = this,
            containerStyles = window.getComputedStyle(that.$.fileUploadContainer, null),
            fileUploadContainerOffset = parseInt(containerStyles.getPropertyValue('margin-top')) + parseInt(containerStyles.getPropertyValue('margin-bottom')) + parseInt(containerStyles.getPropertyValue('padding-top')) + parseInt(containerStyles.getPropertyValue('padding-bottom')),
            fileRow = that.$.container.querySelector('.jqx-file'),
            headersHeight = that.$.fileUploadHeader.offsetHeight,
            footersHeight = that.$.fileUploadFooter.offsetHeight,
            inlineHeight = that.style.height;
        let totalFilesContainerHeight = 0;

        if (fileRow) {
            that._rowHeight = fileRow.offsetHeight;
        }

        that.style.height = 'auto';

        if (that._containerOverflows) {
            that.$.container.classList.remove('jqx-overflow');
        }

        that._elementsAutoHeight = that.offsetHeight;
        that.style.height = inlineHeight;

        if (that._containerOverflows) {
            that.$.container.classList.add('jqx-overflow');
        }

        if (that.$.totalFiles.classList.contains('jqx-hidden') > -1) {
            that.$.totalFiles.classList.remove('jqx-hidden');
            totalFilesContainerHeight = that.$.totalFiles.offsetHeight;
            that.$.totalFiles.classList.add('jqx-hidden');
        }

        that._availableHeight = that.offsetHeight - (headersHeight + footersHeight) - fileUploadContainerOffset - totalFilesContainerHeight;
    }
});
/**
 * jqxFilterBuilder custom element.
 */
JQX('jqx-filter-builder', class FilterBuilder extends JQX.BaseElement {
    /**
    * Element's properties
    */
    static get properties() {
        return {
            'customOperations': {
                value: [],
                type: 'array',
                reflectToAttribute: false
            },
            'disableContextMenu': {
                value: false,
                type: 'boolean'
            },
            'fields': {
                value: null,
                type: 'array?',
                reflectToAttribute: false
            },
            'formatStringDate': {
                value: 'dd-MMM-yy',
                type: 'string'
            },
            'formatStringDateTime': {
                value: 'dd-MMM-yy HH:mm:ss',
                type: 'string'
            },
            'hint': {
                value: null,
                type: 'string?'
            },
            'icons': {
                value: {
                    '=': '=',
                    '<>': '',
                    '>': '>',
                    '>=': '',
                    '<': '<',
                    '<=': '',
                    'startswith': 'a|bc',
                    'endswith': 'ab|c',
                    'contains': 'abc',
                    'notcontains': '!abc',
                    'isblank': '',
                    'isnotblank': ''
                },
                type: 'object',
                reflectToAttribute: false
            },
            'maxConditions': {
                value: null,
                type: 'number?',
                validator: '_maxValidator'
            },
            'maxConditionsPerGroup': {
                value: null,
                type: 'number?',
                validator: '_maxValidator'
            },
            'maxLevel': {
                value: null,
                type: 'number?',
                validator: '_maxValidator'
            },
            'messages': {
                value: {
                    'en': {
                        'add': 'Add',
                        'addCondition': 'Add Condition',
                        'addGroup': 'Add Group',
                        'and': 'And',
                        'notand': 'Not And',
                        'or': 'Or',
                        'notor': 'Not Or',
                        '=': 'Equals',
                        '<>': 'Does not equal',
                        '>': 'Greater than',
                        '>=': 'Greater than or equal to',
                        '<': 'Less than',
                        '<=': 'Less than or equal to',
                        'startswith': 'Starts with',
                        'endswith': 'Ends with',
                        'contains': 'Contains',
                        'notcontains': 'Does not contain',
                        'isblank': 'Is blank',
                        'isnotblank': 'Is not blank',
                        'wrongParentGroupIndex': '{{elementType}}: Wrong parent group index in "{{method}}" method.',
                        'missingFields': '{{elementType}}: Fields are required for proper condition\'s adding. Set "fields" source and then conditions will be added as expected.',
                        'wrongElementNode': '{{elementType}}: Incorect node / node Id in "{{method}}" method.',
                        'invalidDataStructure': '{{elementType}}: Used invalid data structure in updateCondition/updateGroup method.',
                        'dateTabLabel': 'DATE',
                        'timeTabLabel': 'TIME'
                    }
                },
                type: 'object',
                extend: true
            },
            'restrictedMode': {
                value: false,
                type: 'boolean'
            },
            'showIcons': {
                value: false,
                type: 'boolean'
            },
            'value': {
                value: ['or'],
                type: 'array?',
                reflectToAttribute: false
            },
            'valueFormatFunction': {
                value: null,
                type: 'function?',
                reflectToAttribute: false
            },
            'valuePlaceholder': {
                value: '&lt;enter a value&gt;',
                type: 'string'
            }
        }
    }

    /** 
    * Filter Builder's required files
    */
    static get requires() {
        return {
            'JQX.Button': 'jqxbutton.js',
            'JQX.CheckBox': 'jqxcheckbox.js',
            'JQX.ScrollBar': 'jqxscrollbar.js',
            'JQX.ListBox': 'jqxlistbox.js',
            'JQX.DropDownList': 'jqxdropdownlist.js',
            'JQX.ComboBox': 'jqxcombobox.js',
            'JQX.Calendar': 'jqxcalendar.js',
            'JQX.TimePicker': 'jqxtimepicker.js',
            'JQX.Tooltip': 'jqxtooltip.js',
            'JQX.Utilities.DateTime': 'jqxdate.js',
            'JQX.DateTimePicker': 'jqxdatetimepicker.js',
            'JQX.Menu': 'jqxmenu.js'
        }
    }

    /**
    * Element's event listeners.
    */
    static get listeners() {
        return {
            'click': '_clickHandler',
            'down': '_downHandler',
            'document.click': '_documentClickHandler',
            'conditionsMenu.itemClick': '_menuItemClickHandler',
            'container.change': '_containerChangeHandler',
            'scrollableContainer.wheel': '_scrollViewerWheelHandler',
            'scrollableOuterContainer.resize': '_resizeHandler',
            'innerContainer.keydown': '_innerContainerKeydownHandler'
        }
    }

    /**
    * Element's HTML template.
    */
    template() {
        return `<div id="container" title="[[hint]]">
                    <div id="innerContainer" class ="jqx-inner-container">
                            <div id="scrollableOuterContainer" class ="jqx-scrollable-outer-container">
                                <jqx-scroll-viewer id="scrollableContainer" class ="jqx-scrollable-container" animation="[[animation]]">
                                    <div id="contentContainer" class ="jqx-content-container"></div>
                                </jqx-scroll-viewer>
                            </div>
                            <div id="editorsContainer" class ="jqx-editors-container">
                                <div id="customEditor" class ="jqx-custom-editor jqx-hidden"></div>
                            </div>
                    </div>
                    <jqx-menu id="conditionsMenu" mode="dropDown" class ="jqx-conditions-menu" theme="[[theme]]" animation="[[animation]]"></jqx-menu>
            </div>`;
    }

    /**
    * Updates the element when a property is changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
    * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;
        const editors = ['textBoxEditor', 'numericTextBoxEditor', 'comboBoxEditor', 'dateTimePickerEditor', 'checkBoxEditor'];
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        switch (propertyName) {
            case 'animation':
            case 'theme':
                editors.forEach(editor => that.$[editor] && (that.$[editor][propertyName] = newValue));
                break;
            case 'customOperations':
                that._handleCustomOperations();
                that._refresh();
                break;
            case 'fields':
                that._mapFieldsToMenu();
                that._refresh();
                break;
            case 'formatStringDate':
            case 'formatStringDateTime':
            case 'showIcons':
            case 'valueFormatFunction':
                that._refresh();
                break;
            case 'locale':
            case 'messages':
                that._localizeInitialValues();
                that._refresh();
                that._handleCustomOperations();//

                if (that.$.dateTimePickerEditor) {
                    if (!that.$.dateTimePickerEditor.messages[that.locale]) {
                        that.$.dateTimePickerEditor.messages[that.locale] = {};
                    }

                    that.$.dateTimePickerEditor.messages[that.locale].dateTabLabel = that.localize('dateTabLabel');
                    that.$.dateTimePickerEditor.messages[that.locale].timeTabLabel = that.localize('timeTabLabel');

                    if (propertyName === 'locale') {
                        that.$.dateTimePickerEditor.locale = that.locale;
                    }
                    else if (propertyName === 'messages') {
                        that.$.dateTimePickerEditor.$.selectDate.innerHTML = that.$.dateTimePickerEditor.messages[that.locale].dateTabLabel;
                        that.$.dateTimePickerEditor.$.selectTime.innerHTML = that.$.dateTimePickerEditor.messages[that.locale].timeTabLabel;
                    }
                }

                break;
            case 'maxConditions':
            case 'maxConditionsPerGroup':
            case 'maxLevel':
            case 'value': {
                that._totalConditions = 0;
                that._validateValue();
                that._emptyElementsStructure(true);
                that._convertValueToFlat(that.value);
                that._getFieldsFromValue();
                that._mapFieldsToMenu();
                that._generateHTMLStructureFromFlatValue();
                that.$.scrollableContainer.refresh();

                const oldValueAsString = JSON.stringify(that.value);

                if (that._oldValueAsString !== oldValueAsString) {
                    that._oldValueAsString = oldValueAsString;
                    that.$.fireEvent('change', { 'value': JSON.parse(oldValueAsString) });
                }

                break;
            }
            case 'valuePlaceholder':
                that._updatePlaceholder();
                break;
        }
    }

    /**
     * Validates the value of "maxConditions", "maxConditionsPerGroup", and "maxLevel"
     * @param {any} oldValue - the old value
     * @param {any} value - the new value
     */
    _maxValidator(oldValue, newValue) {
        if (typeof newValue !== 'number') {
            return newValue;
        }

        return Math.max(1, newValue);
    }

    /**
    * Element's ready method.
    */
    ready() {
        super.ready();

        const that = this;

        that._validateValue();
        that._setInitialValues();
        that._handleCustomOperations();
        that._emptyElementsStructure(true);
        that._totalConditions = 0;
        that._convertValueToFlat(that.value);
        that._getFieldsFromValue();
        that._generateHTMLStructureFromFlatValue();
        that.$.conditionsMenu._noAutoFocus = true;

        that._oldValueAsString = JSON.stringify(that.value);

        setTimeout(function () {
            that.$.scrollableContainer.refresh();
        }, 25);
    }

    /*
    * Creates new condition
    * @param {Any} parentGroup - html object or group id
    * @param {Array} data - contains dataField, operator and value
    */
    addCondition(parentGroup, data) {
        const that = this;

        that._checkFieldsExistence();
        that._addElement('condition', parentGroup, data);
    }

    /*
    * Creates new empty group by given operator and parent group
    * @param {Any} parentGroup - could be html object or nodeId
    * @param {String} groupOperator - 'and'/'or'/'notand'/'notor'
    */
    addGroup(parentGroup, groupOperator) {
        const that = this;

        that._addElement('group', parentGroup, groupOperator);
    }

    /*
    * Removes condition
    * @param {Any} elementNode - HTML element or nodeId of the element
    */
    removeCondition(elementNode) {
        const that = this;

        that._validateNode(elementNode, 'removeCondition');
        that._deleteElement(elementNode, 'condition');
        that._refresh();
    }

    /*
    * Removes a group with all of it's children
    * @param {Any} elementNode - HTML element or nodeId of the element
    */
    removeGroup(elementNode) {
        const that = this;

        that._validateNode(elementNode, 'removeGroup');
        that._deleteElement(elementNode, 'group');
        that._refresh();
    }

    /**
    * Generates string representation of the value
    * @param {Boolean} useLabels - controls the way of string representation. In mode without labels the object is stringified. In mode with 
    */
    toString(useLabels) {
        const that = this;

        if (!useLabels) {
            return JSON.stringify(that.value);
        }

        let formattedValueFlat = [],
            groupsWithItems = [];

        for (let i = 0; i < that._valueFlat.length; i++) {
            const item = that._valueFlat[i];
            let formattedItem = {};

            if (item.type === 'condition') {
                const fieldData = that._getFieldByFieldName(item.data[0]),
                    type = fieldData.dataType,
                    category = '[' + (fieldData.label || fieldData.value) + ']',
                    operator = that.localize(item.data[1]),
                    value = ['boolean', 'number'].indexOf(type) !== -1 ? item.data[2] + '' : '\'' + item.data[2] + '\'';

                formattedItem.data = category + ' ' + operator + ' ' + value;
            }
            else {
                formattedItem.data = item.data;
            }

            formattedItem.nodeId = item.nodeId;
            formattedItem.parentId = item.parentId;
            formattedItem.type = item.type;

            formattedValueFlat.push(formattedItem);
        }

        for (let i = 0; i < formattedValueFlat.length; i++) {
            const item = formattedValueFlat[i];
            let group = {};

            if (item.type === 'group') {
                const hasItems = formattedValueFlat.filter(testItem => {
                    return (testItem.parentId === item.nodeId && testItem.type === 'condition');
                });

                if (hasItems.length > 0) {
                    let content = hasItems.map(mappedItem => mappedItem.data),
                        prefix = '',
                        sufix = '',
                        groupOperator = item.data;

                    if (['notand', 'notor'].indexOf(groupOperator) !== -1) {
                        prefix = 'Not (';
                        sufix = ')';
                        groupOperator = groupOperator.substring(3);
                    }

                    group.nodeId = item.nodeId;
                    group.parentId = item.parentId;
                    group.data = item.data;

                    group.structure = prefix + content.join(' ' + that.localize(groupOperator) + ' ') + sufix;
                    groupsWithItems.push(group);
                }
            }
        }

        groupsWithItems = groupsWithItems.filter(item => {
            return (item.structure.length > 1);
        });
        groupsWithItems.sort(function (a, b) {
            return (b.nodeId.split('.').length - a.nodeId.split('.').length);
        });

        for (let i = 0; i < groupsWithItems.length; i++) {
            const curentElement = groupsWithItems[i],
                parentElement = groupsWithItems.filter(item => {
                    return (item.nodeId === curentElement.parentId)
                })[0];

            if (parentElement && parentElement.structure) {
                let groupOperator = parentElement.data;

                if (['notand', 'notor'].indexOf(groupOperator) !== -1) {
                    groupOperator = groupOperator.substring(3);

                    parentElement.structure = parentElement.structure.slice(0, parentElement.structure.length - 1) + ' ' + that.localize(groupOperator) + ' (' + curentElement.structure + '))';
                }
                else {
                    parentElement.structure = parentElement.structure + ' ' + that.localize(groupOperator) + ' (' + curentElement.structure + ')';
                }
            }
        }

        return groupsWithItems[groupsWithItems.length - 1].structure;
    }

    /*
    * Updates content of a condition
    * @param {Any} elementNode - HTML element or nodeId of the element
    * @param {Array} data - an array with a new condition settings
    */
    updateCondition(elementNode, data) {
        const that = this,
            editedItem = that._validateNode(elementNode, 'updateCondition');

        that._validateUserData(data, true);

        editedItem.data = data;
        that._refresh();
    }

    /*
    * Updates content of a group
    * @param {Any} elementNode - HTML element or nodeId of the element
    * @param {String} data - the new state of the group condition operator
    */
    updateGroup(elementNode, data) {
        const that = this,
            editedItem = that._validateNode(elementNode, 'updateGroup');

        that._validateUserData(data);

        editedItem.data = data;
        that._refresh();
    }

    /*
    * Creates new group or condition
    * @param {String} type - 'group' or 'condition'
    * @param {Any} parentGroup - html object or group id
    * @param {Any} data - if type is group - contains group's operator;  if type is condition - dataField, operator and value
    */
    _addElement(type, parentGroup, data/*, noRefresh*/) {
        parentGroup = parentGroup || '0';

        const that = this,
            parentGroups = that._valueFlat.filter(item => {
                return (item.nodeId === parentGroup && item.type === 'group')
            }),
            parentGroupExists = parentGroups.length > 0 ? parentGroups[0] : false,
            siblings = that._valueFlat.filter(item => {
                return item.parentId === parentGroup
            });
        let addGroupAtPosition = 0,
            groupSeparator = '';

        if (!parentGroupExists) {
            that.error(that.localize('wrongParentGroupIndex', { elementType: that.nodeName.toLowerCase(), method: 'addGroup/addCondition' }));
        }

        if (type === 'group') {
            data = data || 'or';
        }
        else {
            if (siblings.filter(item => item.type === 'condition').length === that.maxConditionsPerGroup ||
                that._totalConditions === that.maxConditions) {
                return;
            }

            const defaultDataField = that.fields && that.fields.length > 0 ? that.fields[0].dataField : that._valueFields[0].dataField;

            that._totalConditions++;

            data = data || [];
            data[0] = data[0] || defaultDataField;
            data[1] = data[1] || '=';
            data[2] = typeof data[2] !== undefined ? data[2] : null;
        }

        if (siblings) {
            let siblingsIndexes = siblings.map(index => {
                const indexPath = index.nodeId.split('.');

                return parseInt(indexPath[indexPath.length - 1]);
            });

            siblingsIndexes = (siblingsIndexes.length === 0) ? [0] : siblingsIndexes;
            addGroupAtPosition = siblingsIndexes.reduce(function (a, b) {
                return Math.max(a, b);
            }) + 1;
        }

        if (parentGroup && parentGroup.length > 0) {
            groupSeparator = '.';
        }

        const itemId = parentGroup + groupSeparator + addGroupAtPosition,
            itemData = {
                nodeId: itemId,
                parentId: parentGroup,
                type: type,
                data: data,
                htmlNode: null
            };

        that._valueFlat.push(itemData);
        that._refresh();
    }

    /**
    * Sets condition row's value to null and sets value's container with valuePlaceholder
    */
    _clearConditionsValue(nodeId, type) {
        const that = this,
            itemAsHTML = that.querySelector('[node-id="' + (nodeId || 0) + '"]'),
            valueContainer = itemAsHTML.querySelector('.jqx-value-container');

        for (let i = 0; i < that._valueFlat.length; i++) {
            if (that._valueFlat[i].nodeId === nodeId) {
                const item = that._valueFlat[i],
                    dataType = type ? that.fields.find(field => field.dataField === type).dataType : that.fields.find(field => field.dataField === item.data[0]).dataType;

                item.data[2] = that._defaultValueByType(dataType);
            }
        }

        valueContainer.innerHTML = that.valuePlaceholder;
        valueContainer.closest('.jqx-filter-value').setAttribute('placeholder', '');
    }

    /**
    * Converts value(represented as nested array) to flat array. Used about internal data representation 
    * @param {Array} groupData - an array with group data
    * @param {String} nodeId - the id of the current element
    */
    _convertValueToFlat(groupData, nodeId) {
        const that = this,
            regEx = /^(and|or|notAnd|notOr)$/i;

        if (!groupData) {
            return;
        }

        const operatorsFilter = groupData.filter(element => ((typeof element === 'string') && element.match(regEx))),
            groupOperator = operatorsFilter ? operatorsFilter[0] : null,
            conditions = groupData.filter(element => {
                return (Array.isArray(element) &&
                    element.length === 3 &&
                    element.filter(subElement => (typeof subElement === 'string') && subElement.match(regEx)).length === 0)
            }),
            subGroups = groupData.filter(element => !conditions.includes(element) && element !== groupOperator);

        if (!operatorsFilter) {
            return;
        }

        const groupSeparator = that._lastProcessedItemInCurrentGroup.parentId ? '.' : '',
            groupNodeId = (that._lastProcessedItemInCurrentGroup.parentId || '') + groupSeparator + ((nodeId || 0));

        if (that._isMaxLevelExceeded(groupNodeId)) {
            return;
        }

        const itemData = {
            nodeId: groupNodeId,
            parentId: that._lastProcessedItemInCurrentGroup.parentId,
            type: 'group',
            data: groupOperator,
            htmlNode: null
        }/*,
            allowedConditionsInGroup = that.maxConditionsPerGroup ? that.maxConditionsPerGroup : conditions.length*/;

        that._valueFlat.push(itemData);
        that._lastProcessedItemInCurrentGroup.position = 0;


        for (let i = 0; i < conditions.length; i++) {
            if (!conditions[i]) {
                break;
            }

            const conditionNodeId = groupNodeId + '.' + ((that._lastProcessedItemInCurrentGroup.position || 0));

            if (that._isMaxLevelExceeded(conditionNodeId)) {
                break;
            }

            const itemData = {
                nodeId: conditionNodeId,
                parentId: groupNodeId,
                type: 'condition',
                data: conditions[i],
                htmlNode: null
            };

            that._totalConditions++;
            that._valueFlat.push(itemData);
            that._lastProcessedItemInCurrentGroup.position++;
        }

        // process nested elements
        for (let i = 0; i < subGroups.length; i++) {
            that._lastProcessedItemInCurrentGroup.parentId = groupNodeId;
            that._convertValueToFlat(subGroups[i], conditions.length + i);
            that._lastProcessedItemInCurrentGroup.position++;
        }
    }

    /**
     * Checks the construction for maxLevel nesting
     */
    _isMaxLevelExceeded(groupId) {
        const that = this,
            valueFlat = that._valueFlat;

        if (that.maxLevel === null || valueFlat.length < 1) {
            return;
        }

        //NOTE: 2 because - 1 is for the 0th (root) group, and -1 because we want to start from 0

        //Checks a specific item
        if (groupId) {
            return groupId.split('.').length - 2 >= that.maxLevel;
        }

        //Checks the whole structure
        for (let i = 0; i < valueFlat.length; i++) {
            const data = valueFlat[i];

            if (data.nodeId.split('.').length - 2 > that.maxLevel) {
                return true;
            }
        }
    }

    /**
    * Handles click event according to the target's type (filter button, add button, delete button, etc.).
    */
    _clickHandler(event) {
        const that = this,
            target = event.target,
            conditionRow = target ? target.closest('.jqx-filter-group-condition') : null,
            conditionId = conditionRow ? conditionRow.getAttribute('node-id') : null,
            filterGroup = target ? target.closest('.jqx-filter-group') : null,
            filterGroupId = filterGroup ? filterGroup.getAttribute('node-id') : null,
            isAddButton = target.closest('.jqx-filter-add-btn'),
            isDeleteButton = target.closest('.jqx-filter-delete-btn'),
            isFilterButton = target.closest('.filter-builder-item'),
            itemId = conditionId || filterGroupId,
            item = that._getItemById(itemId);
        let clickedComponent;

        if (that.disabled) {
            return;
        }

        if (isFilterButton || isDeleteButton || isAddButton) {
            if (isFilterButton) {
                if (isFilterButton.classList.contains('jqx-filter-field-name')) {
                    clickedComponent = 'fieldButton';
                }
                else if (isFilterButton.classList.contains('jqx-filter-operation')) {
                    clickedComponent = 'operationButton';
                }
                else if (isFilterButton.classList.contains('jqx-filter-value')) {
                    clickedComponent = 'valueButton';
                }
                else {
                    clickedComponent = 'groupOperationButton';
                }
            }
            else if (isAddButton) {
                clickedComponent = 'addButton';
            }
            else {
                clickedComponent = 'deleteButton';
            }

            that.$.fireEvent('itemClick', {
                id: item.nodeId,
                type: item.type,
                component: clickedComponent,
                data: item.data
            });
        }

        if (isDeleteButton) {
            const groupOperatorRow = target.closest('.jqx-filter-group-operator'),
                conditionRow = target.closest('.jqx-filter-group-condition');

            that._clickHandlerDeleteButton(groupOperatorRow, conditionRow, filterGroup);
            return;
        }
        else if (isAddButton) {
            that._closeEditor();
            that._contextMenuOptions = that._addOptions;
            that._handleContextMenu(target);
            return;
        }
        else if (isFilterButton) {
            const elementClassList = isFilterButton.classList;

            that._clickHandlerFilterButton(elementClassList, itemId, target);
            return;
        }

        if (that.$.conditionsMenu.opened) {
            that.$.fireEvent('menuClosing');
            that.$.conditionsMenu.close();
            that.$.fireEvent('menuClose');
        }

        const isTargetADropDown = target.closest('.jqx-drop-down'),
            targetIsEditor = (that._editor && that._editor.contains(target) || (isTargetADropDown && isTargetADropDown.ownerElement === that._editor)) || target.closest('.jqx-custom-editor');

        if (!that._editorIsOpen || !that._editor || targetIsEditor) {
            return;
        }

        if (that._scrollBarDown) {
            delete that._scrollBarDown;
            return;
        }

        that._closeEditor();
    }

    /**
      * Handling click on delete button
      */
    _clickHandlerDeleteButton(groupOperatorRow, conditionRow, filterGroup) {
        const that = this;

        if (that.$.conditionsMenu.opened) {
            that.$.fireEvent('menuClosing');
            that.$.conditionsMenu.close();
            that.$.fireEvent('menuClose');
        }

        that._closeEditor();

        if (groupOperatorRow) {
            that._deleteElement(filterGroup, 'group');
            that._generateValue();
        }
        else if (conditionRow) {
            that._deleteElement(conditionRow);
            that._generateValue();
        }

        that.$.scrollableContainer.refresh();
    }

    /**
    * Handling click on delete buton
    */
    _clickHandlerFilterButton(elementClassList, itemId, target) {
        const that = this;

        if (target.closest('.jqx-editors-container')) {
            return;
        }

        that._closeEditor();
        that._editedItem = that._getItemById(itemId);

        if (!elementClassList.contains('jqx-filter-field-name') && (!that._editedItem.data || !that._editedItem.data.length)) {
            return;
        }

        if (elementClassList.contains('jqx-filter-group-operation')) {
            prepareContextMenu(target, that._groupOperationDescriptions, that._editedItem.data);
            return;
        }
        else if (elementClassList.contains('jqx-filter-add-btn')) {
            prepareContextMenu(target, that._groupOperationDescriptions);
        }
        else if (elementClassList.contains('jqx-filter-field-name')) {
            if (!that._fields) {
                that._mapFieldsToMenu();
            }

            prepareContextMenu(target, that._fields, that._editedItem.data[0]);
            return;
        }
        else if (elementClassList.contains('jqx-filter-operation')) {
            const selectedField = that._getFieldByFieldName(that._editedItem.data[0]);

            if (!selectedField) {
                return;
            }

            let filteredOptions = that._filterOperationDescriptions.slice();

            if (selectedField && selectedField.filterOperations) {
                filteredOptions = that._filterOperationDescriptions.filter(item => {
                    return selectedField.filterOperations.indexOf(item.value) > -1;
                });
            }
            else {
                let filterOperationsByType;

                switch (selectedField.dataType) {
                    case 'number':
                        filterOperationsByType = ['=', '<>', '<', '>', '<=', '>=', 'isblank', 'isnotblank'];
                        break;
                    case 'date':
                        filterOperationsByType = ['=', '<>', '<', '>', '<=', '>=', 'isblank', 'isnotblank'];
                        break;
                    case 'datetime':
                        filterOperationsByType = ['=', '<>', '<', '>', '<=', '>=', 'isblank', 'isnotblank'];
                        break;
                    case 'boolean':
                        filterOperationsByType = ['=', '<>', 'isblank', 'isnotblank'];
                        break;
                    case 'object':
                        filterOperationsByType = ['isblank', 'isnotblank'];
                        break;
                    case 'string':
                        filterOperationsByType = ['contains', 'notcontains', 'startswith', 'endswith', '=', '<>', 'isblank', 'isnotblank'];
                        break;
                    default:
                        filterOperationsByType = ['contains', 'notcontains', 'startswith', 'endswith', '=', '<>', '<', '>', '<=', '>=', 'isblank', 'isnotblank'];
                        break;
                }

                filteredOptions = that._filterOperationDescriptions.filter(item => {
                    return filterOperationsByType.indexOf(item.value) > -1;
                });
            }

            if (that.showIcons) {
                filteredOptions = filteredOptions.map(item => {
                    item.label = '<div class="jqx-filter-builder-icon">' + that.icons[item.value] + '</div><div class="jqx-filter-builder-menu-item">' + that.localize(item.value) + '</div>';

                    return item;
                });
            }

            prepareContextMenu(target, filteredOptions.slice(), that._editedItem.data[1]);
            return;
        }
        else {
            that._openEditor(target);
            return;
        }

        function deSelectMenuItem() {
            const alredySelectedItem = that.$.conditionsMenu.querySelector('.jqx-selected-menu-item');

            if (alredySelectedItem) {
                alredySelectedItem.classList.remove('jqx-selected-menu-item');
            }
        }

        function prepareContextMenu(target, dataSource, selectedItem) {
            deSelectMenuItem();
            that._contextMenuOptions = dataSource.length === 0 ? that._defaultFilterOperationDescriptions : dataSource;
            that._handleContextMenu(target);

            const selectedField = selectedItem,
                chosenMenuItem = that.$.conditionsMenu.querySelector('jqx-menu-item[value="' + selectedField + '"]');

            if (!that.$.conditionsMenu.opened || !chosenMenuItem) {
                return;
            }

            chosenMenuItem.classList.add('jqx-selected-menu-item');
        }
    }

    /**
    * Closes an editor and sets the new value in the value's cotainer
    * @param {Boolean} preventEventFiring (optional).
    */
    _closeEditor(preventEventFiring) {
        const that = this;
        let storedValue;

        if (!that._editedItem || !that._editorIsOpen) {
            return;
        }

        if (that._editor === that.$.dateTimePickerEditor) {
            storedValue = that._editor.value;

            if (storedValue) {
                storedValue = storedValue.toDate();
            }
        }
        else if (that._editor === that.$.checkBoxEditor) {
            storedValue = that._editor.checked;
        }
        else if (that._editor === that.$.customEditor) {
            storedValue = that._selectedCustomCondition.handleValue(that._editor);
        }
        else {
            const selectedField = that._getFieldByFieldName(that._editedItem.data[0]);

            if (selectedField.dataType === 'array') {
                storedValue = that._editor.value.split(',');
            }
            else if (selectedField.dataType === 'object') {
                storedValue = JSON.parse(that._editor.value);
            }
            else {
                storedValue = that._editor.value;
            }
        }

        const editedItem = that._editedItem,
            editedRow = editedItem.htmlNode,
            nodeId = editedItem.nodeId,
            valueDataType = that._getFieldByFieldName(editedItem.data[0]).dataType,
            editedHTMLvalueComponent = editedRow.querySelector('.jqx-filter-value'),
            editedHTMLvalueContainer = editedRow.querySelector('.jqx-value-container'),
            eventData = {
                value: storedValue,
                valueType: valueDataType || 'string',
                editedItem: editedItem
            };

        that.$.fireEvent('editorClosing', eventData);
        that._updateValueInFlatArray(nodeId, storedValue, 'value', (valueDataType || 'string'));
        that._generateValue(preventEventFiring);
        editedHTMLvalueComponent.removeAttribute('edited');
        that.$.editorsContainer.removeAttribute('open');

        if (that._editor === that.$.checkBoxEditor) {
            editedHTMLvalueContainer.innerHTML = that._editor.checked ? 'true' : 'false';
        }
        else if (that._editor === that.$.customEditor) {
            const value = that._selectedCustomCondition.valueTemplate(that._editor);
            editedHTMLvalueContainer.innerHTML = value;
        }
        else {
            editedHTMLvalueContainer.innerHTML = that._formatValueStringRepresentation(that._editor.value, that._editedItem.data[0]);
        }

        that._editor.classList.add('jqx-hidden');
        that._editorIsOpen = that._enterIsPressedInEditor = false;
        that.$.fireEvent('editorClose', eventData);
        that.$.scrollableContainer.refresh();
    }

    _defaultValueByType(type) {
        let defaultValue;

        switch (type) {
            case 'number':
                defaultValue = 0;
                break;
            case 'date':
            case 'datetime': {
                defaultValue = new Date();
                defaultValue.setHours(0, 0, 0);
                break;
            }
            case 'boolean':
                defaultValue = false;
                break;
            case 'object':
                defaultValue = null;
                break;
            default:
                defaultValue = '';
        }

        return defaultValue;
    }

    /**
    * Removes a condition and it's HTML representation
    * @param {Any} elementNode.
    * @param {String} type.
    */
    _deleteElement(elementNode, type) {
        const that = this,
            actualElement = elementNode instanceof HTMLElement ? elementNode :
                that._valueFlat.find(item => item.nodeId === elementNode).htmlNode,
            nodeId = typeof elementNode === 'string' ? elementNode : elementNode.getAttribute('node-id');

        if (!nodeId || nodeId.length === 1) {
            return;
        }

        type === 'group' ? deleteGroup(nodeId) : deleteCondition(nodeId);

        function deleteCondition(nodeId) {
            const items = that._valueFlat.filter(item => {
                return (nodeId === item.nodeId);
            });
            let item = items ? items[0] : null;

            that._valueFlat.splice(that._valueFlat.indexOf(item), 1);
            that._totalConditions--;
        }

        function deleteGroup(nodeId) {
            const items = that._valueFlat.filter(item => {
                return (nodeId === item.nodeId);
            }),
                item = items ? items[0] : null;

            for (let i = 0; i < that._valueFlat.length; i++) {
                const nestedItem = that._valueFlat[i],
                    nestedNodeId = nestedItem.nodeId;

                if (nestedItem.parentId === nodeId) {
                    nestedItem.type === 'group' ? deleteGroup(nestedNodeId) : deleteCondition(nestedNodeId);
                }
            }

            (that._valueFlat.indexOf(item) > -1) && that._valueFlat.splice(that._valueFlat.indexOf(item), 1);
        }

        for (let i = (that._valueFlat.length - 1); i >= 0; i--) {
            const parentGroup = that._valueFlat.filter(item => {
                return (that._valueFlat[i].parentId === item.nodeId);
            });

            if (parentGroup.length === 0 && that._valueFlat[i].nodeId !== '0') {
                that._valueFlat.splice(i, 1);
                that._totalConditions--;
            }
        }

        that._generateValue();
        actualElement.parentElement.removeChild(actualElement);

        function updateNodeIds(siblings, parentId) {
            siblings.forEach((element, index) => {
                const valueFlatItem = that._valueFlat.find(item => item.htmlNode === element),
                    id = parentId + '.' + index;

                element.setAttribute('node-id', id);
                valueFlatItem.parentId = parentId;
                valueFlatItem.nodeId = id;

                if (element.classList.contains('jqx-filter-group')) {
                    updateNodeIds(Array.from(element.children[1].children), id);
                }
            });
        }

        updateNodeIds(Array.from(that.$.contentContainer.firstElementChild.children[1].children), '0');
    }

    /**
    * Document click handler - closes menu and/or editor on click outside of the element
    */
    _documentClickHandler(event) {
        const that = this;

        if (event.target.closest('jqx-filter-builder')) {
            return;
        }

        if (that.$.conditionsMenu.opened) {
            that.$.fireEvent('menuClosing');
            that.$.conditionsMenu.close();
            that.$.fireEvent('menuClose');
        }

        if (that._editorIsOpen && !that._scrollBarDown) {
            that._closeEditor();
        }

        delete that._scrollBarDown;
    }

    /**
     * down handler
     */
    _downHandler(event) {
        const that = this;

        if (event.target.closest('jqx-scroll-bar')) {
            that._scrollBarDown = true;
        }
        else {
            delete that._scrollBarDown;
        }
    }

    /**
     * Editor's change handler
     */
    _containerChangeHandler(event) {
        event.stopPropagation();
    }

    /**
    * Generates HTML structure from flat array and adds/replaces 
    * @param {Array} data - contains dataField, operator and value
    */
    _emptyElementsStructure(emptyValueFlat) {
        const that = this,
            contentContainer = that.$.contentContainer;

        while (contentContainer.firstChild) {
            contentContainer.removeChild(contentContainer.firstChild);
        }

        that._valueFlat = emptyValueFlat ? [] : that._valueFlat;
        that._lastProcessedItemInCurrentGroup = { parentId: null, id: null, position: null };
    }

    /**
    * Creates filter group row
    * @param {String} groupOperator (optional).
    */
    _filterGroupRow(groupOperator) {
        const that = this;

        groupOperator = that.localize(groupOperator || 'or');

        let groupRow = document.createElement('div'),
            template = `<span class ="jqx-filter-delete-btn"></span>
                <span class ="filter-builder-item jqx-filter-group-operation">${groupOperator}</span>
                <span class ="jqx-filter-add-btn"></span>`;

        groupRow.className = 'jqx-filter-group-operator';
        groupRow.innerHTML = template;
        groupRow.data = groupOperator || 'or';//

        return groupRow;
    }

    /**
    * Removes a condition and it's HTML representation
    * @param {Any} value.
    * @param {String} field.
    */
    _formatValueStringRepresentation(value, field) {
        const that = this,
            fieldData = that._getFieldByFieldName(field);
        let valueFormattedByType;

        if (!fieldData) {
            return value;
        }

        if (((!value || value.length === 0) && fieldData.dataType !== 'boolean' && (fieldData.dataType === 'number' && value === null)) || (fieldData.dataType === 'string' && (!value || value.length === 0))) {
            return that.valuePlaceholder;
        }

        switch (fieldData.dataType) {
            case 'date':
            case 'datetime':
                if (value) {
                    value = validateDateTimeValue(value);
                    value.calendar.days = that._localizedDays;
                    value.calendar.months = that._localizedMonths;
                    value.calendar.locale = that.locale;
                    JQX.Utilities.DateTime.cache = [];
                    valueFormattedByType = value.toString(fieldData.dataType === 'date' ? that.formatStringDate : that.formatStringDateTime);
                }
                else {
                    valueFormattedByType = that.valuePlaceholder;
                }

                break;
            case 'array':
                valueFormattedByType = typeof value === 'string' ? value.split(',') : value;
                break;
            case 'object':
                valueFormattedByType = typeof value === 'string' ? value : JSON.stringify(value);
                break;
            case 'number':
                valueFormattedByType = value;
                break;
            case 'boolean':
                valueFormattedByType = value === false ? 'false' : 'true';
                break;
            default:
                valueFormattedByType = value + '';
                break;

        }

        if (!that.valueFormatFunction) {
            return valueFormattedByType;
        }

        function validateDateTimeValue(value) {
            if (value === 0 || typeof value === 'number' || typeof value === 'string' || value === true || value === '' || value === '0' ||
                Array.isArray(value) || typeof value === 'object' && value.constructor === Date) {
                return new JQX.Utilities.DateTime(value);
            }
            else {
                return value;
            }
        }

        return that.valueFormatFunction(valueFormattedByType, field, (fieldData.dataType || 'string'));
    }

    /**
    * Generates HTML structure from flat array and adds/replaces 
    */
    _generateHTMLStructureFromFlatValue() {
        const that = this,
            fragment = document.createDocumentFragment();

        if (!that._valueFlat || that._valueFlat.length === 0) {
            return;
        }

        for (let i = 0; i < that._valueFlat.length; i++) {
            const item = that._valueFlat[i],
                customOperation = that.customOperations ? that.customOperations.find(operation => operation.name === item.data[1]) : false,
                parentGroupHTMLcontainer = item.parentId ? that.querySelector('[node-id="' + item.parentId + '"]').querySelector('.jqx-filter-group-condition-container') : that.$.contentContainer;

            if (item.type === 'group') {
                const groupContainerBlock = document.createElement('div'),
                    groupOperatorBlock = that._filterGroupRow(item.data),
                    groupConditionsContainerBlock = document.createElement('div');

                groupContainerBlock.className = 'jqx-filter-group';
                groupConditionsContainerBlock.className = 'jqx-filter-group-condition-container';
                groupContainerBlock.appendChild(groupOperatorBlock);
                groupContainerBlock.appendChild(groupConditionsContainerBlock);
                fragment.appendChild(groupContainerBlock);

                groupContainerBlock.setAttribute('node-id', item.nodeId);
                that._valueFlat[i].htmlNode = groupContainerBlock;

                if (that._isMaxLevelExceeded(item.nodeId + '.0')) {
                    groupContainerBlock.setAttribute('max-level', '');
                }
            }
            else {
                const condition = that._newFilterConditionRow(item.data);

                condition.setAttribute('node-id', item.nodeId);
                fragment.appendChild(condition);
                that._valueFlat[i].htmlNode = condition;

                if (['isblank', 'isnotblank'].indexOf(item.data[1]) !== -1 || (customOperation && customOperation.hideValue)) {
                    condition.children[3].classList.add('jqx-hidden');
                }
            }

            parentGroupHTMLcontainer.appendChild(fragment);
        }
    }

    /**
    * Generates the new value of "value" property from flat array
    */
    _generateValue() {
        const that = this;
        let groupsWithItems = [],
            value = that._valueFlat.slice();

        createNestedArray(value);

        function createNestedArray(flatValue) {
            for (let i = 0; i < flatValue.length; i++) {
                const item = flatValue[i];
                let group = {};

                if (item.type === 'group') {
                    group.nodeId = item.nodeId;
                    group.parentId = item.parentId;
                    group.structure = [item.data || 'or'];
                    groupsWithItems.push(group);
                }
            }

            for (let i = 0; i < groupsWithItems.length; i++) {
                const group = groupsWithItems[i],
                    conditions = flatValue.filter(item => {
                        return (item.parentId === group.nodeId && item.type === 'condition');
                    });

                for (let i = 0; i < conditions.length; i++) {
                    i === 0 ? group.structure.unshift(conditions[i].data) : group.structure.push(conditions[i].data);
                }
            }

            groupsWithItems = groupsWithItems.filter(item => {
                return (item.structure.length > 1);
            });
            groupsWithItems.sort(function (a, b) {
                return (b.nodeId.split('.').length - a.nodeId.split('.').length);
            });

            for (let i = 0; i < groupsWithItems.length; i++) {
                const curentElement = groupsWithItems[i],
                    parentElement = groupsWithItems.filter(item => {
                        return (item.nodeId === curentElement.parentId)
                    })[0];

                if (parentElement && parentElement.structure) {
                    parentElement.structure.push(curentElement.structure);
                }
            }
        }

        if (groupsWithItems.length > 0) {
            that.value = that._valueFlat.length > 1 ? groupsWithItems[groupsWithItems.length - 1].structure : groupsWithItems;
        }
        else {
            that.value = [that._getItemById('0').data];
        }

        const oldValueAsString = JSON.stringify(that.value);

        if (that._oldValueAsString !== oldValueAsString) {
            that._oldValueAsString = oldValueAsString;
            that.$.fireEvent('change', { 'value': JSON.parse(oldValueAsString) });
        }
    }

    /**
    * Return field's data by given field name
    * @param {String} fieldName
    */
    _getFieldByFieldName(fieldName) {
        const that = this,
            fields = that.fields ? that.fields.filter(item => {
                return item.dataField === fieldName;
            }) : that._valueFields.filter(item => {
                return item.dataField === fieldName;
            });

        return fields[0] || null;
    }

    /**
    * Generates an array of field objecst, used as a backup when fields property is not set
    */
    _getFieldsFromValue() {
        const that = this,
            items = that._valueFlat,
            fieldsNames = [],
            fields = [];

        for (let i = 0; i < items.length; i++) {
            if (items[i].type === 'condition') {
                const fieldName = items[i].data[0];

                if (fieldsNames.indexOf(fieldName) === -1) {
                    const fieldElement = { label: fieldName, dataField: fieldName, dataType: 'string', format: null };

                    fieldsNames.push(fieldName);
                    fields.push(fieldElement);
                }
            }
        }

        that._valueFields = fields;
    }

    /**
    * Return item's data by given id
    * @param {String} id - item's id (or parent id - demending on the second parameter)
    * @param {Boolean} isParent (optional)  - of the items is searched by parentId
    */
    _getItemById(id, isParent) {
        const that = this,
            matches = that._valueFlat.filter(item => {
                if (isParent) {
                    return item.parentId === id;
                }
                return item.nodeId === id;
            }),
            editedItem = matches.length > 0 ? matches[0] : null;

        return editedItem;
    }

    /**
    * Handles context menu position
    * @param {HTML element} target (optional) - the component which is clicked
    */
    _handleContextMenu(target) {
        const that = this;

        if (that._selectedElement === target && that.$.conditionsMenu.opened) {
            return;
        }

        const targetCoordinates = target.getBoundingClientRect(),
            elementCoordinates = that.getBoundingClientRect(),
            offsetTop = targetCoordinates.height,
            x = targetCoordinates.left + that.$.contentContainer.scrollLeft - elementCoordinates.left,
            y = targetCoordinates.top + that.$.contentContainer.scrollTop - elementCoordinates.top + offsetTop,
            selectedFlatItemId = target.closest('[node-id]').getAttribute('node-id'),
            selectedFlatItem = that._getItemById(selectedFlatItemId);
        let targetType = null;

        if (target.closest('.jqx-filter-delete-btn')) {
            targetType = 'buttonDelete';
        }
        else if (target.closest('.jqx-filter-add-btn')) {
            if (that.restrictedMode) {
                that._checkFieldsExistence();

                const conditionField = that.fields ? that.fields[0] : that._valueFields[0],
                    operation = (conditionField.filterOperations && conditionField.filterOperations.length > 0) ? conditionField.filterOperations[0] : '=';

                that._addElement('condition', 0, [conditionField.dataField, operation, that._defaultValueByType(conditionField.dataType)]);
                return;
            }

            targetType = 'buttonAdd';
        }
        else if (target.closest('.jqx-filter-group-operation')) {
            targetType = 'groupOperation';
        }
        else if (target.closest('.jqx-filter-field-name')) {
            targetType = 'conditionField';
        }
        else if (target.closest('.jqx-filter-operation')) {
            targetType = 'conditionOperation';
        }

        const eventData = {
            'target': target,
            'targetX': targetCoordinates.left,
            'targetY': targetCoordinates.top,
            'parentGroupId': selectedFlatItem.parentId,
            'id': selectedFlatItem.nodeId,
            'type': selectedFlatItem.type,
            'data': selectedFlatItem.data,
            'targetType': targetType
        };

        if (that.$.conditionsMenu.opened) {
            that.$.fireEvent('menuClosing');
            that.$.conditionsMenu.close();
            that.$.fireEvent('menuClose');
        }
        that._closeEditor();

        if (that.disableContextMenu) {
            that._selectedElement = target;
            that.$.fireEvent('menuOpening', eventData);
            that.$.fireEvent('menuOpen', eventData);
            return;
        }

        that.$.fireEvent('menuOpening', eventData);
        that.$.conditionsMenu.dataSource = that._contextMenuOptions;
        that.$.conditionsMenu.open(x, y);
        that._selectedElement = target;
        that.$.fireEvent('menuOpen', eventData);
        that.$.scrollableContainer.refresh();
    }

    /**
    * Add custom operations to the menu's operations list
    */
    _handleCustomOperations() {
        const that = this;

        that._filterOperationDescriptions = that._defaultFilterOperationDescriptions;

        for (let i = 0; i < that.customOperations.length; i++) {
            const operation = that.customOperations[i];

            that._filterOperationDescriptions.push({
                label: operation.label,
                value: operation.name,
                custom: true,
                index: i,
                editorTemplate: operation.editorTemplate,
                valueTemplate: operation.valueTemplate,
                handleValue: operation.handleValue
            });
        }
    }

    /**
    * Initializes Editors instance if it's not initialized.
    */
    _initializeEditor(editor) {
        const that = this,
            editorTagName = 'jqx-' + JQX.Utilities.Core.toDash(editor),
            editorElement = document.createElement(editorTagName);

        if (editor === 'numericTextBox') {
            editorElement.spinButtons = true;
            editorElement.inputFormat = 'floatingPoint';
        }
        else if (editor === 'dateTimePicker') {
            editorElement.calendarButton = true;
            editorElement.dropDownDisplayMode = 'auto';
            editorElement.enableMouseWheelAction = true;
            editorElement.locale = that.locale;

            if (!editorElement.messages[that.locale]) {
                editorElement.messages[that.locale] = {};
            }

            editorElement.messages[that.locale].dateTabLabel = that.localize('dateTabLabel');
            editorElement.messages[that.locale].timeTabLabel = that.localize('timeTabLabel');
        }

        editorElement.tabIndex = '1';
        editorElement.theme = that.theme;
        editorElement.animation = that.animation;
        that.$[editor + 'Editor'] = editorElement;
        editorElement.$ = JQX.Utilities.Extend(editorElement);
        editorElement.className = editorTagName + '-editor jqx-hidden';
        that.$.editorsContainer.appendChild(editorElement);
        that['_' + editor + 'Initialized'] = true;
    }

    /**
     * InnerContainer keydown eventHandler 
     * @param {any} event
     */
    _innerContainerKeydownHandler(event) {
        const that = this;

        if (event.key !== 'Escape' && event.key !== 'Enter' || !that._editorIsOpen) {
            return;
        }

        that._closeEditor();
    }

    /**
    * Updates value on blur
    */
    _inputBlurHandler() {
        const that = this;
        let storedValue;

        if (that._editor === that.$.dateTimePickerEditor) {
            storedValue = that._editor.value;

            if (storedValue) {
                storedValue = storedValue.toDate();
            }
        }
        else if (that._editor === that.$.checkBoxEditor) {
            storedValue = that._editor.checked;
        }
        else if (that._editor === that.$.customEditor) {
            storedValue = that._selectedCustomCondition.handleValue(that._editor);
        }
        else {
            const selectedField = that._getFieldByFieldName(that._editedItem.data[0]);

            if (selectedField.dataType === 'array') {
                storedValue = that._editor.value.split(',');
            }
            else if (selectedField.dataType === 'object') {
                storedValue = JSON.parse(that._editor.value);
            }
            else {
                storedValue = that._editor.value;
            }

            //   storedValue = that._editor.value;
        }

        const editedItem = that._editedItem,
            nodeId = editedItem.nodeId,
            valueDataType = that._getFieldByFieldName(editedItem.data[0]).dataType;


        that._updateValueInFlatArray(nodeId, storedValue, 'value', (valueDataType || 'string'));
        that._generateValue();
    }

    /**
     * Localizes default values for the menus.
     */
    _localizeInitialValues() {
        const that = this,
            localizedNames = JQX.Utilities.DateTime.getLocalizedNames(that.locale);

        that._addOptions = [
            { label: that.localize('addCondition'), value: 'addCondition' },
            { label: that.localize('addGroup'), value: 'addGroup' }
        ];
        that._groupOperationDescriptions = [
            { label: that.localize('and'), value: 'and' },
            { label: that.localize('notand'), value: 'notand' },
            { label: that.localize('or'), value: 'or' },
            { label: that.localize('notor'), value: 'notor' }
        ];
        that._defaultFilterOperationDescriptions = that._filterOperationDescriptions = [
            { label: that.localize('='), value: '=', custom: false },
            { label: that.localize('<>'), value: '<>', custom: false },
            { label: that.localize('>'), value: '>', custom: false },
            { label: that.localize('>='), value: '>=', custom: false },
            { label: that.localize('<'), value: '<', custom: false },
            { label: that.localize('<='), value: '<=', custom: false },
            { label: that.localize('startswith'), value: 'startswith', custom: false },
            { label: that.localize('endswith'), value: 'endswith', custom: false },
            { label: that.localize('contains'), value: 'contains', custom: false },
            { label: that.localize('notcontains'), value: 'notcontains', custom: false },
            { label: that.localize('isblank'), value: 'isblank', custom: false },
            { label: that.localize('isnotblank'), value: 'isnotblank', custom: false }
        ];

        that._localizedDays = localizedNames.days;
        that._localizedMonths = localizedNames.months;
    }

    /**
    * Map fields data source to match menu's label and value.
    */
    _mapFieldsToMenu() {
        const that = this;

        if (!that.fields && !that._valueFields) {
            return;
        }

        that._fields = (that.fields || that._valueFields).map(field => {
            let menuField = {};

            menuField.label = field.label;
            menuField.value = field.dataField;
            menuField.dataType = field.dataType;

            return menuField;
        });
    }

    /**
    * Handles menu item click.
    */
    _menuItemClickHandler(event) {
        const that = this,
            selectedElement = that._selectedElement.closest('.filter-builder-item'),
            details = event.detail,
            value = details.value,
            label = that.localize(value) || details.label;

        if (selectedElement) {
            const selectedIsCondition = selectedElement.closest('.jqx-filter-group-condition'),
                selectedIsGroup = selectedElement.closest('.jqx-filter-group'),
                nodeId = selectedIsCondition ? selectedIsCondition.getAttribute('node-id') : selectedIsGroup.getAttribute('node-id');
            let updatedPosition = 2;

            selectedElement.innerHTML = label;
            selectedElement.value = value;

            if (that._editedItem && selectedElement.classList.contains('jqx-filter-field-name') && that._editedItem.data[0] !== value) {
                const valueHTMLnode = selectedElement.parentNode.querySelector('.jqx-filter-value'),
                    customOperationsWithoutValue = that.customOperations.map(item => {
                        if (item.hideValue) {
                            return item.name;
                        }
                    }).filter(item => item),
                    operationsWithoutValue = customOperationsWithoutValue.concat(['isblank', 'isnotblank']);

                that._clearConditionsValue(nodeId, value);
                that._setInitialFilterOperation(nodeId, value);
                (operationsWithoutValue.indexOf(value) > -1) ? valueHTMLnode.classList.add('jqx-hidden') : valueHTMLnode.classList.remove('jqx-hidden');
            }

            if (selectedElement.classList.contains('jqx-filter-field-name')) {
                updatedPosition = 0;
            }
            else if (selectedElement.classList.contains('jqx-filter-operation')) {
                const valueHTMLnode = selectedElement.parentNode.querySelector('.jqx-filter-value');
                let customOperation;

                if (that.customOperations) {
                    const customOperations = that.customOperations.filter(operation => {
                        return operation.name === value;
                    });

                    if (customOperations.length > 0) {
                        customOperation = customOperations[0];
                    }
                }

                if (['isblank', 'isnotblank'].indexOf(value) > -1 || (customOperation && customOperation.hideValue)) {
                    that._clearConditionsValue(nodeId);
                    valueHTMLnode.classList.add('jqx-hidden');
                }
                else {
                    valueHTMLnode.classList.remove('jqx-hidden');
                }

                updatedPosition = 1;
            }
            else if (selectedElement.classList.contains('jqx-filter-group-operation')) {
                for (let i = 0; i < that._valueFlat.length; i++) {
                    if (that._valueFlat[i].nodeId === nodeId) {
                        that._valueFlat[i].data = selectedElement.value;
                    }
                }

                that._generateValue();
                that.$.scrollableContainer.refresh();
                return;
            }

            for (let i = 0; i < that._valueFlat.length; i++) {
                if (that._valueFlat[i].nodeId === nodeId) {
                    that._valueFlat[i].data[updatedPosition] = selectedElement.value;
                }
            }

            that._generateValue();
            that.$.scrollableContainer.refresh();
            return;
        }

        const selectedFilterGroup = that._selectedElement.closest('.jqx-filter-group'),
            selectedFilterGroupId = selectedFilterGroup.getAttribute('node-id');

        if (that._isMaxLevelExceeded(selectedFilterGroupId + '.0')) {
            return;
        }

        if (value === 'addCondition' && ((that.maxConditions && (that._totalConditions < that.maxConditions)) || !that.maxConditions)) {
            that._checkFieldsExistence();

            const conditionField = that.fields ? that.fields[0] : that._valueFields[0],
                operation = (conditionField.filterOperations && conditionField.filterOperations.length > 0) ? conditionField.filterOperations[0] : '=';

            that._addElement('condition', selectedFilterGroupId, [conditionField.dataField, operation, that._defaultValueByType(conditionField.dataType)]);
        }
        else if (value === 'addGroup') {
            that._addElement('group', selectedFilterGroupId, 'and');
        }

        that.$.scrollableContainer.refresh();
    }

    _setInitialFilterOperation(nodeId, fieldName) {
        const that = this;
        const newField = that.fields.find(field => field.dataField === fieldName),
            selectedItem = that._valueFlat.find(item => item.nodeId === nodeId),
            operationHtmlNode = selectedItem.htmlNode.getElementsByClassName('jqx-filter-operation')[0],
            newFieldOperation = (newField && newField.filterOperations && newField.filterOperations.length > 0) ? newField.filterOperations[0] : '=';
        let newFieldOperationLabel = that.localize(newFieldOperation);

        if (!newFieldOperationLabel) {
            newFieldOperationLabel = that.customOperations.find(operation => operation.name === newFieldOperation).label;
        }

        selectedItem.data[1] = newFieldOperation;
        operationHtmlNode.innerHTML = newFieldOperationLabel;
    }

    _checkFieldsExistence() {
        const that = this;

        if ((!that.fields || that.fields.length === 0) && (!that._valueFields || that._valueFields.length === 0)) {
            that.error(that.localize('missingFields', { elementType: that.nodeName.toLowerCase() }));
        }
    }

    /**
    * Creates new filter condition row
    * @param {Array} condition (optional). An array with a condition params. If "condition" parameter is not set - in the method is used default value
    */
    _newFilterConditionRow(condition) {
        condition = condition || [];

        const that = this,
            dataField = condition[0] ? condition[0] : that.fields[0].dataField,
            value = that._formatValueStringRepresentation(condition[2], condition[0]),
            dataFieldsWithLabels = that.fields ? that.fields.filter(item => {
                return item.dataField === dataField;
            }) : that._valueFields.filter(item => {
                return item.dataField === dataField;
            }),
            dataFieldsLabel = dataFieldsWithLabels.length > 0 ? dataFieldsWithLabels[0].label : condition[0];
        let operation = that.localize(condition[1]);

        if (!operation && that.customOperations && that.customOperations.length > 0) {
            operation = that.customOperations.find(operation => operation.name === condition[1]).label;
        }

        let conditionRow = document.createElement('div'),
            template = `<span class ="jqx-filter-delete-btn"></span>
                <span class ="filter-builder-item jqx-filter-field-name">${dataFieldsLabel}</span>
                <span class ="filter-builder-item jqx-filter-operation">${operation || ''}</span>
                <span class ="filter-builder-item jqx-filter-value"><span class ="jqx-value-container">${value}</span></span>`;

        conditionRow.className = 'jqx-filter-group-condition';
        conditionRow.innerHTML = template;

        return conditionRow;
    }

    /**
    * Open an editor at the position of the current editted condition value container
    * @param {Html element} target - the clicked HTML element. Used to be localized element's data and set into editor
    */
    _openEditor(target) {
        const that = this,
            id = target && target.closest('.jqx-filter-group-condition') ? target.closest('.jqx-filter-group-condition').getAttribute('node-id') : null,
            valueContainer = target.closest('.jqx-filter-value'),
            editedItem = that._getItemById(id),
            field = editedItem.data[0] || that.fields[0].dataField || that._valueFields[0].dataField,
            fieldData = that._getFieldByFieldName(field);
        let value;

        if (editedItem) {
            value = editedItem.data[2];

            if (value === undefined) {
                value = '';
            }
        }
        else {
            value = '';
        }

        if (!fieldData) {
            return;
        }

        if (that._editorIsOpen) {
            that._closeEditor();
        }

        if (that.$.conditionsMenu.opened) {
            that.$.fireEvent('menuClosing');
            that.$.conditionsMenu.close();
            that.$.fireEvent('menuClose');
        }
        valueContainer.setAttribute('edited', '');
        that._editedItem = editedItem;

        const fields = that.fields || that._valueFields,
            fieldItemsMatch = fields.filter(item => {
                return item.dataField === field;
            }),
            foundCustomConditions = that._filterOperationDescriptions.filter(item => {
                return ((item.value === editedItem.data[1]) && item.custom);
            }),
            fieldItem = fieldItemsMatch.length > 0 ? fieldItemsMatch[0] : null,
            fieldType = (fieldData.lookup && fieldData.lookup.dataSource) ? 'lookup' : fieldItem.dataType;

        if (foundCustomConditions.length === 0 || !foundCustomConditions[0].editorTemplate) {
            that._openEditorByFieldType(fieldType, value, fieldData);
        }
        else {
            that._selectedCustomCondition = foundCustomConditions[0];
            that._openCustomEditor(fieldType, value, fieldData);
        }

        that.$.fireEvent('editorOpening', {
            value: value,
            type: fieldType,
            editedItem: editedItem
        });

        setTimeout(function () {
            that._editor.focus();

            if (that._editor === that.$.numericTextBoxEditor || that._editor === that.$.textBoxEditor) {
                that.$.scrollableContainer.scrollLeft = that.$.scrollableContainer.$.scrollViewerContainer.scrollLeft;
                that.$.scrollableContainer.scrollTop = that.$.scrollableContainer.$.scrollViewerContainer.oldTop;
                that.$.scrollableContainer.$.scrollViewerContainer.scrollLeft = 0;
                that.$.scrollableContainer.$.scrollViewerContainer.scrollTop = 0;
                that._editor.$.input.selectionStart = that._editor.$.input.selectionEnd = that._editor.$.input.value.length;
            }

            that.$.scrollableContainer.refresh();
            that.$.fireEvent('editorOpen', {
                value: value,
                type: fieldType,
                editedItem: editedItem
            });
        }, 0);

        that._editor.classList.remove('jqx-hidden');
        that._editorIsOpen = true;
        that.$.editorsContainer.setAttribute('open', '');
        valueContainer.appendChild(that.$.editorsContainer);
        that.$.scrollableContainer.refresh();
    }

    /**
    * Open specific editor, regarding field type settings and set it's value
    * @param {String} fieldType - type of the edited field, each type has different handling
    * @param {Any} value - the value, that must be set to the editor
    */
    _openEditorByFieldType(fieldType, value, fieldData) {
        const that = this;

        switch (fieldType) {
            case 'lookup':
                if (!that._comboBoxInitialized) {
                    that._initializeEditor('comboBox');
                }

                that._editor = that.$.comboBoxEditor;
                that._editor.dataSource = fieldData.lookup.dataSource;
                that._editor.dropDownAppendTo = that.$.container;
                that._editor.selectedValues = [value];
                break;
            case 'boolean':
                if (!that._checkBoxInitialized) {
                    that._initializeEditor('checkBox');
                }

                that._editor = that.$.checkBoxEditor;
                that._editor.checked = !!value;
                break;
            case 'datetime':
                if (!that._dateTimePickerInitialized) {
                    that._initializeEditor('dateTimePicker');
                }

                that._editor = that.$.dateTimePickerEditor;
                that._editor.formatString = that.formatStringDateTime;
                that._editor.dropDownAppendTo = that.$.container;
                that._editor.value = value;
                break;
            case 'date':
                if (!that._dateTimePickerInitialized) {
                    that._initializeEditor('dateTimePicker');
                }

                that._editor = that.$.dateTimePickerEditor;
                that._editor.formatString = that.formatStringDate;
                that._editor.dropDownAppendTo = that.$.container;
                that._editor.value = value;
                break;
            case 'number':
                if (!that._numericTextBoxInitialized) {
                    that._initializeEditor('numericTextBox');
                }

                value = value ? value : 0;
                that._editor = that.$.numericTextBoxEditor;
                that._editor.value = value;
                break;
            case 'array':
                if (!that._textBoxInitialized) {
                    that._initializeEditor('textBox');
                }

                that._editor = that.$.textBoxEditor;
                that._editor.value = value.toString();
                break;
            case 'object':
                if (!that._textBoxInitialized) {
                    that._initializeEditor('textBox');
                }

                value = value ? value : {};
                that._editor = that.$.textBoxEditor;
                that._editor.value = JSON.stringify(value);
                break;
            default:
                if (!that._textBoxInitialized) {
                    that._initializeEditor('textBox');
                }

                that._editor = that.$.textBoxEditor;
                that._editor.value = value + '';
        }
    }

    /**
    * Open custom editor
    */
    _openCustomEditor(fieldType, value, fieldData) {
        const that = this,
            editorStructure = that.customOperations[that._selectedCustomCondition.index].editorTemplate(fieldType, value, fieldData);

        that.$.customEditor.innerHTML = '';

        if (editorStructure) {
            that.$.customEditor.appendChild(editorStructure);
        }

        that._editor = that.$.customEditor;
    }

    /**
    * Refreshes the structure
    */
    _refresh() {
        const that = this;

        that._generateValue();
        that._emptyElementsStructure();
        that._generateHTMLStructureFromFlatValue();
        that.$.scrollableContainer.refresh();
    }

    /**
    * Handles scrollbars on resize
    */
    _resizeHandler() {
        const that = this;

        that.$.scrollableContainer.refresh();
    }

    /**
     * scrollViewer wheel handler.
     */
    _scrollViewerWheelHandler(event) {
        const that = this;

        if (event.type === 'wheel' && that.$.scrollableContainer.scrollHeight) {
            event.stopPropagation();
            event.preventDefault();
        }
    }

    /**
    * Set default values for the menus
    */
    _setInitialValues() {
        const that = this;

        that._mapFieldsToMenu();
        that._localizeInitialValues();
        that.$.conditionsMenu.dropDownAppendTo = that.$.container;
        that.$.conditionsMenu.dataSource = that._groupOperationDescriptions;

        that._valueFlat = [];
        that._lastProcessedItemInCurrentGroup = { parentId: null, id: null, position: null };
    }

    /**
     * Updates innerHTML of all fields.
     */
    _updatePlaceholder() {
        const that = this;

        for (let i = 0; i < that._valueFlat.length; i++) {
            const item = that._valueFlat[i];

            if (item.type === 'condition' && (item.data[2] === null || item.data[2] === '')) {
                item.htmlNode.querySelector('.jqx-value-container').innerHTML = that.valuePlaceholder;
            }
        }

        if (that.$.textBoxEditor) {
            that.$.textBoxEditor.placeholder = that.valuePlaceholder;
        }
    }

    /**
    * Updates value in the flat array.
    * @param {String} nodeId
    * @param {Any} value
    * @param {String} updatedComponent
    * @param {String} valueType
    */
    _updateValueInFlatArray(nodeId, value, updatedComponent, valueType) {
        const that = this;

        if (!nodeId || that.disabled) {
            return;
        }

        valueType = valueType || 'string';
        updatedComponent = updatedComponent || 'value';

        if (value !== null) {
            switch (valueType) {
                case 'number':
                    value = parseFloat(value);
                    break;
                case 'boolean':
                    value = !!value;
                    break;
                case 'string':
                    value = value + '';
                    break;
            }
        }

        for (let i = 0; i < that._valueFlat.length; i++) {
            if (that._valueFlat[i].nodeId === nodeId) {
                switch (updatedComponent) {
                    case 'column':
                        that._valueFlat[i].data[0] = value;
                        break;
                    case 'filterCondition':
                        that._valueFlat[i].data[1] = value;
                        break;
                    case 'value':
                        that._valueFlat[i].data[2] = value;
                        break;
                    case 'groupCondition':
                        that._valueFlat[i].data = value;
                        break;
                }
            }
        }
    }

    /*
    * Validates if node exists in the internal element's structure. 
    * @param {Any} elementNode - HTML element or nodeId of the element
    * @param {String} methodName - an array with a new condition settings
    */
    _validateNode(elementNode, methodName) {
        const that = this;
        let editedItem;

        if (elementNode instanceof HTMLElement) {
            editedItem = that._getItemById(elementNode.getAttribute('node-id'));
        }
        else if (typeof elementNode === 'string') {
            editedItem = that._getItemById(elementNode);
        }
        else {
            that.error(that.localize('wrongElementNode', { elementType: that.nodeName.toLowerCase(), method: methodName }));
        }

        if (!editedItem) {
            that.error(that.localize('wrongElementNode', { elementType: that.nodeName.toLowerCase(), method: methodName }));
        }

        return editedItem;
    }

    /*
    * Validates if node exists in the internal element's structure. 
    * @param {Any} data - HTML element or nodeId of the element
    * @param {Boolean} isCondition - flag defined where the data will be used (condition or group)
    */
    _validateUserData(data, isCondition) {
        const that = this;

        if (isCondition) {
            if (!Array.isArray(data) || data.length < 3) {
                that.error(that.localize('invalidDataStructure', { elementType: that.nodeName.toLowerCase() }));
            }
        }
        else {
            const regEx = /^(and|or|notAnd|notOr)$/i;

            if (!(typeof data === 'string') || !data.match(regEx)) {
                that.error(that.localize('invalidDataStructure', { elementType: that.nodeName.toLowerCase() }));
            }
        }
    }

    /**
     * Validates the structure of the "value" array.
     */
    _validateValue() {
        const that = this,
            maxConditions = that.maxConditions,
            maxConditionsPerGroup = that.maxConditionsPerGroup,
            maxLevel = that.maxLevel;
        let totalConditions = 0;

        if (maxConditions === null && maxConditionsPerGroup === null && maxLevel === null) {
            return;
        }

        const value = that.value,
            finalResult = [];

        function isCondition(structure) {
            return structure.length === 3 && typeof structure[0] === 'string' && typeof structure[1] === 'string';
        }

        function process(structure, level, result) {
            let conditionsPerGroup = 0;

            structure.forEach(item => {
                if (Array.isArray(item)) {
                    if (isCondition(item)) {
                        // condition
                        if (maxConditions !== null && maxConditions === totalConditions ||
                            maxConditionsPerGroup !== null && maxConditionsPerGroup === conditionsPerGroup) {
                            return;
                        }

                        result.push(item);
                        conditionsPerGroup++;
                        totalConditions++;
                    }
                    else {
                        // inner group
                        if (maxLevel !== null && maxLevel === level + 1) {
                            return;
                        }

                        const group = [];

                        result.push(group);
                        process(item, level + 1, group);
                    }
                }
                else {
                    // operator
                    result.push(item);
                }
            });
        }

        process(value, 0, finalResult);
        that.value = finalResult;
    }
});

/**
 * jqxQueryBuilder custom element.
 */
JQX('jqx-query-builder', class QueryBuilder extends JQX.BaseElement {
    /**
     * Element's properties
     */
    static get properties() {
        return {
            'allowDrag': {
                value: false,
                type: 'boolean'
            },
            'applyMode': {
                allowValues: ['immediately', 'change'],
                value: 'change',
                type: 'string'
            },
            'customOperations': {
                value: [],
                type: 'array',
                reflectToAttribute: false
            },
            //'disableContextMenu': {
            //    value: false,
            //    type: 'boolean'
            //},
            'fields': {
                value: null,
                type: 'array?',
                reflectToAttribute: false
            },
            'fieldsMode': {
                value: 'dynamic',
                allowedValues: ['dynamic', 'static'],
                type: 'string'
            },
            'formatStringDate': {
                value: 'dd-MMM-yy',
                type: 'string'
            },
            'formatStringDateTime': {
                value: 'dd-MMM-yy HH:mm:ss',
                type: 'string'
            },
            'getDynamicField': {
                value: null,
                type: 'function?'
            },
            'icons': {
                value: {
                    '=': 'equals',
                    '<>': 'notequals',
                    '>': 'greaterthan',
                    '>=': 'greaterthanorequal',
                    '<': 'lessthan',
                    '<=': 'lessthanorequal',
                    'startswith': 'startswith',
                    'endswith': 'endswith',
                    'contains': 'contains',
                    'notcontains': 'notcontains',
                    'isblank': 'isblank',
                    'isnotblank': 'isnotblank'
                },
                type: 'object',
                reflectToAttribute: false
            },
            //'maxConditions': {
            //    value: null,
            //    type: 'number?'
            //},
            //'maxConditionsPerGroup': {
            //    value: null,
            //    type: 'number?'
            //},
            'messages': {
                value: {
                    'en': {
                        'add': 'Add',
                        'addCondition': 'Add Condition',
                        'addGroup': 'Add Group',
                        'and': 'And',
                        'notand': 'Not And',
                        'or': 'Or',
                        'notor': 'Not Or',
                        '=': 'Equals',
                        '<>': 'Does not equal',
                        '>': 'Greater than',
                        '>=': 'Greater than or equal to',
                        '<': 'Less than',
                        '<=': 'Less than or equal to',
                        'startswith': 'Starts with',
                        'endswith': 'Ends with',
                        'contains': 'Contains',
                        'notcontains': 'Does not contain',
                        'isblank': 'Is blank',
                        'isnotblank': 'Is not blank',
                        'wrongParentGroupIndex': '{{elementType}}: Wrong parent group index in "{{method}}" method.',
                        'wrongElementNode': '{{elementType}}: Incorect node / node Id in "{{method}}" method.',
                        'invalidDataStructure': '{{elementType}}: Used invalid data structure in updateCondition/updateGroup method.',
                        'dateTabLabel': 'DATE',
                        'timeTabLabel': 'TIME',
                        'queryLabel': 'Query'
                    }
                },
                type: 'object',
                extend: true
            },
            'operatorPlaceholder': {
                value: 'Operator',
                type: 'string'
            },
            'propertyPlaceholder': {
                value: 'Property',
                type: 'string'
            },
            //'requiredFields': {
            //    value: null,
            //    type: 'array?',
            //    reflectToAttribute: false
            //},
            'showIcons': {
                value: false,
                type: 'boolean'
            },
            'value': {
                value: [],
                type: 'array?',
                reflectToAttribute: false
            },
            'valueFormatFunction': {
                value: null,
                type: 'function?',
                reflectToAttribute: false
            },
            'valuePlaceholder': {
                value: 'Value',
                type: 'string'
            }
        }
    }

    /**
    *  Required files
    */
    static get requires() {
        const requiredFiles = {
            'JQX.Button': 'jqxbutton.js',
            'JQX.Calendar': 'jqxcalendar.js',
            'JQX.CheckBox': 'jqxcheckbox.js',
            'JQX.DateTimePicker': 'jqxdatetimepicker.js',
            'JQX.DropDownList': 'jqxdropdownlist.js',
            'JQX.Input': 'jqxinput.js',
            'JQX.ListBox': 'jqxlistbox.js',
            'JQX.Menu': 'jqxmenu.js',
            'JQX.NumericTextBox': 'jqxnumerictextbox.js',
            'JQX.ScrollBar': 'jqxscrollbar.js',
            'JQX.TimePicker': 'jqxtimepicker.js',
            'JQX.Tooltip': 'jqxtooltip.js',
            'JQX.Utilities.BigNumber': 'jqxmath.js',
            'JQX.Utilities.DateTime': 'jqxdate.js',
            'JQX.Utilities.Draw': 'jqxdraw.js',
            'JQX.Utilities.NumericProcessor': 'jqxnumeric.js',
        };

        if (!window.NIComplex) {
            requiredFiles['JQX.Utilities.Complex'] = 'jqxcomplex.js';
        }

        return requiredFiles;
    }

    /**
     * Element's event listeners.
     */
    static get listeners() {
        return {
            'down': '_downHandler',
            'move': '_moveHandler',
            'resize': '_resizeHandler',
            'editorsContainer.keydown': '_innerContainerKeydownHandler',
            'conditionsMenu.closing': '_menuClosingHandler',
            'conditionsMenu.itemClick': '_menuItemClickHandler',
            'contentContainer.change': '_contentContainerChangeHandler',
            'document.down': '_documentDownHandler',
            'document.move': '_documentMoveHandler',
            'document.up': '_documentUpHandler'
        }
    }

    /**
     * Element's HTML template.
     */
    template() {
        return `<div id="container">
                    <jqx-scroll-viewer id="scrollableContainer" class ="jqx-scrollable-container" animation="[[animation]]">
                        <div id="queryLabel" class="jqx-query-builder-label jqx-unselectable"></div>
                        <div id="contentContainer" class ="jqx-content-container"></div>
                    </jqx-scroll-viewer>
                    <div id="editorsContainer" class ="jqx-editors-container">
                        <div id="customEditor" class ="jqx-custom-editor jqx-hidden"></div>
                    </div>
                    <jqx-menu id="conditionsMenu" mode="dropDown" class ="jqx-conditions-menu" theme="[[theme]]" animation="[[animation]]"></jqx-menu>
                </div>`;
    }

    /**
   * Updates the element when a property is changed.
   * @param {string} propertyName The name of the property.
   * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
   * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
   */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this;

        switch (propertyName) {
            case 'animation':
            case 'theme':
                ['textBoxEditor', 'numericTextBoxEditor', 'comboBoxEditor', 'dateTimePickerEditor', 'checkBoxEditor']
                    .forEach(editor => that.$[editor] && (that.$[editor][propertyName] = newValue));
                break;
            case 'formatStringDate':
            case 'formatStringDateTime':
            case 'valueFormatFunction':
                that._refresh();
                break;
            case 'operatorPlaceholder':
                Array.from(that.querySelectorAll('.jqx-filter-operation[placeholder]')).forEach(element => element.firstElementChild.innerHTML = newValue);
                break;
            case 'propertyPlaceholder':
                Array.from(that.querySelectorAll('.jqx-filter-field-name[placeholder]')).forEach(element => element.firstElementChild.innerHTML = newValue);
                break;
            case 'showIcons':
                that._closeEditor();

                if (newValue) {
                    that._filterOperationDescriptions.map(item => item.icon = that.icons[item.value]);
                }
                else {
                    that._filterOperationDescriptions.map(item => delete item.icon);
                }

                break;
            case 'customOperations':
            case 'fields':
            case 'value': {
                const oldValueAsString = JSON.stringify(that._validValue);

                if (propertyName === 'customOperations') {
                    that._handleCustomOperations();
                }
                else if (propertyName === '') {
                    that._mapFieldsToMenu();
                }

                that._applyValue();

                if (that._oldValueAsString !== oldValueAsString) {
                    that._oldValueAsString = oldValueAsString;
                    that.$.fireEvent('change', { value: JSON.parse(oldValueAsString) });
                }

                break;
            }
            case 'valuePlaceholder':
                Array.from(that.querySelectorAll('.jqx-filter-value[placeholder]')).forEach(element => element.firstElementChild.innerHTML = newValue);
                break;
            case 'locale':
            case 'messages':
                that._localizeInitialValues();
                that._refresh();
                that._handleCustomOperations();//

                if (that.$.dateTimePickerEditor) {
                    if (!that.$.dateTimePickerEditor.messages[that.locale]) {
                        that.$.dateTimePickerEditor.messages[that.locale] = {};
                    }

                    that.$.dateTimePickerEditor.messages[that.locale].dateTabLabel = that.localize('dateTabLabel');
                    that.$.dateTimePickerEditor.messages[that.locale].timeTabLabel = that.localize('timeTabLabel');

                    if (propertyName === 'locale') {
                        that.$.dateTimePickerEditor.locale = that.locale;
                    }
                    else if (propertyName === 'messages') {
                        that.$.dateTimePickerEditor.$.selectDate.innerHTML = that.$.dateTimePickerEditor.messages[that.locale].dateTabLabel;
                        that.$.dateTimePickerEditor.$.selectTime.innerHTML = that.$.dateTimePickerEditor.messages[that.locale].timeTabLabel;
                    }
                }

                break;
            case 'icons':
                that._closeEditor();
                break;
        }
    }

    /**
    * Element's ready method.
    */
    ready() {
        super.ready();

        const that = this;

        that._setInitialValues();
        that._handleCustomOperations();
        that._applyValue();

        Object.defineProperty(that, 'value', {
            get: function () {
                if (that.context === that) {
                    return that.properties.value.value;
                }
                else {
                    return that._validValue;
                }
            },
            set(value) {
                that.updateProperty(that, that._properties.value, value);
            }
        });
    }

    /**
   * Set default values for the menus
   */
    _setInitialValues() {
        const that = this;

        that._autoScrollCoefficient = JQX.Utilities.Core.Browser.Firefox ? 4 : JQX.Utilities.Core.Browser.Edge ? 8 : 2;
        that._isMobile = JQX.Utilities.Core.isMobile;

        that._manuallyAddedFields = [];
        that._localizeInitialValues();
        that.$.conditionsMenu.dropDownAppendTo = that.$.container;
        that.$.conditionsMenu.dataSource = that._groupOperationDescriptions;

        that._valueFlat = [];
        that._lastProcessedItemInCurrentGroup = { parentId: null, id: null, position: null };
    }

    /**
     * Applies value.
     */
    _applyValue() {
        const that = this;

        that._emptyElementsStructure(true);
        that._validateValue();
        //that._setRequiredFields();
        that._convertValueToFlat(that.value);
        that._getFieldsFromValue();
        that._mapFieldsToMenu();
        that._generateHTMLStructureFromFlatValue(true);
        that._restrictNesting();
        that._validValue = that._getValidValue();
        that._oldValueAsString = JSON.stringify(that._validValue);
    }

    /**
     * Set's the requested fields
     */
    _setRequiredFields() {
        const that = this;

        if (!that.requiredFields || !that.requiredFields.length) {
            return;
        }

        const currentValue = that.value;
        let reqGroup = [];

        for (let i = 0; i < that.requiredFields.length; i++) {
            const reqField = that.requiredFields[i],
                field = that.fields.find(field => field.dataField === reqField);

            if (field) {
                let valueRecords = [];

                if (currentValue) {
                    let i = 0;

                    //Doing a lookup on the value for records that contain 'requiredFields'
                    //Modifies the value dynamically
                    while (i < currentValue.length) {
                        const val = currentValue[i];

                        if (Array.isArray(val)) {
                            let r = 0;

                            while (r < val.length) {
                                let record = val[r];

                                if (record && record[0] === field.dataField) {
                                    valueRecords.push(record);
                                    val.splice(r > 0 ? r - 1 : r, 2);
                                    continue;
                                }

                                r++;
                            }
                        }

                        if (!val.length) {
                            currentValue.splice(i, 2);
                            continue;
                        }

                        i++;
                    }
                }

                //Check if group records exist inside value
                if (valueRecords) {
                    for (let r = 0; r < valueRecords.length; r++) {
                        reqGroup.push(valueRecords[r]);
                        reqGroup.push('and');
                    }
                }
                else {
                    //If no records create a placeholder
                    reqGroup.push([reqField]);
                    reqGroup.push('and');
                }
            }
        }

        //Remove the lastly added 'and' condition
        if (typeof reqGroup[reqGroup.length - 1] === 'string') {
            reqGroup.pop();
        }

        //Add the Required Fields on Top of the value
        that.value.unshift(reqGroup, 'and')
    }

    /**
     * Change event Handler for the ContentContainer
     * @param {any} event
     */
    _contentContainerChangeHandler(event) {
        const that = this;

        event.stopPropagation();

        if (that.applyMode !== 'immediately' || !that._editorIsOpen || !that._editor) {
            return;
        }

        const editedHTMLField = that._editor.closest('.filter-builder-item');

        if (!editedHTMLField.classList.contains('jqx-filter-value')) {
            that._closeEditor();
        }
    }

    /**
    * Map field's data with menu's label and value.
    */
    _mapFieldsToMenu() {
        const that = this;

        if (!that.fields && !that._valueFields) {
            return;
        }

        that._fields = (that.fields || that._valueFields).concat(that._manuallyAddedFields).map(field => {
            return { label: field.label, value: field.dataField, dataType: field.dataType, filterOperations: field.filterOperations, lookup: field.lookup };
        });
    }

    /**
    * Localizes default values for the menus.
    */
    _localizeInitialValues() {
        const that = this;

        that.$.queryLabel.innerHTML = that.localize('queryLabel');

        that._addOptions = [
            { label: that.localize('addCondition'), value: 'addCondition' },
            { label: that.localize('addGroup'), value: 'addGroup' }
        ];

        that._groupOperationDescriptions = [
            { label: that.localize('and'), value: 'and' },
            //{ label: that.localize('notand'), value: 'notand' },
            { label: that.localize('or'), value: 'or' }
            //{ label: that.localize('notor'), value: 'notor' }
        ];

        that._defaultFilterOperationDescriptions = that._filterOperationDescriptions = [
            { label: that.localize('='), value: '=', custom: false },
            { label: that.localize('<>'), value: '<>', custom: false },
            { label: that.localize('>'), value: '>', custom: false },
            { label: that.localize('>='), value: '>=', custom: false },
            { label: that.localize('<'), value: '<', custom: false },
            { label: that.localize('<='), value: '<=', custom: false },
            { label: that.localize('startswith'), value: 'startswith', custom: false },
            { label: that.localize('endswith'), value: 'endswith', custom: false },
            { label: that.localize('contains'), value: 'contains', custom: false },
            { label: that.localize('notcontains'), value: 'notcontains', custom: false },
            { label: that.localize('isblank'), value: 'isblank', custom: false },
            { label: that.localize('isnotblank'), value: 'isnotblank', custom: false }
        ];

        //TODO: To Be moved to _formatValueStringRepresentation
        const localizedNames = JQX.Utilities.DateTime.getLocalizedNames(that.locale);

        that._localizedDays = localizedNames.days;
        that._localizedMonths = localizedNames.months;
    }

    /**
    * Add custom operations to the menu's operations list
    */
    _handleCustomOperations() {
        const that = this;

        that._filterOperationDescriptions = that._defaultFilterOperationDescriptions.slice(0);

        for (let i = 0; i < that.customOperations.length; i++) {
            const operation = that.customOperations[i];

            that._filterOperationDescriptions.push({
                label: operation.label,
                value: operation.name,
                custom: true,
                index: i,
                editorTemplate: operation.editorTemplate,
                valueTemplate: operation.valueTemplate,
                handleValue: operation.handleValue,
                hideValue: operation.hideValue
            });
        }
    }

    /**
   * InnerContainer keydown eventHandler 
   * @param {any} event
   */
    _innerContainerKeydownHandler(event) {
        const that = this;

        if (that._editorIsOpen && (event.key === 'Escape' || event.key === 'Enter')) {
            that._closeEditor();
        }
    }

    /**
     * Document down handler - closes menu and/or editor on click outside of the element
     */
    _documentDownHandler(event) {
        const that = this,
            target = event.originalEvent.target;

        if (target.closest('.jqx-input-drop-down-menu') || that.$.conditionsMenu.contains(target)) {
            return;
        }

        const isDropDown = target.closest('.jqx-drop-down');

        if (target.closest('jqx-query-builder') === that || (isDropDown && that.contains(isDropDown.ownerElement))) {
            that._clickHandler(event.originalEvent);
            return;
        }

        if (that._editorIsOpen && !that._scrollBarDown) {
            that._closeEditor();
        }

        delete that._scrollBarDown;
    }

    /**
    * Generates HTML structure from flat array and adds/replaces
    * @param {Array} data - contains dataField, operator and value
    */
    _emptyElementsStructure(emptyValueFlat) {
        const that = this,
            contentContainer = that.$.contentContainer;

        while (contentContainer.firstChild) {
            contentContainer.removeChild(contentContainer.firstChild);
        }

        that._valueFlat = emptyValueFlat ? [] : that._valueFlat;
        that._lastProcessedItemInCurrentGroup = { parentId: null, id: null, position: null };
    }

    /**
    * Resize handler
    */
    _resizeHandler() {
        this.$.scrollableContainer.refresh();
    }

    /**
     * Returns the number of all conditions
     */
    _getTotalConditions() {
        return this.getElementsByClassName('jqx-filter-group-condition').length;
    }

    /**
     * Validates the structure of the "value" array.
     */
    _validateValue() {
        const that = this,
            value = that.value;

        if (!Array.isArray(value) ||
            JSON.stringify(value).replace(/[\[\]]/g, '') === '') {
            that.value = [[[]]];
            return;
        }

        if (value.length === 3 && typeof value[0] === 'string') {
            that.value = [[value]];
        }

        if (Array.isArray(value[0]) && value[0].length === 3 && typeof value[0][0] === 'string') {
            that.value = [value];
        }

        while (typeof value[0] === 'string') {
            value.shift();
        }

        while (typeof value[value.length - 1] === 'string') {
            value.pop();
        }

        that.value.forEach(item => {
            if (Array.isArray(item) && item.length === 0) {
                item.push([]);
            }
        });
    }

    /**
   * Converts value(represented as nested array) to flat array. Used for internal data representation 
   * @param {Array} groupData - an array with group data
   * @param {String} nodeId - the id of the current element
   */
    _convertValueToFlat(groupData) {
        const that = this,
            operatorList = ['and', 'or', 'notAnd', 'notOr'];

        if (!groupData) {
            return;
        }

        let totalConditions = 0,
            totalGroups = 0;

        function createItems(groupData, groupIndex) {
            let operator;

            for (let i = 0; i < groupData.length; i++) {
                const data = groupData[i],
                    isDataAnOperator = typeof data === 'string' && operatorList.indexOf(data) > -1;
                let item = { htmlNode: null };

                if (isDataAnOperator) {
                    operator = data.trim();
                    continue;
                }

                operator = operator || 'and';

                //Check if condition/group
                if (Array.isArray(data)) {
                    let groupConditions = that._valueFlat.filter(item => item.parentId + '' === groupIndex + '').length;

                    //Check if condition
                    if (!data.find(item => Array.isArray(item))) {

                        if (that.maxConditions && totalConditions >= that.maxConditions || that.maxConditionsPerGroup && groupConditions >= that.maxConditionsPerGroup) {
                            continue;
                        }

                        //Create Operator
                        if (i !== 0) {
                            that._valueFlat.push({ nodeId: groupIndex + '.' + groupConditions, type: 'operator', data: operator, parentId: groupIndex + '' });
                            operator = '';
                            groupConditions++;
                        }

                        //Create Condition
                        item.nodeId = groupIndex + '.' + groupConditions;
                        item.parentId = groupIndex + '';
                        item.type = 'condition';
                        item.data = data;

                        totalConditions++;
                        that._valueFlat.push(item);
                    }
                    else {
                        item.nodeId = (totalGroups += 1) + '';
                        item.type = 'group';
                        item.data = operator;
                        that._valueFlat.push(item);

                        createItems(data, item.nodeId);
                        operator = '';
                    }
                }
            }
        }

        //Empty the flat value
        that._valueFlat = [];
        createItems(groupData, 0);

        delete that._totalGroups;
    }

    /**
    * Generates an array of field objects, used as a backup when fields property is not set
    */
    _getFieldsFromValue() {
        const that = this,
            items = that._valueFlat,
            fieldsNames = [],
            fields = [];

        function getDataType(data) {
            if (typeof data === 'boolean') {
                return 'boolean';
            }

            if (data instanceof Date) {
                if (data.getHours() > 0 || data.getMinutes() > 0 || data.getSeconds() > 0) {
                    return 'datetime';
                }

                return 'date';
            }

            if (!isNaN(data)) {
                return 'number';
            }

            return 'string';
        }

        for (let i = 0; i < items.length; i++) {
            const item = items[i];

            if (item.type === 'condition') {
                const fieldName = item.data[0];

                if (fieldName && fieldsNames.indexOf(fieldName) === -1) {
                    const fieldElement = { label: fieldName, dataField: fieldName, dataType: getDataType(item.data[2]), format: null };

                    fieldsNames.push(fieldName);
                    fields.push(fieldElement);
                }
            }
        }

        that._valueFields = fields;
    }

    /*
   * Creates new group or condition
   * @param {String} type - 'group' or 'condition'
   * @param {Any} parentGroup - html object or group id
   * @param {Any} data - if type is group - contains group's operator;  if type is condition - dataField, operator and value
   */
    _addElement(type, parentGroup, data, noRefresh) {
        const that = this,
            siblings = that._valueFlat.filter(item => {
                return item.parentId === parentGroup
            });
        let addGroupAtPosition = 0,
            groupSeparator = '';

        data = data || (type === 'group' ? 'or' : []);

        if (siblings.length) {
            let siblingsIndexes = siblings.map(index => {
                const indexPath = index.nodeId.split('.');

                return parseInt(indexPath[indexPath.length - 1]);
            });

            siblingsIndexes = (siblingsIndexes.length === 0) ? [0] : siblingsIndexes;
            addGroupAtPosition = siblingsIndexes.reduce((a, b) => Math.max(a, b)) + 1;
        }

        if (parentGroup && parentGroup.length > 0) {
            groupSeparator = '.';
        }

        let itemId = (parentGroup || '') + groupSeparator + (type === 'group' ? that._valueFlat.filter(item => item.type === 'group').length + 1 : addGroupAtPosition);

        let lastGroupSibling = siblings[0];

        if (siblings.length) {
            for (let s = 0; s < siblings.length; s++) {
                const sibling = siblings[s],
                    siblingIndex = sibling.nodeId.split('.').pop();

                if (parseInt(siblingIndex) > parseInt(lastGroupSibling.nodeId.split('.').pop())) {
                    lastGroupSibling = sibling;
                }
            }
        }
        else {
            lastGroupSibling = that._valueFlat.find(item => item.nodeId === parentGroup);
        }

        let lastGroupSiblingIndex = lastGroupSibling ? that._valueFlat.indexOf(lastGroupSibling) + 1 : that._valueFlat.length;

        if (type === 'condition' && siblings.length > 0) {
            that._valueFlat.splice(lastGroupSiblingIndex, 0, { nodeId: itemId, parentId: parentGroup, type: 'operator', data: ['and'], htmlNode: null });
            itemId = (parentGroup || '') + groupSeparator + (addGroupAtPosition + 1);
            lastGroupSiblingIndex++;
        }

        const itemData = {
            nodeId: itemId,
            parentId: parentGroup,
            type: type,
            data: data,
            htmlNode: null
        };

        that._valueFlat.splice(lastGroupSiblingIndex, 0, itemData);

        if (type === 'group') {
            that._addElement('condition', itemId, [], true);
        }

        if (!noRefresh) {
            that._refresh();
        }
    }

    /**
   * Removes a condition and it's HTML representation
   * @param {Any} elementNode.
   * @param {String} type.
   */
    _deleteElement(elementNode, type) {
        const that = this,
            nodeId = typeof elementNode === 'string' ? elementNode : elementNode.getAttribute('node-id');

        if (!nodeId || nodeId.length === 1) {
            return;
        }

        function deleteOperator(index) {
            const operator = that._valueFlat[index];

            //Remove the nested operator for the condition
            if (operator && operator.type === 'operator') {
                that._valueFlat.splice(index, 1);
                operator.htmlNode.parentElement.removeChild(operator.htmlNode);
                return true;
            }
        }

        function deleteCondition(nodeId) {
            let item,
                indexInGroup = 0,
                groupId = nodeId.split('.');

            groupId.pop();
            groupId = groupId.join('.');

            for (let i = 0; i < that._valueFlat.length; i++) {
                const flatItem = that._valueFlat[i];

                if (flatItem.type !== 'condition') {
                    continue;
                }

                if (flatItem.nodeId === nodeId) {
                    item = flatItem;
                    break;
                }

                if (flatItem.parentId === groupId) {
                    indexInGroup++;
                }
            }

            const itemIndex = that._valueFlat.indexOf(item);

            //Remove the condition
            that._valueFlat.splice(itemIndex, 1);
            //that._totalConditions--;
            item.htmlNode.parentElement.removeChild(item.htmlNode);

            //Remove the operator for the condition
            const isPreviousOperatorRemoved = deleteOperator(itemIndex - 1);

            //If the removed condition was 1st in the group, remove the next nested condition as well
            if (!indexInGroup) {
                deleteOperator(itemIndex - (isPreviousOperatorRemoved ? 1 : 0));
            }

            const groupNode = that._valueFlat.filter(item => item.nodeId === groupId)[0].htmlNode;

            if (groupNode.children[1].childElementCount > 0 && groupNode.children[2].hasAttribute('limit-selection') &&
                !groupNode.children[1].lastElementChild.hasAttribute('limit-selection')) {
                groupNode.children[2].removeAttribute('limit-selection');
            }
        }

        function deleteGroup(nodeId) {
            const item = that._valueFlat.filter(item => nodeId === item.nodeId && item.type === 'group')[0];

            for (let i = 0; i < that._valueFlat.length; i++) {
                const nestedItem = that._valueFlat[i],
                    nestedNodeId = nestedItem.nodeId;

                if (nestedItem.parentId === nodeId) {
                    nestedItem.type === 'group' ? deleteGroup(nestedNodeId) : deleteCondition(nestedNodeId);
                }
            }

            that._valueFlat.indexOf(item) > -1 && that._valueFlat.splice(that._valueFlat.indexOf(item), 1);
            item.htmlNode.parentElement.removeChild(item.htmlNode);
        }

        type === 'group' ? deleteGroup(nodeId) : deleteCondition(nodeId);

        //Delete the group if it's empty
        if (!type || type === 'condition') {
            let groupId = nodeId.split('.');

            groupId.pop();
            groupId = groupId.join('.');

            if (!that._valueFlat.filter(i => i.parentId === groupId).length) {
                if (that._valueFlat.filter(item => item.type === 'group').length > 1) {
                    deleteGroup(groupId);
                }

                //Set the new 0th group
                if (groupId === '0') {
                    const firstGroup = that._valueFlat.find(item => item.type === 'group'),
                        oldGroupId = firstGroup.nodeId;

                    firstGroup.nodeId = '0';
                    firstGroup.htmlNode.setAttribute('node-id', '0');

                    const groupConditions = that._valueFlat.filter(item => item.parentId === oldGroupId);

                    for (let c = 0; c < groupConditions.length; c++) {
                        const con = groupConditions[c];

                        con.parentId = '0';
                        con.nodeId = '0.' + c;
                        con.htmlNode.setAttribute('node-id', con.nodeId);
                    }
                }
            }

            //if (that.requiredFields && that.requiredFields.length) {
            //    const firstNonRestrictedGroup = that._valueFlat.find(item => item.type === 'group' && !item.restricted);

            //    if (firstNonRestrictedGroup) {
            //        firstNonRestrictedGroup.htmlNode.querySelector('.jqx-filter-group-operator').setAttribute('restricted', '');
            //    }
            //}

            that._generateValue();
        }
    }

    /**
     * Generates a flat structure form HTML
     */
    _generateHTMLStructureFromFlatValue(validation) {
        const that = this,
            fragment = document.createDocumentFragment();

        if (!that._valueFlat || that._valueFlat.length === 0) {
            return;
        }

        //let lastGroup;

        for (let i = 0; i < that._valueFlat.length; i++) {
            const item = that._valueFlat[i],
                customOperation = that.customOperations ? that.customOperations.find(operation => operation.name === item.data[1]) : false,
                parentGroupHTMLcontainer = item.parentId ? that.querySelector('[node-id="' + item.parentId + '"]').querySelector('.jqx-filter-group-condition-container') : that.$.contentContainer;

            if (item.type === 'group') {
                const groupContainerBlock = document.createElement('div'),
                    groupOperator = that.localize(item.data) || '';

                groupContainerBlock.className = 'jqx-filter-group';
                groupContainerBlock.innerHTML = '<div class="jqx-filter-group-operator">' + groupOperator + '</div>' +
                    '<div class="jqx-filter-group-condition-container"></div>' +
                    '<div class="jqx-filter-add-condition-btn"><div>' + that.localize('add') + '</div></div>' +
                    '<div class="jqx-filter-add-btn"></div>';

                //Set the group operator 'data' attribute
                groupContainerBlock.firstElementChild.data = groupOperator;

                fragment.appendChild(groupContainerBlock);

                groupContainerBlock.setAttribute('node-id', item.nodeId);
                that._valueFlat[i].htmlNode = groupContainerBlock;

                //if (!lastGroup && that.requiredFields && that.requiredFields.length) {
                //    groupContainerBlock.setAttribute('restricted', '');
                //    item.restricted = true;
                //}

                //lastGroup = groupContainerBlock;
            }
            else if (item.type === 'condition') {
                const condition = that._newFilterConditionRow(item.data);

                condition.setAttribute('node-id', item.nodeId);
                fragment.appendChild(condition);
                that._valueFlat[i].htmlNode = condition;

                if (item.data[0] !== undefined && item.data[1] === undefined) {
                    const validOperations = that._getFilterOperations(that._fields.find(field => field.value === item.data[0]));

                    that._handleOnlyOperation(validOperations, item.data, condition);
                }
                else if (['isblank', 'isnotblank'].indexOf(item.data[1]) !== -1 || (customOperation && customOperation.hideValue)) {
                    item.data.splice(2, 1);
                    condition.children[2].classList.add('jqx-visibility-hidden');
                }
            }
            else {
                const operator = document.createElement('div');

                operator.className = 'jqx-filter-nested-operator';
                operator.setAttribute('node-id', item.nodeId);
                operator.innerHTML = that.localize(item.data);

                fragment.appendChild(operator);
                that._valueFlat[i].htmlNode = operator;
            }

            parentGroupHTMLcontainer.appendChild(fragment);
        }

        if (validation) {
            that._validateValueAdvanced();
        }

        that.$.scrollableContainer.refresh();
    }

    /**
     * Advanced value validation.
     */
    _validateValueAdvanced() {
        const that = this,
            value = that.value;
        let toRefresh = false,
            toRefreshValue = false,
            consecutiveStrings = 0;

        for (let i = 0; i < value.length; i++) {
            const group = value[i];

            if (typeof group === 'string') {
                continue;
            }

            for (let j = group.length - 1; j >= 0; j--) {
                let item = group[j];

                if (Array.isArray(item) && item.length === 0 && j !== group.length - 1) {
                    group.splice(j, 1);

                    if (j === 0) {
                        group.splice(0, 1);
                    }

                    toRefresh = true;
                }
                else if (typeof item === 'string') {
                    item = item.toLowerCase();
                    consecutiveStrings++;

                    if (consecutiveStrings > 1 || item !== 'and' && item !== 'or') {
                        toRefreshValue = true;
                    }

                    continue;
                }

                consecutiveStrings = 0;
            }
        }

        if (toRefresh) {
            that._emptyElementsStructure(true);
            that._convertValueToFlat(that.value);
            that._generateHTMLStructureFromFlatValue();
        }

        if (toRefreshValue) {
            that._generateValue(true);
        }
    }

    /**
     * Restict nesting in condition groups if a "placeholder" condition is already present.
     */
    _restrictNesting() {
        const that = this,
            addConditionBtns = Array.from(that.getElementsByClassName('jqx-filter-add-condition-btn'));

        addConditionBtns.forEach(btn => {
            const lastCondition = btn.previousElementSibling.lastElementChild;

            if (lastCondition && lastCondition.hasAttribute('limit-selection')) {
                btn.setAttribute('limit-selection', '');
            }
        });
    }

    /**
    * Handles click event according to the target's type (filter button, add button, delete button, etc.).
    */
    _clickHandler(event) {
        const that = this,
            target = event.target;

        if (that.disabled || !target || !target.closest || (!that._isMobile && event.button !== 0)) {
            return;
        }

        if (that._scrollBarDown) {
            delete that._scrollBarDown;
            return;
        }

        const isTargetADropDown = target.closest('.jqx-drop-down'),
            targetIsEditor = (that._editor && that._editor.contains(target) || (isTargetADropDown && (that._editor.contains(isTargetADropDown.ownerElement) ||
                that._editor === isTargetADropDown.ownerElement))) || target.closest('.jqx-custom-editor');

        if (that._editor && that._editorIsOpen && !targetIsEditor) {
            that._closeEditor();
        }

        const filterItem = target.closest('.jqx-filter-group-condition') || target.closest('.jqx-filter-nested-operator') || target.closest('.jqx-filter-group');

        if (!filterItem) {
            return;
        }

        const item = that._getItemById(filterItem.getAttribute('node-id'));

        if (!item) {
            return;
        }

        that.$.fireEvent('itemClick', {
            id: item.nodeId,
            type: item.type,
            data: item.data
        });

        if (target.closest('.jqx-filter-delete-btn')) {
            that._clickHandlerDeleteButton(item.htmlNode);
            return;
        }

        const isAddButton = target.closest('.jqx-filter-add-btn') || target.closest('.jqx-filter-add-condition-btn');

        //Add group
        if (isAddButton) {
            const selectedFilterGroupId = isAddButton.closest('.jqx-filter-group').getAttribute('node-id');

            if (isAddButton.classList.contains('jqx-filter-add-condition-btn') && ((that.maxConditions && (that._getTotalConditions() < that.maxConditions)) || !that.maxConditions)) {
                that._addElement('condition', selectedFilterGroupId, []);
                //that._totalConditions++;
            }
            else {
                that._clickHandlerFilterButton(isAddButton.classList, item.nodeId, target);
            }

            return;
        }

        const isFilterButton = target.closest('.filter-builder-item') || target.closest('.jqx-filter-group-operator') || target.closest('.jqx-filter-nested-operator');

        if (isFilterButton) {
            const elementClassList = isFilterButton.classList;

            that._clickHandlerFilterButton(elementClassList, item.nodeId, target);
        }
    }

    /**
     * down handler
     */
    _downHandler(event) {
        const that = this;

        if (!event.originalEvent || (!that._isMobile && event.button !== 0)) {
            return;
        }

        const target = event.originalEvent.target;

        if (that.allowDrag && target.classList.contains('jqx-filter-group-condition') &&
            event.pageX < target.getBoundingClientRect().left) {
            const conditions = that._valueFlat.filter(item => item.type === 'condition');

            if (conditions.length === 1 ||
                conditions.length === 2 && conditions[0].parentId === conditions[1].parentId &&
                conditions[1].htmlNode.hasAttribute('limit-selection')) {
                return;
            }

            that._dragDetails = {
                coords: {
                    x: event.pageX, y: event.pageY
                },
                item: target,
                originalEvent: event
            };

            that.$.scrollableContainer._scrollView.disableSwipeScroll = true;
            that._hoveredCondition = target;
            window.getSelection().removeAllRanges();
            return;
        }

        this._scrollBarDown = target.closest('jqx-scroll-bar');

        event.stopPropagation();
        event.preventDefault();
    }

    /**
     * move handler.
     */
    _moveHandler(event) {
        if (event.originalEvent.type === 'touchmove') {
            event.originalEvent.preventDefault();
        }
    }

    /**
     * document move handler.
     */
    _documentMoveHandler(event) {
        const that = this,
            dragDetails = that._dragDetails;

        if (!dragDetails) {
            return;
        }

        const draggedItem = dragDetails.item;

        if (!dragDetails.feedbackShown) {
            if (Math.abs(dragDetails.coords.x - event.pageX) > 5 ||
                Math.abs(dragDetails.coords.y - event.pageY) > 5) {
                const draggedItemData = that._valueFlat.filter(item => item.htmlNode === draggedItem)[0],
                    dragStartEvent = that.$.fireEvent('dragStart', { data: draggedItemData.data, item: draggedItem, originalEvent: event });

                if (dragStartEvent.defaultPrevented) {
                    delete that._dragDetails;
                    delete that._hoveredCondition;
                    that.$.scrollableContainer._scrollView.disableSwipeScroll = false;
                    return;
                }

                dragDetails.allConditions = Array.from(that.getElementsByClassName('jqx-filter-group-condition'));
                dragDetails.data = draggedItemData;
                dragDetails.feedback = that._addDragFeedback();
                dragDetails.feedbackShown = true;
                dragDetails.rect = that.getBoundingClientRect();

                draggedItem.classList.add('dragged');
            }
            else {
                return;
            }
        }

        const y = event.clientY;
        let target = event.originalEvent.target,
            hoveredItem;

        that.$.fireEvent('dragging', { data: dragDetails.data, item: draggedItem, originalEvent: event });
        that.setAttribute('dragging', '');

        dragDetails.feedback.style.left = (event.pageX + 10) + 'px';
        dragDetails.feedback.style.top = (event.pageY + 10) + 'px';

        if (that._isMobile) {
            const oldHoveredItem = that._hoveredCondition;

            if (oldHoveredItem) {
                oldHoveredItem.classList.remove('drop-target', 'top', 'bottom');
                delete that._hoveredCondition;
            }

            const realTarget = document.elementFromPoint(event.clientX, y);

            if (realTarget) {
                target = realTarget;
            }
        }

        let closestCondition = target.closest('.jqx-filter-group-condition'),
            side;

        if (closestCondition) {
            hoveredItem = closestCondition;

            const rect = hoveredItem.getBoundingClientRect(),
                topDistance = Math.abs(y - rect.top),
                bottomDisatnce = Math.abs(y - rect.bottom);

            side = topDistance < bottomDisatnce ? 'top' : 'bottom';
        }
        else {
            let closest, closestDistance;

            dragDetails.allConditions.forEach(condition => {
                const rect = condition.getBoundingClientRect(),
                    topDistance = Math.abs(y - rect.top),
                    bottomDisatnce = Math.abs(y - rect.bottom),
                    bestDistance = Math.min(topDistance, bottomDisatnce);

                if (closestDistance === undefined || bestDistance < closestDistance) {
                    closest = condition;
                    closestDistance = bestDistance;
                    side = topDistance < bottomDisatnce ? 'top' : 'bottom';
                }
            });

            closestCondition = closest;
        }

        if (closestCondition !== draggedItem && !(closestCondition.hasAttribute('limit-selection') && side === 'bottom')) {
            const conditionsInGroup = Array.from(closestCondition.parentElement.getElementsByClassName('jqx-filter-group-condition')),
                indexOfDraggedItem = conditionsInGroup.indexOf(draggedItem);

            if (indexOfDraggedItem !== -1) {
                if (side === 'top' && closestCondition === conditionsInGroup[indexOfDraggedItem + 1] ||
                    side === 'bottom' && closestCondition === conditionsInGroup[indexOfDraggedItem - 1]) {
                    closestCondition = undefined;
                }
            }
        }
        else {
            closestCondition = undefined;
        }

        hoveredItem = closestCondition;
        dragDetails.side = side;

        clearInterval(that._dragInterval);
        that._dragInterval = setInterval(function () {
            const rect = dragDetails.rect;

            if (that.$.scrollableContainer.scrollHeight > 0 &&
                rect.left <= event.clientX && rect.left + rect.width >= event.clientX) {
                if (y >= rect.top && y <= rect.top + 36) {
                    that.$.scrollableContainer.scrollTop -= that._autoScrollCoefficient;
                }
                else if (y >= rect.top + rect.height - 36 && y <= rect.top + rect.height) {
                    that.$.scrollableContainer.scrollTop += that._autoScrollCoefficient;
                }
                else {
                    clearInterval(that._dragInterval);
                }
            }
            else {
                clearInterval(that._dragInterval);
            }
        }, 1);

        if (hoveredItem) {
            if (that._hoveredCondition && hoveredItem !== that._hoveredCondition) {
                that._hoveredCondition.classList.remove('drop-target', 'top', 'bottom');
            }

            const hoveredItemGroup = hoveredItem.closest('.jqx-filter-group');

            if (hoveredItemGroup && hoveredItemGroup.hasAttribute('restricted')) {
                that._hoveredCondition = undefined;
                return;
            }

            that._hoveredCondition = hoveredItem;
            hoveredItem.classList.remove('top', 'bottom');
            hoveredItem.classList.add(side, 'drop-target');
        }
        else if (that._hoveredCondition) {
            that._hoveredCondition.classList.remove('drop-target', 'top', 'bottom');
            delete that._hoveredCondition;
        }
    }

    /**
     * Adds drag feedback.
     */
    _addDragFeedback() {
        const feedback = document.createElement('div');

        feedback.className = 'jqx-query-builder-drag-feedback';
        document.body.appendChild(feedback);
        return feedback;
    }

    /**
     * document move handler.
     */
    _documentUpHandler(event) {
        const that = this,
            dragDetails = that._dragDetails;

        if (!dragDetails) {
            if (that.$.conditionsMenu.opened && that._selectedElement && !that._selectedElement.classList.contains('jqx-filter-add-btn')) {
                that.$.conditionsMenu._hoverViaKeyboard(that.$.conditionsMenu.querySelector('jqx-menu-item[value="' + that._editedItem.data + '"]'));
            }

            return;
        }

        const draggedItem = dragDetails.item,
            draggedItemData = dragDetails.data,
            hoveredItem = that._hoveredCondition;

        delete that._dragDetails;
        delete that._hoveredCondition;
        that.$.scrollableContainer._scrollView.disableSwipeScroll = false;

        if (!that.hasAttribute('dragging')) {
            return;
        }

        clearInterval(that._dragInterval);
        window.getSelection().removeAllRanges();
        that.removeAttribute('dragging');
        draggedItem.classList.remove('dragged');
        document.body.removeChild(dragDetails.feedback);

        if (!hoveredItem) {
            that.$.fireEvent('dragEnd', { data: draggedItemData.data, item: draggedItem, originalEvent: event, target: null, targetData: null, targetSide: null });
            return;
        }

        const hoveredItemData = that._valueFlat.filter(item => item.htmlNode === hoveredItem)[0],
            dragEndEvent = that.$.fireEvent('dragEnd', {
                data: draggedItemData.data,
                item: draggedItem,
                originalEvent: event,
                target: hoveredItem,
                targetData: hoveredItemData.data,
                targetSide: dragDetails.side
            });

        hoveredItem.classList.remove('drop-target', 'top', 'bottom');

        if (dragEndEvent.defaultPrevented) {
            return;
        }

        const value = that.value,
            draggedPath = draggedItemData.nodeId.split('.').map(index => parseFloat(index)),
            groupInValue = value[(draggedPath[0] - 1) * 2],
            hoveredPath = hoveredItemData.nodeId.split('.').map(index => parseFloat(index)),
            targetGroupInValue = value[(hoveredPath[0] - 1) * 2];
        let operator = 'and';

        if (groupInValue.length > 1) {
            if (draggedPath[1] === 0) {
                // condition is first in group
                operator = groupInValue[1];
                groupInValue[1] = '!remove!';
            }
            else {
                // condition is not first in group
                operator = groupInValue[draggedPath[1] - 1];
                groupInValue[draggedPath[1] - 1] = '!remove!';
            }
        }

        groupInValue[draggedPath[1]] = '!remove!';

        if (dragDetails.side === 'top') {
            targetGroupInValue.splice(hoveredPath[1], 0, draggedItemData.data, operator);
        }
        else {
            targetGroupInValue.splice(hoveredPath[1] + 1, 0, operator, draggedItemData.data);
        }

        for (let i = 0; i < value.length; i++) {
            if (Array.isArray(value[i])) {
                value[i] = value[i].filter(member => member !== '!remove!');
            }
        }

        for (let i = value.length - 1; i >= 0; i--) {
            if (Array.isArray(value[i]) && value[i].length === 0) {
                if (i === 0) {
                    value.splice(0, 2);
                }
                else {
                    value.splice(i - 1, 2);
                    i--;
                }
            }
        }

        that._emptyElementsStructure(true);
        that._convertValueToFlat(value);
        that._generateHTMLStructureFromFlatValue();
        that._validValue = that._getValidValue();

        const oldValueAsString = JSON.stringify(that._validValue);

        if (that._oldValueAsString !== oldValueAsString) {
            that._oldValueAsString = oldValueAsString;
            that.$.fireEvent('change', { value: JSON.parse(oldValueAsString) });
        }
    }

    /**
    * Handling click on delete button
    */
    _clickHandlerDeleteButton(item, isEmptyCheck) {
        const that = this;

        if (!item || !item.classList) {
            return;
        }

        that._closeEditor();

        if (that.getElementsByClassName('jqx-filter-group-condition').length === 1) {
            // resets only condition
            const containers = that._valueFlat[1].htmlNode.children;

            that.value = [[[]]];
            that._validValue = that._getValidValue();

            that._valueFlat[1].data = [];
            that._valueFlat[1].htmlNode.setAttribute('limit-selection', '');
            containers[0].setAttribute('placeholder', '');
            containers[1].setAttribute('placeholder', '');
            containers[2].setAttribute('placeholder', '');
            containers[0].firstElementChild.innerHTML = that.propertyPlaceholder;
            containers[1].firstElementChild.innerHTML = that.operatorPlaceholder;
            containers[2].firstElementChild.innerHTML = that.valuePlaceholder;

            const oldValueAsString = JSON.stringify(that._validValue);

            if (that._oldValueAsString !== oldValueAsString) {
                that._oldValueAsString = oldValueAsString;
                that.$.fireEvent('change', { value: JSON.parse(oldValueAsString) });
            }

            return;
        }

        if (item.classList.contains('jqx-filter-group')) {
            if (isEmptyCheck && that._valueFlat.filter(conditionItem => conditionItem.parentId === item.getAttribute('node-id')).length > 0) {
                return;
            }

            that._deleteElement(item, 'group');
        }
        else {
            that._deleteElement(item);
        }

        that._generateValue();
        that.$.scrollableContainer.refresh();

        Array.from(that.$.contentContainer.children).forEach((filterGroup, index) => {
            const parentId = (index + 1).toString();

            filterGroup.setAttribute('node-id', parentId);
            that._valueFlat.filter(item => item.htmlNode === filterGroup)[0].nodeId = parentId;

            Array.from(filterGroup.children[1].children).forEach((element, index) => {
                const valueFlatItem = that._valueFlat.filter(item => item.htmlNode === element)[0],
                    id = parentId + '.' + index;

                element.setAttribute('node-id', id);
                valueFlatItem.parentId = parentId;
                valueFlatItem.nodeId = id;
            });
        });
    }

    /**
     * Handles menu closing.
     */
    _menuClosingHandler(event) {
        const detail = event.detail;

        if (detail.trigger === 'interaction' && this._selectedElement === detail.target) {
            event.preventDefault();
        }
    }

    /**
     * Handles menu item click.
     */
    _menuItemClickHandler(event) {
        const that = this,
            selectedElement = that._selectedElement.closest('.jqx-filter-group-operator, .jqx-filter-nested-operator'),
            details = event.detail,
            value = details.value;
        let nodeId;

        if (selectedElement) {
            selectedElement.innerHTML = that.localize(value) || details.label;
            selectedElement.value = value;

            if (selectedElement.classList.contains('jqx-filter-nested-operator')) {
                nodeId = selectedElement.getAttribute('node-id');
            }
            else {
                nodeId = selectedElement.parentElement.getAttribute('node-id');
            }

            for (let i = 0; i < that._valueFlat.length; i++) {
                if (that._valueFlat[i].nodeId === nodeId) {
                    that._valueFlat[i].data = selectedElement.value;
                    break;
                }
            }

            that._generateValue();
        }
        else {
            nodeId = that._selectedElement.parentElement.getAttribute('node-id');
            that._addElement('group', null, value);
        }

        that.$.scrollableContainer.refresh();
    }

    /**
    * Creates new filter condition row
    * @param {Array} condition (optional). An array with a condition params. If "condition" parameter is not set - in the method is used default value
    */
    _newFilterConditionRow(condition = []) {
        const that = this,
            dataField = condition[0];
        let dataFieldWithLabel = that._fields.find(item => item.value === dataField),
            dataFieldsLabel = dataFieldWithLabel ? dataFieldWithLabel.label : undefined;
        let operation;

        if (dataField === undefined || !dataFieldsLabel && that.fieldsMode === 'static') {
            condition.length = 0;
        }
        else {
            if (!dataFieldsLabel) {
                dataFieldWithLabel = that._getDynamicFieldInfo(dataField);
                dataFieldsLabel = dataFieldWithLabel.label;
                condition[0] = dataFieldWithLabel.dataField;
            }

            const validOperations = that._getFilterOperations(dataFieldWithLabel);

            operation = validOperations.find(validOperation => validOperation.value === condition[1]);

            if (!operation) {
                condition.splice(1, 2);
            }
            else {
                operation = operation.label;
            }
        }

        const value = that._formatValueStringRepresentation(condition[2], condition[0], condition[1]);
        let conditionRow = document.createElement('div'),
            template = '<div class ="filter-builder-item jqx-filter-field-name" ' + (dataFieldsLabel ? '><div class ="jqx-value-container">' + dataFieldsLabel : 'placeholder><div class ="jqx-value-container">' + that.propertyPlaceholder) + '</div></div>' +
                '<div class ="filter-builder-item jqx-filter-operation" ' + (operation ? '><div class ="jqx-value-container">' + operation : 'placeholder><div class ="jqx-value-container">' + that.operatorPlaceholder) + '</div></div>' +
                '<div class ="filter-builder-item jqx-filter-value" ' +
                (condition[2] !== undefined ? '><div class ="jqx-value-container">' + value : 'placeholder><div class ="jqx-value-container">' + that.valuePlaceholder) + '</div></div>' +
                '<div class ="jqx-filter-delete-btn"></div>';

        conditionRow.className = 'jqx-filter-group-condition';
        conditionRow.innerHTML = template;

        if (!condition.length) {
            conditionRow.setAttribute('limit-selection', '');
        }

        return conditionRow;
    }

    /**
    * Removes a condition and it's HTML representation
    * @param {Any} value.
    * @param {String} field.
    */
    _formatValueStringRepresentation(value, field, operation) {
        const that = this,
            fieldData = that._getFieldByFieldName(field);
        let valueFormattedByType;

        if (!fieldData) {
            return value;
        }

        if (value === undefined || value === null) {
            return that.valuePlaceholder;
        }

        if (operation !== undefined && that.customOperations && that.customOperations.length > 0) {
            operation = that.customOperations.find(customOperation => customOperation.name === operation);

            if (operation && operation.valueTemplate) {
                return operation.valueTemplate(that._editor, value);
            }
        }

        switch (fieldData.dataType) {
            case 'date':
            case 'datetime':
                value = value instanceof Date || typeof value === 'string' || (typeof value === 'number' && !isNaN(value)) ? new JQX.Utilities.DateTime(value) : value;
                value.calendar.days = that._localizedDays;
                value.calendar.months = that._localizedMonths;
                value.calendar.locale = that.locale;
                valueFormattedByType = value.toString(fieldData.dataType === 'date' ? that.formatStringDate : that.formatStringDateTime);
                break;
            case 'array':
                valueFormattedByType = typeof value === 'string' ? value.split(',') : value;
                break;
            case 'object':
                valueFormattedByType = typeof value === 'string' ? value : JSON.stringify(value);
                break;
            case 'number':
                valueFormattedByType = value;
                break;
            case 'boolean':
                valueFormattedByType = !!value;
                break;
            default:
                valueFormattedByType = value + '';
                break;

        }

        if (!that.valueFormatFunction) {
            return valueFormattedByType;
        }

        return that.valueFormatFunction(valueFormattedByType, field, (fieldData.dataType || 'string'));
    }

    /**
    * Return field's data by given field name
    * @param {String} fieldName
    */
    _getFieldByFieldName(fieldName) {
        return Object.assign({}, this._fields.find(item => item.value === fieldName));
    }

    /**
    * Refreshes the structure
    */
    _refresh() {
        const that = this;

        that._generateValue();
        that._emptyElementsStructure();
        that._generateHTMLStructureFromFlatValue();
        that._restrictNesting();
    }

    /**
    * Generates the new value of "value" property from flat
    */
    _generateValue(preventEventFiring) {
        const that = this;
        let groupsWithItems = [],
            value = that._valueFlat.slice(0),
            structure = [];

        //Get all condition groups
        for (let i = 0; i < value.length; i++) {
            const item = value[i];
            let group = {};

            if (item.type === 'group') {
                group.nodeId = item.nodeId;
                group.parentId = item.parentId;
                group.data = item.data;
                //group.structure = [item.data || 'or'];
                //group.structure = item.data ? [item.data] : [];
                group.structure = [];
                groupsWithItems.push(group);
            }
        }

        for (let i = 0; i < groupsWithItems.length; i++) {
            const group = groupsWithItems[i];
            //let conditions = [],
            //operators = [];

            for (let g = 0; g < value.length; g++) {
                const item = value[g];

                if (item.parentId === group.nodeId) {
                    if (item.type === 'condition') {
                        //const operator = value.filter(item => {
                        //    return (item.parentId === group.nodeId && item.type === 'condition' && item.data.length)
                        //});
                        const operator = value[g - 1];

                        if (operator && operator.parentId === group.nodeId && operator.type === 'operator') {
                            group.structure.push(operator.data.toString());
                        }

                        group.structure.push(item.data);
                    }
                    //else if (item.type === 'operator') {
                    //    operators.push(item);
                    //}
                }
            }

            //conditions = value.filter(item => {
            //    return (item.parentId === group.nodeId && item.type === 'condition' && item.data.length);
            //}),
            //operators = value.filter(item => {
            //    return (item.parentId === group.nodeId && item.type === 'condition' && item.data.length);
            //});

            //for (let i = 0; i < conditions.length; i++) {
            //   i === 0 ? group.structure.unshift(conditions[i].data) : group.structure.push(conditions[i].data);
            //}
        }

        groupsWithItems = groupsWithItems.filter(item => {
            return (item.structure.length > 0);
        });

        groupsWithItems.sort(function (a, b) {
            return (b.nodeId.split('.').length - a.nodeId.split('.').length);
        });

        for (let i = 0; i < groupsWithItems.length; i++) {
            const currentElement = groupsWithItems[i],
                group = groupsWithItems.filter(item => {
                    return (item.nodeId === currentElement.parentId)
                })[0];

            if (group && group.structure) {
                group.structure.push(currentElement.structure);
                continue;
            }

            if (currentElement.nodeId === '0') {
                structure = structure.concat(currentElement.structure);
                continue;
            }

            //Push the group operator
            if (currentElement.data) {
                if (i > 0) {
                    structure.push(currentElement.data);
                }

                //Concat the group structure
                structure.push(currentElement.structure);
            }
        }

        //if (groupsWithItems.length > 0) {
        //    that.value = that._valueFlat.length > 1 ? groupsWithItems[groupsWithItems.length - 1].structure : groupsWithItems;
        //}
        //else {
        //const data = that._getItemById('0').data;

        //that.value = data ? [data] : [];
        //}

        that.value = structure;
        that._validateValue();
        that._validValue = that._getValidValue();

        if (!preventEventFiring) {
            const oldValueAsString = JSON.stringify(that._validValue);

            if (that._oldValueAsString !== oldValueAsString) {
                that._oldValueAsString = oldValueAsString;
                that.$.fireEvent('change', { value: JSON.parse(oldValueAsString) });
            }
        }
    }

    /**
    * Return item's data by given id
    * @param {String} id - item's id (or parent id - demending on the second parameter)
    * @param {Boolean} isParent (optional)  - of the items is searched by parentId
    */
    _getItemById(id, isParent) {
        const that = this,
            matches = that._valueFlat.filter(item => {
                if (isParent) {
                    return item.parentId === id;
                }
                return item.nodeId === id;
            }),
            editedItem = matches.length > 0 ? matches[0] : null;

        return editedItem;
    }

    /**
    * Closes an editor and sets the new value in the value's cotainer
    * @param {Boolean} preventEventFiring (optional).
    */
    _closeEditor(preventEventFiring) {
        const that = this;
        let storedValue;

        if (!that._editedItem || !that._editorIsOpen) {
            return;
        }

        const editedItem = that._editedItem,
            //editedRow = editedItem.htmlNode,
            //nodeId = editedItem.nodeId,
            editedHTMLField = that._editor.closest('.filter-builder-item'),
            editedHTMLvalueContainer = editedHTMLField.querySelector('.jqx-value-container'),
            condition = editedHTMLField.parentElement,
            valueContainer = condition.children[2];

        if (that._editor === that.$.dateTimePickerEditor) {
            storedValue = that._editor.value;

            if (storedValue) {
                storedValue = storedValue.toDate();
            }
        }
        else if (that._editor === that.$.checkBoxEditor) {
            storedValue = that._editor.checked;
        }
        else if (that._editor === that.$.customEditor) {
            if (that._editor) {
                const customNumericTextBoxes = Array.from(that._editor.getElementsByTagName('jqx-numeric-text-box'));

                customNumericTextBoxes.forEach(customNumericTextBox => customNumericTextBox._inputBlurHandler());
            }

            storedValue = that._selectedCustomCondition.handleValue(that._editor);
        }
        else if (that._editor === that.$.numericTextBoxEditor) {
            that._editor._inputBlurHandler();
            storedValue = that._editor.value;
        }
        else if (editedHTMLField.classList.contains('jqx-filter-value')) {
            const selectedField = that._getFieldByFieldName(that._editedItem.data[0]);

            if (selectedField.dataType === 'array') {
                storedValue = that._editor.value.split(',');
            }
            else if (selectedField.dataType === 'object') {
                storedValue = JSON.parse(that._editor.value);
            }
            else {
                storedValue = that._editor.value;
            }
        }
        else {
            storedValue = that._editor.value;
        }

        //editedHTMLvalueComponent = editedRow.querySelector('.jqx-filter-value'),

        //that._updateValueInFlatArray(nodeId, storedValue, 'value', (valueDataType || 'string'));
        //Converted the new value to the appropriate type


        //Update the condition object with the new value
        if (editedHTMLField.classList.contains('jqx-filter-field-name')) {
            if (storedValue.trim() === '') {
                that._hideEditor(editedHTMLField, editedItem.data[0] === undefined);
                return;
            }

            if (condition.hasAttribute('limit-selection')) {
                // "placeholder" condition
                condition.removeAttribute('limit-selection');
                condition.parentElement.nextElementSibling.removeAttribute('limit-selection');
            }

            const existingField = that._fields.find(item => item.label === storedValue),
                oldFieldValue = editedItem.data[0];

            if (existingField) {
                editedItem.data[0] = existingField.value;
            }
            else if (that.fieldsMode === 'dynamic') {
                const dynamicFieldInfo = that._getDynamicFieldInfo(storedValue);

                storedValue = dynamicFieldInfo.label;
                editedItem.data[0] = dynamicFieldInfo.dataField;
            }
            else {
                editedHTMLvalueContainer.innerHTML = that._fields.find(item => item.value === oldFieldValue).label;
                that._hideEditor(editedHTMLField);
                return;
            }

            editedHTMLvalueContainer.innerHTML = storedValue;
            that._handleFieldChange([oldFieldValue, editedItem.data[0]], [valueContainer, editedItem, condition]);
        }
        else if (editedHTMLField.classList.contains('jqx-filter-operation')) {
            that._handleOperationChange([editedItem, storedValue, that._editor.$.input.dataValue], [editedHTMLvalueContainer, valueContainer]);
        }
        else {
            editedItem.data[2] = storedValue;
            editedHTMLvalueContainer.innerHTML = that._formatValueStringRepresentation(storedValue, that._editedItem.data[0], that._editedItem.data[1]);
        }

        that._generateValue(preventEventFiring);
        that._hideEditor(editedHTMLField);
    }

    /**
     * Gets the info of a dynamic field.
     */
    _getDynamicFieldInfo(value) {
        const that = this,
            dynamicFieldInfo = { label: value, dataField: value, dataType: 'string' };

        if (that.getDynamicField) {
            const customInfo = that.getDynamicField(value);

            if (customInfo.label) {
                dynamicFieldInfo.label = customInfo.label;
            }

            if (customInfo.dataField) {
                dynamicFieldInfo.dataField = customInfo.dataField;
            }

            if (customInfo.dataType) {
                dynamicFieldInfo.dataType = customInfo.dataType;
            }

            if (customInfo.filterOperations &&
                Array.isArray(customInfo.filterOperations) && customInfo.filterOperations.length > 0) {
                dynamicFieldInfo.filterOperations = customInfo.filterOperations;
            }

            if (customInfo.lookup) {
                dynamicFieldInfo.lookup = customInfo.lookup;
            }
        }

        that._manuallyAddedFields.push(dynamicFieldInfo);
        that._mapFieldsToMenu();
        return dynamicFieldInfo;
    }

    /**
     * Handles field change.
     */
    _handleFieldChange(fields, elements) {
        const that = this,
            oldFieldValue = fields[0],
            editedItem = elements[1],
            condition = elements[2],
            valueContainer = elements[0],
            newField = that._fields.find(field => field.value === fields[1]),
            newOperations = that._getFilterOperations(newField);

        if (!oldFieldValue || editedItem.data[1] === undefined) {
            that._handleOnlyOperation(newOperations, editedItem.data, condition);
            return;
        }

        const oldField = that._fields.find(field => field.value === oldFieldValue),
            oldFieldType = oldField.dataType,
            newFieldType = newField.dataType;

        if (newField === oldField ||
            newFieldType === oldFieldType && !newField.filterOperations && !oldField.filterOperations) {
            return;
        }

        const validInNewOperations = !!newOperations.find(operation => operation.value === editedItem.data[1]);

        if (validInNewOperations) {
            if (newFieldType === oldFieldType) {
                return;
            }

            if (newFieldType === 'date' && oldFieldType === 'datetime' ||
                newFieldType === 'datetime' && oldFieldType === 'date') {
                // reformat previous value
                valueContainer.firstElementChild.innerHTML = that._formatValueStringRepresentation(editedItem.data[2], editedItem.data[0], editedItem.data[1]);
                return;
            }

            // remove previous value
            editedItem.data.splice(2, 1);
            valueContainer.setAttribute('placeholder', '');
            valueContainer.firstElementChild.innerHTML = that.valuePlaceholder;
            return;
        }

        // remove previous operator and value
        editedItem.data.splice(1, 2);
        condition.children[1].setAttribute('placeholder', '');
        condition.children[1].firstElementChild.innerHTML = that.operatorPlaceholder;
        valueContainer.setAttribute('placeholder', '');
        valueContainer.firstElementChild.innerHTML = that.valuePlaceholder;
        valueContainer.classList.remove('jqx-visibility-hidden');

        that._handleOnlyOperation(newOperations, editedItem.data, condition);
    }

    /**
     * Handles change to a field with only one operation.
     */
    _handleOnlyOperation(newOperations, data, condition) {
        if (newOperations.length === 1) {
            const onlyOperation = newOperations[0];

            data[1] = onlyOperation.value;
            condition.children[1].removeAttribute('placeholder', '');
            condition.children[1].firstElementChild.innerHTML = newOperations[0].label;

            if (onlyOperation.value === 'isblank' || onlyOperation.value === 'isnotblank' || onlyOperation.custom && onlyOperation.hideValue) {
                data.splice(2, 1);
                condition.children[2].classList.add('jqx-visibility-hidden');
            }
        }
    }

    /**
     * Handles operation change.
     */
    _handleOperationChange(data, elements) {
        const that = this,
            editedItem = data[0],
            storedLabel = data[1],
            storedValue = data[2],
            editedHTMLvalueContainer = elements[0],
            valueContainer = elements[1],
            oldOperation = editedItem.data[1] !== undefined ? that._filterOperationDescriptions.find(item => item.value === editedItem.data[1]) : undefined,
            newOperation = that._filterOperationDescriptions.find(item => item.value === storedValue),
            newOperationValue = newOperation.value;

        if (newOperation === oldOperation) {
            return;
        }

        editedItem.data[1] = newOperationValue;
        editedHTMLvalueContainer.innerHTML = storedLabel;

        if (newOperationValue === 'isblank' || newOperationValue === 'isnotblank' || newOperation.custom && newOperation.hideValue) {
            editedItem.data.splice(2, 1);
            valueContainer.classList.add('jqx-visibility-hidden');
        }
        else if (valueContainer.classList.contains('jqx-visibility-hidden')) {
            valueContainer.setAttribute('placeholder', '');
            valueContainer.classList.remove('jqx-visibility-hidden');
            valueContainer.firstElementChild.innerHTML = that.valuePlaceholder;
        }
        else if (newOperation.custom || oldOperation && oldOperation.custom) {
            editedItem.data.splice(2, 1);
            valueContainer.setAttribute('placeholder', '');
            valueContainer.firstElementChild.innerHTML = that.valuePlaceholder;
        }
    }

    /**
     * Hides editor.
     */
    _hideEditor(editedHTMLField, placeholder) {
        const that = this;

        if (placeholder) {
            editedHTMLField.setAttribute('placeholder', '');
        }

        editedHTMLField.removeAttribute('edited');
        that.$.editorsContainer.removeAttribute('open');

        if (that._editor.close) {
            that._editor.close();
        }

        that._editor.classList.add('jqx-hidden');
        that._editorIsOpen = that._enterIsPressedInEditor = false;
        that.$.scrollableContainer.refresh();
    }

    /**
    * Handling click on delete buton
    */
    _clickHandlerFilterButton(elementClassList, itemId, target) {
        const that = this;

        function prepareContextMenu(target, dataSource, selectedItem) {
            that._contextMenuOptions = dataSource.length === 0 ? that._defaultFilterOperationDescriptions : dataSource;
            that._handleContextMenu(target);

            if (that.$.conditionsMenu.opened) {
                that.$.conditionsMenu._discardKeyboardHover();
                that.$.conditionsMenu._hoverViaKeyboard(that.$.conditionsMenu.querySelector('jqx-menu-item[value="' + selectedItem + '"]'));
            }
        }

        if (target.closest('.jqx-editors-container')) {
            return;
        }

        that._closeEditor();
        that._editedItem = that._getItemById(itemId);

        if (elementClassList.contains('jqx-filter-add-btn')) {
            prepareContextMenu(target, that._groupOperationDescriptions);
            return;
        }

        if (!elementClassList.contains('jqx-filter-field-name') && (!that._editedItem.data || !that._editedItem.data.length)) {
            return;
        }

        if (elementClassList.contains('jqx-filter-group-operator') || elementClassList.contains('jqx-filter-nested-operator')) {
            prepareContextMenu(target, that._groupOperationDescriptions, that._editedItem.data);
        }
        else {
            const filterBuilderItem = target.closest('.filter-builder-item');

            filterBuilderItem.removeAttribute('placeholder');

            that._openEditor(target);
        }
    }

    /**
    * Handles context menu position
    * @param {HTML element} target (optional) - the component that is clicked
    */
    _handleContextMenu(target) {
        const that = this;

        if (that._selectedElement === target && that.$.conditionsMenu.opened) {
            that.$.conditionsMenu.close();
            return;
        }

        that._closeEditor();

        if (that.disableContextMenu) {
            that._selectedElement = target;
            return;
        }

        const targetCoordinates = target.getBoundingClientRect(),
            elementCoordinates = that.getBoundingClientRect(),
            x = targetCoordinates.left + that.$.contentContainer.scrollLeft - elementCoordinates.left,
            y = targetCoordinates.top + that.$.contentContainer.scrollTop - elementCoordinates.top + targetCoordinates.height;

        that.$.conditionsMenu.dataSource = that._contextMenuOptions;
        that.$.conditionsMenu.open(x, y + 3);
        that._selectedElement = target;
        that.$.scrollableContainer.refresh();
    }

    /**
    * Open an editor at the position of the current editted condition value container
    * @param {Html element} target - the clicked HTML element. Used to be localized element's data and set into editor
    */
    _openEditor(target) {
        const that = this,
            id = target && target.closest('.jqx-filter-group-condition') ? target.closest('.jqx-filter-group-condition').getAttribute('node-id') : null,
            valueContainer = target.closest('.filter-builder-item'),
            editedItem = that._getItemById(id);
        let field = '';

        if (editedItem.data[0] !== undefined) {
            field = editedItem.data[0];
        }
        else if (that._fields.length) {
            field = that._fields[0].value;
        }

        let fieldData = that._getFieldByFieldName(field),
            value = '', dataValue;
        //filterItemIndex = target.contains('jqx-filter-field-name') ? 0 : (target.contains('jqx-filter-operation') ? 1 : 2);
        //value = editedItem ? editedItem.data[filterItemIndex] : '' || '';

        let filterItemIndex;

        if (valueContainer.classList.contains('jqx-filter-field-name')) {
            filterItemIndex = 0;

            if (!that._fields) {
                that._mapFieldsToMenu();
            }

            fieldData.lookup = { dataSource: that._fields.slice(), readonly: false };
            value = fieldData.label || '';
            dataValue = fieldData.value;
        }
        else if (valueContainer.classList.contains('jqx-filter-operation')) {
            filterItemIndex = 1;

            let filteredOptions = that._getFilterOperations(fieldData);

            fieldData.lookup = { dataSource: filteredOptions, readonly: true };

            let correspondingOption = filteredOptions.find(option => option.value === editedItem.data[filterItemIndex]) ||
                filteredOptions[0];

            value = correspondingOption.label;
            dataValue = correspondingOption.value;
        }
        else {
            filterItemIndex = 2;
            value = editedItem.data[filterItemIndex];

            if (value === undefined) {
                value = '';
            }
        }

        if (that._editorIsOpen) {
            that._closeEditor();
        }

        valueContainer.setAttribute('edited', '');
        that._editedItem = editedItem;

        const fields = that._fields,
            fieldItemsMatch = fields.filter(item => {
                return item.value === field;
            }),
            foundCustomConditions = that._filterOperationDescriptions.filter(item => {
                return ((item.value === editedItem.data[1]) && item.custom);
            }),
            fieldItem = fieldItemsMatch.length > 0 ? fieldItemsMatch[0] : null,
            fieldType = (fieldData.lookup && fieldData.lookup.dataSource) ? 'lookup' : fieldItem.dataType;

        if (filterItemIndex !== 2 || foundCustomConditions.length === 0 || !foundCustomConditions[0].editorTemplate) {
            that._openEditorByFieldType(fieldType, value, fieldData, dataValue);
        }
        else {
            that._selectedCustomCondition = foundCustomConditions[0];
            that._openCustomEditor(fieldType, value, fieldData);
        }

        setTimeout(function () {
            that._editor.focus();

            if (that._editor === that.$.numericTextBoxEditor || that._editor === that.$.textBoxEditor) {
                that.$.scrollableContainer.scrollLeft = that.$.scrollableContainer.$.scrollViewerContainer.scrollLeft;
                that.$.scrollableContainer.scrollTop = that.$.scrollableContainer.$.scrollViewerContainer.oldTop;
                that.$.scrollableContainer.$.scrollViewerContainer.scrollLeft = 0;
                that.$.scrollableContainer.$.scrollViewerContainer.scrollTop = 0;
                that._editor.$.input.selectionStart = that._editor.$.input.selectionEnd = that._editor.$.input.value.length;
            }

            that.$.scrollableContainer.refresh();
        }, 0);

        that._editor.classList.remove('jqx-hidden');
        that._editorIsOpen = true;
        that.$.editorsContainer.setAttribute('open', '');
        valueContainer.appendChild(that.$.editorsContainer);
        that.$.scrollableContainer.refresh();

        if (fieldData.lookup && fieldData.lookup.readonly) {
            that._editor.open();
        }
    }

    /**
     * Returns filter operations by field.
     */
    _getFilterOperations(fieldData) {
        const that = this;
        let filteredOptions = that._filterOperationDescriptions.slice();

        if (fieldData.filterOperations) {
            filteredOptions = that._filterOperationDescriptions.filter(item => fieldData.filterOperations.indexOf(item.value) > -1);
        }
        else {
            let filterOperationsByType;

            switch (fieldData.dataType) {
                case 'date':
                case 'datetime':
                case 'number':
                    filterOperationsByType = ['=', '<>', '<', '>', '<=', '>=', 'isblank', 'isnotblank'];
                    break;
                case 'boolean':
                    filterOperationsByType = ['=', '<>', 'isblank', 'isnotblank'];
                    break;
                case 'object':
                    filterOperationsByType = ['isblank', 'isnotblank'];
                    break;
                case 'string':
                    filterOperationsByType = ['contains', 'notcontains', 'startswith', 'endswith', '=', '<>', 'isblank', 'isnotblank'];
                    break;
                default:
                    filterOperationsByType = ['contains', 'notcontains', 'startswith', 'endswith', '=', '<>', '<', '>', '<=', '>=', 'isblank', 'isnotblank'];
                    break;
            }

            filteredOptions = that._filterOperationDescriptions.filter(item => filterOperationsByType.indexOf(item.value) > -1);
        }

        if (that.showIcons) {
            filteredOptions.map(item => item.icon = that.icons[item.value]);
        }

        return filteredOptions;
    }

    /**
     * Open custom editor
     */
    _openCustomEditor(fieldType, value, fieldData) {
        const that = this,
            editorStructure = that.customOperations[that._selectedCustomCondition.index].editorTemplate(fieldType, value, fieldData);

        that.$.customEditor.innerHTML = '';

        if (editorStructure) {
            that.$.customEditor.appendChild(editorStructure);
        }

        that._editor = that.$.customEditor;
    }

    /**
    * Open specific editor, regarding field type settings and set it's value
    * @param {String} fieldType - type of the edited field, each type has different handling
    * @param {Any} value - the value, that must be set to the editor
    */
    _openEditorByFieldType(fieldType, value, fieldData, dataValue) {
        const that = this;

        switch (fieldType) {
            case 'boolean':
                that._initializeEditor('checkBox');
                that._editor.checked = !!value;
                break;
            case 'date':
            case 'datetime':
                that._initializeEditor('dateTimePicker');
                that._editor.formatString = fieldType === 'date' ? that.formatStringDate : that.formatStringDateTime;
                that._editor.value = value;
                break;
            case 'number':
                that._initializeEditor('numericTextBox');
                that._editor.value = value ? value : 0;
                break;
            default:
                that._initializeEditor('input');

                that._editor.dropDownWidth = 'auto';

                if (fieldType === 'lookup') {
                    that._editor.dataSource = fieldData.lookup.dataSource;
                    that._editor.dropDownAppendTo = that.$.container;
                    that._editor.dropDownButtonPosition = 'right';
                    that._editor.readonly = !!fieldData.lookup.readonly;
                }
                else {
                    that._editor.dataSource = [];
                    that._editor.dropDownButtonPosition = 'none';
                    that._editor.readonly = false;
                }

                if (fieldType === 'object') {
                    that._editor.value = JSON.stringify(value ? value : {});
                }
                else {
                    if (value === '' && that._editor.readonly) {
                        value = fieldData.lookup.dataSource[0].label || '';
                    }

                    that._editor.value = value + '';

                    if (dataValue) {
                        that._editor.$.input.dataValue = dataValue;
                    }
                }

                break;
        }
    }

    /**
    * Initializes Editors instance if it's not initialized.
    */
    _initializeEditor(editor) {
        const that = this;

        if (that.$[editor + 'Editor']) {
            that._editor = that.$[editor + 'Editor'];
            return;
        }

        const editorElement = document.createElement('jqx-' + JQX.Utilities.Core.toDash(editor));

        if (editor === 'numericTextBox') {
            editorElement.spinButtons = true;
            editorElement.inputFormat = 'floatingPoint';
        }
        else if (editor === 'dateTimePicker') {
            editorElement.dropDownAppendTo = that.$.container;
            editorElement.calendarButton = true;
            editorElement.dropDownDisplayMode = 'auto';
            editorElement.enableMouseWheelAction = true;
            editorElement.locale = that.locale;

            if (!editorElement.messages[that.locale]) {
                editorElement.messages[that.locale] = {};
            }

            editorElement.messages[that.locale].dateTabLabel = that.localize('dateTabLabel');
            editorElement.messages[that.locale].timeTabLabel = that.localize('timeTabLabel');
        }

        editorElement.theme = that.theme;
        editorElement.animation = that.animation;
        editorElement.$.addClass('jqx-hidden underlined');
        that.$.editorsContainer.appendChild(editorElement);
        that._editor = that.$[editor + 'Editor'] = editorElement;
    }

    /**
     * Gets the value without invalid or incomplete conditions.
     */
    _getValidValue() {
        const that = this,
            value = that.properties.value.value,
            result = [];
        let emptyGroup = false;

        value.forEach((group) => {
            if (Array.isArray(group)) {
                let groupIsValid = false,
                    emptyCondition = false;
                const groupContent = [];

                group.forEach((condition) => {
                    if (Array.isArray(condition)) {
                        const field = condition[0],
                            operation = condition[1],
                            val = condition[2];

                        if (field === undefined || operation === undefined) {
                            emptyCondition = true;
                            return;
                        }

                        if (val !== undefined || operation === 'isblank' || operation === 'isnotblank') {
                            groupIsValid = true;
                            groupContent.push(condition);
                            return;
                        }

                        const operationInfo = that._filterOperationDescriptions.find(currentOperation => currentOperation.value === operation);

                        if (operationInfo.custom && operationInfo.hideValue) {
                            groupIsValid = true;
                            groupContent.push(condition);
                        }
                        else {
                            emptyCondition = true;
                        }
                    }
                    else if (emptyCondition) {
                        emptyCondition = false;
                    }
                    else {
                        groupContent.push(condition);
                    }
                });

                if (groupIsValid) {
                    if (typeof groupContent[groupContent.length - 1] === 'string') {
                        groupContent.pop();
                    }

                    result.push(groupContent);
                }
                else {
                    emptyGroup = true;
                }
            }
            else if (emptyGroup) {
                emptyGroup = false;
            }
            else {
                result.push(group);
            }
        });

        if (typeof result[result.length - 1] === 'string') {
            result.pop();
        }

        return result;
    }
});

/**
 * Filter panel custom element.
 */

JQX('jqx-filter-panel', class FilterPanel extends JQX.BaseElement {
    /**
     * Filter panel's properties.
     */
    static get properties() {
        return {
            'buttons': {
                value: ['clear', 'filter'],
                type: 'array'
            },
            'data': {
                value: null,
                type: 'array?',
                reflectToAttribute: false
            },
            'dataField': {
                value: null,
                type: 'string?'
            },
            'dataSource': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'evaluateFilterExpression': {
                value: null,
                type: 'function?',
                reflectToAttribute: false
            },
            'filterType': {
                value: 'string',
                allowedValues: ['numeric', 'string', 'date', 'boolean'],
                type: 'string'
            },
            'formatString': {
                value: 'd',
                type: 'string'
            },
            'messages': {
                value: {
                    'en': {
                        'addCondition': 'Add Condition',
                        'addGroup': 'Add Group',
                        'and': 'and',
                        'blanks': '(Blanks)',
                        'cancel': 'Cancel',
                        'clear': 'Clear',
                        'contains': 'contains',
                        'containsCaseSensitive': 'contains (case sensitive)',
                        'dateTabLabel': 'DATE',
                        'doesNotContain': 'does not contain',
                        'doesNotContainCaseSensitive': 'does not contain (case sensitive)',
                        'empty': 'empty',
                        'endsWith': 'ends with',
                        'endsWithCaseSensitive': 'ends with (case sensitive)',
                        'equal': 'equal',
                        'equalCaseSensitive': 'equal (case sensitive)',
                        'filter': 'Filter',
                        'filterBuilderPlaceholder': '&lt;enter a value&gt;',
                        'greaterThan': 'greater than',
                        'greaterThanOrEqual': 'greater than or equal',
                        'lessThan': 'less than',
                        'lessThanOrEqual': 'less than or equal',
                        'mismatchedProperties': 'jqxFilterPanel: The "filterType" and the data type of the selected "dataField" are mismatched.',
                        'missingProperty': 'jqxFilterPanel: When mode is \'excel\', either "data" and "dataField" or "dataSource" of type Array have to be set.',
                        'notEmpty': 'not empty',
                        'notEqual': 'not equal',
                        'notNull': 'not null',
                        'null': 'null ',
                        'or': 'or',
                        'placeholderDate': 'Enter date',
                        'placeholderTime': 'Enter time',
                        'selectAll': '(Select All)',
                        'showRows': 'Show rows where:',
                        'startsWith': 'starts with',
                        'startsWithCaseSensitive': 'starts with (case sensitive)',
                        'timeTabLabel': 'TIME'
                    }
                },
                type: 'object',
                extend: true
            },
            'mode': {
                value: 'default',
                allowedValues: ['default', 'excel', 'filterBuilder'],
                type: 'string'
            }
        };
    }

    /**
     * Filter panel's event listeners.
     */
    static get listeners() {
        return {
            'cancelButton.click': 'cancel',
            'clearButton.click': 'clear',
            'filterButton.click': 'filter'
        };
    }

    /**
     * Filter panel's required files.
     */
    static get requires() {
        return {
            'JQX.Button': 'jqxbutton.js',
            'JQX.DateTimePicker': 'jqxdatetimepicker.js',
            'JQX.DropDownList': 'jqxdropdownlist.js',
            'JQX.FilterBuilder': 'jqxfilterbuilder.js',
            'JQX.NumericTextBox': 'jqxnumerictextbox.js',
            'JQX.Tree': 'jqxtree.js',
            'JQX.FilterGroup': 'jqxfilter.js'
        }
    }

    /**
     * Filter panel's HTML template.
     */
    template() {
        const template =
            `<div id="container" class="jqx-container">
                <div id="label" class="jqx-filter-panel-label"></div>
                <div id="mainContainer"></div>
                <div id="buttonContainer" class="jqx-filter-panel-button-container">
                    <jqx-button id="filterButton" class="primary" animation="[[animation]]" disabled="[[disabled]]" unfocusable="[[unfocusable]]"></jqx-button>
                    <jqx-button id="clearButton" animation="[[animation]]" disabled="[[disabled]]" unfocusable="[[unfocusable]]"></jqx-button>
                    <jqx-button id="cancelButton" animation="[[animation]]" disabled="[[disabled]]" unfocusable="[[unfocusable]]"></jqx-button>
                </div>
            </div>`;

        return template;
    }

    /**
     * Invoked when an instance of custom element is attached to the DOM for the first time.
     */
    ready() {
        super.ready();

        const that = this,
            filterType = that.filterType;

        that._localize();
        that._setButtonsVisibility();
        that._filterType = filterType + 'Filter';
        that._filterHandler = new JQX.Utilities[filterType.slice(0, 1).toUpperCase() + filterType.slice(1) + 'FilterHandler'](that);
    }

    /**
     * Discards current filtering.
     */
    cancel() {
        const that = this;

        that._filterHandler[that.mode + 'Cancel']();
        that.$.fireEvent('cancel');
    }

    /**
     * Clears current filtering.
     */
    clear() {
        const that = this;

        that._filterHandler[that.mode + 'Clear']();
        that.$.fireEvent('clear');
    }

    reset() {
        const that = this;

        that.$.clearButton.removeAttribute('hover');
        that.$.filterButton.removeAttribute('hover');
        that.$.cancelButton.removeAttribute('hover');

        that._filterHandler[that.mode + 'Clear']();
        that._filterHandler.filterObject = new JQX.Utilities.FilterGroup();
    }

    getFilter() {
        if (this._filterHandler) {
            const filter = new JQX.Utilities.FilterGroup();

            for (let filterProperty in this._filterHandler.filterObject) {
                filter[filterProperty] = this._filterHandler.filterObject[filterProperty];
            }

            return filter;
        }

        return null;
    }

    /**
     * Evaluates a filter.
     */
    evaluate(value) {
        try {
            return this._filterHandler.evaluate(value);
        }
        catch (error) {
            return false;
        }
    }

    /**
     * Applies current filtering.
     */
    filter() {
        const that = this;

        that._filterHandler[that.mode + 'Filter']();
        that.$.fireEvent('filter');
    }

    /**
     * Gets the current filter state.
     */
    getState() {
        return this._filterHandler.cachedFilter;
    }

    /**
     * Loads a previously saved filter state.
     *
     * @param {Object} state An object returned by the method getState.
     */
    loadState(state) {
        try {
            const that = this;

            that._filterHandler.cachedFilter = state;
            that._filterHandler[that.mode + 'Cancel']();
        }
        catch (error) {
            //
        }
    }

    /**
     * Called when a property is changed.
     */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this,
            filterHandler = that._filterHandler;

        function clearStoredObjects() {
            const objectNames = ['cachedFilter', 'caseSensitive', 'customExcelFilterObjects', 'customItems', 'dataSource', 'defaultListSelection', 'defaultListSource', 'displayMode', 'filterBuilder', 'filterBuilderObject', 'filterBuilderOperations', 'filterObject', 'firstInput', 'firstList', 'operationsMapping', 'operatorList', 'secondInput', 'secondList', 'timeOnly', 'tree'];

            objectNames.forEach(function (index) {
                delete filterHandler[objectNames[index]];
            });

            delete that._filterHandler;
        }

        function reRender() {
            that.$.mainContainer.innerHTML = '';
            clearStoredObjects();
            that._filterHandler = new JQX.Utilities[that.filterType.slice(0, 1).toUpperCase() + that.filterType.slice(1) + 'FilterHandler'](that);
        }

        switch (propertyName) {
            case 'animation':
            case 'disabled':
            case 'unfocusable':
                switch (that.mode) {
                    case 'default':
                        [filterHandler.firstList, filterHandler.firstInput, filterHandler.logicalOperatorList, filterHandler.secondList, filterHandler.secondInput].forEach(function (element) {
                            element[propertyName] = newValue;
                        });
                        break;
                    case 'excel':
                        filterHandler.tree[propertyName] = newValue;
                        break;
                    case 'filterBuilder':
                        filterHandler.filterBuilder[propertyName] = newValue;

                        if (filterHandler.caseSensitive) {
                            filterHandler.caseSensitive[propertyName] = newValue;
                        }

                        break;
                }

                break;
            case 'buttons':
                that._setButtonsVisibility();
                break;
            case 'data':
            case 'dataField':
                if (that.mode === 'excel' && !Array.isArray(that.dataSource)) {
                    reRender();
                }

                break;
            case 'dataSource':
                if (that.mode === 'excel') {
                    reRender();
                }

                break;
            case 'filterType':
                that._filterType = newValue + 'Filter';
                reRender();
                break;
            case 'mode':
                reRender();
                break;
            case 'formatString':
                if (that.filterType !== 'date') {
                    return;
                }

                switch (that.mode) {
                    case 'default':
                        filterHandler.firstInput.formatString = newValue;
                        filterHandler.secondInput.formatString = newValue;
                        break;
                    case 'excel':
                        reRender();
                        break;
                    case 'filterBuilder':
                        filterHandler.filterBuilder.formatStringDate = newValue;
                        filterHandler.filterBuilder.formatStringDateTime = newValue;
                        break;
                }

                break;
            case 'locale':
            case 'messages': {
                that._localize();

                switch (that.mode) {
                    case 'default': {
                        const firstListSelection = filterHandler.firstList.selectedIndexes,
                            operatorListSelection = filterHandler.logicalOperatorList.selectedIndexes,
                            secondListSelection = filterHandler.secondList.selectedIndexes;

                        filterHandler.setDefaults();
                        filterHandler.firstList.dataSource = filterHandler.defaultListSource;
                        filterHandler.logicalOperatorList.dataSource = [{ value: 0, label: that.localize('and') }, { value: 1, label: that.localize('or') }];
                        filterHandler.secondList.dataSource = filterHandler.defaultListSource;

                        if (that.filterType === 'date') {
                            const inputs = [filterHandler.firstInput, filterHandler.secondInput];

                            inputs.forEach(function (input) {

                                if (!input.messages[that.locale]) {
                                    input.messages[that.locale] = {};
                                }

                                input.messages[that.locale].dateTabLabel = that.localize('dateTabLabel');
                                input.messages[that.locale].timeTabLabel = that.localize('timeTabLabel');

                                if (propertyName === 'locale') {
                                    input.locale = that.locale;
                                }
                                else {
                                    input.$.selectDate.innerHTML = input.messages[that.locale].dateTabLabel;
                                    input.$.selectTime.innerHTML = input.messages[that.locale].timeTabLabel;
                                }

                                if (input._dropDownDisplayMode === 'timePicker') {
                                    input.placeholder = that.localize('placeholderTime');
                                    input.placeholder = that.localize('placeholderTime');
                                }
                                else {
                                    input.placeholder = that.localize('placeholderDate');
                                    input.placeholder = that.localize('placeholderDate');
                                }
                            });
                        }

                        filterHandler.firstList.selectedIndexes = firstListSelection;
                        filterHandler.logicalOperatorList.selectedIndexes = operatorListSelection;
                        filterHandler.secondList.selectedIndexes = secondListSelection;
                        break;
                    }
                    case 'excel':
                        filterHandler.tree.selectAll.label = that.localize('selectAll');

                        if (filterHandler.tree.blanks) {
                            filterHandler.tree.blanks.label = that.localize('blanks');
                        }
                        break;
                    case 'filterBuilder':
                        filterHandler.localizeFilterBuilder();

                        if (propertyName === 'messages') {
                            filterHandler.filterBuilder._localizeInitialValues();
                            filterHandler.filterBuilder._refresh();
                        }

                        filterHandler.filterBuilder.$.scrollableContainer.refresh();
                        break;
                }

                break;
            }
        }
    }

    /**
     * Localizes element.
     */
    _localize() {
        const that = this;

        that.$.label.innerHTML = that.localize('showRows');
        that.$.filterButton.innerHTML = that.localize('filter');
        that.$.clearButton.innerHTML = that.localize('clear');
        that.$.cancelButton.innerHTML = that.localize('cancel');
    }

    /**
     * Sets buttons visibility.
     */
    _setButtonsVisibility() {
        const that = this,
            buttonsVisibility = that.buttons;

        ['cancel', 'clear', 'filter'].forEach(function (button) {
            if (buttonsVisibility.indexOf(button) !== -1) {
                that['$' + button + 'Button'].removeClass('jqx-hidden');
            }
            else {
                that['$' + button + 'Button'].addClass('jqx-hidden');
            }
        });
    }
});
JQX.Utilities.Assign('BaseFilterHandler', class BaseFilterHandler {
    constructor(context) {
        const that = this;

        that.context = context;
        that.filterObject = new JQX.Utilities.FilterGroup();
        that.setDefaults();

        if (context.filterType === 'date') {
            const sampleDateTime = new JQX.Utilities.DateTime(),
                formatString = context.formatString,
                formatStringRegExp = sampleDateTime.getParseRegExp(sampleDateTime.calendar, formatString.replace(/y+/g, 'yyyyy'));

            that.displayMode = JQX.Utilities.DateTime.detectDisplayMode(sampleDateTime, formatString, formatStringRegExp);
            that.timeOnly = that.displayMode === 'timePicker';
        }

        if (context.mode === 'default') {
            that.createDefaultHTMLStructure();
            return;
        }

        that.operationsMapping = {
            '=': 'EQUAL',
            '<>': 'NOT_EQUAL',
            '<': 'LESS_THAN',
            '>': 'GREATER_THAN',
            '<=': 'LESS_THAN_OR_EQUAL',
            '>=': 'GREATER_THAN_OR_EQUAL',
            'isblank': 'EMPTY',
            'isnotblank': 'NOT_EMPTY',
            'contains': 'CONTAINS',
            'notcontains': 'DOES_NOT_CONTAIN',
            'startswith': 'STARTS_WITH',
            'endswith': 'ENDS_WITH',
            'NULL': 'NULL',
            'NOT_NULL': 'NOT_NULL'
        };

        if (context.mode === 'excel') {
            that.createExcelHTMLStructure();
        }
        else if (context.mode === 'filterBuilder') {
            that.createBuilderHTMLStructure();
        }
    }

    /**
     * Sets default source and selection.
     */
    setDefaults() {
        const that = this,
            context = that.context;

        that.defaultListSource = [
            { value: 'EQUAL', label: context.localize('equal') },
            { value: 'NOT_EQUAL', label: context.localize('notEqual') },
            { value: 'LESS_THAN', label: context.localize('lessThan') },
            { value: 'LESS_THAN_OR_EQUAL', label: context.localize('lessThanOrEqual') },
            { value: 'GREATER_THAN', label: context.localize('greaterThan') },
            { value: 'GREATER_THAN_OR_EQUAL', label: context.localize('greaterThanOrEqual') },
            { value: 'NULL', label: context.localize('null') },
            { value: 'NOT_NULL', label: context.localize('notNull') }
        ];
        that.filterBuilderOperations = ['<', '=', '<>', '<=', '>', '>=', 'NULL', 'NOT_NULL'];
        that.defaultListSelection = 2;
    }

    /**
     * Creates the filter panel's HTML structure in default mode.
     */
    createDefaultHTMLStructure() {
        const that = this,
            context = that.context,
            firstList = document.createElement('jqx-drop-down-list'),
            operatorList = document.createElement('jqx-drop-down-list'),
            secondList = document.createElement('jqx-drop-down-list'),
            fragment = document.createDocumentFragment();

        firstList.classList.add('jqx-filter-panel-list');
        firstList.dataSource = that.defaultListSource;
        firstList.selectedIndexes = [that.defaultListSelection];

        operatorList.classList.add('jqx-filter-panel-operator-list');
        operatorList.dataSource = [{ value: 0, label: context.localize('and') }, { value: 1, label: context.localize('or') }];

        secondList.classList.add('jqx-filter-panel-list');
        secondList.dataSource = that.defaultListSource;
        secondList.selectedIndexes = [that.defaultListSelection];

        that.firstList = firstList;
        that.logicalOperatorList = operatorList;
        that.secondList = secondList;

        that.appendInputs();
        that.firstInput.classList.add('jqx-filter-panel-input');
        that.secondInput.classList.add('jqx-filter-panel-input');

        operatorList.dropDownHeight = 'auto';
        operatorList.selectedIndexes = [0];

        [firstList, that.firstInput, operatorList, secondList, that.secondInput].forEach(function (element) {
            element.animation = context.animation;
            element.disabled = context.disabled;
            element.unfocusable = context.unfocusable;
            element.dropDownPosition = 'bottom';
            element.dropDownAppendTo = 'body';
            element.dropDownMaxHeight = 200;
            element.dropDownWidth = 'auto';
            fragment.appendChild(element);
        });

        that.context.$.mainContainer.appendChild(fragment);
        that.cacheFilter(that.defaultListSelection, 0, that.defaultListSelection);
    }

    /**
     * Caches filter.
     */
    cacheFilter(firstFilterComparison, operator, secondFilterComparison) {
        const that = this;

        that.cachedFilter = {
            firstFilterComparison: firstFilterComparison,
            firstFilterValue: that.firstInput.value,
            logicalOperator: operator,
            secondFilterComparison: secondFilterComparison,
            secondFilterValue: that.secondInput.value
        };
    }

    /**
     * Applies filter.
     */
    defaultFilter() {
        const that = this,
            context = that.context,
            firstFilterComparison = that.firstList.selectedValues[0],
            firstFilterValue = that.getFilterInputValue(that.firstInput),
            operator = parseFloat(that.logicalOperatorList.selectedValues[0]),
            secondFilterComparison = that.secondList.selectedValues[0],
            secondFilterValue = that.getFilterInputValue(that.secondInput),
            filterObject = that.filterObject;

        filterObject.clear();

        if (firstFilterValue !== '' || ['NULL', 'NOT_NULL', 'EMPTY', 'NOT_EMPTY'].indexOf(firstFilterComparison) !== -1) {
            const firstFilter = filterObject.createFilter(context._filterType, firstFilterValue, firstFilterComparison, undefined, context.formatString, context.locale, that.firstInput._dropDownDisplayMode === 'timePicker');

            filterObject.addFilter(operator, firstFilter);
        }

        if (secondFilterValue !== '' || ['NULL', 'NOT_NULL', 'EMPTY', 'NOT_EMPTY'].indexOf(secondFilterComparison) !== -1) {
            const secondFilter = filterObject.createFilter(context._filterType, secondFilterValue, secondFilterComparison, undefined, context.formatString, context.locale, that.secondInput._dropDownDisplayMode === 'timePicker');

            filterObject.addFilter(operator, secondFilter);
        }

        that.cacheFilter(that.firstList.selectedIndexes[0], that.logicalOperatorList.selectedIndexes[0], that.secondList.selectedIndexes[0]);
    }

    /**
     * Parses filter input value.
     */
    getFilterInputValue(input) {
        return input.value;
    }

    /**
     * Applies filter ('excel' mode).
     */
    excelFilter() {
        const that = this,
            context = that.context;

        if (Array.isArray(context.dataSource)) {
            that.customExcelFilter();
            return;
        }

        const tree = that.tree,
            filterObject = that.filterObject;

        filterObject.clear();
        that.customItems = [];

        if (tree._menuItems['0'].selected) {
            return;
        }

        const selectedIndexes = tree.selectedIndexes;

        selectedIndexes.forEach(function (index) {
            const item = tree._menuItems[index];

            if (item instanceof JQX.TreeItem) {
                const value = item.value;

                if (item.hasAttribute('default-item')) {
                    const filterComparison = that.getExcelComparison(value),
                        filter = filterObject.createFilter(context._filterType, value, filterComparison, undefined, context.formatString, context.locale, that.timeOnly);

                    filterObject.addFilter('or', filter);
                }
                else {
                    that.customItems.push(item);
                }
            }
        });
        that.cachedFilter = selectedIndexes.slice(0);
    }

    /**
     * Applies filter ('excel' mode with custom data source).
     */
    customExcelFilter() {
        const that = this,
            tree = that.tree;

        delete that.customExcelFilterObjects;

        if (tree._menuItems['0'].selected) {
            return;
        }

        const context = that.context,
            filterObjects = [],
            selectedIndexes = tree.selectedIndexes;

        selectedIndexes.forEach(function (index) {
            const item = tree._menuItems[index];

            if (item instanceof JQX.TreeItem) {
                let value = item.value;


                if (!Array.isArray(value)) {
                    return;
                }

                if (!Array.isArray(value[0])) {
                    value = [value];
                }

                const filterObject = new JQX.Utilities.FilterGroup();

                for (let i = 0; i < value.length; i++) {
                    const condition = value[i],
                        operation = that.operationsMapping[condition[1]],
                        filter = filterObject.createFilter(context._filterType, condition[2], operation, undefined, context.formatString, context.locale, that.timeOnly);

                    filterObject.addFilter('and', filter);
                }

                filterObjects.push(filterObject);
            }
        });

        that.customExcelFilterObjects = filterObjects;
        that.cachedFilter = selectedIndexes.slice(0);
    }

    /**
     * Gets filter comparison ('excel' mode).
     */
    getExcelComparison(value) {
        return value === '' ? 'NULL' : 'EQUAL';
    }

    /**
     * Applies filter ('filterBuilder' mode).
     */
    filterBuilderFilter() {
        const that = this,
            filterSettings = that.filterBuilder.value,
            caseSensitive = that.context.filterType === 'string' ? that.caseSensitive.checked : false,
            filterResult = { filters: [] };

        function recursion(currentContext, collection) {
            const filterObject = new JQX.Utilities.FilterGroup(),
                operator = currentContext[1];

            collection.logicalOperator = operator;

            for (let i = 0; i < currentContext.length; i++) {
                if (i === 1) {
                    continue;
                }

                const node = currentContext[i];

                if (Array.isArray(node)) {
                    if (Array.isArray(node[0])) {
                        const subCollection = { filters: [] };

                        collection.filters.push(subCollection);
                        recursion(node, subCollection);
                    }
                    else {
                        filterObject.addFilter(operator, that.createFilterBuilderFilter(filterObject, node, caseSensitive));
                    }
                }
            }

            if (filterObject.filters.length > 0) {
                collection.filters.push(filterObject);
            }
        }

        recursion(filterSettings, filterResult);
        that.filterBuilderObject = filterResult;
        that.cachedFilter = {
            filterBuilder: JSON.parse(JSON.stringify(that.filterBuilder.value), function (key, value) {
                return /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}).(\d{3})Z$/.test(value) ? new Date(value) : value;
            }),
            caseSensitive: caseSensitive
        };
    }

    /**
     * Calls the "createFilter" method with the correct arguments.
     */
    createFilterBuilderFilter(filterObject, node, caseSensitive) {
        const that = this,
            context = that.context;
        let operation = that.operationsMapping[node[1]]

        if (caseSensitive && ['CONTAINS', 'DOES_NOT_CONTAIN', 'STARTS_WITH', 'ENDS_WITH', 'EQUAL'].indexOf(operation) !== -1) {
            operation += '_CASE_SENSITIVE';
        }

        return filterObject.createFilter(
            context._filterType,
            node[2],
            operation,
            undefined,
            context.formatString,
            context.locale,
            false
        );
    }

    /**
     * Clears filter.
     */
    defaultClear() {
        const that = this;

        that.firstList.selectedIndexes = [that.defaultListSelection];
        that.firstInput.value = '';
        that.logicalOperatorList.selectedIndexes = [0];
        that.secondList.selectedIndexes = [that.defaultListSelection];
        that.secondInput.value = '';

        that.filterObject.clear();
        that.cacheFilter(that.defaultListSelection, 0, that.defaultListSelection);
    }

    /**
     * Clears filter ('excel' mode).
     */
    excelClear() {
        const that = this;

        that.tree.select('0');
        that.filterObject.clear();
        that.cachedFilter = that.tree.selectedIndexes.slice(0);
    }

    /**
     * Clears filter ('filterBuilder' mode).
     */
    filterBuilderClear() {
        const that = this;

        that.filterBuilder.value = ['and'];

        if (that.context.filterType === 'string') {
            that.caseSensitive.checked = false;
        }

        that.cachedFilter = { filterBuilder: ['and'], caseSensitive: false };
    }

    /**
     * Cancels current filter application.
     */
    defaultCancel() {
        const that = this;

        that.firstList.selectedIndexes = [that.cachedFilter.firstFilterComparison];
        that.firstInput.value = that.cachedFilter.firstFilterValue;
        that.logicalOperatorList.selectedIndexes = [that.cachedFilter.logicalOperator];
        that.secondList.selectedIndexes = [that.cachedFilter.secondFilterComparison];
        that.secondInput.value = that.cachedFilter.secondFilterValue;
    }

    /**
     * Cancels current filter application ('excel' mode).
     */
    excelCancel() {
        const that = this;

        that.tree.selectedIndexes = that.cachedFilter.slice(0);
    }

    /**
     * Cancels current filter application ('filterBuilder' mode).
     */
    filterBuilderCancel() {
        const that = this;

        that.filterBuilder.value = that.cachedFilter.filterBuilder;

        if (that.context.filterType === 'string') {
            that.caseSensitive.checked = that.cachedFilter.caseSensitive;
        }
    }

    /**
     * Creates the filter panel's HTML structure in 'excel' mode.
     */
    createExcelHTMLStructure() {
        const that = this,
            context = that.context,
            tree = document.createElement('jqx-tree'),
            uniqueValuesDetails = { data: context.data, dataField: context.dataField, filterType: context._filterType };

        if (!context.dataSource || !Array.isArray(context.dataSource)) {
            if (!context.data || !context.dataField) {
                context.error(context.localize('missingProperty'));
            }

            if (context.filterType === 'date') {
                uniqueValuesDetails.formatString = context.formatString;
                uniqueValuesDetails.displayMode = that.displayMode;
                that.dataSource = that.filterObject.getUniqueValues(uniqueValuesDetails, context);

                try {
                    that.getHierarchicalDataSource(that.displayMode);
                }
                catch (error) {
                    context.error(context.localize('mismatchedProperties'));
                }

                if (that.timeOnly) {
                    tree.classList.add('standard-excel');
                }
                else {
                    tree.classList.add('date-excel');
                }
            }
            else {
                that.dataSource = that.filterObject.getUniqueValues(uniqueValuesDetails, context);
                tree.classList.add('standard-excel');
            }

            if (typeof context.dataSource === 'function') {
                that.dataSource = context.dataSource(that.dataSource) || that.dataSource;
            }
        }
        else {
            that.processCustomDataSource(tree);
        }

        tree.animation = context.animation;
        tree.disabled = context.disabled;
        tree.unfocusable = context.unfocusable;
        tree.dataSource = [
            {
                label: context.localize('selectAll'),
                value: '',
                items: that.dataSource,
                expanded: true,
                selected: true
            }
        ];
        tree.selectionMode = 'checkBox';
        tree.hasThreeStates = true;
        tree.toggleMode = 'arrow';
        tree.addEventListener('collapsing', function (event) {
            if (event.detail.item.level === 1) {
                event.preventDefault();
            }
        });
        tree._onCompleted = function () {
            that.cachedFilter = tree.selectedIndexes.slice(0);

            if (tree.classList.contains('date-excel')) {
                for (let path in tree._menuItems) {
                    if (path === '0') {
                        continue;
                    }

                    const item = tree._menuItems[path];

                    item.firstElementChild.style.paddingLeft = ((item.level - 1) * 20 - 10) + 'px';
                }
            }
            else {
                tree._menuItems['0'].firstElementChild.style.paddingLeft = 0;
            }

            tree.selectAll = tree._menuItems['0'];
            tree.blanks = tree.querySelector('[label="' + context.localize('blanks') + '"]');
        }
        that.tree = tree;

        context.$.mainContainer.appendChild(tree);
    }

    /**
     * Processes custom data source in 'excel' mode.
     */
    processCustomDataSource(tree) {
        const that = this,
            context = that.context,
            dataSource = context.dataSource;

        tree.classList.add('standard-excel');
        that.dataSource = dataSource;
    }

    /**
     * Creates the filter panel's HTML structure in 'filterBuilder' mode.
     */
    createBuilderHTMLStructure() {
        const that = this,
            context = that.context,
            filterBuilder = document.createElement('jqx-filter-builder'),
            dataField = context.dataField,
            dataType = context.filterType === 'numeric' ? 'number' : context.filterType;

        that.filterBuilder = filterBuilder;
        filterBuilder.animation = context.animation;
        filterBuilder.disabled = context.disabled;
        filterBuilder.unfocusable = context.unfocusable;
        filterBuilder.value = ['and'];
        filterBuilder.fields = [{ label: dataField, dataField: dataField, dataType: dataType, filterOperations: that.filterBuilderOperations }];
        that.localizeFilterBuilder();
        context.$.mainContainer.appendChild(filterBuilder);

        if (dataType === 'string') {
            const caseSensitive = document.createElement('jqx-check-box');

            caseSensitive.classList.add('case-sensitive');
            caseSensitive.innerHTML = 'Case sensitive';
            caseSensitive.animation = context.animation;
            caseSensitive.disabled = context.disabled;
            caseSensitive.unfocusable = context.unfocusable;
            caseSensitive.checked = false;
            that.caseSensitive = caseSensitive;
            context.$.mainContainer.appendChild(caseSensitive);
        }
        that.filterBuilderObject = { filters: [] };
        that.cachedFilter = { filterBuilder: ['and'], caseSensitive: false };
    }

    /**
     * Localizes filter builder.
     */
    localizeFilterBuilder() {
        const that = this,
            context = that.context,
            filterBuilder = that.filterBuilder;
        let defaultMessages = filterBuilder.messages[context.locale];

        if (!defaultMessages) {
            defaultMessages = {};
            filterBuilder.messages[context.locale] = defaultMessages;
        }

        filterBuilder.customOperations = [{
            name: 'NULL',
            label: context.localize('null'),
            hideValue: true
        },
        {
            name: 'NOT_NULL',
            label: context.localize('notNull'),
            hideValue: true
        }];
        defaultMessages['addCondition'] = context.localize('addCondition');
        defaultMessages['addGroup'] = context.localize('addGroup');
        defaultMessages['<'] = context.localize('lessThan');
        defaultMessages['<='] = context.localize('lessThanOrEqual');
        defaultMessages['<>'] = context.localize('notEqual');
        defaultMessages['='] = context.localize('equal');
        defaultMessages['>'] = context.localize('greaterThan');
        defaultMessages['>='] = context.localize('greaterThanOrEqual');
        defaultMessages['and'] = context.localize('and');
        defaultMessages['contains'] = context.localize('contains');
        defaultMessages['endswith'] = context.localize('endsWith');
        defaultMessages['isblank'] = context.localize('empty');
        defaultMessages['isnotblank'] = context.localize('notEmpty');
        defaultMessages['notcontains'] = context.localize('doesNotContain');
        defaultMessages['or'] = context.localize('or');
        defaultMessages['startswith'] = context.localize('startsWith');
        defaultMessages['dateTabLabel'] = context.localize('dateTabLabel');
        defaultMessages['timeTabLabel'] = context.localize('timeTabLabel');

        filterBuilder.formatStringDate = context.formatString;
        filterBuilder.formatStringDateTime = context.formatString;
        filterBuilder.locale = context.locale;
        filterBuilder.valuePlaceholder = context.localize('filterBuilderPlaceholder');
    }

    /**
     * Evaluates a filter.
     */
    evaluate(value) {
        const that = this,
            context = that.context;

        if (context.mode === 'default') {
            return that.filterObject.evaluate(value);
        }

        if (context.mode === 'excel') {
            let result = false;

            if (Array.isArray(context.dataSource)) {
                if (!that.customExcelFilterObjects || that.customExcelFilterObjects.length === 0) {
                    return true;
                }

                for (let i = 0; i < that.customExcelFilterObjects.length; i++) {
                    result = result || that.customExcelFilterObjects[i].evaluate(value);
                }

                return result;
            }

            if (that.customItems && that.customItems.length > 0) {
                if (that.filterObject.filters.length > 0) {
                    result = that.filterObject.evaluate(value);
                }

                if (that.customItems && context.evaluateFilterExpression) {
                    for (let i = 0; i < that.customItems.length; i++) {
                        const customCalculation = context.evaluateFilterExpression(value, that.customItems[i].value);

                        if (customCalculation !== undefined) {
                            result = result || customCalculation;
                        }
                    }
                }
            }
            else {
                result = that.filterObject.evaluate(value);
            }

            return result;
        }

        function evaluateGroup(group) {
            let result = group.logicalOperator === 'and' ? true : false;

            for (let i = 0; i < group.filters.length; i++) {
                let currentResult;

                if (group.filters[i] instanceof JQX.Utilities.FilterGroup) {
                    currentResult = group.filters[i].evaluate(value);
                }
                else {
                    currentResult = evaluateGroup(group.filters[i]);
                }

                result = group.logicalOperator === 'and' ? result && currentResult : result || currentResult;
            }

            return result;
        }

        if (!that.filterBuilderObject.logicalOperator) {
            return true;
        }

        return evaluateGroup(that.filterBuilderObject);
    }
});

JQX.Utilities.Assign('NumericFilterHandler', class NumericFilterHandler extends JQX.Utilities.BaseFilterHandler {
    /**
     * Appends inputs specific to filter type.
     */
    appendInputs() {
        const that = this,
            firstInput = document.createElement('jqx-numeric-text-box'),
            secondInput = document.createElement('jqx-numeric-text-box');

        firstInput.inputFormat = 'floatingPoint';
        firstInput.nullable = true;
        firstInput.spinButtons = true;
        firstInput.value = null;
        secondInput.inputFormat = 'floatingPoint';
        secondInput.nullable = true;
        secondInput.spinButtons = true;
        secondInput.value = null;

        that.firstInput = firstInput;
        that.secondInput = secondInput;
    }

    /**
     * Parses filter input value.
     */
    getFilterInputValue(input) {
        if (input.value === null || input.value === '') {
            return '';
        }

        return parseFloat(input.value);
    }
});

JQX.Utilities.Assign('StringFilterHandler', class StringFilterHandler extends JQX.Utilities.BaseFilterHandler {
    /**
     * Sets default source and selection.
     */
    setDefaults() {
        const that = this,
            context = that.context;

        that.defaultListSource = [
            { value: 'EMPTY', label: context.localize('empty') },
            { value: 'NOT_EMPTY', label: context.localize('notEmpty') },
            { value: 'CONTAINS', label: context.localize('contains') },
            { value: 'CONTAINS_CASE_SENSITIVE', label: context.localize('containsCaseSensitive') },
            { value: 'DOES_NOT_CONTAIN', label: context.localize('doesNotContain') },
            { value: 'DOES_NOT_CONTAIN_CASE_SENSITIVE', label: context.localize('doesNotContainCaseSensitive') },
            { value: 'STARTS_WITH', label: context.localize('startsWith') },
            { value: 'STARTS_WITH_CASE_SENSITIVE', label: context.localize('startsWithCaseSensitive') },
            { value: 'ENDS_WITH', label: context.localize('endsWith') },
            { value: 'ENDS_WITH_CASE_SENSITIVE', label: context.localize('endsWithCaseSensitive') },
            { value: 'EQUAL', label: context.localize('equal') },
            { value: 'EQUAL_CASE_SENSITIVE', label: context.localize('equalCaseSensitive') },
            { value: 'NULL', label: context.localize('null') },
            { value: 'NOT_NULL', label: context.localize('notNull') }
        ];
        that.filterBuilderOperations = ['contains', 'isblank', 'isnotblank', 'notcontains', 'startswith', 'endswith', '=', 'NULL', 'NOT_NULL'];
        that.defaultListSelection = 2;
    }

    /**
     * Appends inputs specific to filter type.
     */
    appendInputs() {
        const that = this,
            firstInput = document.createElement('input'),
            secondInput = document.createElement('input');

        firstInput.classList.add('jqx-input');
        secondInput.classList.add('jqx-input');

        that.firstInput = firstInput;
        that.secondInput = secondInput;
    }

    /**
     * Gets filter comparison ('excel' mode).
     */
    getExcelComparison(value) {
        return value === '' ? 'EMPTY' : 'EQUAL_CASE_SENSITIVE';
    }
});

JQX.Utilities.Assign('DateFilterHandler', class DateFilterHandler extends JQX.Utilities.BaseFilterHandler {
    /**
     * Appends inputs specific to filter type.
     */
    appendInputs() {
        const that = this,
            context = that.context,
            firstInput = document.createElement('jqx-date-time-picker'),
            secondInput = document.createElement('jqx-date-time-picker');

        firstInput.calendarButton = true;
        firstInput.editMode = 'partial';
        firstInput.formatString = context.formatString;
        firstInput.dropDownDisplayMode = 'auto';
        firstInput.locale = context.locale;

        if (!firstInput.messages[context.locale]) {
            firstInput.messages[context.locale] = {};
        }

        firstInput.messages[context.locale].dateTabLabel = context.localize('dateTabLabel');
        firstInput.messages[context.locale].timeTabLabel = context.localize('timeTabLabel');
        firstInput.nullable = true;
        firstInput.value = null;

        secondInput.calendarButton = true;
        secondInput.editMode = 'partial';
        secondInput.formatString = context.formatString;
        secondInput.dropDownDisplayMode = 'auto';
        secondInput.locale = context.locale;

        if (!secondInput.messages[context.locale]) {
            secondInput.messages[context.locale] = {};
        }

        secondInput.messages[context.locale].dateTabLabel = context.localize('dateTabLabel');
        secondInput.messages[context.locale].timeTabLabel = context.localize('timeTabLabel');
        secondInput.nullable = true;
        secondInput.value = null;
        secondInput._onCompleted = function () {
            if (secondInput._dropDownDisplayMode === 'timePicker') {
                firstInput.placeholder = context.localize('placeholderTime');
                firstInput.placeholder = context.localize('placeholderTime');
            }
            else {
                firstInput.placeholder = context.localize('placeholderDate');
                firstInput.placeholder = context.localize('placeholderDate');
            }
        };

        that.firstInput = firstInput;
        that.secondInput = secondInput;
    }

    /**
     * Parses filter input value.
     */
    getFilterInputValue(input) {
        if (input.value === null) {
            return '';
        }

        const result = input.value.toDate();

        if (this.displayMode === 'calendar') {
            result.setHours(0, 0, 0);
        }

        return result;
    }

    /**
     * Clears filter.
     */
    defaultClear() {
        const that = this;

        that.firstList.selectedIndexes = [that.defaultListSelection];
        that.firstInput.value = null;
        that.logicalOperatorList.selectedIndexes = [0];
        that.secondList.selectedIndexes = [that.defaultListSelection];
        that.secondInput.value = null;

        that.filterObject.clear();
        that.cacheFilter(that.defaultListSelection, 0, that.defaultListSelection);
    }

    /**
     * Gets hierarchical data source ('excel' mode).
     */
    getHierarchicalDataSource(displayMode) {
        const that = this,
            dataSource = that.dataSource,
            mapping = {},
            treeSource = [];
        let blanks;

        if (displayMode === 'timePicker') {
            return;
        }

        if (dataSource[dataSource.length - 1].value === '') {
            blanks = dataSource[dataSource.length - 1];
            dataSource.pop();
        }

        dataSource.forEach(function (item) {
            const date = item.value,
                year = date.getFullYear(),
                month = new Intl.DateTimeFormat(that.context.locale, { month: 'long' }).format(date),
                day = date.getDate();

            if (!mapping[year]) {
                mapping[year] = {};
            }

            if (!mapping[year][month]) {
                mapping[year][month] = {};
            }

            if (!mapping[year][month][day]) {
                if (displayMode === 'calendar') {
                    mapping[year][month][day] = date;
                    return;
                }
                else {
                    mapping[year][month][day] = {};
                }
            }

            if (displayMode === 'calendar') {
                return;
            }

            const hours = date.getHours(),
                minutes = date.getMinutes(),
                seconds = date.getSeconds();

            if (!mapping[year][month][day][hours]) {
                mapping[year][month][day][hours] = {};
            }

            if (!mapping[year][month][day][hours][minutes]) {
                mapping[year][month][day][hours][minutes] = {};
            }

            if (!mapping[year][month][day][hours][minutes][seconds]) {
                mapping[year][month][day][hours][minutes][seconds] = date;
            }
        });

        for (let year in mapping) {
            const yearLevelItem = { label: year, items: [], customAttribute: 'default-item' };

            treeSource.push(yearLevelItem);

            for (let month in mapping[year]) {
                const monthLevelItem = { label: month, items: [], customAttribute: 'default-item' };

                yearLevelItem.items.push(monthLevelItem);

                for (let day in mapping[year][month]) {
                    const dayLeveItem = { label: day, customAttribute: 'default-item' };

                    monthLevelItem.items.push(dayLeveItem);

                    if (displayMode === 'calendar') {
                        dayLeveItem.value = mapping[year][month][day];
                        continue;
                    }

                    dayLeveItem.items = [];

                    for (let hours in mapping[year][month][day]) {
                        const hoursLevelItem = { label: '0'.repeat(2 - hours.length) + hours, items: [], customAttribute: 'default-item' };

                        dayLeveItem.items.push(hoursLevelItem);

                        for (let minutes in mapping[year][month][day][hours]) {
                            const minutesLevelItem = { label: ':' + '0'.repeat(2 - minutes.length) + minutes, items: [], customAttribute: 'default-item' };

                            hoursLevelItem.items.push(minutesLevelItem);

                            for (let seconds in mapping[year][month][day][hours][minutes]) {
                                const secondsLevelItem = {
                                    label: ':' + '0'.repeat(2 - seconds.length) + seconds,
                                    value: mapping[year][month][day][hours][minutes][seconds],
                                    customAttribute: 'default-item'
                                };

                                minutesLevelItem.items.push(secondsLevelItem);
                            }
                        }
                    }
                }
            }
        }

        if (blanks) {
            treeSource.push(blanks);
        }

        that.dataSource = treeSource;
    }
});

JQX.Utilities.Assign('BooleanFilterHandler', class BooleanFilterHandler extends JQX.Utilities.BaseFilterHandler {
    /**
     * Caches filter.
     */
    cacheFilter(firstFilterComparison, operator, secondFilterComparison) {
        const that = this;

        that.cachedFilter = {
            firstFilterComparison: firstFilterComparison,
            firstFilterValue: that.firstInput.selectedIndexes.slice(0),
            logicalOperator: operator,
            secondFilterComparison: secondFilterComparison,
            secondFilterValue: that.secondInput.selectedIndexes.slice(0)
        };
    }

    /**
     * Sets default source and selection.
     */
    setDefaults() {
        const that = this,
            context = that.context;

        that.defaultListSource = [
            { value: 'EQUAL', label: context.localize('equal') },
            { value: 'NOT_EQUAL', label: context.localize('notEqual') },
            { value: 'NULL', label: context.localize('null') },
            { value: 'NOT_NULL', label: context.localize('notNull') }
        ];
        that.filterBuilderOperations = ['=', '<>', 'NULL', 'NOT_NULL'];
        that.defaultListSelection = 0;
    }

    /**
     * Appends inputs specific to filter type.
     */
    appendInputs() {
        const that = this,
            firstInput = document.createElement('jqx-drop-down-list'),
            secondInput = document.createElement('jqx-drop-down-list');

        firstInput.dataSource = [{ value: true, label: 'true' }, { value: false, label: 'false' }];
        firstInput.selectedIndexes = [];
        firstInput.selectionMode = 'zeroOrOne';
        secondInput.dataSource = [{ value: true, label: 'true' }, { value: false, label: 'false' }];
        secondInput.selectedIndexes = [];
        secondInput.selectionMode = 'zeroOrOne';

        that.firstInput = firstInput;
        that.secondInput = secondInput;
    }

    /**
     * Parses filter input value.
     */
    getFilterInputValue(input) {
        if (input.selectedValues.length === 0) {
            return '';
        }

        return input.selectedValues[0] === 'true';
    }

    /**
     * Clears filter.
     */
    defaultClear() {
        const that = this;

        that.firstList.selectedIndexes = [that.defaultListSelection];
        that.firstInput.selectedIndexes = [];
        that.logicalOperatorList.selectedIndexes = [0];
        that.secondList.selectedIndexes = [that.defaultListSelection];
        that.secondInput.selectedIndexes = [];

        that.filterObject.clear();
        that.cacheFilter(that.defaultListSelection, 0, that.defaultListSelection);
    }

    /**
     * Cancels current filter application.
     */
    defaultCancel() {
        const that = this;

        that.firstList.selectedIndexes = [that.cachedFilter.firstFilterComparison];
        that.firstInput.selectedIndexes = that.cachedFilter.firstFilterValue;
        that.logicalOperatorList.selectedIndexes = [that.cachedFilter.logicalOperator];
        that.secondList.selectedIndexes = [that.cachedFilter.secondFilterComparison];
        that.secondInput.selectedIndexes = that.cachedFilter.secondFilterValue;
    }
});


/**
* List Item custom element.
*/
JQX('jqx-list-item', class Item extends JQX.ContentElement {
    // Item's properties.
    static get properties() {
        return {
            'alternationIndex': {
                value: -1,
                type: 'int'
            },
            'color': {
                value: '',
                type: 'string'
            },
            'displayMode': {
                allowedValues: ['plain', 'checkBox', 'radioButton'],
                value: 'plain',
                type: 'string'
            },
            'grouped': {
                value: false,
                type: 'boolean'
            },
            'selected': {
                value: false,
                type: 'boolean'
            },
            'value': {
                value: '',
                type: 'string'
            },
            'label': {
                value: '',
                type: 'string'
            },
            'details': {
                value: '',
                type: 'string'
            },
            'group': {
                value: '',
                type: 'string'
            },
            'hidden': {
                value: false,
                type: 'boolean'
            },
            'readonly': {
                value: false,
                type: 'boolean'
            }
        };
    }

    get hasStyleObserver() {
        return false;
    }

    get enableShadowDOM() {
        return false;
    }

    get _focused() {
        const that = this;

        if (that.__focused === undefined) {
            that.__focused = false;
        }

        return that.__focused;
    }

    set _focused(value) {
        const that = this;

        that.__focused = value;

        if (value) {
            that.setAttribute('focus', '');
        }
        else {
            that.removeAttribute('focus');
        }
    }
    /**
    * jqx-list-item's template.
    */
    template() {
        return `<div id="container">
                   <span id='itemInput' class ='jqx-input jqx-hidden'></span>
                    <span class ="jqx-overlay" id="overlay"></span>
                    <div id="itemContainer" class ="jqx-content jqx-list-item-container"><span class="jqx-content-label" inner-h-t-m-l=\'[[innerHTML]]\'><content></content></span><span inner-h-t-m-l=\'[[details]]\' id="details" class="jqx-content-details"></span></div>
                </div>`;
    }

    appendChild(node) {
        const that = this;

        if (!that.isCompleted || node.classList.contains('jqx-ripple')) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        that.$.itemContainer.innerHTML = '';

        if (node instanceof HTMLElement) {
            that.$.itemContainer.appendChild(node);
        }
    }

    insertBefore(newNode, referenceNode) {
        const that = this;

        if (!that.isCompleted) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        referenceNode.parentNode.insertBefore(newNode, referenceNode);
    }

    removeChild(node) {
        const that = this;

        if (!that.isCompleted || node.classList.contains('jqx-ripple')) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (node instanceof HTMLElement) {
            that.$.itemContainer.removeChild(node);
        }
    }

    attached() {
        const that = this;

        super.attached();

        that.ownerListBox = that.getListBox();
    }

    /**
    * jqx-list-item's event listeners.
    **/
    static get listeners() {
        return {
            'mouseenter': '_itemOnMouseEnter',
            'mouseleave': '_itemOnMouseLeave'
        };
    }

    /**
    * Called when the element is ready. Used for one-time configuration of the Item.
    */
    ready() {
        super.ready();

        const that = this;

        if (that.label !== '') {
            that.innerHTML = that.label;
        }
        else if (that.innerHTML !== '') {
            that.label = that.innerHTML;
        }

        that._setDisplayMode(that.displayMode);
        that._setItemColor();

        that.$.container.noRipple = true;
    }


    /**
    * Called when a property is changed.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        super.propertyChangedHandler(propertyName, oldValue, newValue);

        if (propertyName === 'hidden') {
            if (!newValue) {
                that.$.removeClass('jqx-hidden');
            }
            else {
                that.$.addClass('jqx-hidden');
            }
        }

        else if (propertyName === 'color') {
            that._setItemColor();
        }
        else if (propertyName === 'displayMode') {
            that._setDisplayMode(newValue);
        }
        else if (propertyName === 'label') {
            const context = that.context;
            that.context = document;
            that.innerHTML = newValue;

            const listBox = that.getListBox();
            listBox.onItemUpdated(that);
            that.context = context;
        }
        else if (propertyName === 'details') {
            const context = that.context;
            that.context = document;
            that.$.details.innerHTML = newValue;

            const listBox = that.getListBox();
            listBox.onItemUpdated(that);
            that.context = context;
        }
        else if (propertyName === 'innerHTML') {
            const listBox = that.getListBox();
            listBox.onItemUpdated(that);
        }
    }

    getListBox() {
        const that = this;

        let parent = that.parentNode;
        while (parent instanceof JQX.ListBox === false && parent !== null) {
            parent = parent.parentNode;
        }

        if (!parent && JQX.EnableShadowDOM) {
            return that.getRootNode().host;
        }

        return parent;
    }

    /**
  * Item onMouseEnter event handler.
  */
    _itemOnMouseEnter() {
        const that = this;

        if (that.disabled || !that.ownerListBox) {
            return;
        }

        if (JQX.ListBox.DragDrop.Dragging && that.ownerListBox.allowDrop) {
            JQX.ListBox.DragDrop.DropDetails = { item: that, position: 'bottom' };
        }

        if (that.ownerListBox.$.verticalScrollBar.thumbCapture || that.ownerListBox.$.horizontalScrollBar.thumbCapture) {
            return;
        }

        that.setAttribute('hover', '');
    }

    /**
     * Item onMouseMove event handler.
    */
    _itemOnMouseMove(event) {
        const that = this;

        if (!that.ownerListBox) {
            return;
        }

        if (JQX.ListBox.DragDrop.Dragging && that.ownerListBox.allowDrop && !JQX.Utilities.Core.isMobile) {
            const itemsWithFeedback = [].slice.call(that.ownerListBox.getElementsByClassName('jqx-list-item-bottom-line-feedback'));

            for (let i = 0; i < itemsWithFeedback.length; i++) {
                itemsWithFeedback[i].$.removeClass('jqx-list-item-line-feedback');
                itemsWithFeedback[i].$.removeClass('jqx-list-item-bottom-line-feedback');
            }

            JQX.ListBox.DragDrop.DropDetails = { item: that, position: 'top' };
            if (!that.ownerListBox._areCSSVarsSupported) {
                if (that.ownerListBox._indexOf(that) === that.ownerListBox._items.length - 1 || that.parentNode.lastElementChild === that) {
                    const rect = that.getBoundingClientRect();

                    if (event.pageY - window.pageYOffset > rect.top + (rect.height / 2) - 1) {
                        JQX.ListBox.DragDrop.DropDetails = { item: that, position: 'bottom' };
                    }
                }
                return;
            }

            that.$.removeClass('jqx-list-item-line-feedback');
            that.$.removeClass('jqx-list-item-bottom-line-feedback');

            if (that.ownerListBox.sorted && that.ownerListBox.autoSort) {
                return;
            }

            const visibleItems = that.ownerListBox._items.filter(item => !item.hidden);

            if (visibleItems.indexOf(that) === visibleItems.length - 1 || that.parentNode.lastElementChild === that) {
                const rect = that.getBoundingClientRect();

                if (event.pageY - window.pageYOffset > rect.top + (rect.height / 2) - 1) {
                    that.$.addClass('jqx-list-item-bottom-line-feedback');
                    JQX.ListBox.DragDrop.DropDetails = { item: that, position: 'bottom' };
                }
                else if (!arguments[1]) {
                    that.$.addClass('jqx-list-item-line-feedback');
                }
            }
            else if (!arguments[1]) {
                that.$.addClass('jqx-list-item-line-feedback');
            }
        }
    }

    /**
    * Item onMouseLeave event handler.
    */
    _itemOnMouseLeave() {
        const that = this;

        if (!that.ownerListBox) {
            return;
        }

        if (JQX.ListBox.DragDrop.Dragging) {
            that.$.removeClass('jqx-list-item-line-feedback');
            that.$.removeClass('jqx-list-item-bottom-line-feedback');
        }

        that.removeAttribute('hover');
    }

    _setDisplayMode(value) {
        const that = this;

        const listBox = that.getListBox();

        if (listBox) {
            const displayMode = listBox.selectionMode === 'checkBox' || listBox.selectionMode === 'radioButton' ? listBox.selectionMode : 'plain';

            that.displayMode = value = displayMode;
        }

        if (value === 'plain') {
            that.$itemInput.addClass('jqx-hidden');
            return;
        }

        that.$itemInput.removeClass('jqx-hidden');
    }

    /**
     * Set's the color property
     */
    _setItemColor() {
        const that = this,
            label = that.querySelector('.jqx-content-label'),
            color = /(^#[0-9A-F]{3}$)|(^#[0-9A-F]{6}$)|(^#[0-9A-F]{8}$)/i.test(that.color) ? that.color : ''; //HEX check

        label.style.backgroundColor = color;
        label.style.color = that._getContrastColor(color);
    }

    /**
    * Returns a contrasting color of the target color
    * @param {any} color - HEX
    */
    _getContrastColor(color) {
        if (!color) {
            return '';
        }

        function hexToRgb(h, e, x) {
            return [parseInt(h, 16), parseInt(e, 16), parseInt(x, 16)];
        }

        let rgb = hexToRgb(color.slice(1, 3), color.slice(3, 5), color.slice(5, 7)),
            luminance = (0.299 * rgb[0] + 0.61 * rgb[1] + 0.114 * rgb[2]) / 255;

        if (parseFloat(luminance.toFixed(2)) > 0.65) {
            return '#000000';
        }
        else {
            return '#FFFFFF';
        }
    }
});

/**
* List Items Group custom element.
*/
JQX('jqx-list-items-group', class ListItemsGroup extends JQX.ContentElement {
    // Item's properties.
    static get properties() {
        return {
            'label': {
                value: '',
                type: 'string'
            }
        };
    }

    get enableShadowDOM() {
        return false;
    }

    /**
    * jqx-list-items-group's template.
    */
    template() {
        return `<div id="container">
                 <span id="itemsLabel" class ="jqx-list-items-group-label">[[label]]</span>
                 <div id="listItemsGroupContainer" inner-h-t-m-l=\'[[innerHTML]]\' class ="jqx-list-items-group-container">
                    <content></content>
                 </div>
               </div>`;
    }

    appendChild(node) {
        const that = this;

        if (!that.isCompleted) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (node instanceof HTMLElement) {
            that.$.listItemsGroupContainer.appendChild(node);
        }
    }

    removeChild(node) {
        const that = this;

        if (!that.isCompleted) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (node instanceof HTMLElement) {
            that.$.listItemsGroupContainer.removeChild(node);
        }
    }

    getListBox() {
        const that = this;

        let parent = that.parentNode;
        while (parent instanceof JQX.ListBox === false && parent !== null) {
            parent = parent.parentNode;
        }

        return parent;
    }

    attached() {
        const that = this;

        super.attached();

        if (!that.ownerListBox) {
            that.ownerListBox = that.getListBox();
        }
    }
});
/**
* List box custom element.
*/
JQX('jqx-list-box', class ListBox extends JQX.ScrollViewer {

    /** 
    * ListBox's properties 
    */
    static get properties() {
        return {
            'allowDrag': {
                value: false,
                type: 'boolean'
            },
            'allowDrop': {
                value: false,
                type: 'boolean'
            },
            'alternationStart': {
                value: 0,
                type: 'int'
            },
            'alternationEnd': {
                value: 0,
                type: 'int'
            },
            'alternationCount': {
                value: 0,
                type: 'int'
            },
            'autoSort': {
                value: true,
                type: 'boolean'
            },
            'dataSource': {
                value: null,
                type: 'any?',
                reflectToAttribute: false
            },
            'dragFeedbackFormatFunction': {
                value: null,
                type: 'function?'
            },
            'dragOffset': {
                value: [10, 10],
                type: 'array'
            },
            'displayLoadingIndicator': {
                value: false,
                type: 'boolean'
            },
            'displayMember': {
                value: '',
                type: 'string'
            },
            'shadowDomMode': {
                allowedValues: ['light', 'shadow'],
                value: 'shadow',
                type: 'string'
            },
            'dropAction': {
                value: 'move',
                type: 'string',
                allowedValues: ['copy', 'move', 'none']
            },
            'editable': {
                value: false,
                type: 'boolean'
            },
            'filterable': {
                value: false,
                type: 'boolean'
            },
            'filterCallback': {
                value: null,
                type: 'function?'
            },
            'filterMode': {
                value: 'containsIgnoreCase',
                allowedValues: ['contains', 'containsIgnoreCase', 'doesNotContain', 'doesNotContainIgnoreCase', 'equals', 'equalsIgnoreCase', 'startsWith', 'startsWithIgnoreCase', 'endsWith', 'endsWithIgnoreCase', 'custom'],
                type: 'string'
            },
            'filterInputPlaceholder': {
                value: '',
                type: 'string'
            },
            'grouped': {
                value: false,
                type: 'boolean'
            },
            'groupMember': {
                value: '',
                type: 'string'
            },
            'itemTemplate': {
                value: null,
                type: 'any'
            },
            'itemHeight': {
                value: null,
                type: 'number?'
            },
            'incrementalSearchDelay': {
                value: 700,
                type: 'number?'
            },
            'incrementalSearchMode': {
                value: 'startsWithIgnoreCase',
                allowedValues: ['contains', 'containsIgnoreCase', 'doesNotContain', 'doesNotContainIgnoreCase', 'equals', 'equalsIgnoreCase', 'startsWith', 'startsWithIgnoreCase', 'endsWith', 'endsWithIgnoreCase'],
                type: 'string'
            },
            'loadingIndicatorPlaceholder': {
                value: 'Loading...',
                type: 'string'
            },
            'loadingIndicatorPosition': {
                value: 'center',
                allowedValues: ['bottom', 'center', 'top'],
                type: 'string'
            },
            'messages': {
                extend: true,
                value: {
                    'en': {
                        'overridingProperties': '{{elementType}}: Overriding properties {{property1}} and {{property2}} applied. The "{{property1}}" property is used by default.',
                        'invalidIndex': '{{elementType}}: "{{method}}" method accepts an index of type number or an Array of numbers.',
                        'indexOutOfBound': '{{elementType}}: Out of bound index/indexes in "{{method}}" method.',
                        'invalidItem': '{{elementType}}: "{{method}}" method accepts an object or an array of objects as it\'s second parameter.',
                        'invalidSettings': '{{elementType}}: "{{method}}" method accepts a string or an object as it\'s second parameter.'
                    }
                },
                type: 'object'
            },
            'name': {
                value: '',
                type: 'string'
            },
            'placeholder': {
                value: 'No Items',
                type: 'string'
            },
            'selectedIndexes': {
                value: [],
                type: 'array'
            },
            'selectedValues': {
                value: [],
                type: 'array'
            },
            'selectionMode': {
                value: 'oneOrManyExtended',
                allowedValues: ['none', 'oneOrManyExtended', 'zeroOrMany', 'oneOrMany', 'zeroOrOne', 'one', 'checkBox', 'radioButton'],
                type: 'string'
            },
            'selectionChangeAction': {
                value: 'release',
                allowedValues: ['press', 'release'],
                type: 'string'
            },
            'sorted': {
                value: false,
                type: 'boolean'
            },
            'sortDirection': {
                value: 'asc',
                type: 'string'
            },
            'topVisibleIndex': {
                value: -1,
                type: 'int'
            },
            'type': {
                value: 'list',
                type: 'string',
                defaultReflectToAttribute: true,
                readonly: true
            },
            'valueMember': {
                value: '',
                type: 'string'
            },
            'virtualized': {
                value: false,
                type: 'boolean'
            }
        }
    }

    /**
    * ScrollViewer have it's shadowRoot set to false. So it needs to be predefined
    */
    get enableShadowDOM() {
        return JQX.EnableShadowDOM;
    }

    /** 
    * ListBox's requires 
    */
    static get requires() {
        return {
            'JQX.ScrollBar': 'jqxscrollbar.js'
        }
    }

    static get styleUrls() {
        return [
            'jqx.listbox.css'
        ]
    }


    /**
     * ListBox's event listeners.
     */
    static get listeners() {
        return {
            'focus': '_focusHandler',
            'blur': '_blurHandler',
            'container.wheel': '_mouseWheelHandler',
            'editInput.change': '_editInputEventHandler',
            'editInput.blur': '_editInputEventHandler',
            'editInput.keydown': '_editInputEventHandler',
            'horizontalScrollBar.change': '_horizontalScrollbarHandler',
            'itemsInnerContainer.down': '_downHandler',
            'itemsInnerContainer.dblclick': '_dblclickEventHandler',
            'itemsInnerContainer.move': '_itemsContainerMoveHandler',
            'itemsContainer.mouseleave': '_mouseLeaveHandler',
            'document.up': '_upHandler',
            'document.move': '_moveHandler',
            'keydown': '_keyDownHandler',
            'keyup': '_keyUpHandler',
            'resize': '_resizeHandler',
            'selectstart': '_selectStartHandler',
            'styleChanged': '_styleChangedHandler',
            'swipeleft': '_swipeLeftHandler',
            'swiperight': '_swipeRightHandler',
            'verticalScrollBar.change': '_verticalScrollbarHandler'
        };
    }

    /*
    * ListBox's HTML template.
    */
    template() {
        return `<div id="container" class="jqx-container">
                 <div class="jqx-list-box-filter-input-container jqx-hidden" id="filterInputContainer">
                     <input id="filterInput" disabled="[[disabled]]" placeholder='[[filterInputPlaceholder]]'>
                 </div>
                 <div id="itemsContainer" class="jqx-list-items-container">
                      <div id="placeholder" class ="jqx-placeholder">[[placeholder]]</div>
                      <div id="itemsInnerContainer" inner-h-t-m-l=\'[[innerHTML]]\' class ="jqx-list-items-inner-container">
                          <content></content>
                      </div>
                      <input type="text" id="editInput" class= "jqx-hidden"/>
                 </div>
                 <jqx-scroll-bar wait id="verticalScrollBar" disabled="[[disabled]]" orientation="vertical"></jqx-scroll-bar>
                 <jqx-scroll-bar wait id="horizontalScrollBar" disabled="[[disabled]]" ></jqx-scroll-bar>
                 <div id="loadingIndicatorContainer" class ="jqx-loader-container">
                    <span id="loadingIndicator" class="jqx-loader"></span>
                    <span id="loadingIndicatorPlaceHolder" class ="jqx-loader-label jqx-hidden">[[loadingIndicatorPlaceholder]]</span>
                 </div>
                <input id="hiddenInput" type="hidden" name="[[name]]">
                </div>`;
    }

    _mouseLeaveHandler() {
        const that = this,
            itemsWithFeedback = [].slice.call(that.getElementsByClassName('jqx-list-item-bottom-line-feedback'));

        //Remove Bottom Line feedbacks
        for (let i = 0; i < itemsWithFeedback.length; i++) {
            itemsWithFeedback[i].$.removeClass('jqx-list-item-line-feedback');
            itemsWithFeedback[i].$.removeClass('jqx-list-item-bottom-line-feedback');
        }
    }

    _downHandler(event) {
        const that = this;

        if (that.disabled || that.displayLoadingIndicator || that.readonly) {
            return;
        }

        let target = event.originalEvent.target;
        let item = null;

        if ((target instanceof JQX.ListItem) && !target.disabled && !target.hidden && !(target instanceof JQX.ListItemsGroup)) {
            item = target.dataItem;
        }
        else {
            while (target.parentElement) {
                if ((target instanceof JQX.ListItem) && !target.disabled && !target.hidden && !(target instanceof JQX.ListItemsGroup)) {

                    item = target.dataItem;
                    break;
                }

                target = target.parentElement;
            }
        }

        JQX.ListBox.DragDrop.StartTime = new Date();
        JQX.ListBox.DragDrop.StartPosition = { left: event.pageX, top: event.pageY };

        if (!item) {
            return;
        }

        event.stopPropagation();

        if (that.hasRippleAnimation) {
            if (!item.readonly && !item.disabled) {
                JQX.Utilities.Animation.Ripple.animate(target.$.overlay, event.pageX, event.pageY);
            }
        }

        if (!JQX.Utilities.Core.isMobile && that.selectionChangeAction === 'press') {
            that._focus(item);
            that.select(item);
        }

        if (!JQX.ListBox.DragDrop.Feedback && that.allowDrag) {
            JQX.ListBox.DragDrop.DraggedFrom = that;
            JQX.ListBox.DragDrop.Feedback = document.createElement('span');

            if (that.dragFeedbackFormatFunction) {
                JQX.ListBox.DragDrop.Feedback.innerHTML = that.dragFeedbackFormatFunction(item);
            }
            else {
                JQX.ListBox.DragDrop.Feedback.appendChild(item.offsetHeight ? item.cloneNode(true) : that._createItem(item));
            }

            JQX.ListBox.DragDrop.Item = item;
            JQX.Utilities.Extend(JQX.ListBox.DragDrop.Feedback).addClass('jqx-popup jqx-list-item jqx-list-item-feedback');
        }
    }

    /**
     * Double click on itemsContainer event handler
     * @param {any} event
     */
    _dblclickEventHandler(event) {
        const that = this;

        if (!that.editable) {
            return;
        }

        const target = event.target.closest('jqx-list-item');

        if (!(target instanceof JQX.ListItem) || target.disabled || target.readonly) {
            that.$editInput.addClass('jqx-hidden');
            return;
        }

        that.$.editInput.owner = target;
        that.$.editInput.value = target.label;
        that.$.editInput.style.height = target.offsetHeight + 'px';
        that.$.editInput.style.top = target.offsetTop + 'px';

        if (that.$editInput.hasClass('jqx-hidden')) {
            that.$editInput.removeClass('jqx-hidden');
        }

        that.$.editInput.focus();
    }

    /**
     * List Item edit input change and blur event handler
     * @param {any} event
     */
    _editInputEventHandler(event) {
        const that = this;

        if (event.type === 'blur' || (event.type === 'keydown' && event.key === 'Escape')) {
            !that.$editInput.hasClass('jqx-hidden') ? that.$editInput.addClass('jqx-hidden') : undefined;
            that.focus();
            return;
        }

        if (event.type === 'keydown' || that.$editInput.hasClass('jqx-hidden')) {
            return;
        }

        const target = event.target;

        event.stopPropagation(); //stop input's original change event

        if (target.owner.label !== target.value) {
            target.owner.label = target.value;

            if (that.itemTemplate) {
                that._applyTemplate(target.owner)
            }

            if (that.dataSource) {
                const index = target.owner.dataIndex;
                const dataItem = that.dataSource[index];

                if (dataItem) {
                    if (that.displayMember) {
                        dataItem[that.displayMember] = target.value;
                    }
                    else {
                        dataItem.label = target.value;
                    }
                }
            }
        }

        that.$editInput.addClass('jqx-hidden');
        that.$.fireEvent('itemLabelChange', {
            'selected': target.owner.selected,
            'disabled': target.owner.disabled,
            'index': that._indexOf(target.owner),
            'label': target.owner.label,
            'value': target.owner.value
        });
    }

    _pointerUpHandler(customEvent) {
        const that = this;
        let event = customEvent.originalEvent;
        let target = event.target;

        const select = (item) => {
            const listBox = item.ownerListBox;

            if (listBox.disabled || listBox !== that || listBox.displayLoadingIndicator || listBox.selectionMode === 'none' || item.grouped || item.readonly) {
                return;
            }

            listBox._focus(item);
            listBox.select(item);
            customEvent.preventDefault();
            JQX.ListBox.DragDrop.StartPosition = null;
            that.$.fireEvent('itemClick', {
                'selected': target.selected,
                'disabled': target.disabled,
                'index': that._indexOf(target),
                'label': target.label,
                'value': target.value
            });
        }

        if ((event.target instanceof JQX.ListItem) && !event.target.disabled && !(event.target instanceof JQX.ListItemsGroup)) {
            select(target.dataItem);
            return;
        }

        while (target.parentElement) {
            if ((target instanceof JQX.ListItem) && !target.disabled && !(target instanceof JQX.ListItemsGroup)) {
                select(target.dataItem);
                break;
            }

            target = target.parentElement;
        }

        if (this.enableShadowDOM && this.shadowDomMode === 'shadow') {
            const composedPath = event.composedPath();

            for (let i = 0; i < composedPath.length; i++) {
                const htmlElement = composedPath[i];

                if (htmlElement instanceof JQX.ListItem && !htmlElement.disabled) {
                    select(htmlElement.dataItem);
                }
            }
        }
    }

    _upHandler(event) {
        const that = this;

        if (that.disabled || that.readonly || !JQX.ListBox.DragDrop.StartPosition) {
            return;
        }

        if (JQX.Utilities.Core.isMobile && !JQX.ListBox.DragDrop.Dragging) {
            const left = Math.abs(event.pageX - JQX.ListBox.DragDrop.StartPosition.left);
            const top = Math.abs(event.pageY - JQX.ListBox.DragDrop.StartPosition.top);
            let canSelect = (left >= 0 && left <= 3) && (top >= 0 && top <= 3);

            if (JQX.Utilities.Core.isMobile) {
                if (new Date() - JQX.ListBox.DragDrop.StartTime >= 300) {
                    canSelect = false;
                    JQX.ListBox.DragDrop.StartTime = null;
                }
            }

            if (canSelect) {
                const closestListBox = event.originalEvent.target.closest('jqx-list-box');

                closestListBox ? closestListBox._pointerUpHandler(event) : that._pointerUpHandler(event);
                JQX.ListBox.DragDrop.StartPosition = null;
            }
            else {
                let target = event.originalEvent.target;
                if ((event.target instanceof JQX.ListItem) && !target.readonly && !event.target.disabled && !(event.target instanceof JQX.ListItemsGroup)) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                else {
                    while (target.parentElement) {
                        if ((target instanceof JQX.ListItem) && !target.readonly && !target.disabled && !(target instanceof JQX.ListItemsGroup)) {
                            event.preventDefault();
                            event.stopPropagation();
                            break;
                        }

                        target = target.parentElement;
                    }
                }
            }
        }
        else if (!JQX.Utilities.Core.isMobile && !JQX.ListBox.DragDrop.Dragging && that.selectionChangeAction === 'release') {
            const closestListBox = event.originalEvent.target.closest('jqx-list-box');

            closestListBox ? closestListBox._pointerUpHandler(event) : that._pointerUpHandler(event);
        }

        if (JQX.ListBox.DragDrop.Feedback) {
            if (JQX.ListBox.DragDrop.Feedback.parentNode) {
                JQX.ListBox.DragDrop.Feedback.parentNode.removeChild(JQX.ListBox.DragDrop.Feedback);
            }
            JQX.ListBox.DragDrop.Feedback = null;
            let dropTarget;

            if (JQX.Utilities.Core.isMobile && JQX.ListBox.DragDrop.Dragging) {
                for (let j = 0; j < JQX.ListBox.DragDrop.ListBoxes.length; j++) {
                    const listBox = JQX.ListBox.DragDrop.ListBoxes[j];
                    const rect = listBox.getBoundingClientRect();

                    if (!listBox.allowDrop || listBox.closest('.jqx-visibility-hidden')) {
                        continue;
                    }

                    if (rect.left <= event.pageX && event.pageX <= rect.left + rect.width && rect.top <= event.pageY && event.pageY <= rect.top + rect.height) {
                        dropTarget = listBox;

                        const visibleItems = listBox._items.filter(item => !item.hidden);

                        for (let i = 0; i < visibleItems.length; i++) {
                            const item = visibleItems[i];
                            const itemRect = item.getBoundingClientRect();

                            if (visibleItems.indexOf(item) === visibleItems.length - 1 || item.parentNode.lastElementChild === item) {
                                if (event.pageY >= rect.top + item.offsetTop - listBox.scrollTop + (itemRect.height / 2) && event.pageY <= rect.top - listBox.scrollTop + item.offsetTop + itemRect.height) {
                                    JQX.ListBox.DragDrop.DropDetails = { item: item, position: 'bottom' };
                                    break;
                                }
                            }
                            if (event.pageY >= rect.top + item.offsetTop - listBox.scrollTop && event.pageY <= rect.top + item.offsetTop + itemRect.height - listBox.scrollTop) {
                                JQX.ListBox.DragDrop.DropDetails = { item: item, position: 'top' };
                                break;
                            }
                        }
                    }
                }
            }

            if (JQX.ListBox.DragDrop.Dragging) {
                if (JQX.ListBox.DragDrop.DropDetails) {
                    let dropItem = JQX.ListBox.DragDrop.DropDetails.item,
                        dragItem = JQX.ListBox.DragDrop.Item;
                    const dragItemListBox = dragItem.ownerListBox;

                    dropTarget = !dropTarget && event.originalEvent.target.closest ? event.originalEvent.target.closest('jqx-list-box') : dropTarget;

                    document.body.classList.remove('jqx-dragging');
                    dropItem.$.removeClass('jqx-list-item-line-feedback');
                    dropItem.$.removeClass('jqx-list-item-bottom-line-feedback');

                    if (dropTarget && dropItem.ownerListBox !== dropTarget && dropTarget.items.length > 0) {
                        dropItem = dropTarget.items[dropTarget.items.length - 1];
                    }

                    if (JQX.ListBox.DragDrop.Item !== dropItem && (dropTarget === dropItem.ownerListBox || JQX.Utilities.Core.isMobile)) {
                        if (dragItem.ownerListBox.dropAction !== 'none') {
                            if (dropItem.ownerListBox !== dragItem.ownerListBox && dragItem.ownerListBox.dropAction === 'move') {
                                JQX.ListBox.DragDrop.Item.ownerListBox.removeChild(JQX.ListBox.DragDrop.Item);
                            }

                            if (dragItem.ownerListBox.dropAction === 'copy') {
                                dragItem = dragItem.cloneNode(true);
                            }

                            JQX.ListBox.DragDrop.Item.group = dropItem.group;

                            const listBox = dropItem.ownerListBox;

                            if (listBox.selectionMode !== 'checkBox' && listBox.selectionMode !== 'radioButton') {
                                listBox.clearSelection();
                            }

                            if (JQX.ListBox.DragDrop.DropDetails.position === 'top') {
                                listBox.insertBefore(dragItem, dropItem);
                            }
                            else {
                                if (dropItem.parentNode.lastElementChild === dropItem) {
                                    listBox.appendChild(dragItem);
                                }
                                else {
                                    listBox.appendChild(dragItem, dropItem);
                                }
                            }

                            listBox.ensureVisible(dragItem);
                            if (listBox.selectionMode === 'checkBox' || listBox.selectionMode === 'radioButton') {
                                listBox._focus(dragItem);
                                listBox._refreshSelection();
                            }
                            else {
                                listBox.clearSelection();
                                listBox.select(dragItem);
                            }
                        }
                    }
                    else if (dropTarget && dropTarget._items.length === 0 && dropTarget.dropAction !== 'none') {
                        if (dropTarget.dropAction === 'move') {
                            JQX.ListBox.DragDrop.Item.ownerListBox.removeChild(JQX.ListBox.DragDrop.Item);
                        }
                        else if (dropTarget.dropAction === 'copy') {
                            dragItem = dragItem.cloneNode(true);
                        }

                        dropTarget.appendChild(dragItem);
                    }

                    if (dragItem.selected && dropTarget !== dragItemListBox) {
                        dragItemListBox._refreshSelection();
                    }

                    const item = JQX.ListBox.DragDrop.Item;
                    const listBox = item.ownerListBox;

                    item.displayMode = listBox.selectionMode === 'checkBox' || listBox.selectionMode === 'radioButton' ? listBox.selectionMode : 'plain';

                    listBox.$.fireEvent('dragEnd', {
                        'item': item,
                        'target': dropItem,
                        'data': JQX.ListBox.DragDrop,
                        'previousContainer': dragItemListBox,
                        'container': dropTarget,
                        'originalEvent': event
                    });

                    listBox._focus(item);
                }
                else {
                    const item = JQX.ListBox.DragDrop.Item;
                    const listBox = item.ownerListBox;

                    item.displayMode = listBox.selectionMode === 'checkBox' || listBox.selectionMode === 'radioButton' ? listBox.selectionMode : 'plain';

                    listBox.$.fireEvent('dragEnd', {
                        'item': item,
                        'target': null,
                        'data': JQX.ListBox.DragDrop,
                        'previousContainer': listBox,
                        'container': listBox,
                        'originalEvent': event
                    });

                    listBox._focus(item);
                }

                event.preventDefault();
            }

            delete JQX.ListBox.DragDrop.DraggedFrom;
            JQX.ListBox.DragDrop.Dragging = false;
            JQX.ListBox.DragDrop.Item = null;
            JQX.ListBox.DragDrop.DropDetails = null;
        }

        for (let i = 0; i < JQX.ListBox.DragDrop.ListBoxes.length; i++) {
            const listBox = JQX.ListBox.DragDrop.ListBoxes[i];

            if (listBox._dragInterval) {
                clearInterval(listBox._dragInterval);
            }
        }
    }

    _itemsContainerMoveHandler(event) {
        const that = this;

        if (JQX.ListBox.DragDrop.Dragging) {
            that._applyItemFeedback(event);
            that._moveHandler(event);
            event.originalEvent.preventDefault();
            event.originalEvent.stopPropagation();
            return false;
        }
    }

    _applyItemFeedback(event) {
        const that = this,
            target = event.originalEvent.target,
            targetItem = target.closest ? target.closest('jqx-list-item') : target;

        //Event.target doesn't work on Mobile. This is used just to the Drop logic inside upHandler
        if (JQX.Utilities.Core.isMobile) {
            JQX.ListBox.DragDrop.DropDetails = { item: JQX.ListBox.DragDrop.Item, position: 'bottom' };
            return;
        }

        if (that.items.length === 0) {
            return;
        }

        if (!targetItem) {
            that.items[that.items.length - 1]._itemOnMouseMove(event, true);
            return;
        }

        targetItem._itemOnMouseMove(event);
    }

    _moveHandler(event) {
        const that = this;

        if (!JQX.ListBox.DragDrop.Feedback || JQX.ListBox.DragDrop.DraggedFrom !== that) {
            return;
        }

        const dragOffset = that.dragOffset;

        if (!JQX.ListBox.DragDrop.Dragging) {
            const left = Math.abs(event.pageX - JQX.ListBox.DragDrop.StartPosition.left);
            const top = Math.abs(event.pageY - JQX.ListBox.DragDrop.StartPosition.top);
            const timeOut = new Date() - JQX.ListBox.DragDrop.StartTime;

            let canStartDrag = (left >= 5 && left <= 15) || (top >= 5 && top <= 15);

            if (JQX.Utilities.Core.isMobile) {
                if (timeOut < 300 || timeOut > 1000) {
                    canStartDrag = false;
                }
            }

            if (canStartDrag) {
                JQX.ListBox.DragDrop.Dragging = true;
                JQX.ListBox.DragDrop.Feedback.style.left = dragOffset[0] + event.pageX + 'px';
                JQX.ListBox.DragDrop.Feedback.style.top = dragOffset[1] + event.pageY + 'px';

                document.body.appendChild(JQX.ListBox.DragDrop.Feedback);
                event.preventDefault();
                event.stopPropagation();

                event.originalEvent.preventDefault();
                event.originalEvent.stopPropagation();

                const item = JQX.ListBox.DragDrop.Item;
                const listBox = item.ownerListBox;

                listBox.$.fireEvent('dragStart', {
                    'item': item,
                    'data': JQX.ListBox.DragDrop,
                    'container': listBox,
                    'previousContainer': listBox,
                    'originalEvent': event.originalEvent
                });

                document.body.classList.add('jqx-dragging');
            }
        }
        else {
            JQX.ListBox.DragDrop.Feedback.style.left = dragOffset[0] + event.pageX + 'px';
            JQX.ListBox.DragDrop.Feedback.style.top = dragOffset[1] + event.pageY + 'px';

            that.$.fireEvent('dragging', {
                'item': JQX.ListBox.DragDrop.Item,
                'data': JQX.ListBox.DragDrop,
                'originalEvent': event.originalEvent
            });

            for (let i = 0; i < JQX.ListBox.DragDrop.ListBoxes.length; i++) {
                const listBox = JQX.ListBox.DragDrop.ListBoxes[i];

                if (listBox._dragInterval) {
                    clearInterval(listBox._dragInterval);
                }

                listBox._dragInterval = setInterval(function () {
                    const rect = listBox.getBoundingClientRect();

                    if (rect.left <= event.clientX && rect.left + rect.width >= event.clientX) {
                        if (event.clientY >= rect.top && event.clientY <= rect.top + 20) {
                            listBox.scrollTop -= 2;
                        }
                        else if (event.clientY >= rect.top + rect.height - 20 && event.clientY <= rect.top + rect.height) {
                            listBox.scrollTop += 2;
                        }
                    }
                }, 1);
            }

            event.preventDefault();
            event.stopPropagation();

            event.originalEvent.preventDefault();
            event.originalEvent.stopPropagation();

            return false;
        }
    }

    _focusHandler() {
        const that = this;
        that._focused = true;
        that.setAttribute('focus', '');
    }

    _blurHandler() {
        const that = this;
        that._focused = false;
        that.removeAttribute('focus');
    }


    appendChild(node) {
        const that = this;

        if (!that.isCompleted) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (that.isVirtualized) {
            if (that._items.indexOf(node) > -1) {
                that._items.splice(that._items.indexOf(node), 1);
            }
            that._items.push(node);
        }
        else {
            node.dataItem = node;

            if (that.enableShadowDOM && that.shadowDomMode === 'light') {
                that.appendChild(node);
            }
            else {
                that.$.itemsInnerContainer.appendChild(node);
            }

            if (that._items.indexOf(node) > -1) {
                that._items.splice(that._items.indexOf(node), 1);
            }
            that._items.push(node);
        }
        that._refreshItems();
        that._refreshSelection();
    }

    insertBefore(newNode, referenceNode) {
        const that = this;

        if (!that.isCompleted) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (that.isVirtualized) {
            if (that._items.indexOf(newNode) > -1) {
                that._items.splice(that._items.indexOf(newNode), 1);
            }
            that._items.splice(that._indexOf(referenceNode), 0, newNode);
        }
        else {
            newNode.dataItem = newNode;
            referenceNode.parentNode.insertBefore(newNode, referenceNode);
            if (that._items.indexOf(newNode) > -1) {
                that._items.splice(that._items.indexOf(newNode), 1);
            }
            that._items.splice(that._indexOf(referenceNode), 0, newNode);
        }
        that._refreshItems();
        that._refreshSelection();
    }

    removeChild(node) {
        const that = this;

        if (!that.isCompleted) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (that.isVirtualized) {
            that._items.splice(that._indexOf(node), 1);
        }
        else {
            if (node.parentNode) {
                const selectedIndexes = that.selectedIndexes.slice(0),
                    selectedValues = that.selectedValues.slice(0),
                    selectedItemIndex = selectedIndexes.indexOf(node.dataIndex);

                node.parentNode.removeChild(node);

                if (selectedItemIndex > -1) {
                    selectedIndexes.splice(selectedItemIndex, 1);
                    selectedValues.splice(selectedItemIndex, 1);

                    that.selectedIndexes = selectedIndexes;
                    that.selectedValues = selectedValues;
                }
            }
        }
        that._refreshItems();
    }

    /**
   * Updates the listbox when a property is changed.
   * @param {string} propertyName The name of the property.
   * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
   * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
   */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this;

        switch (propertyName) {
            case 'innerHTML':
                that.clearSelection();
                that._dataBind();
                that.innerHTML = that.content = JQX.Utilities.Core.html(that.$.content);
                break;
            case 'dataSource':
            case 'valueMember':
            case 'groupMember':
            case 'displayMember': {
                that.clearSelection();
                that._dataBind();
                break;
            }
            case 'disabled':
            case 'unfocusable':
                that._setFocusable();
                break;
            case 'displayLoadingIndicator': {
                that._setLoadingIndicatorVisibility();
                break;
            }
            case 'filterable': {
                that._refreshFilter();
                that._refreshLayout();
                break;
            }
            case 'grouped': {
                if (newValue) {
                    that._group();
                }
                else {
                    that._ungroup();
                }

                if (that.selectionMode === 'radioButton') {
                    if (that.selectedValues.length > 0) {
                        const selectedValues = that.selectedValues;

                        that.clearSelection();
                        that.select(selectedValues[0]);
                    }
                }
                else {
                    that._refreshSelection();
                }

                that._refreshLayout();
                break;
            }
            case 'itemTemplate': {
                if (newValue === null || newValue === '') {
                    that._items.map((item) => item.innerHTML = item.label);
                    delete that._bindingDetails;
                    that._refreshLayout();
                    return;
                }

                const items = that.querySelectorAll('jqx-list-item');
                const itemsReady = function () {
                    if (that._handleItemTemplate(newValue)) {
                        that._items.map((item) => that._applyTemplate(item));
                        that._refreshLayout();
                    }

                    if (that.ownerElement && that.ownerElement._setDropDownSize) {
                        that.ownerElement._setDropDownSize();
                    }

                    that.$.fireEvent('bindingComplete');
                }

                if (items.length === 0) {
                    itemsReady();
                }
                else {
                    that._ensureItemsReady(items, itemsReady);
                }

                break;
            }
            case 'selectedIndexes':
            case 'selectedValues': {
                let _selectedIndexes = that.selectedIndexes.slice(0);
                let _selectedValues = that.selectedValues.slice(0);


                if (!that._items || that._items.length === 0) {
                    that.selectedIndexes = [];
                    that.selectedValues = [];

                    //Update the hidden form input
                    that.$.hiddenInput.value = that.selectedValues.toString();
                    return;
                }

                that._propertyChanging = true;

                if (propertyName === 'selectedIndexes') {
                    _selectedIndexes = oldValue.slice(0);
                    that.clearSelection();

                    for (let i = 0; i < newValue.length; i++) {
                        const index = newValue[i];
                        const item = that._items[index];

                        if (item) {
                            if (that.selectionMode === 'oneOrManyExtended' || that.selectionMode === 'oneOrMany') {
                                if (that.selectedIndexes.length > 0 && i === 0) {
                                    that.clearSelection();
                                }
                                that._select(item);
                            }
                            else {
                                that.select(item);
                            }
                        }
                    }
                }
                else {
                    _selectedValues = oldValue.slice(0);
                    that.selectedValues = [];
                    that.clearSelection();

                    for (let i = 0; i < newValue.length; i++) {
                        const selectedValue = newValue[i];
                        const item = that.getItem(selectedValue);

                        if (item) {
                            if (that.selectionMode === 'oneOrManyExtended') {
                                that._select(item);
                            }
                            else {
                                that.select(item);
                            }
                        }
                    }
                }

                if (that.selectedIndexes.length > 0) {
                    that._focus(that._items[that.selectedIndexes[0]]);
                }

                that._propertyChanging = false;

                if (JSON.stringify(_selectedValues) !== JSON.stringify(that.selectedValues.slice(0))) {
                    let selectedItems = [],
                        unselectedItems = [];

                    // get all newly unselected items
                    for (let i = 0; i < _selectedIndexes.length; i++) {
                        if (that.selectedIndexes.indexOf(_selectedIndexes[i]) < 0) {
                            unselectedItems.push(that._items[_selectedIndexes[i]]);
                        }
                    }

                    // get all newly selected items
                    for (let i = 0; i < that.selectedIndexes.length; i++) {
                        if (_selectedIndexes.indexOf(that.selectedIndexes[i]) < 0) {
                            selectedItems.push(that._items[that.selectedIndexes[i]]);
                        }
                    }

                    let eventDetails = {
                        'addedItems': selectedItems,
                        'removedItems': unselectedItems
                    };

                    if (that.selectedIndexes.length > 0) {
                        const lastSelectedItem = that._items[that.selectedIndexes[that.selectedIndexes.length - 1]];

                        if (lastSelectedItem !== undefined) {
                            eventDetails.selected = lastSelectedItem.selected;
                            eventDetails.disabled = lastSelectedItem.disabled;
                            eventDetails.index = that._indexOf(lastSelectedItem);
                            eventDetails.label = lastSelectedItem.label;
                            eventDetails.value = lastSelectedItem.value;
                        }
                    }
                    else {
                        eventDetails.selected = false;
                        eventDetails.disabled = false;
                        eventDetails.index = -1;
                        eventDetails.label = '';
                        eventDetails.value = '';
                    }

                    that.$.fireEvent('change', eventDetails);
                }

                break;
            }
            case 'selectionMode': {
                const displayMode = that.selectionMode === 'checkBox' || that.selectionMode === 'radioButton' ? that.selectionMode : 'plain';
                const _selectedIndexes = that.selectedIndexes.slice(0);
                const _selectedValues = that.selectedValues.slice(0);

                that._propertyChanging = true;

                const selectedValues = that.selectedValues;

                that.selectedValues = [];

                that.clearSelection();
                for (let i = 0; i < selectedValues.length; i++) {
                    const selectedValue = selectedValues[i];
                    const item = that.getItem(selectedValue);

                    if (item) {
                        if (that.selectionMode === 'oneOrManyExtended') {
                            that._select(item);
                        }
                        else {
                            that.select(item);
                        }
                    }
                }

                that._items.forEach(item => item.displayMode = displayMode);
                that._recycle();

                that._propertyChanging = false;

                if (JSON.stringify(_selectedValues) !== JSON.stringify(that.selectedValues.slice(0))) {
                    let selectedItems = [],
                        unselectedItems = [];

                    // get all newly unselected items
                    for (let i = 0; i < _selectedIndexes.length; i++) {
                        if (that.selectedIndexes.indexOf(_selectedIndexes[i]) < 0) {
                            unselectedItems.push(that._items[_selectedIndexes[i]]);
                        }
                    }

                    // get all newly selected items
                    for (let i = 0; i < that.selectedIndexes.length; i++) {
                        if (_selectedIndexes.indexOf(that.selectedIndexes[i]) < 0) {
                            selectedItems.push(that._items[that.selectedIndexes[i]]);
                        }
                    }

                    let eventDetails = {
                        'addedItems': selectedItems,
                        'removedItems': unselectedItems
                    };

                    if (_selectedIndexes.length > 0) {
                        const lastSelectedIndex = that._items[_selectedIndexes[_selectedIndexes.length - 1]];

                        if (lastSelectedIndex) {
                            eventDetails.selected = lastSelectedIndex.selected;
                            eventDetails.disabled = lastSelectedIndex.disabled;
                            eventDetails.index = that._indexOf(lastSelectedIndex);
                            eventDetails.label = lastSelectedIndex.label;
                            eventDetails.value = lastSelectedIndex.value;
                        }
                    }

                    that.$.fireEvent('change', eventDetails);
                }

                break;
            }
            case 'topVisibleIndex':
                that._setTopVisibleIndex(newValue);

                break;
            case 'autoSort':
                that._canSort = newValue;
                break;
            case 'sortDirection':
            case 'sorted': {
                that._canSort = true;

                if (newValue) {
                    that._sort();
                }
                else {
                    that._unsort();
                }

                const selectedValues = that.selectedValues;
                that.selectedValues = [];
                that._refreshSelection();
                for (let i = 0; i < selectedValues.length; i++) {
                    const selectedValue = selectedValues[i];
                    const item = that.getItem(selectedValue);

                    if (item) {
                        if (that.selectionMode === 'oneOrManyExtended') {
                            that._select(item);
                        }
                        else {
                            that.select(item);
                        }
                    }
                }

                that._refreshLayout();

                that._canSort = that.autoSort;
                break;
            }
        }
    }

    /**
    * refreshes selection items.
    */
    _refreshSelection() {
        const that = this;

        if (!that._items || that._items.length === 0) {
            return;
        }

        const selectedValues = that.selectedValues;

        that.selectedIndexes = [];
        that.selectedValues = [];

        for (let i = 0; i < that._items.length; i++) {
            const item = that._items[i];

            item.selected = false;

            if (selectedValues.indexOf(item.value) > -1) {
                that.select(item);
            }
        }

        that._recycle();
    }

    /**
      * Unselects all items.
      */
    clearSelection() {
        const that = this;

        if (!that._items || that._items.length === 0) {
            return;
        }

        let removedItems = [];

        for (let i = 0; i < that._items.length; i++) {
            if (that._items[i].selected) {
                removedItems.push(that._items[i]);
            }
        }

        that._items.map(item => item.selected = false);

        const _selectedValues = that.selectedValues.slice(0);
        const _selectedIndexes = that.selectedIndexes.slice(0);

        that.selectedIndexes = [];
        that.selectedValues = [];

        //Update the hidden form input
        that.$.hiddenInput.value = that.selectedValues.toString();

        that._recycle();

        if (that.context !== that) {
            let eventDetails = {
                'addedItems': [],
                'removedItems': removedItems
            };

            if (_selectedIndexes.length > 0) {
                const lastSelectedIndex = that._items[_selectedIndexes[_selectedIndexes.length - 1]];

                if (lastSelectedIndex) {
                    eventDetails.selected = lastSelectedIndex.selected;
                    eventDetails.disabled = lastSelectedIndex.disabled;
                    eventDetails.index = that._indexOf(lastSelectedIndex);
                    eventDetails.label = lastSelectedIndex.label;
                    eventDetails.value = lastSelectedIndex.value;
                }
            }

            that.$.fireEvent('change', eventDetails);
        }
    }

    ensureVisible(item) {
        const that = this;

        if (!item) {
            return;
        }

        if (typeof item === 'string') {
            item = that.getItem(item);
            if (!item) {
                return false;
            }
        }

        if (!that.isVirtualized && that.$.itemsContainer.scrollTop !== that.scrollTop) {
            that.scrollTop = that.$.itemsContainer.scrollTop;
        }

        if (item.top + item.height >= that.scrollTop + that.offsetHeight) {

            that.scrollTop = that.scrollTop + item.height;

            if (!that.isVirtualized) {
                that.$.itemsContainer.scrollTop = that.scrollTop;
            }
        }

        if (item.top <= that.scrollTop || item.top >= that.scrollTop + that.$.itemsContainer.offsetHeight) {
            that.scrollTop = item.top;

            if (!that.isVirtualized) {
                that.$.itemsContainer.scrollTop = that.scrollTop;
            }
        }

        if (that._indexOf(item) === 0 || (that._indexOf(item) === 1 && that._items.length > 1 && that._items[0].grouped)) {
            that.scrollTop = 0;
            if (!that.isVirtualized) {
                that.$.itemsContainer.scrollTop = that.scrollTop;
            }
        }
        else if (that._indexOf(item) === that._items.length - 1) {
            that.scrollTop = that.scrollHeight;

            if (!that.isVirtualized) {
                that.$.itemsContainer.scrollTop = that.scrollTop;
            }
        }

        return true;
    }
    /**
    * Returns an array with the items from the list.
    */
    get items() {
        const that = this;

        if (that._filteredItems) {
            return that._filteredItems;
        }

        return that._items;
    }

    /**
    * ListBox ready method.
    */
    ready() {
        super.ready();
        const that = this;

        //LightDom test
        if (that.enableShadowDOM && that.shadowDomMode === 'light') {
            const fragment = document.createDocumentFragment();

            [].slice.call(that.$.itemsInnerContainer.children).map(item => fragment.appendChild(item));

            that.appendChild(fragment);

            that.$.itemsInnerContainer.appendChild(document.createElement('slot'));
        }

        that._areCSSVarsSupported = JQX.Utilities.Core.CSSVariablesSupport();
        that._keysPressed = {};
        that._incrementalSearchQuery = '';
        that._incrementalSearchItems = [];
        that._canSort = true;
        that._previousEntry = '';
        that.isUpdating = 0;

        if (that._scrollView) {
            that._scrollView = new JQX.Utilities.Scroll(that, that.$.horizontalScrollBar, that.$.verticalScrollBar);
            that._scrollView.hScrollBar.$.addClass('jqx-hidden');
            that._scrollView.vScrollBar.$.addClass('jqx-hidden');
        }

        const vScrollBar = that._scrollView.vScrollBar;
        const hScrollBar = that._scrollView.hScrollBar;

        vScrollBar.hasStyleObserver = false;
        hScrollBar.hasStyleObserver = false;
        vScrollBar.hasResizeObserver = false;
        hScrollBar.hasResizeObserver = false;
        vScrollBar.wait = false;
        hScrollBar.wait = false;


        that._setFocusable();
        that._setLoadingIndicatorVisibility();
        that._refreshFilter();

        that._initializeInnerHTML();
        that._dataBind();
    }

    attached() {
        const that = this;

        super.attached();

        if (!JQX.ListBox.DragDrop) {
            JQX.ListBox.DragDrop = { ListBoxes: [] };
        }

        JQX.ListBox.DragDrop.ListBoxes.push(that);

        if (!that._scrollView) {
            that._scrollView = new JQX.Utilities.Scroll(that, that.$.horizontalScrollBar, that.$.verticalScrollBar);
        }

        if (that.selectedIndexes.length > 0) {
            that.ensureVisible(that._items[that.selectedIndexes[0]]);
        }
    }

    detached() {
        const that = this;

        super.detached();

        if (that._scrollView) {
            that._scrollView.unlisten();
            delete that._scrollView;
        }

        if (JQX.ListBox.DragDrop && JQX.ListBox.DragDrop.ListBoxes) {
            const index = JQX.ListBox.DragDrop.ListBoxes.indexOf(that);
            JQX.ListBox.DragDrop.ListBoxes.splice(index, 1);
        }
    }

    _createItem(item, index, recycling) {
        const that = this;

        const displayMode = that.selectionMode === 'checkBox' || that.selectionMode === 'radioButton' ? that.selectionMode : 'plain';
        const htmlItem = recycling ? {} : document.createElement('jqx-list-item');

        htmlItem.ownerListBox = that;

        if (typeof item === 'number') {
            item = '' + item;
        }

        const getMemberValue = function (memberName, defaultMemberName) {
            if (item[memberName] !== undefined) {
                return '' + item[memberName];
            }

            return item[defaultMemberName];
        }

        let label = typeof item === 'string' ? item : getMemberValue(that.displayMember, 'label'),
            value = typeof item === 'string' ? item : getMemberValue(that.valueMember, 'value'),
            group = getMemberValue(that.groupMember, 'group')

        if (undefined === label) {
            if (index !== undefined) {
                label = '' + index;
            }
            else {
                label = '';
            }
        }

        htmlItem.label = htmlItem.innerHTML = '' + label;

        if (undefined === value) {
            if (index !== undefined) {
                value = '' + index;
            }
            else {
                value = label;
            }
        }

        if (item.color) {
            htmlItem.color = item.color;
        }

        htmlItem.value = '' + value;
        htmlItem.displayMode = displayMode;
        htmlItem.selected = item.selected ? item.selected : false;
        htmlItem.disabled = item.disabled ? item.disabled : false;
        htmlItem.dataItem = htmlItem;

        if (index !== undefined) {
            htmlItem.dataIndex = index;
        }

        that._alternateItem(htmlItem);

        if (item.title) {
            htmlItem.title = item.title;
        }

        if (group) {
            htmlItem.group = '' + group;
        }

        return htmlItem;
    }

    _alternateItem(item) {
        const that = this;
        const start = that.alternationStart;
        const end = that.alternationEnd > 0 ? that.alternationEnd : Infinity;

        if (that.alternationCount <= 0) {
            return;
        }

        if (that._alternationIndexCounter === undefined) {
            that._alternationIndexCounter = 0;
        }

        if (item.dataIndex >= start && item.dataIndex <= end) {
            item.alternationIndex = that._alternationIndexCounter++;
            if (that._alternationIndexCounter === that.alternationCount) {
                that._alternationIndexCounter = 0;
            }
        }
    }

    _beginUpdate() {
        const that = this;

        that.isUpdating++;
    }

    _isUpdating() {
        const that = this;

        return that.isUpdating > 0;
    }

    _endUpdate() {
        const that = this;

        that.isUpdating--;
    }

    get _scrollHeight() {
        const that = this;

        let scrollHeight = 0;

        if (that.isVirtualized) {
            if (that.__scrollHeight) {
                return that.__scrollHeight;
            }

            if (that._items.length === 0) {
                return 0;
            }

            that.isUpdating++;

            const measureItem = that._createItem(that.dataSource[0]);
            that.$.itemsInnerContainer.appendChild(measureItem);

            for (let i = 0; i < that._items.length; i++) {
                const item = that._items[i];

                if (item.hidden) {
                    item.height = 0;
                    item.top = scrollHeight;
                    continue;
                }

                if (!that.itemHeight) {
                    measureItem.label = item.label;
                    item.height = measureItem.offsetHeight;
                }
                else {
                    if (that.itemHeight < 32) {
                        that.itemHeight = 32;
                    }

                    item.height = that.itemHeight;
                }

                item.top = scrollHeight;
                scrollHeight += item.height;
            }

            that.$.itemsInnerContainer.removeChild(measureItem)
            that.__scrollHeight = scrollHeight - that.$.itemsInnerContainer.offsetHeight;
            if (that.filterable) {
                that.__scrollHeight += that.$.filterInput.offsetHeight;
            }

            scrollHeight = that.__scrollHeight;
            that.isUpdating--;
        }
        else {
            for (let i = 0; i < that._items.length; i++) {
                const item = that._items[i];

                if (item.hidden) {
                    item.height = 0;
                    item.top = scrollHeight;
                    continue;
                }

                if (!that.itemHeight) {
                    item.height = item.offsetHeight;
                }
                else if (that.itemHeight !== 'auto') {
                    item.height = that.itemHeight;
                    item.style.height = item.height + 'px';
                }

                item.top = item.offsetTop;
                scrollHeight += item.height;
            }

            scrollHeight = that.$.itemsInnerContainer.scrollHeight - that.$.itemsInnerContainer.offsetHeight;

            if (that.filterable && scrollHeight > 0) {
                scrollHeight += that.$.filterInput.offsetHeight;
            }

            that.__scrollHeight = scrollHeight;
        }

        return scrollHeight;

        //Note: Incorrectly decreases the scrollHeight
        //let bottomOffset = 0;

        //if (scrollHeight) {
        //    bottomOffset = 2 * (parseInt(getComputedStyle(that.$.itemsInnerContainer).getPropertyValue('--jqx-list-item-vertical-offset')) || 0);
        //}

        //return scrollHeight - bottomOffset;
    }

    _initializeRecyclingItems() {
        const that = this;

        if ((!that.dataSource || (that.dataSource && that.dataSource.length === 0)) || !that.isVirtualized) {
            return;
        }

        let itemsHeight = 0;
        let listBoxHeight = that.offsetHeight;

        that.$.itemsInnerContainer.innerHTML = '';
        that._recyclingItems = [];

        const createRecyclingItems = function () {
            for (let i = 0; i < that.dataSource.length; i++) {
                const item = that.dataSource[i];
                const htmlItem = that._createItem(item);

                if (that.itemHeight && that.itemHeight !== 'auto') {
                    htmlItem.style.height = that.itemHeight + 'px';
                }

                that.$.itemsInnerContainer.appendChild(htmlItem);

                itemsHeight += htmlItem.offsetHeight;

                htmlItem.dataItem = that._items[i];
                that._recyclingItems.push(htmlItem);

                if (itemsHeight > 1.5 * listBoxHeight) {
                    break;
                }
            }
        }

        createRecyclingItems();

        let maxIterations = 0;

        while (itemsHeight < 1.5 * listBoxHeight && ++maxIterations < 5) {
            createRecyclingItems();
        }
    }

    _dataBind() {
        const that = this;

        if (!that._scrollView) {
            that._scrollView = new JQX.Utilities.Scroll(that, that.$.horizontalScrollBar, that.$.verticalScrollBar);
        }

        if (typeof that.dataSource === 'function') {
            that._items = [];
        }

        if (typeof that.dataSource === 'string') {
            that.dataSource = JSON.parse(that.dataSource);
        }

        if (that.dataSource !== null && Array.isArray(that.dataSource)) {
            that.isUpdating++;

            const initializeDataBoundItems = (fragment) => {
                that._items = [];
                that._groups = [];

                const dataSource = that.dataSource;

                for (let i = 0; i < dataSource.length; i++) {
                    const item = dataSource[i],
                        htmlItem = that._createItem(item, i, !fragment);

                    that._items[i] = htmlItem;

                    if (fragment) {
                        fragment.appendChild(htmlItem);
                    }
                }
            }

            if (that.isVirtualized) {
                initializeDataBoundItems();
                that._initializeRecyclingItems();
            }
            else {
                const fragment = document.createDocumentFragment();

                that.$.itemsInnerContainer.innerHTML = '';

                initializeDataBoundItems(fragment);
                that.$.itemsInnerContainer.appendChild(fragment);
            }

            that.isUpdating--;
        }

        const items = that.enableShadowDOM ? that.shadowRoot.querySelectorAll('jqx-list-item') : that.querySelectorAll('jqx-list-item');
        const itemsReady = function () {
            that.isUpdating++;

            if (!that.dataSource) {
                that._initializeHtmlListItems();
                that._initializeHtmlListGroups();
            }

            if (that.grouped) {
                that._group();
            }

            if (that.sorted) {
                that._sort();
            }

            that._refreshLayout();

            that._initializeSelection();
            that.isInitialized = true;
            that._canSort = that.autoSort;

            that.isUpdating--;

            if (that.itemTemplate) {
                if (that._handleItemTemplate(that.itemTemplate)) {
                    that._items.map((item) => that._applyTemplate(item));
                    that._refreshLayout();
                }
            }

            if (that.__onCompleted) {
                that._onCompleted = that.__onCompleted;
                that.__onCompleted = null;
                that._onCompleted();
            }


            if (that.topVisibleIndex > -1) {
                that._setTopVisibleIndex(that.topVisibleIndex);
            }

            that.$.fireEvent('bindingComplete');
            that._updateTopVisibleIndex();

            if (that._items.length === 0) {
                that.clearItems();
            }
        }

        if (items.length === 0) {
            itemsReady();
        }
        else {
            if (that._onCompleted) {
                that.__onCompleted = that._onCompleted;
                that._onCompleted = null;
            }
            that._ensureItemsReady(items, itemsReady);
        }
    }

    _ensureItemsReady(nodes, callback) {
        const that = this;

        const contextCallback = function () {
            const setContext = function (context) {
                for (let i = 0; i < nodes.length; i++) {
                    nodes[i].context = context === 'node' ? nodes[i] : document;
                }
            }

            setContext('node');
            callback();
            setContext();
        }

        if (nodes.length === 0) {
            contextCallback();
        }
        else {
            that._nodesReadyListeners = 0;

            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];

                const readyEventHandler = function () {
                    that._nodesReadyListeners--;
                    if (that._nodesReadyListeners === 0) {
                        contextCallback();

                        delete that._nodesReadyListeners;
                    }
                }.bind(that);

                if (!node.isCompleted) {
                    that._nodesReadyListeners++;
                    node._onCompleted = readyEventHandler;
                }
            }

            if (that._nodesReadyListeners === 0) {
                contextCallback();
            }
        }
    }

    _initializeInnerHTML() {
        const that = this;

        if (that.$.itemsInnerContainer.innerHTML.indexOf('<option') >= 0) {
            that.$.itemsInnerContainer.innerHTML = that.$.itemsInnerContainer.innerHTML.replace(/<optgroup/ig, '<jqx-list-items-group').replace(/<\/optgroup/ig, '<\/jqx-list-items-group').replace(/<option/ig, '<jqx-list-item').replace(/<\/option/ig, '<\/jqx-list-item');
        }
        else if (that.$.itemsInnerContainer.innerHTML.indexOf('<ul') >= 0) {
            that.$.itemsInnerContainer.innerHTML = that.$.itemsInnerContainer.innerHTML.replace(/<ul/ig, '<jqx-list-items-group').replace(/<\/ul/ig, '<\/jqx-list-items-group').replace(/<li/ig, '<jqx-list-item').replace(/<\/li/ig, '<\/jqx-list-item');
        }
    }

    _initializeHtmlListItems() {
        const that = this;

        const htmlItems = that.enableShadowDOM && that.shadowDomMode === 'shadow' ? that.shadowRoot.querySelectorAll('jqx-list-item') : that.querySelectorAll('jqx-list-item');
        const displayMode = that.selectionMode === 'checkBox' || that.selectionMode === 'radioButton' ? that.selectionMode : 'plain';

        const getMemberValue = function (item, memberName, defaultMemberName) {
            if (item[memberName] !== undefined) {
                return '' + item[memberName];
            }

            return item[defaultMemberName];
        }

        that._items = [];

        let top = 0;

        for (let i = 0; i < htmlItems.length; i++) {
            const item = htmlItems[i];

            item.dataIndex = i;
            item.label = item.innerHTML;
            item.dataItem = item;

            if (!item.top) {
                item.top = top;
            }

            if (!item.height) {
                item.height = item.offsetHeight;
            }

            top += item.height;

            if (!item.value) {
                item.value = '' + i;
            }

            const label = getMemberValue(item, that.displayMember, 'label');
            const value = getMemberValue(item, that.valueMember, 'value')
            const group = getMemberValue(item, that.groupMember, 'group')

            if (item.label !== label) {
                item.label = label;
            }

            if (item.value !== value) {
                item.value = value;
            }

            if (item.group !== group) {
                item.group = group;
            }

            //NOTE: the context must be set to document in order for item._setDisplayMode() to get called
            const originalContext = item.context;

            item.context = document;
            item.displayMode = displayMode;
            item.context = originalContext;

            that._alternateItem(item);

            if (item.selected) {
                that.selectedIndexes.push(i);
                that.selectedValues.push(item.value);
            }

            that._items.push(item);
        }

        if (that.itemTemplate && that._handleItemTemplate(that.itemTemplate)) {
            that._items.map((item) => that._applyTemplate(item));
        }
    }


    _group() {
        const that = this;

        that.isUpdating++;

        let groups = [];
        let items = [];

        if (that._canSort) {
            that._unsort();
        }

        for (let i = 0; i < that._items.length; i++) {
            const item = that._items[i];
            let label = item.group ? item.group.trim() : item.innerHTML.charAt(0) || item.label.charAt(0);
            label += ' ';

            if (!groups[label]) {
                groups[groups.length++] = groups[label] = { items: [item], label: label };
            }
            else {
                groups[label].items.push(item);
            }
        }

        if (!that.isVirtualized) {
            while (that.$.itemsInnerContainer.firstChild) {
                that.$.itemsInnerContainer.removeChild(that.$.itemsInnerContainer.firstChild);
            }

            const fragment = document.createDocumentFragment();

            that._groups = [];

            for (let i = 0; i < groups.length; i++) {
                const group = groups[i];
                const groupElement = document.createElement('jqx-list-items-group');

                groupElement.label = group.label;
                groupElement.dataIndex = i;

                for (let j = 0; j < groups[i].items.length; j++) {
                    const item = group.items[j];

                    items.push(item);
                    item.group = group.label;

                    groupElement.appendChild(item);
                }

                that._groups.push(groupElement);

                fragment.appendChild(groupElement);
            }

            that._items = items;

            const isIE = /Trident|Edge/.test(navigator.userAgent);
            if (isIE) {
                setTimeout(function () {
                    that.$.itemsInnerContainer.appendChild(fragment);
                }, 50);
            }
            else {
                that.$.itemsInnerContainer.appendChild(fragment);
            }
        }
        else {
            that._groups = [];

            for (let i = 0; i < groups.length; i++) {
                const group = groups[i];
                group.dataIndex = i;
                group.grouped = true;
                group.hidden = false;
                group.displayMode = 'plain';

                items.push(group);

                for (let j = 0; j < groups[i].items.length; j++) {
                    const item = group.items[j];

                    item.group = group;
                    items.push(item);
                }
            }

            that._groups = groups;
            that._items = items;
        }

        if (that.sorted) {
            that._sort();
        }

        that.isUpdating--;
    }

    _ungroup() {
        const that = this;

        that.isUpdating++;

        that._groups = [];
        if (that._canSort) {
            that._unsort();
        }

        let items = [];

        if (!that.isVirtualized) {
            const fragment = document.createDocumentFragment();

            for (let i = 0; i < that._items.length; i++) {
                const item = that._items[i];

                fragment.appendChild(item);
                items.push(item);
            }

            if (items.length > 0) {
                that.$.itemsInnerContainer.innerHTML = '';
                that.$.itemsInnerContainer.appendChild(fragment);
            }
        }
        else {
            for (let i = 0; i < that._items.length; i++) {
                const item = that._items[i];

                if (item.grouped) {
                    continue;
                }

                items.push(item);
            }
        }

        that._items = items;

        if (that.sorted) {
            that._sort();
        }

        that.isUpdating--;
    }

    _initializeHtmlListGroups() {
        const that = this;
        const htmlListItemsGroups = that.$.itemsInnerContainer.querySelectorAll('jqx-list-items-group');

        that._groups = [];

        for (let i = 0; i < htmlListItemsGroups.length; i++) {
            const group = htmlListItemsGroups[i];
            group.dataIndex = i;

            that._groups.push(group);
        }
    }

    _initializeSelection() {
        const that = this;
        /*
                if (that.selectionMode === 'one' || that.selectionMode === 'oneOrMany' || that.selectionMode === 'oneOrManyExtended') {
                    if (that.selectedIndexes.length === 0 && that.selectedValues.length === 0 && that._items.length > 0 && firstSelectableItem) {
                    }
                }
        */
        const selectedIndexes = that.selectedIndexes.slice(0);
        const selectedValues = that.selectedValues.slice(0);

        that.clearSelection();

        if (that.selectionMode === 'oneOrManyExtended') {
            that._keysPressed['Control'] = true;
        }

        for (let i = 0; i < that._items.length; i++) {
            const item = that._items[i];

            if (selectedIndexes.indexOf(i) >= 0 || selectedValues.indexOf(item.value || item.label) >= 0) {
                if (that._focusedItem) {
                    that._focusedItem._focused = false;
                }
                that._focusedItem = null;
                that.select(item);
            }
        }

        if (that.selectionMode === 'oneOrManyExtended') {
            that._keysPressed['Control'] = false;
        }
    }

    onItemUpdated() {
        const that = this;

        if (!that.isInitialized || that._isUpdating()) {
            return;
        }

        that.isUpdating++;
        that._refreshLayout();
        that.isUpdating--;
    }

    _refreshItems() {
        const that = this;

        if (!that.isInitialized || that._isUpdating()) {
            return;
        }

        that.isUpdating++;

        if (that.grouped) {
            that._ungroup();
        }
        else if (that.sorted && that._canSort) {
            that._unsort();
        }

        if (!that.isVirtualized) {
            that._items = [];

            const items = that.enableShadowDOM ? that.shadowRoot.querySelectorAll('jqx-list-item') : that.querySelectorAll('jqx-list-item');

            for (let i = 0; i < items.length; i++) {
                items[i].dataIndex = i;

                that._alternateItem(items[i]);
                that._items.push(items[i]);
            }
        }

        if (that.grouped) {
            that._group();
        }
        else if (that.sorted) {
            that._sort();
        }

        that._refreshLayout();
        that.isUpdating--;
    }

    /**
    * Incremental Search logic.
    */
    _applyIncrementalSearch(key) {
        const that = this;
        if (that.incrementalSearchDelay === null || isNaN(that.incrementalSearchDelay)) {
            return;
        }

        if (['Shift', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Control', 'Home', 'End', 'PageUp', 'PageDown'].indexOf(key) > -1) {
            return;
        }

        if (that._incrementalSearchQuery.indexOf(key) !== 0) {
            that._incrementalSearchQuery += key;
        }

        if (that._incrementalSearchTimer) {
            clearTimeout(that._incrementalSearchTimer);
        }

        that._incrementalSearch();
        that._incrementalSearchTimer = setTimeout(function () {
            that._incrementalSearchQuery = '';
        }, that.incrementalSearchDelay);
        return;
    }


    /**
    * Selects an item by its HTML Element or Value.
    */
    select(item) {
        const that = this;

        if (typeof item === 'string') {
            item = that.getItem(item);
            if (!item) {
                return;
            }
        }
        if (typeof item === 'number') {
            item = that.getItem(item);
            if (!item) {
                return;
            }
        }

        if (item.grouped || item.readonly) {
            return;
        }

        if (that.selectionMode === 'none') {
            that.selectedIndexes = [];
            that.selectedValues = [];
            return;
        }

        if (!that._focusedItem !== item && that.selectionMode !== 'none') {
            if (that._focusedItem) {
                that._focusedItem._focused = false;
            }

            that._focusedItem = item;
            item._focused = true;
        }

        switch (that.selectionMode) {
            case 'one':
                if (that.selectedIndexes.length === 1 && that.selectedIndexes[0] === that._indexOf(item)) {
                    return false;
                }

                that._previouslySelectedIndexes = that.selectedIndexes;

                if (that.selectedIndexes.length >= 1) {
                    that.clearSelection();
                }

                that._select(item);
                delete that._previouslySelectedIndexes;
                return true;
            case 'zeroOrOne':
                if (that.selectedIndexes.length === 1 && that.selectedIndexes[0] === that._indexOf(item)) {
                    that.unselect(item);
                    return true;
                }

                that._previouslySelectedIndexes = that.selectedIndexes;

                if (that.selectedIndexes.length >= 1) {
                    that.clearSelection();
                }

                that._select(item);
                delete that._previouslySelectedIndexes;
                return true;
            case 'radioButton':
                that._previouslySelectedIndexes = that.selectedIndexes;

                if (that.$.itemsInnerContainer.querySelectorAll('jqx-list-items-group').length > 0) {
                    const group = item.parentNode;


                    if (!item.selected) {
                        for (let index in group.children) {
                            const item = group.children[index];

                            if (item.selected) {
                                that.unselect(item);
                            }
                        }

                        that._select(item);
                    }

                    delete that._previouslySelectedIndexes;
                    return true;
                }
                else if (that.isVirtualized && that._groups.length > 0) {
                    const group = item.group;

                    if (!item.selected) {
                        for (let index in group.items) {
                            const item = group.items[index];

                            if (item.selected) {
                                that.unselect(item);
                            }
                        }

                        that._select(item);
                    }

                    delete that._previouslySelectedIndexes;
                    return true;
                }


                if (!item.selected) {
                    if (that.selectedIndexes.length >= 1) {
                        that.clearSelection();
                    }

                    that._select(item);
                }

                delete that._previouslySelectedIndexes;
                return true;
            case 'oneOrMany':
                if (!item.selected) {
                    that._select(item);
                }
                else if (that.selectedIndexes.length > 1) {
                    that.unselect(item);
                }
                return true;
            case 'zeroOrMany':
            case 'checkBox':
                if (!item.selected) {
                    that._select(item);
                }
                else {
                    that.unselect(item);
                }
                return true;
            case 'oneOrManyExtended': {
                const selectedValues = that.selectedValues;

                if (that._keysPressed['Control']) {
                    if (that.selectedIndexes.length > 1) {
                        if (item.selected) {
                            that.unselect(item);
                            that._focus(that._items[that.selectedIndexes[0]]);
                        }
                        else {
                            that._select(item);
                        }
                    }
                    else {
                        that._select(item);
                    }
                    return true;
                }

                if (that._keysPressed['Shift']) {
                    const selectedItem = that._items[that.selectedIndexes[0]];
                    let index;

                    that.clearSelection();

                    const preventEvent = selectedValues.indexOf(selectedItem.value) >= 0 || selectedItem.selected;

                    that._select(selectedItem, preventEvent);

                    if (that._indexOf(selectedItem) > that._indexOf(item)) {
                        index = that._indexOf(selectedItem) - 1;
                        while (index >= that._indexOf(item)) {
                            const item = that._items[index];
                            const preventEvent = selectedValues.indexOf(item.value) >= 0 || item.selected;

                            that._select(item, preventEvent);
                            index--;
                        }
                    }
                    else {
                        index = that._indexOf(selectedItem) + 1;
                        while (index <= that._indexOf(item)) {
                            const item = that._items[index];
                            const preventEvent = selectedValues.indexOf(item.value) >= 0 || item.selected;

                            that._select(item, preventEvent);
                            index++;
                        }
                    }

                    const unselectedItems = [];

                    for (let i = 0; i < selectedValues.length; i++) {
                        unselectedItems.push(that.getItem(selectedValues[i]));
                    }

                    if (unselectedItems.length > 0 && !that._propertyChanging) {
                        let selectedItems = [];

                        for (let i = 0; i < that.selectedValues.length; i++) {
                            const previousSelectedValue = that.selectedValues[i];

                            if (selectedValues.indexOf(previousSelectedValue) < 0) {
                                selectedItems.push(that.getItem(previousSelectedValue));
                            }
                        }

                        that.$.fireEvent('change', {
                            'addedItems': selectedItems,
                            'removedItems': unselectedItems,
                            'selected': item.selected,
                            'disabled': item.disabled,
                            'index': that._indexOf(item),
                            'label': item.label,
                            'value': item.value
                        });
                    }

                    return true;
                }

                for (let i = 0; i < selectedValues.length; i++) {
                    const value = selectedValues[i];
                    const selectedItem = that.getItem(value)

                    if (item !== selectedItem) {
                        that.unselect(selectedItem);
                    }
                }

                that.clearSelection();
                that._select(item, selectedValues.indexOf(item.value) >= 0);
                return true;

            }
        }

        return false;
    }

    /**
    * Returns the contents of the template with the new content applied.
    */
    _applyTemplate(item, refreshLayout) {
        const that = this;

        if (that.itemTemplate === null) {
            return;
        }

        if (typeof that.itemTemplate === 'function') {
            that.itemTemplate(item, { label: item.label, value: item.value, index: that._items.indexOf(item) });
            return;
        }

        if (!that._bindingDetails || that._bindingDetails.length === 0) {
            return;
        }

        const bindingsCount = that._bindingDetails.length;
        let clone = document.importNode(that._template.content, true),
            bindingHolderElement,
            bindingStringsCount;

        for (let b = 0; b < bindingsCount; b++) {
            bindingHolderElement = clone.childNodes[that._bindingDetails[b].childNodeIndex];
            bindingStringsCount = that._bindingDetails[b].bindingString.length;
            for (let i = 0; i < bindingStringsCount; i++) {
                const propertyName = that._bindingDetails[b].bindingString[i];
                const propertyValue = propertyName.indexOf('label') >= 0 ? item.label : item.value;

                bindingHolderElement.innerHTML = bindingHolderElement.innerHTML.replace(propertyName, propertyValue);
            }
        }

        item.innerHTML = '';
        for (let i = 0; i < clone.childNodes.length; i++) {
            if (clone.childNodes[i].outerHTML) {
                item.innerHTML += clone.childNodes[i].outerHTML;
            }
        }

        if (refreshLayout === false) {
            return;
        }

        if (that._scrollHeightTimer) {
            clearInterval(that._scrollHeightTimer);
            that._scrollHeightCounter = 0;
        }

        that._scrollHeightTimer = setInterval(function () {
            if (that._lastScrollHeight !== that.$.itemsInnerContainer.scrollHeight || that._scrollHeightCounter === 10) {
                that._refreshLayout();
                clearInterval(that._scrollHeightTimer);
            }
            that._lastScrollHeight = that.$.itemsInnerContainer.scrollHeight;
            that._scrollHeightCounter++;
        }, 50);

    }

    /**
     * Filter items.
     */
    _filterItems(noSelectionRefresh, callback, ignoreFilterQueryLength) {
        const that = this;
        const filterQuery = that.$.filterInput.value;
        let filteredItems, items;

        const updateListBox = function () {
            if (items.length === 0) {
                that._filteredItems = [];

                if (callback) {
                    callback();
                }

                return;
            }

            filteredItems = that._queryItems(filterQuery, that.filterMode);

            for (let i = 0; i < items.length; i++) {
                items[i].hidden = true;
                items[i].$.addClass('jqx-hidden');
            }

            for (let i = 0; i < filteredItems.length; i++) {
                const item = filteredItems[i];

                item.hidden = false;
                item.$.removeClass('jqx-hidden');
            }

            if (that.grouped && that.isVirtualized) {
                for (let i = 0; i < that._groups.length; i++) {
                    const group = that._groups[i];
                    const items = group.items;

                    let canHide = true;

                    for (let j = 0; j < items.length; j++) {
                        if (!items[j].hidden) {
                            canHide = false;
                        }
                    }

                    if (canHide) {
                        group.hidden = true;
                    }
                }
            }

            if (that.grouped && !that.isVirtualized) {
                for (let i = 0; i < that._groups.length; i++) {
                    const group = that._groups[i];
                    const items = [].concat(...group.querySelectorAll('jqx-list-item'));

                    let canHide = true;

                    for (let j = 0; j < items.length; j++) {
                        if (!items[j].$.hasClass('jqx-hidden')) {
                            canHide = false;
                        }
                    }

                    if (canHide) {
                        group.$.addClass('jqx-hidden');
                    }
                    else {
                        group.$.removeClass('jqx-hidden');
                    }
                }
            }

            that._filteredItems = filteredItems;
            that._refreshLayout();

            if (callback) {
                callback();
            }

            if (noSelectionRefresh) {
                return;
            }

            that._refreshSelection();
        }

        if (typeof (that.dataSource) === 'function') {
            if (filterQuery || ignoreFilterQueryLength) {
                const queryCallback = function (response) {
                    if ((!filterQuery && !ignoreFilterQueryLength) || !that.isAttached) {
                        return;
                    }

                    that._updateListBoxAfterQuery = function () {
                        filteredItems = items = that._items;
                        updateListBox();
                    };

                    that.clearItems();
                    that.insert(0, response);
                }

                const response = that.dataSource(filterQuery, queryCallback);

                if (response) {
                    if (!filterQuery && !ignoreFilterQueryLength) {
                        return;
                    }

                    that._updateListBoxAfterQuery = function () {
                        filteredItems = items = that._items;
                        updateListBox();
                    };

                    that.clearItems();
                    that.insert(0, response);
                }
            }
            else {
                that.clearItems();
                filteredItems = items = that._items;
                updateListBox();
            }
        }
        else {
            items = that._items;

            if (items.length === 0) {
                return;
            }

            updateListBox();
        }
    }

    /**
    * Returns the next item in the list.
    */
    _getNextItem(activeItemIndex) {
        const that = this,
            items = that._items,
            itemsCount = that._items.length;
        let index = Math.max(activeItemIndex + 1, 0);

        while (index < itemsCount) {
            const item = items[index];

            if (!item.disabled && !item.hidden && !item.grouped && !item.readonly) {
                return item;
            }

            index++;
        }

        return items[activeItemIndex];
    }

    /**
    * Returns the previous item in the list.
    */
    _getPreviousItem(activeItemIndex) {
        const that = this,
            items = that._items;
        let index = Math.max(activeItemIndex - 1, 0);

        while (index > -1) {
            const item = items[index];

            if (!item.disabled && !item.hidden && !item.grouped && !item.readonly) {
                return item;
            }

            index--;
        }

        return items[activeItemIndex];
    }

    /**
    * Calculates the width/height of the items.
    */
    get _scrollWidth() {
        const that = this,
            items = that._items;

        if (that.__scrollWidth) {
            return that.__scrollWidth;
        }

        that.__scrollWidth = (() => {
            const that = this;
            let longestItemWidth;

            let longestLabel = '';
            for (let i = 0; i < items.length; i++) {
                if (items[i].hidden) {
                    continue;
                }

                const label = items[i].label;
                if (label.length > longestLabel.length) {
                    longestLabel = label;
                }
            }

            const measureItem = that._createItem({ label: longestLabel });

            that.$.itemsContainer.appendChild(measureItem);
            measureItem.label = longestLabel;

            //This setting is enough to make the item width to 'auto' and measure it's size
            measureItem.style.width = 'auto';

            //if not checked, fails in Karma because element is not Completed
            if (measureItem.isCompleted) {
                measureItem.$.itemContainer.style.width = 'auto';
            }

            const measureItemStyle = getComputedStyle(measureItem);
            const padding = parseInt(measureItemStyle.paddingLeft) + parseInt(measureItemStyle.paddingRight);

            longestItemWidth = (measureItem.$.itemContainer || measureItem).offsetWidth + padding;

            measureItem.parentNode.removeChild(measureItem);


            return longestItemWidth;

        })();

        return that.__scrollWidth;
    }

    update(index, details) {
        const that = this;
        const htmlItem = that._items[index];

        if (htmlItem) {
            if (typeof details === 'string') {
                htmlItem.label = details;
                if (undefined === htmlItem.value) {
                    htmlItem.value = details;
                }
            }
            else {
                for (let detail in details) {
                    if (detail === 'selected' && htmlItem[detail] !== details[detail]) {
                        that.select(htmlItem);
                    }
                    else {
                        htmlItem[detail] = details[detail];
                    }

                    if (detail === 'group') {
                        that._refreshItems();
                    }
                }
            }

            if (that.sorted || that.grouped || that.isVirtualized) {
                that._refreshItems();
                that._refreshSelection();
            }
        }
        else {
            that.error(that.localize('indexOutOfBound', { elementType: that.nodeName.toLowerCase(), method: 'update' }));
        }
    }

    insert(index, items) {
        const that = this;
        let htmlItems = [];

        function itemsReady() {
            that._refreshItems();

            if (that._items.length === 0) {
                return;
            }

            if (that._updateListBoxAfterQuery) {
                that._updateListBoxAfterQuery();
                delete that._updateListBoxAfterQuery;
            }

            that._refreshSelection();

            that.$.fireEvent('bindingComplete');
        }

        if (!index) {
            index = 0;
        }

        if (Array.isArray(items)) {
            that.isUpdating++;
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const htmlItem = that._createItem(item);

                htmlItems.push(htmlItem);

                if (index >= that._items.length || that._items.length === 0) {
                    that.appendChild(htmlItem);
                }
                else {
                    that.insertBefore(htmlItem, that._items[index]);
                }
            }
            that.isUpdating--;
        }
        else {
            const htmlItem = that._createItem(items);

            htmlItems.push(htmlItem);

            if (index >= that._items.length || that._items.length === 0) {
                that.appendChild(htmlItem);
            }
            else {
                that.insertBefore(htmlItem, that._items[index]);
            }
        }

        if (htmlItems.length > 0) {
            htmlItems.map(item => that._applyTemplate(item));
            that._ensureItemsReady(htmlItems, itemsReady);
        }
    }

    remove(index) {
        const that = this;
        const htmlItem = that._items[index];

        if (htmlItem) {
            if (that.isVirtualized) {
                that._items.splice(index, 1);
            }
            else {
                htmlItem.parentNode.removeChild(htmlItem);
            }

            if (htmlItem.selected) {
                that.unselect(htmlItem);
            }

            that._refreshItems();
            that._refreshSelection();
            if (that.selectedIndexes.length === 0 && that._items.length > 0) {
                if (that.selectionMode === 'oneOrMany' || that.selectionMode === 'one' || that.selectionMode === 'oneOrManyExtended') {
                    that.select(that._items[0]);
                }
            }
        }
        else {
            that.error(that.localize('indexOutOfBound', { elementType: that.nodeName.toLowerCase(), method: 'remove' }));
        }
    }

    /**
      * Update all matched cases from the filter input.
      */
    _queryItems(searchQuery, searchMode) {
        const that = this;
        const result = [];
        const findItem = function (item, filterQuery) {
            if (item.grouped) {
                return item;
            }

            switch (searchMode) {
                case 'startsWith':
                    if (item.label.indexOf(filterQuery) === 0) {
                        return item;
                    }
                    break;
                case 'startsWithIgnoreCase':
                    if (item.label.toLowerCase().indexOf(filterQuery.toLowerCase()) === 0) {
                        return item;
                    }
                    break;
                case 'doesNotContain':
                    if (item.label.indexOf(filterQuery) < 0) {
                        return item;
                    }
                    break;
                case 'doesNotContainIgnoreCase':
                    if (item.label.toLowerCase().indexOf(filterQuery.toLowerCase()) < 0) {
                        return item;
                    }
                    break;
                case 'contains':
                    if (item.label.indexOf(filterQuery) > -1) {
                        return item;
                    }
                    break;
                case 'containsIgnoreCase':
                    if (item.label.toLowerCase().indexOf(filterQuery.toLowerCase()) > -1) {
                        return item;
                    }
                    break;
                case 'equals':
                    if (item.label.localeCompare(filterQuery) === 0) {
                        return item;
                    }
                    break;
                case 'equalsIgnoreCase':
                    if (item.label.toLowerCase().localeCompare(filterQuery.toLowerCase()) === 0) {
                        return item;
                    }
                    break;
                case 'endsWith':
                    if (item.label.endsWith(filterQuery)) {
                        return item;
                    }
                    break;
                case 'endsWithIgnoreCase':
                    if (item.label.toLowerCase().endsWith(filterQuery.toLowerCase())) {
                        return item;
                    }
                    break;
                case 'custom':
                    if (that.filterCallback(item, searchQuery)) {
                        return item;
                    }

                    break;
            }

            return null;
        }

        if (searchQuery.length === 0) {
            return that._items;
        }

        for (let i = 0; i < that._items.length; i++) {
            const item = findItem(that._items[i], searchQuery);

            if (item) {
                result.push(item);
            }
        }

        return result;
    }

    _select(item, preventEvent) {
        const that = this;
        const selectedIndex = that.selectedIndexes.indexOf(that._indexOf(item));
        const indexes = that.selectedIndexes.slice(0),
            values = that.selectedValues.slice(0);

        item.selected = true;

        if (selectedIndex === -1) {
            indexes.push(that._indexOf(item));
            values.push(item.value || item.label);
        }
        else {
            that._recycle();
            return false;
        }

        that.selectedIndexes = indexes;
        that.selectedValues = values;
        that._recycle();

        //Update the hidden form input
        that.$.hiddenInput.value = values.toString();

        if (!that.isCompleted || preventEvent || !that.isInitialized || that._propertyChanging) {
            return;
        }

        let previouslySelectedItems = [];

        if (that._previouslySelectedIndexes) {
            for (let i = 0; i < that._previouslySelectedIndexes.length; i++) {
                if (that.selectedIndexes.indexOf(that._previouslySelectedIndexes[i]) < 0) {
                    previouslySelectedItems.push(that._items[that._previouslySelectedIndexes[i]]);
                }
            }

            delete that._previouslySelectedIndexes;
        }

        that.$.fireEvent('change', {
            'addedItems': [item],
            'removedItems': previouslySelectedItems,
            'selected': item.selected,
            'disabled': item.disabled,
            'index': that._indexOf(item),
            'label': item.label,
            'value': item.value
        });

        return true;
    }

    /**
     * Handles the topVisibleIndex property. Sets an item always as first in the listBox view area
     * @param {any} item
     */
    _setTopVisibleIndex(item) {
        const that = this;

        if (typeof item === 'number') {
            that.topVisibleIndex = Math.max(0, item);
            item = that._items[that.topVisibleIndex];
        }

        if (!item) {
            return false;
        }

        if (item.top !== that.scrollTop) {
            that.scrollTop = item.top;

            if (!that.isVirtualized) {
                that.$.itemsContainer.scrollTop = that.scrollTop;
            }

            //Update topVisibleIndex to the first visible item
            if (that.scrollHeight === that.scrollTop) {
                that._updateTopVisibleIndex();
            }
        }
    }

    /**
     * Updates the topVisibleIndex
     */
    _updateTopVisibleIndex() {
        const that = this,
            minScrollTop = that.scrollTop + that._scrollView.verticalScrollBar.offsetHeight - that.offsetHeight;
        let lastVisibleItem;

        if (that.scrollTop < that.scrollHeight / 2) {
            for (let i = 0; i < that._items.length; i++) {
                if (that._items[i].top > minScrollTop) {
                    lastVisibleItem = that._items[i];
                    break;
                }
            }
        }
        else {
            for (let i = that._items.length - 1; i >= 0; i--) {
                if (that._items[i].top < minScrollTop) {
                    break;
                }

                lastVisibleItem = that._items[i];
            }
        }

        if (lastVisibleItem) {
            that.topVisibleIndex = lastVisibleItem.dataIndex;
        }
    }

    unselect(item) {
        const that = this;

        if (!item) {
            return;
        }

        if (typeof item === 'string') {
            item = that.getItem(item);
            if (!item) {
                return;
            }
        }

        if (that.selectionMode === 'none') {
            that.clearSelection();
            return;
        }

        const selectedIndex = that.selectedIndexes.indexOf(that._indexOf(item));
        const indexes = that.selectedIndexes.slice(0),
            values = that.selectedValues.slice(0);

        item.selected = false;

        if (selectedIndex >= 0) {
            indexes.splice(selectedIndex, 1);
            values.splice(selectedIndex, 1);
        }
        else {
            return false;
        }

        that.selectedIndexes = indexes;
        that.selectedValues = values;

        //Update the hidden form input
        that.$.hiddenInput.value = values.toString();

        if (!that.isCompleted || that._propertyChanging) {
            return;
        }

        that.$.fireEvent('change', {
            'addedItems': [],
            'removedItems': [item],
            'selected': item.selected,
            'disabled': item.disabled,
            'index': that._indexOf(item),
            'label': item.label,
            'value': item.value
        });

        that._recycle();

        return true;
    }

    /**
    * Validates the template and if valid, returns an object with binding details.
    */
    _handleItemTemplate(template) {

        if (template === null || !template) {
            return;
        }

        if (typeof template === 'function') {
            return template;
        }

        const that = this;

        if (!('content' in document.createElement('template'))) {
            that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() }));
            that.itemTemplate = null;
            return;
        }

        template = document.getElementById(template);
        if (template === null || !('content' in template)) {
            that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: 'itemTemplate' }));
            that.itemTemplate = null;
            return;
        }

        const templateContent = template.content,
            childrenCount = templateContent.childNodes.length,
            regex = /{{\w+}}/g;
        let bindingString,
            bindingsFound;

        that._bindingDetails = [];
        that._template = template;
        for (let i = 0; i < childrenCount; i++) {
            bindingsFound = [];
            while ((bindingString = regex.exec(templateContent.childNodes[i].innerHTML))) {
                bindingsFound.push(bindingString[0]);
            }

            if (bindingsFound.length > 0) {
                that._bindingDetails.push({ childNodeIndex: i, bindingString: bindingsFound });
            }
        }

        return true;
    }


    /**
    * Handles pressed keys.
    */
    _handleKeyStrokes(key) {
        const that = this;
        const toFocus = that.selectionMode === 'radioButton' || that.selectionMode === 'checkBox' || that.selectionMode === 'zeroOrMany'
            || that.selectionMode === 'oneOrMany' || that.selectionMode === 'zeroOrOne';
        let items = that._items;

        if (that.filterable && that.$.filterInput.value.length > 0) {
            items = that._filteredItems;
        }


        if (that.disabled || that.readonly) {
            return;
        }

        switch (key) {
            case 'ArrowLeft':
            case 'ArrowUp':
                that._handleArrowKeys(true);
                break;
            case 'ArrowRight':
            case 'ArrowDown':
                that._handleArrowKeys(false);
                break;
            case ' ': {
                if (that.selectedIndexes.length < 1 && !that._focusedItem) {
                    return;
                }

                const focusedItem = that._focusedItem ? that._focusedItem : that._items[that.selectedIndexes[that.selectedIndexes.length - 1]];

                const makeSelection = (item) => {
                    if (item.selected && that.selectionMode !== 'radioButton') {
                        that.unselect(item);
                    }
                    else {
                        that.select(item);
                    }
                }

                if (that.selectionMode === 'oneOrMany') {
                    if (focusedItem.selected && that.selectedIndexes.length > 1) {
                        makeSelection(focusedItem);
                    }
                    else if (!focusedItem.selected) {
                        makeSelection(focusedItem);
                    }
                    return;
                }

                makeSelection(focusedItem);
                break;
            }
            case 'Home': {
                if (items.length === 0) {
                    return;
                }

                if (toFocus) {
                    that._focus(items[0]);
                }
                else {
                    if (!that._keysPressed['Shift']) {
                        that.clearSelection();
                    }
                    that.select(items[0]);
                    that._focus(items[0]);
                }
                that.scrollTop = 0;
                break;
            }
            case 'End': {
                if (items.length === 0) {
                    return;
                }

                if (toFocus) {
                    that._focus(items[items.length - 1]);
                }
                else {
                    if (!that._keysPressed['Shift']) {
                        that.clearSelection();
                    }
                    that.select(items[items.length - 1]);
                    that._focus(items[items.length - 1]);
                }
                that.scrollTop = that.scrollHeight;
                break;
            }
            case 'PageUp': {
                that._pageUpKeyHandler(items);
                break;
            }
            case 'PageDown': {
                that._pageDownKeyHandler(items);
                break;
            }
        }

        that._recycle();
    }
    /**
    * Horizontal Scroll Bar handler
    */
    _horizontalScrollbarHandler(event) {
        const that = this;

        event.stopPropagation();

        if (that.isVirtualized) {
            that._recycle();
        }
        else {
            that.$.itemsContainer.scrollLeft = event.detail.value;
        }
    }

    _unsort() {
        const that = this;

        that.isUpdating++;

        const sortByIndex = function (a, b) {
            let indexA = a.dataIndex;
            let indexB = b.dataIndex;

            if (indexA < indexB) {
                return -1;
            }
            if (indexA > indexB) {
                return 1;
            }

            return 0;
        };

        if (!that.isVirtualized) {
            if (that._groups.length > 0) {
                that._groups.sort(sortByIndex);

                let sortedItems = [];

                for (let i = 0; i < that._groups.length; i++) {
                    const group = that._groups[i];
                    const items = [].concat(...group.querySelectorAll('jqx-list-item'));

                    items.sort(sortByIndex);
                    sortedItems = sortedItems.concat(items);
                }

                that._items = sortedItems;
            }
            else {
                that._items.sort(sortByIndex);
            }

            that._applySortOrder();
        }
        else {
            if (that._groups.length > 0) {
                that._groups.sort(sortByIndex);

                let sortedItems = [];

                for (let i = 0; i < that._groups.length; i++) {
                    const group = that._groups[i];
                    const items = [].concat(...group.items);

                    items.sort(sortByIndex);

                    sortedItems.push(group);
                    sortedItems = sortedItems.concat(items);
                }

                that._items = sortedItems;
            }
            else {
                that._items.sort(sortByIndex);
            }
        }

        that.isUpdating--;
    }

    _applySortOrder() {
        const that = this;

        const reorder = function (items) {
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const parentNode = item.parentNode;

                if (!parentNode) {
                    continue;
                }

                parentNode.appendChild(item);
            }
        }

        reorder(that._items);
        reorder(that._groups);
    }

    _sort() {
        const that = this;

        if (!that._canSort) {
            return;
        }

        that.isUpdating++;

        const sortByLabel = function (a, b) {
            let labelA = a.label;
            let labelB = b.label;

            if (that.sortDirection === 'asc') {
                if (labelA < labelB) {
                    return -1;
                }
                if (labelA > labelB) {
                    return 1;
                }
            }
            else {
                if (labelA < labelB) {
                    return 1;
                }
                if (labelA > labelB) {
                    return -1;
                }
            }

            return 0;
        };

        that._groups.sort(sortByLabel);

        if (!that.isVirtualized) {
            if (that._groups.length > 0) {
                let sortedItems = [];
                for (let i = 0; i < that._groups.length; i++) {
                    const group = that._groups[i];
                    const items = [].concat(...group.querySelectorAll('jqx-list-item'));

                    items.sort(sortByLabel);
                    sortedItems = sortedItems.concat(items);
                }

                that._items = sortedItems;
            }
            else {
                that._items.sort(sortByLabel);
            }

            that._applySortOrder();
        }
        else {
            if (that._groups.length > 0) {
                let sortedItems = [];
                for (let i = 0; i < that._groups.length; i++) {
                    const group = that._groups[i];
                    const items = [].concat(...group.items);

                    sortedItems.push(group);
                    items.sort(sortByLabel);
                    sortedItems = sortedItems.concat(items);
                }

                that._items = sortedItems;
            }
            else {
                that._items.sort(sortByLabel);
            }
        }

        that.isUpdating--;
    }

    getItem(value) {
        const that = this;

        for (let i = 0; i < that._items.length; i++) {
            if (that._items[i].value === value) {
                return that._items[i];
            }
        }

        return null;
    }

    _focus(item) {
        const that = this;

        if (!item || that.selectionMode === 'none' || that.disabled || that.readonly) {
            return;
        }


        if (that._focusedItem) {
            that._focusedItem._focused = false;
        }

        that._focusedItem = item;
        that._focusedItem._focused = true;
    }

    /**
     * KeyDown handler.
     */
    _keyDownHandler(event) {
        const that = this,
            activeElement = that.enableShadowDOM ? that.shadowRoot.activeElement : document.activeElement;

        let key = event.key;

        if (that.disabled || that.readonly) {
            return;
        }

        if (that.filterable && that.$.filterInput === activeElement) {
            return;
        }

        if (!that._focused) {
            return;
        }

        if (that._items.length === 0 || that.disabled || that.displayLoadingIndicator) {
            return;
        }

        if (that.editable) {
            if (key === 'F2') {
                that._dblclickEventHandler({ target: that._focusedItem });
                return;
            }
            else {
                if (that.$.editInput === activeElement) {
                    return;
                }
            }
        }

        if (that.selectionMode === 'none') {
            return;
        }

        event.stopPropagation();

        // Fix for not standartized event.key in Edge.
        switch (key) {
            case 'Down':
            case 'Right':
            case 'Left':
            case 'Up':
                key = 'Arrow' + key;
                break;
        }

        if (that.filterable) {
            switch (key) {
                case 'ArrowLeft':
                case 'ArrowRight':
                    return;
                case 'ArrowUp':
                case 'ArrowDown':
                    event.preventDefault();
            }
        }

        that._applyIncrementalSearch(key);
        if (['Shift', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Control', ' ', 'Home', 'End', 'PageUp', 'PageDown'].indexOf(key) < 0) {
            return;
        }

        event.preventDefault(); //prevent window scrolling

        if (!that._focusedItem && that._items.length > 0) {

            if (that.selectionMode === 'one' || that.selectionMode === 'oneOrMany' || that.selectionMode === 'oneOrManyExtended') {
                that.select(that._items[0]);
            }
            else {
                that._focus(that._items[0]);
            }
            return;
        }

        switch (that.selectionMode) {
            case 'one':
                if (key === 'Shift' || key === 'Control' || key === ' ') {
                    return;
                }

                that._handleKeyStrokes(key);
                break;
            case 'oneOrMany':
            case 'zeroOrOne':
            case 'zeroOrMany':
            case 'radioButton':
            case 'checkBox':
                if (key === 'Shift' || key === 'Control') {
                    return;
                }

                that._handleKeyStrokes(key);
                break;
            case 'oneOrManyExtended':
                if (key === ' ') {
                    return;
                }

                that._keysPressed[key] = event.type === 'keydown';
                that._handleKeyStrokes(key);
                break;
        }
    }

    /**
    * KeyUp handler.
    */
    _keyUpHandler(event) {
        const that = this,
            activeElement = that.enableShadowDOM ? that.shadowRoot.activeElement : document.activeElement;

        if (that.editable && that.$.editInput === activeElement) {
            return;
        }

        if (that.filterable && that.$.filterInput === activeElement) {
            if (that._filterTimer) {
                clearTimeout(that._filterTimer);
            }

            that._filterTimer = setTimeout(function () {
                const context = that.context;

                that.context = that;
                that._filterItems();
                that.scrollTop = that.$.itemsContainer.scrollTop = 0;
                that.scrollLeft = that.$.itemsContainer.scrollLeft = 0;
                that.context = context;
            }, 300);
            return;
        }

        if (!that._focused) {
            return;
        }

        if (that._focusedItem && that._focusedItem.hidden) {
            if (that._filteredItems.length > 0) {
                let itemToFocus = that._filteredItems[0];

                if (itemToFocus.grouped && that._filteredItems.length > 1) {
                    itemToFocus = that._filteredItems[1];
                }
                that._focus(itemToFocus);
                that._recycle();
            }
        }

        event.stopPropagation();
        event.preventDefault();

        if (that.disabled) {
            return;
        }

        if (['Shift', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Control', ' ', 'PageUp', 'PageDown'].indexOf(event.key) < 0) {
            return;
        }

        that._keysPressed[event.key] = false;
    }


    /**
    * Container mousewheel event handler.
    */
    _mouseWheelHandler(event) {
        const that = this;

        if (!that.computedHorizontalScrollBarVisibility && !that.computedVerticalScrollBarVisibility) {
            return;
        }

        if (!that.disabled && that.computedVerticalScrollBarVisibility) {
            event.stopPropagation();
            event.preventDefault();
            that.scrollTo(that.scrollTop + that._getScrollCoefficient(event, that.offsetHeight));
        }
    }

    /**
    * Page Down key handler.
    */
    _pageDownKeyHandler(items) {
        const that = this;

        if (items.length === 0) {
            return;
        }

        let selectedItem = that._items[that.selectedIndexes[that.selectedIndexes.length - 1]];
        if (that.selectionMode === 'checkBox' || that.selectionMode === 'radioButton' || that.selectionMode === 'zeroOrMany' ||
            that.selectionMode === 'oneOrMany' || that.selectionMode === 'zeroOrOne') {
            if (that._focusedItem) {
                selectedItem = that._focusedItem;
            }
        }

        let item;
        const selectedItemIndex = that._indexOf(selectedItem);
        let viewTop = selectedItem.top + that.$.itemsContainer.offsetHeight - selectedItem.height;

        for (let i = selectedItemIndex; i < items.length; i++) {
            if (items[i].top >= viewTop) {
                item = items[i];
                break;
            }
        }

        if (!item) {
            item = items[items.length - 1];
        }

        if (that.selectionMode === 'checkBox' || that.selectionMode === 'radioButton' || that.selectionMode === 'zeroOrMany'
            || that.selectionMode === 'oneOrMany' || that.selectionMode === 'zeroOrOne') {
            that._focus(item);
        }
        else {
            if (!item.selected) {
                if (!that._keysPressed['Shift']) {
                    that.clearSelection();
                }
                that.select(item);
                that._focus(item);
            }
        }

        if (item.height + item.top > that.$.itemsContainer.scrollTop + that.$.itemsContainer.offsetHeight ||
            item.top < that.$.itemsContainer.scrollTop) {
            that.scrollTop = item.top - that.$.itemsContainer.offsetHeight + item.height;
        }
    }

    /**
    * Page Up key handler.
    */
    _pageUpKeyHandler(items) {
        const that = this;

        if (items.length === 0) {
            return;
        }

        let selectedItem = that._items[that.selectedIndexes[that.selectedIndexes.length - 1]];

        if (that.selectionMode === 'checkBox' || that.selectionMode === 'radioButton' || that.selectionMode === 'zeroOrMany' ||
            that.selectionMode === 'oneOrMany' || that.selectionMode === 'zeroOrOne') {
            if (that._focusedItem) {
                selectedItem = that._focusedItem;
            }
        }

        const viewTop = selectedItem.top - that.$.itemsContainer.offsetHeight;
        const selectedItemIndex = that._indexOf(selectedItem);
        let item;


        for (let i = selectedItemIndex; i > 0; i--) {
            if (items[i].top <= viewTop) {
                item = items[i];
                break;
            }
        }

        if (!item) {
            item = items[0];
        }

        if (that.selectionMode === 'checkBox' || that.selectionMode === 'radioButton' || that.selectionMode === 'zeroOrMany' ||
            that.selectionMode === 'oneOrMany' || that.selectionMode === 'zeroOrOne') {
            that._focus(item);
        }
        else {
            if (!item.selected) {
                if (!that._keysPressed['Shift']) {
                    that.clearSelection();
                }
                that.select(item);
                that._focus(item);
            }
        }

        that.scrollTop = item.top;

        const itemIndex = that._indexOf(item);

        if (itemIndex === 0) {
            that.scrollTop = 0;
        }
    }

    /**
    * Removes all items from DOM. 
    */
    clearItems() {
        const that = this;

        that.$.itemsInnerContainer.innerHTML = '';
        that.clearSelection();
        that._items = [];
        that.$placeholder.removeClass('jqx-hidden');
    }

    /**
    * List Box resize handler.
    */
    _resizeHandler(event) {
        const that = this;

        if (event.target === that && !that._isUpdatingScrollBars) {
            that._isUpdatingScrollBars = true;
            that._initializeRecyclingItems();
            that._refreshLayout();
            that._isUpdatingScrollBars = false;
        }
    }

    _indexOf(item) {
        const that = this;

        if (!item) {
            return -1;
        }

        let index = that._items.indexOf(item);

        if (index === -1) {
            index = that._items.indexOf(that.getItem(item.value));
        }

        return index;
    }

    /**
    * Search items.
    */
    _incrementalSearch() {
        const that = this;
        const canSelect = that.selectionMode !== 'radioButton' && that.selectionMode !== 'checkBox' &&
            that.selectionMode !== 'zeroOrMany' && that.selectionMode !== 'oneOrMany' && that.selectionMode !== 'zeroOrOne';

        let searchQuery;
        let i = 0;

        switch (that.incrementalSearchMode) {
            case 'containsIgnoreCase':
            case 'equalsIgnoreCase':
            case 'startsWithIgnoreCase':
            case 'endsWithIgnoreCase':
                searchQuery = that._incrementalSearchQuery.toLowerCase();
                break;
            default:
                searchQuery = that._incrementalSearchQuery;
                break;
        }

        const select = function (item) {
            if (item.grouped || item.readonly) {
                return;
            }

            if (canSelect) {
                if (that.selectedIndexes.length > 0) {
                    that.clearSelection();
                }
                that._focus(item);
                that.select(item);
            }
            else {
                that._focus(item);
            }

            //Move the scrollBar when item is out of view
            if (item.height + item.top > that.$.itemsContainer.scrollTop + that.$.itemsContainer.offsetHeight ||
                item.top < that.scrollTop) {
                that.scrollTop = item.top;
            }
            if (that._indexOf(item) === 0) {
                that.scrollTop = 0;
            }
            if (that._indexOf(item) === that._items.length - 1) {
                that.scrollTop = that.scrollHeight;
            }
        }

        if (that._previousEntry.localeCompare(searchQuery) !== 0) {
            that._incrementalSearchItems = that._queryItems(that._incrementalSearchQuery, that.incrementalSearchMode);
            delete that._itemPosition;
        }

        //Previously entered string.
        that._previousEntry = searchQuery;

        const foundItemsCount = that._incrementalSearchItems.length;

        if (foundItemsCount === 0) {
            return;
        }

        if (foundItemsCount === 1) {
            select(that._incrementalSearchItems[0]);
            return;
        }

        if (that._itemPosition !== undefined) {
            if (that._itemPosition < foundItemsCount - 1) {
                i = that._itemPosition;
            }
            else {
                i = 0;
                if (canSelect) {
                    that._incrementalSearchItems[that._itemPosition].selected = false;
                    that.selectedIndexes = [];
                    that.selectedValues = [];
                }
                else {
                    that._incrementalSearchItems[that._itemPosition]._focused = false;
                }
            }
        }
        else if (canSelect) {
            that.clearSelection();
        }

        for (i; i < foundItemsCount; i++) {
            if (that._incrementalSearchItems[i].selected && canSelect) {
                that._incrementalSearchItems[i].selected = false;
                that.selectedIndexes = [];
                that.selectedValues = [];
                continue;
            }
            if (!canSelect && that._incrementalSearchItems[i]._focused) {
                that._incrementalSearchItems[i]._focused = false;
                continue;
            }
            select(that._incrementalSearchItems[i]);
            that._itemPosition = i;
            return;
        }
    }

    /**
    * Document select start handler.
    */
    _selectStartHandler(event) {
        const that = this,
            activeElement = that.enableShadowDOM ? that.shadowRoot.activeElement : document.activeElement;

        if (that.$.filterInput === activeElement) {
            return;
        }

        if (that.$.editInput === activeElement) {
            return;
        }

        event.preventDefault();
    }

    /**
    * Sets an item active via Keyboard.
    */
    /**
    * Sets an item active via Keyboard.
    */
    _handleArrowKeys(isArrowUp) {
        const that = this;
        const canSelect = that.selectionMode !== 'radioButton' && that.selectionMode !== 'checkBox' && that.selectionMode !== 'zeroOrMany' && that.selectionMode !== 'oneOrMany' && that.selectionMode !== 'zeroOrOne';

        if (that.disabled || that.readonly) {
            return;
        }

        let focusedItemIndex;

        if (that._focusedItem && !that._keysPressed['Shift']) {
            focusedItemIndex = that._indexOf(that._focusedItem);
            that._focusedItem._focused = false;
        }
        else if (that.selectedIndexes.length !== 0) {
            focusedItemIndex = that.selectedIndexes[that.selectedIndexes.length - 1]
        }
        else {
            return;
        }

        const focusedItem = isArrowUp ?
            that._getPreviousItem(focusedItemIndex) :
            that._getNextItem(focusedItemIndex);

        that._focus(focusedItem);

        if (canSelect) {
            if (that._keysPressed['Shift']) {
                that.select(focusedItem);
            }
            else if (that._items[focusedItemIndex] !== focusedItem) {
                that.clearSelection();
                that.select(focusedItem);
            }
        }

        that.ensureVisible(focusedItem);
    }
    /**
    * Enable/Disable the filter input component.
    */
    _refreshFilter() {
        const that = this;

        if (that.filterable) {
            that.$.filterInput.disabled = that.disabled || that.displayLoadingIndicator ? true : false;
            that.$filterInputContainer.removeClass('jqx-hidden');
            that.$itemsContainer.addClass('filter');
            return;
        }

        that.$.filterInput.disabled = true;
        that.$filterInputContainer.addClass('jqx-hidden');
        that.$itemsContainer.removeClass('filter');
    }

    /**
    * Set tabIndex.
    */
    _setFocusable() {
        const that = this;

        if (that.disabled || that.unfocusable) {
            that.removeAttribute('tabindex');
            return;
        }

        that.tabIndex = that.tabIndex > 0 ? that.tabIndex : 0;
    }

    /**
    * Set Loading Indicator Visibility
    */
    _setLoadingIndicatorVisibility() {
        const that = this;

        if (that.displayLoadingIndicator) {
            that.$loadingIndicatorContainer.hasClass('jqx-visibility-hidden') ?
                that.$loadingIndicatorContainer.removeClass('jqx-visibility-hidden') : that.$loadingIndicatorContainer.removeClass('jqx-hidden');
            return;
        }

        //Check for old browsers.
        that._areCSSVarsSupported ?
            that.$loadingIndicatorContainer.addClass('jqx-hidden') : that.$loadingIndicatorContainer.addClass('jqx-visibility-hidden');
    }

    /**
    * Sets the initial scroll bar sizes.
    */
    _refreshLayout() {
        const that = this;
        const source = that._items;

        that.__scrollHeight = null;
        that.__scrollWidth = null;
        that._height = null;

        if (!that._scrollView) {
            that._scrollView = new JQX.Utilities.Scroll(that, that.$.horizontalScrollBar, that.$.verticalScrollBar);
        }

        that.$itemsContainer.removeClass('hscroll');
        that.$itemsContainer.removeClass('vscroll');

        if (!source || source === null || source.length === 0) {
            that.scrollWidth = 0;
            that.scrollHeight = 0;
            that.$filterInputContainer.removeClass('vscroll');
            that.$placeholder.removeClass('jqx-hidden');

            if (that.isVirtualized) {
                that._recycle();
            }

            return;
        }

        that.$placeholder.addClass('jqx-hidden');

        const horizontalOffset = 2 * (parseInt(getComputedStyle(that.$.itemsInnerContainer).getPropertyValue('--jqx-list-item-horizontal-offset')) || 0);

        let hScrollWidth = that._scrollWidth - that.$.itemsContainer.offsetWidth - horizontalOffset;
        let vScrollHeight = that._scrollHeight;

        that._refreshHorizontalScrollBarVisibility(hScrollWidth);
        that._refreshVerticalScrollBarVisibility(vScrollHeight);


        if (that.horizontalScrollBarVisibility === 'hidden') {
            that.$.itemsInnerContainer.style.width = that.$.itemsContainer.offsetWidth - horizontalOffset;
        }
        else {
            that.$.itemsInnerContainer.style.width = Math.max(that.$.itemsContainer.offsetWidth - horizontalOffset, -horizontalOffset + that.__scrollWidth) + 'px';
        }

        if (that.computedVerticalScrollBarVisibility) {
            hScrollWidth = that._scrollWidth - that.$.itemsContainer.offsetWidth - that._scrollView.vScrollBar.offsetWidth;
            that._refreshHorizontalScrollBarVisibility(hScrollWidth);

            if (that.horizontalScrollBarVisibility !== 'hidden') {
                that.$.itemsInnerContainer.style.width = Math.max(that.$.itemsContainer.offsetWidth - horizontalOffset, -horizontalOffset + that.__scrollWidth - that._scrollView.vScrollBar.offsetWidth) + 'px';
            }

            if (that.computedHorizontalScrollBarVisibility) {
                if (!(that.horizontalScrollBarVisibility === 'visible' && that.scrollWidth === 0)) {
                    that.__scrollHeight += that._scrollView.hScrollBar.offsetHeight;
                }
                else if (that.horizontalScrollBarVisibility === 'visible') {
                    that.__scrollHeight += that._scrollView.hScrollBar.offsetHeight;
                }

                that.scrollHeight = that.__scrollHeight;
            }

            if (that.isVirtualized) {
                that._recycle();
            }

            return;
        }

        hScrollWidth = that._scrollWidth - that.$.itemsContainer.offsetWidth - horizontalOffset;
        that._refreshHorizontalScrollBarVisibility(hScrollWidth);

        if (that.computedHorizontalScrollBarVisibility) {
            that.scrollHeight = that._scrollHeight;
            that._refreshVerticalScrollBarVisibility(that.scrollHeight);

            //Resize event not thrown after 'bottom-corner' is applied
            if (that._scrollView.vScrollBar.$.hasClass('bottom-corner')) {
                that._scrollView.vScrollBar.refresh();
            }
        }

        if (that.isVirtualized) {
            that._recycle();
        }

        const isIE = /Trident|Edge/.test(navigator.userAgent);
        if (!that.isRefreshing && isIE) {
            setTimeout(function () {
                that.isRefreshing = true;
                that._refreshLayout();
                that.isRefreshing = false;
            }, 50);
        }
    }

    /**
    * Style change event.
    */
    _styleChangedHandler() {
        const that = this;

        that._refreshLayout();
    }

    /**
    * SwipeLeft event handler.
    **/
    _swipeLeftHandler() {
    }

    /**
    * SwipeRight event handler.
    */
    _swipeRightHandler() {
    }

    /**
    * Enable/Disable Horizontal Scroll bar.
    */
    _refreshHorizontalScrollBarVisibility(scrollWidth) {
        const that = this;

        that.scrollWidth = scrollWidth;

        if (that.computedHorizontalScrollBarVisibility) {
            that.scrollLeft = that.$.itemsContainer.scrollLeft;
            that.$itemsContainer.addClass('hscroll');
        }
        else {
            that.$itemsContainer.removeClass('hscroll');
        }
    }

    /**
    * Enable/Disable Vertical Scroll bar.
    */
    _refreshVerticalScrollBarVisibility(scrollHeight) {
        const that = this;

        that.scrollHeight = scrollHeight;

        if (that.computedVerticalScrollBarVisibility) {
            that.$itemsContainer.addClass('vscroll');
            that.$filterInputContainer.addClass('vscroll');

        }
        else {
            that.$itemsContainer.removeClass('vscroll');
            that.$filterInputContainer.removeClass('vscroll');
        }
    }

    /**
    * Validates Template properties.
    */
    _validateTemplate(property, template) {
        if (template === null || !template) {
            return;
        }

        const that = this;

        if (!('content' in document.createElement('template'))) {
            that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() }));
            that[property] = null;
            return;
        }

        template = document.getElementById(template);
        if (template === null || !('content' in template)) {
            that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: property }));
            that[property] = null;
            return;
        }

        return template;
    }

    _getItemIndexByPosition(position) {
        const that = this;

        const getItemIndex = (items) => {
            let bottomPointer = 0;
            let topPointer = items.length - 1;

            if (position <= 0) {
                return 0;
            }

            const lastNode = items[items.length - 1];

            if (lastNode.top <= position) {
                return items.length - 1;
            }

            const condition = true;

            while (condition) {
                const midPointer = Math.floor((bottomPointer + topPointer) / 2);
                const currentitem = items[midPointer];
                if (that._isItemInPosition(currentitem, position)) {
                    return midPointer;
                }
                else if (currentitem.top < position) {
                    bottomPointer = midPointer + 1;
                }
                else if (currentitem.top > position) {
                    topPointer = midPointer - 1;
                }
            }
        };

        const items = that.filterable && that.$.filterInput.value.length > 0 ? that._filteredItems : that._items;
        const index = getItemIndex(items);

        return index;
    }

    _isItemInPosition(item, position) {
        const topPixel = item.top;
        const bottomPixel = item.top + item.height;
        const pixelInRow = topPixel <= position && bottomPixel > position;

        return pixelInRow;
    }

    get isVirtualized() {
        const that = this;

        return that.virtualized && that.dataSource && that.dataSource.length > 0
    }

    _recycle() {
        const that = this;

        if (!that._recyclingItems) {
            return;
        }

        let height = that._height;
        if (!that._height) {
            height = that._height = that.$.itemsContainer.offsetHeight;
        }

        let j = 0;

        const value = that.scrollTop;
        const itemIndex = that._getItemIndexByPosition(value);
        const items = that.filterable && that.$.filterInput.value.length > 0 ? that._filteredItems : that._items;
        const item = items[itemIndex];

        let itemTop = item ? item.top : 0;

        that.$.itemsInnerContainer.style.left = -that.scrollLeft + 'px';
        that.$.itemsInnerContainer.style.top = -value + itemTop + 'px';

        that.isUpdating++;

        if (itemIndex >= 0) {
            for (let i = itemIndex; i < items.length; i++) {
                const item = items[i];

                if (item.height === 0) {

                    continue;
                }

                if (itemTop + item.height >= value && itemTop <= value + height) {
                    const listItem = that._recyclingItems[j++];

                    if (!listItem) {
                        break;
                    }

                    listItem.context = document;
                    listItem.dataItem = item;
                    listItem.label = item.label;
                    listItem.value = item.value;
                    listItem.selected = item.selected;
                    listItem._focused = item._focused;
                    listItem.hidden = item.hidden;
                    listItem.grouped = item.grouped;
                    listItem.readonly = item.readonly;
                    listItem.style.height = item.height + 'px';
                    that._alternateItem(listItem);

                    if (item.title) {
                        listItem.title = item.title;
                    }
                    else {
                        listItem.title = '';
                    }

                    if (!item.grouped) {
                        listItem.displayMode = item.displayMode;
                    }
                    else {
                        listItem.displayMode = 'plain';
                    }

                    if (that.scrollWidth > 0) {
                        listItem.style.width = that.$.itemsInnerContainer.offsetWidth + that.scrollWidth + 'px';
                    }

                    if (that.itemTemplate && that._handleItemTemplate(that.itemTemplate)) {
                        that._applyTemplate(listItem, false);
                    }
                }
                else {
                    break;
                }
                itemTop += item.height;
            }
        }

        if (j < that._recyclingItems.length) {
            for (let i = j; i < that._recyclingItems.length; i++) {
                const listItem = that._recyclingItems[j++];
                const context = listItem.context;

                listItem.context = document;
                listItem.hidden = true;
                listItem.context = context;
            }
        }

        that.isUpdating--;
    }

    /**
    * Vertical Scroll Bar handler
    */
    _verticalScrollbarHandler(event) {
        const that = this;
        const value = event.detail.value;
        event.stopPropagation();

        if (that.isVirtualized) {
            that._recycle();
        }
        else {
            that.$.itemsContainer.scrollTop = value;
        }

        that._updateTopVisibleIndex();

        if (event.context.max === event.context.value) {
            that.$.fireEvent('scrollBottomReached');
            return;
        }

        if (event.context.min === event.context.value) {
            that.$.fireEvent('scrollTopReached');
        }
    }
});
/**
 * Numeric text box custom element.
 */
JQX('jqx-numeric-text-box', class NumericTextBox extends JQX.BaseElement {
    /**
     * Numeric text box's properties.
     */
    static get properties() {
        return {
            'decimalSeparator': {
                value: '.',
                type: 'string'
            },
            'enableMouseWheelAction': {
                value: false,
                type: 'boolean'
            },
            'inputFormat': {
                value: 'integer',
                allowedValues: ['integer', 'floatingPoint', 'complex'],
                type: 'string'
            },
            'hint': {
                value: '',
                type: 'string'
            },
            'label': {
                value: '',
                type: 'string'
            },
            'leadingZeros': {
                value: false,
                type: 'boolean'
            },
            'max': {
                value: null,
                type: 'any'
            },
            'messages': {
                value: {
                    'en': {
                        'binary': 'BIN',
                        'octal': 'OCT',
                        'decimal': 'DEC',
                        'hexadecimal': 'HEX',
                        'integerOnly': 'jqxNumericTextBox: The property {{property}} can only be set when inputFormat is integer.',
                        'noInteger': 'jqxNumericTextBox: the property {{property}} cannot be set when inputFormat is integer.',
                        'significantPrecisionDigits': 'jqxNumericTextBox: the properties significantDigits and precisionDigits cannot be set at the same time.'
                    }
                },
                type: 'object',
                extend: true
            },
            'min': {
                value: null,
                type: 'any'
            },
            'name': {
                value: '',
                type: 'string'
            },
            'nullable': {
                value: false,
                type: 'boolean'
            },
            'opened': {
                value: false,
                type: 'boolean'
            },
            'outputFormatString': {
                value: null,
                type: 'string?'
            },
            'placeholder': {
                value: '',
                type: 'string'
            },
            'dropDownEnabled': {
                value: false,
                type: 'boolean'
            },
            'precisionDigits': {
                value: null,
                type: 'number?'
            },
            'radix': {
                value: 10,
                allowedValues: [2, 8, 10, 16, 'binary', 'octal', 'decimal', 'hexadecimal'],
                type: 'any'
            },
            'radixDisplay': {
                value: false,
                type: 'boolean'
            },
            'radixDisplayPosition': {
                value: 'left',
                allowedValues: ['left', 'right'],
                type: 'string'
            },
            'scientificNotation': {
                value: false,
                type: 'boolean'
            },
            'showUnit': {
                value: false,
                type: 'boolean'
            },
            'significantDigits': {
                value: null,
                type: 'number?'
            },
            'spinButtons': {
                value: false,
                type: 'boolean'
            },
            'spinButtonsDelay': {
                value: 75,
                type: 'number'
            },
            'spinButtonsInitialDelay': {
                value: 0,
                type: 'number'
            },
            'spinButtonsPosition': {
                value: 'right',
                allowedValues: ['left', 'right'],
                type: 'string'
            },
            'spinButtonsStep': {
                value: '1',
                type: 'any'
            },
            'type': {
                value: 'numeric',
                type: 'string',
                defaultReflectToAttribute: true,
                readonly: true
            },
            'unit': {
                value: 'kg',
                type: 'string'
            },
            'validation': {
                value: 'strict',
                allowedValues: ['strict', 'interaction'],
                type: 'string'
            },
            'value': {
                value: '0',
                type: 'any?'
            },
            'wordLength': {
                value: 'int32',
                allowedValues: ['int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32', 'int64', 'uint64'],
                type: 'string'
            }
        };
    }

    /**
     * Numeric text box's event listeners.
     */
    static get listeners() {
        return {
            'mouseenter': '_mouseenterMouseleaveHandler',
            'mouseleave': '_mouseenterMouseleaveHandler',
            'downButton.click': '_downButtonClickHandler',
            'downButton.mouseenter': '_mouseenterMouseleaveHandler',
            'downButton.mouseleave': '_mouseenterMouseleaveHandler',
            'dropDown.click': '_dropDownItemClickHandler',
            'dropDown.mouseout': '_mouseenterMouseleaveHandler',
            'dropDown.mouseover': '_mouseenterMouseleaveHandler',
            'input.blur': '_inputBlurHandler',
            'input.change': '_inputChangeHandler',
            'input.focus': '_inputFocusHandler',
            'input.keydown': '_inputKeydownHandler',
            'input.keyup': '_inputKeyupHandler',
            'input.paste': '_inputPasteHandler',
            'input.wheel': '_inputWheelHandler',
            'radixDisplayButton.click': '_radixDisplayButtonClickHandler',
            'radixDisplayButton.mouseenter': '_mouseenterMouseleaveHandler',
            'radixDisplayButton.mouseleave': '_mouseenterMouseleaveHandler',
            'upButton.click': '_upButtonClickHandler',
            'upButton.mouseenter': '_mouseenterMouseleaveHandler',
            'upButton.mouseleave': '_mouseenterMouseleaveHandler',
            'document.down': '_documentMousedownHandler',
            'document.up': '_documentMouseupHandler'
        };
    }

    /**
     * Numeric text box's required files.
     */
    static get requires() {
        if (window.NIComplex) {
            return {
                'JQX.Button': 'jqxbutton.js',
                'JQX.Utilities.BigNumber': 'jqxmath.js',
                'JQX.Utilities.NumericProcessor': 'jqxnumeric.js'
            };
        }

        return {
            'JQX.Button': 'jqxbutton.js',
            'JQX.Utilities.Complex': 'jqxcomplex.js',
            'JQX.Utilities.BigNumber': 'jqxmath.js',
            'JQX.Utilities.NumericProcessor': 'jqxnumeric.js'
        };
    }

    /**
     * CSS files needed for the element (ShadowDOM)
     */
    static get styleUrls() {
        return [
            'jqx.button.css',
            'jqx.numerictextbox.css'
        ]
    }

    /**
     * Numeric text box's HTML template.
     */
    template() {
        const template =
            '<div id="container" class="jqx-container">' +
            '<span id="label" inner-h-t-m-l="[[label]]" class="jqx-label"></span>' +
            '<div id="radixDisplayButton" class="jqx-unselectable jqx-input-addon jqx-numeric-text-box-component jqx-numeric-text-box-radix-display"></div>' +
            '<input id="input" type="text" spellcheck="false" class="jqx-input jqx-numeric-text-box-component" placeholder="[[placeholder]]" readonly="[[readonly]]" disabled="[[disabled]]" name="[[name]]" />' +
            '<div id="unitDisplay" class="jqx-unselectable jqx-input-addon jqx-numeric-text-box-component jqx-numeric-text-box-unit-display"></div>' +
            '<div id="spinButtonsContainer" class="jqx-input-addon jqx-numeric-text-box-component jqx-spin-buttons-container">' +
            '<jqx-repeat-button initial-delay="[[spinButtonsInitialDelay]]" delay="[[spinButtonsDelay]]" animation="[[animation]]" unfocusable id="upButton" class="jqx-spin-button">' +
            '<div class="jqx-arrow jqx-arrow-up"></div>' +
            '</jqx-repeat-button>' +
            '<jqx-repeat-button initial-delay="[[spinButtonsInitialDelay]]" delay="[[spinButtonsDelay]]" animation="[[animation]]" unfocusable id="downButton" class="jqx-spin-button">' +
            '<div class="jqx-arrow jqx-arrow-down"></div>' +
            '</jqx-repeat-button>' +
            '</div>' +
            '<ul id="dropDown" class="jqx-visibility-hidden jqx-drop-down">' +
            '<li id="dropDownItem2" class="jqx-list-item" data-value="2"></li>' +
            '<li id="dropDownItem8" class="jqx-list-item" data-value="8"></li>' +
            '<li id="dropDownItem10" class="jqx-list-item" data-value="10"></li>' +
            '<li id="dropDownItem16" class="jqx-list-item" data-value="16"></li>' +
            '</ul>' +
            '<span id="hint" class ="jqx-hint"  inner-h-t-m-l="[[hint]]"></span>' +
            '</div>';

        return template;
    }

    /**
     * Invoked when an instance of custom element is attached to the DOM for the first time.
     */
    ready() {
        super.ready();

        const that = this;

        that._numericProcessor = new JQX.Utilities.NumericProcessor(that, 'inputFormat');
        that._numberRenderer = new JQX.Utilities.NumberRenderer();
        that._numberRenderer.localizationObject.decimalseparator = that.decimalSeparator;

        that._radixPrefixes = { 10: 'd', 2: 'b', 8: 'o', 16: 'x' };

        // regular expressions for binary, octal, decimal and hexadecimal numbers
        that._regex = {
            2: new RegExp(/^[0-1]+$/),
            8: new RegExp(/^[0-7]+$/),
            10: new RegExp(/^[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?$/),
            16: new RegExp(/^[0-9a-f]+$/i)
        };
        // regular expressions for special values
        that._regexSpecial = {
            nan: new RegExp(/^(nan)$/i),
            inf: new RegExp(/^((-?inf(inity)?)|([+\-]?))$/i),
            nonNumericValue: new RegExp(/^$|(^((nan)|((-?inf(inity)?)|([+\-]?))|(null))$)/i),
            exaValue: new RegExp(/^[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[E][+\-]\d*)?i$/)
        }

        that._initialDropDownOptionsSet = false;

        if (that.spinButtonsPosition === 'left') {
            that.$.container.insertBefore(that.$.spinButtonsContainer, that.$.label.nextElementSibling);
        }

        if (that.radixDisplayPosition === 'right') {
            that.$.container.insertBefore(that.$.radixDisplayButton, that.$.unitDisplay.nextElementSibling);
        }

        that._setInitialComponentDisplay();

        that._initialAdjustments();

        that._refreshShape();

        that._initialized = true;
    }

    _refreshShape() {
        const that = this;

        const addons = that.$.container.querySelectorAll('.jqx-numeric-text-box-component:not(.jqx-hidden)');

        if (addons.length > 0) {
            addons[0].classList.add('jqx-numeric-text-box-component-border-left');
            addons[addons.length - 1].classList.add('jqx-numeric-text-box-component-border-right');
        }
    }

    /*
     * Public methods
     */

    /**
     * Sets or gets the value of the numeric text box.
     *
     * @param {Number/String} value Optional value to be set to the numeric text box. If this parameter is not set, the method gets the value.
     * @param {Boolean} suppressValidation Optional If true is passed, the value is not validated.
     */
    val(value, suppressValidation) {
        const that = this,
            isEmptyObject = value !== null && typeof value === 'object' && Object.keys(value).length === 0;

        if (value !== undefined && isEmptyObject === false) {
            // use as value setter
            const oldValue = that.value;

            if ((value === '' || value === null) && oldValue === null) {
                return null;
            }

            if (value === null) {
                that._triggerChangeEvent = that.validation === 'strict';
                that._validate(false, null);
                that._triggerChangeEvent = false;
                that._programmaticValueIsSet = true;
                return;
            }

            value = value.toString();
            if (value.toUpperCase() !== oldValue.toString().toUpperCase()) {
                if (suppressValidation === undefined) {
                    // sets the value after validation
                    that._triggerChangeEvent = that.validation === 'strict';
                    that._validate(false, value);
                    that._triggerChangeEvent = false;
                }
                else {
                    // sets the value without validation
                    that._setValue(value);
                }

                that._programmaticValueIsSet = true;
            }
            else {
                return value;
            }
        }
        else {
            // use as value getter
            return that.value;
        }
    }

    /**
     * Focuses the input of the numeric text box.
     */
    focus() {
        this.$.input.focus();
    }

    /*
     * Private methods
     */

    /**
     * Updates the internal spin buttons step object ("_spinButtonsStepObject").
     */
    _updateSpinButtonsStepObject() {
        const that = this;
        that._spinButtonsStepObject = that._numericProcessor.createDescriptor(that.spinButtonsStep, true);
    }

    /**
     * Sets the initial display of the various numeric text box components.
     */
    _setInitialComponentDisplay() {
        const that = this;

        if (that.spinButtons === false) {
            that.$spinButtonsContainer.addClass('jqx-hidden');
        }

        if (that.radixDisplay === false) {
            that.$radixDisplayButton.addClass('jqx-hidden');
        }

        if (that.showUnit === false) {
            that.$unitDisplay.addClass('jqx-hidden');
        }
    }

    /**
     * Makes initial validations and adjustments to the numeric text box.
     */
    _initialAdjustments() {
        const that = this;

        that._radixNumber = that._getRadix(that.radix);
        that._wordLengthNumber = that._numericProcessor.getWordLength(that.wordLength);

        that._validatePropertyCompatibility();
        that._numericProcessor.validateMinMax(true, true);

        that._updateSpinButtonsStepObject();

        that._validate(true);
        that._programmaticValueIsSet = true;
        that._cachedInputValue = that.$.input.value;

        if (that._editableValue === undefined) {
            that._editableValue = that._cachedInputValue;
        }

        that.$.radixDisplayButton.innerHTML = that._radixPrefixes[that._radixNumber];
        that.$.unitDisplay.innerHTML = that.unit;

        if (that.disabled) {
            that.$.upButton.disabled = true;
            that.$.downButton.disabled = true;
        }

        if (that.opened) {
            if (that.dropDownEnabled && !that.disabled && that.value !== null) {
                that._openRadix();
            }
            else {
                that.opened = false;
            }
        }

        that._setFocusable();
    }

    /**
     * Validates some initial non-numeric property values.
     */
    _validatePropertyCompatibility() {
        const that = this;

        if (that.inputFormat !== 'integer') {
            if (that._radixNumber !== 10) {
                that.error(that.localize('integerOnly', { property: 'radix' }));
            }

            if (that.radixDisplay) {
                that.error(that.localize('integerOnly', { property: 'radixDisplay' }));
            }

            if (that.dropDownEnabled) {
                that.error(that.localize('integerOnly', { property: 'dropDownEnabled' }));
            }

            if (that.wordLength !== 'int32') {
                that.error(that.localize('integerOnly', { property: 'wordLength' }));
            }
        }
        else if (that.precisionDigits !== null) {
            that.error(that.localize('noInteger', { property: 'precisionDigits' }));
        }

        if (that.significantDigits === null && that.precisionDigits === null) {
            that.significantDigits = 8;
        }
        else if (that.significantDigits !== null && that.precisionDigits !== null) {
            that.error(that.localize('significantPrecisionDigits'));
        }
    }

    /**
     * Validates the value of the numeric text box.
     */
    _validate(initialValidation, programmaticValue) {
        const that = this;
        let value;

        if (initialValidation) {
            value = that.value;

            if (value === undefined) {
                if (that.nullable) {
                    value = null;
                }
                else {
                    value = '0';
                }
            }
        }
        else {
            if (programmaticValue === undefined || (programmaticValue === null && !that.nullable)) {
                value = that.$.input.value;
                if (value === that.value && that._programmaticValueIsSet !== true) {
                    that.$.input.value = that._cachedInputValue;
                    return;
                }
            }
            else {
                value = programmaticValue;
            }
        }

        if (that.nullable && (value === null || value === '')) {
            that.value = null;
            that._number = null;
            that.$.input.value = '';
            that._cachedInputValue = '';
            that._editableValue = '';
            that._disableComponents();
            return;
        }

        const validationOptions = that._numericProcessor.prepareForValidation(initialValidation, programmaticValue, value);
        if (validationOptions === undefined) {
            that._disableComponents();
            return;
        }

        const validNumber = that._numericProcessor.createDescriptor(
            validationOptions.value,
            true,
            true,
            (!initialValidation && programmaticValue === undefined) || that.validation === 'strict',
            initialValidation || programmaticValue !== undefined,
            validationOptions.enteredComplexNumber
        );

        if (initialValidation) {
            that._number = validNumber;
            let renderedValue = that._renderValue(validNumber);
            that.value = validNumber.toString();
            that.$.input.value = renderedValue;
        }
        else {
            that._updateValue(validNumber);
        }

        that._programmaticValueIsSet = false;

        that._disableComponents();
    }

    /**
     * Validates the value of the numeric text box when it is not a number.
     */
    _handleNonNumericValue(initialValidation, programmaticValue, value) {
        const that = this;
        if (that.inputFormat !== 'integer') {
            if (that._regexSpecial.nan.test(value)) {
                // 'NaN' (or a derivative) has been entered
                that._handleNaN(initialValidation);
                return;
            }

            if (that._regexSpecial.inf.test(value)) {
                // '(-)Inf' (or a derivative) has been entered
                that._handleInfinity(initialValidation, programmaticValue, value);
                return;
            }
        }

        // invalid input
        if (initialValidation) {
            let defaultValue = that._numericProcessor.createDescriptor(0);
            that._number = that._validateRange(defaultValue);
            const defaultValidValue = that._renderValue(that._number);
            that.value = that._number.toString();
            that.$.input.value = defaultValidValue;
        }
        else {
            // the old value is reverted
            if (programmaticValue === undefined) {
                that.$.input.value = that._cachedInputValue;
            }
            else {
                const correctValue = that._number.toString();
                if (that.value !== correctValue) {
                    that.value = correctValue;
                }
            }
        }
    }

    /**
     * Handles NaN (or derivative) entered value.
     */
    _handleNaN(initialValidation) {
        const that = this;

        that.$.input.value = 'NaN';

        if (initialValidation) {
            that.value = NaN;
            that._number = NaN;
        }
        else {
            const oldValue = that.value;

            if (oldValue === null || oldValue.toString() !== 'NaN') {
                that.value = NaN;
                that._number = NaN;

                that._cachedInputValue = 'NaN';
                that._editableValue = 'NaN';
                if (that._triggerChangeEvent) {
                    that.$.fireEvent('change', { 'value': NaN, 'oldValue': oldValue, 'radix': that._radixNumber });
                }
            }
        }
    }

    /**
     * Handles (-)Infinity (or derivative) entered value.
     */
    _handleInfinity(initialValidation, programmaticValue, value) {
        const that = this;
        let newInputValue, newValue;

        if (value.charAt(0) === '-') {
            if (value.charAt(1) === '') {
                newInputValue = '-';
            }
            else {
                newInputValue = '-Inf';
            }

            newValue = -Infinity;
        }
        else {
            if (value.indexOf('') !== -1) {
                newInputValue = '';
            }
            else {
                newInputValue = 'Inf';
            }

            newValue = Infinity;
        }

        if (newValue === -Infinity && that.min === -Infinity ||
            newValue === Infinity && that.max === Infinity ||
            programmaticValue !== undefined) {
            if (initialValidation) {
                that.value = newValue;
                that._number = newValue;
                that.$.input.value = newInputValue;
            }
            else {
                const oldValue = that.value;
                if (value !== newInputValue) {
                    that.$.input.value = newInputValue;
                }

                if (oldValue !== newValue) {
                    that.value = newValue;
                    that._number = newValue;

                    that._cachedInputValue = newInputValue;
                    that._editableValue = newInputValue;
                    if (that._triggerChangeEvent) {
                        that.$.fireEvent('change', { 'value': newValue, 'oldValue': oldValue, 'radix': that._radixNumber });
                    }
                }
            }
        }
        else {
            // if -Infinity/Infinity is out of the "min"-"max" range, the value is set to "min"/"max" instead
            if (newValue === -Infinity) {
                that._validate(false, that.min);
            }
            else {
                that._validate(false, that.max);
            }
        }
    }

    /**
     * Checks if the value is within the range from min to max.
     */
    _validateRange(numberToValidate) {
        const that = this;
        numberToValidate = that._numericProcessor.validate(numberToValidate, that._minObject, that._maxObject);
        return numberToValidate;
    }

    /**
     * Invoked when the value of a public property has been changed by the user.
     */
    propertyChangedHandler(key, oldValue, value) {
        super.propertyChangedHandler(key, oldValue, value);

        const that = this,
            input = that.$.input;

        function handleLeadingZeros() {
            if (that._initialDropDownOptionsSet === true) {
                that._setDropDownOptions();
            }

            if (that._radixNumber === 2 || that._radixNumber === 16) {
                that._cachedInputValue = that._number.toString(that._radixNumber, that._wordLengthNumber, that.leadingZeros);
                that._editableValue = that._cachedInputValue;
                that.$.input.value = that._cachedInputValue;
            }
        }

        // eslint-disable-next-line
        if (value != oldValue) {
            switch (key) {
                case 'disabled':
                    that._setFocusable();

                    if (value === true) {
                        that.$.upButton.disabled = true;
                        that.$.downButton.disabled = true;
                    }
                    else {
                        that._disableComponents();
                    }

                    break;
                case 'unfocusable':
                    that._setFocusable();
                    break;
                case 'enableMouseWheelAction':
                case 'placeholder':
                case 'readonly':
                case 'spinButtonsDelay':
                case 'spinButtonsInitialDelay':
                    break;
                case 'value': {
                    if (value === '' && oldValue === null) {
                        return;
                    }

                    if (value === null || value === '' || oldValue === null) {
                        that.value = oldValue;
                        that._triggerChangeEvent = that.validation === 'strict';
                        that._validate(false, value);
                        that._triggerChangeEvent = false;
                        that._programmaticValueIsSet = true;
                        return;
                    }

                    const stringValue = value.toString(),
                        stringOldValue = oldValue.toString();

                    if (stringOldValue !== stringValue) {
                        if (stringOldValue.toUpperCase() === stringValue.toUpperCase()) {
                            that.value = oldValue;
                        }

                        that.value = oldValue;
                        that._triggerChangeEvent = that.validation === 'strict';
                        that._validate(false, stringValue);
                        that._triggerChangeEvent = false;
                        that._programmaticValueIsSet = true;
                    }
                    break;
                }
                case 'radix':
                    if (that.inputFormat === 'integer') {
                        that._changeRadix(value);
                    }
                    else {
                        that.error(that.localize('integerOnly', { property: 'radix' }));
                    }
                    break;
                case 'leadingZeros':
                    if (that.inputFormat === 'integer' && that._number !== null) {
                        handleLeadingZeros();
                    }

                    break;
                case 'min':
                case 'max': {
                    if (value !== null) {
                        that[`_${key}IsNull`] = false;
                    }
                    that._numericProcessor.validateMinMax(key === 'min', key === 'max');

                    if (that.validation === 'strict') {
                        that._triggerChangeEvent = true;
                        that._validate(false, that.value);
                        that._triggerChangeEvent = false;
                    }
                    else if (that._regexSpecial.nonNumericValue.test(that.value) === false) {
                        const numberToValidate = that._numericProcessor.createDescriptor(that._number),
                            validValue = that._validateRange(numberToValidate);

                        if (that._numericProcessor.compare(that.value, validValue) === true) {
                            that._programmaticValueIsSet = true;
                        }
                    }
                    break;
                }
                case 'opened':
                    if (value) {
                        if (that.dropDownEnabled && !that.disabled && that.value !== null) {
                            that._openRadix();
                        }
                        else {
                            that.opened = false;
                        }
                    }
                    else {
                        that._closeRadix();
                    }
                    break;
                case 'outputFormatString':
                    if (value) {
                        that._cachedInputValue = that._numberRenderer.formatNumber(that._number, value);
                        that.$.input.value = that._cachedInputValue;
                    }
                    else {
                        that._cachedInputValue = that._editableValue;
                        that.$.input.value = that._editableValue;
                    }

                    break;
                case 'dropDownEnabled':
                    if (value) {
                        if (that.inputFormat !== 'integer') {
                            that.error(that.localize('integerOnly', { property: 'dropDownEnabled' }));
                        }

                        if (that._initialDropDownOptionsSet === true) {
                            that._setDropDownOptions();
                        }
                    }
                    else if (that.opened) {
                        that._closeRadix();
                    }
                    break;
                case 'spinButtons':
                    if (value) {
                        that.$spinButtonsContainer.removeClass('jqx-hidden');
                    }
                    else {
                        that.$spinButtonsContainer.addClass('jqx-hidden');
                    }
                    that._refreshShape();
                    break;
                case 'spinButtonsStep':
                    that._updateSpinButtonsStepObject();
                    break;
                case 'significantDigits':
                case 'precisionDigits': {
                    if (key === 'precisionDigits' && that.inputFormat === 'integer') {
                        that.error(that.localize('noInteger', { property: key }));
                    }

                    if (key === 'significantDigits' && that.precisionDigits !== null) {
                        that.precisionDigits = null;
                    }
                    else if (key === 'precisionDigits' && that.significantDigits !== null) {
                        that.significantDigits = null;
                    }

                    if (that._regexSpecial.nonNumericValue.test(that.value) === false) {
                        const renderedValue = that._renderValue(that._number);

                        input.value = renderedValue;
                    }

                    break;
                }
                case 'decimalSeparator': {
                    that._numberRenderer.localizationObject.decimalseparator = that.decimalSeparator;

                    const numericValue = that._discardDecimalSeparator(input.value, oldValue),
                        valueWithNewSeparator = that._applyDecimalSeparator(numericValue),
                        editableValueWithNewSeparator = that._applyDecimalSeparator(that._discardDecimalSeparator(that._editableValue, oldValue));

                    input.value = valueWithNewSeparator;
                    that._editableValue = editableValueWithNewSeparator;
                    break;
                }
                case 'spinButtonsPosition':
                    if (value === 'left') {
                        that.$.container.insertBefore(that.$.spinButtonsContainer, that.$.label.nextElementSibling);
                    }
                    else {
                        that.$.container.insertBefore(that.$.spinButtonsContainer, that.$.dropDown);
                    }

                    that._refreshShape();
                    break;
                case 'wordLength':
                    that._wordLengthNumber = that._numericProcessor.getWordLength(value);

                    if (that.inputFormat === 'integer') {
                        that._numericProcessor.validateMinMax(true, true);

                        if (that._number !== null) {
                            let validValue = that._validateRange(new JQX.Utilities.BigNumber(that._number));

                            that._updateValue(validValue);

                            if (that.leadingZeros) {
                                handleLeadingZeros();
                            }
                        }
                    }
                    break;
                case 'radixDisplay':
                    if (value) {
                        if (that.inputFormat !== 'integer') {
                            that.error(that.localize('integerOnly', { property: 'radixDisplay' }));
                        }

                        that.$radixDisplayButton.removeClass('jqx-hidden');
                    }
                    else {
                        that.$radixDisplayButton.addClass('jqx-hidden');
                    }
                    that._refreshShape();
                    break;
                case 'radixDisplayPosition':
                    if (value === 'left') {
                        that.$.container.insertBefore(that.$.radixDisplayButton, that.$.input);
                    }
                    else {
                        that.$.container.insertBefore(that.$.radixDisplayButton, that.$.unitDisplay.nextElementSibling);
                    }

                    that._refreshShape();
                    break;
                case 'inputFormat':
                    that._changeInputFormat(oldValue, value);
                    break;
                case 'showUnit':
                    if (value) {
                        that.$unitDisplay.removeClass('jqx-hidden');
                    }
                    else {
                        that.$unitDisplay.addClass('jqx-hidden');
                    }
                    that._refreshShape();
                    break;
                case 'unit':
                    that.$.unitDisplay.innerHTML = value;
                    break;
                case 'scientificNotation': {
                    if (that._regexSpecial.nonNumericValue.test(that.value) === false) {
                        const renderedValue = that._renderValue(that._number);
                        input.value = renderedValue;
                    }

                    break;
                }
                case 'locale':
                case 'messages':
                    that._initialDropDownOptionsSet = false;
                    break;
                case 'nullable':
                    if (oldValue === true && that.value === null) {
                        that._validate(false, '0');
                    }

                    break;
                case 'validation':
                    if (value === 'strict') {
                        that._triggerChangeEvent = true;
                        that._validate(false, that.value);
                        that._triggerChangeEvent = false;
                    }

                    break;
            }
        }
        else if (typeof value !== 'string' && typeof oldValue === 'string') {
            that[key] = oldValue;
        }
        that._cachedInputValue = input.value;
    }

    /**
     * Changes the input format.
     */
    _changeInputFormat(oldFormat, newFormat) {
        const that = this;

        that._numericProcessor = new JQX.Utilities.NumericProcessor(that, 'inputFormat');

        if (oldFormat === 'complex') {
            // 'complex' -> 'integer'/'floatingPoint'
            that._changeFromComplexInputFormat(newFormat);
            return;
        }

        if (newFormat === 'integer' && oldFormat === 'floatingPoint') {
            // 'floatingPoint' -> 'integer'
            that._changeFromFloatingPointToIntegerInputFormat();
        }

        if (newFormat === 'floatingPoint' && oldFormat === 'integer') {
            // 'integer' -> 'floatingPoint'
            that._changeFromIntegerToFloatingPointInputFormat();
        }

        if (newFormat === 'complex') {
            // 'integer'/'floatingPoint' -> 'complex'
            that._changeToComplexInputFormat(oldFormat);
        }

        that._updateSpinButtonsStepObject();

        if (that.value !== null) {
            that._inputFormatChangedFlag = true;
            that._validate(undefined, that._number.toString());
            that._inputFormatChangedFlag = false;
        }
    }

    /**
     * Changes the input format from 'complex' to 'integer' or 'floatingPoint'.
     */
    _changeFromComplexInputFormat(newFormat) {
        const that = this;
        that.spinButtonsStep = that._spinButtonsStepObject.realPart;
        that._updateSpinButtonsStepObject();

        if (newFormat === 'integer') {
            if (that.min === -Infinity) {
                that.min = null;
            }
            else {
                that.min = that._minObject.realPart;
            }
            if (that.max === Infinity) {
                that.max = null;
            }
            else {
                that.max = that._maxObject.realPart;
            }
        }
        else {
            if (that.min !== -Infinity) {
                that.min = that._minObject.realPart;
            }
            if (that.max !== Infinity) {
                that.max = that._maxObject.realPart;
            }
        }
        that._numericProcessor.validateMinMax(true, true);

        if (that.value !== null) {
            that._inputFormatChangedFlag = true;
            that._validate(undefined, that._number.realPart.toString());
            that._inputFormatChangedFlag = false;
        }
    }

    /**
     * Changes the input format from 'floatingPoint' to 'integer'.
     */
    _changeFromFloatingPointToIntegerInputFormat() {
        const that = this;
        if (that.min === -Infinity) {
            that.min = null;
        }
        if (that.max === Infinity) {
            that.max = null;
        }
        that._numericProcessor.validateMinMax(true, true);
    }

    /**
     * Changes the input format from 'integer' to 'floatingPoint'.
     */
    _changeFromIntegerToFloatingPointInputFormat() {
        const that = this;
        if (that.radixDisplay) {
            that.radixDisplay = false;
            that.$radixDisplayButton.addClass('jqx-hidden');
        }

        if (that._radixNumber !== 10) {
            that.radix = 10;
            that._radixNumber = 10;
        }

        if (that._minIsNull) {
            that.min = -Infinity;
            that._minObject = -Infinity;
        }
        else {
            that._minObject = parseFloat(that._minObject.toString());
        }

        if (that._maxIsNull) {
            that.max = Infinity;
            that._maxObject = Infinity;
        }
        else {
            that._maxObject = parseFloat(that._maxObject.toString());
        }

        if (that.dropDownEnabled) {
            that.dropDownEnabled = false;
        }
    }

    /**
     * Changes the input format from 'integer' to 'floatingPoint'.
     */
    _changeToComplexInputFormat(oldFormat) {
        const that = this;
        if (oldFormat === 'integer') {
            if (that.radixDisplay) {
                that.radixDisplay = false;
                that.$radixDisplayButton.addClass('jqx-hidden');
            }

            if (that._minIsNull) {
                that.min = null;
            }
            if (that._maxIsNull) {
                that.max = null;
            }

            if (that.dropDownEnabled) {
                that.dropDownEnabled = false;
            }
        }

        that._numericProcessor.validateMinMax(that.min !== -Infinity, that.max !== Infinity);
    }

    /**
     * Updates the value of the numeric text box input and the "value" property and triggers the respective events.
     */
    _updateValue(value) {
        const that = this,
            enteredValue = that.$.input.value,
            newValue = value.toString(that._radixNumber, that._wordLengthNumber, that.leadingZeros);

        if (enteredValue !== newValue || enteredValue !== that._cachedInputValue) {
            const renderedValue = that._renderValue(value),
                oldValue = that.value,
                newValueIsNotNumeric = that._regexSpecial.nonNumericValue.test(newValue);

            that.$.input.value = renderedValue;
            that._cachedInputValue = renderedValue;

            if (that._inputFormatChangedFlag || newValueIsNotNumeric && renderedValue !== oldValue ||
                newValueIsNotNumeric === false && that._numericProcessor.compare(value, that._number)) {
                that._number = that._numericProcessor.createDescriptor(value);

                const actualNewValue = that._number.toString();
                that.value = actualNewValue;

                that._setDropDownOptions();

                if (that._triggerChangeEvent) {
                    that.$.fireEvent('change', { 'value': actualNewValue, 'oldValue': oldValue, 'radix': that._radixNumber });
                }
            }
        }
        else {
            that.value = that._number.toString();
        }
    }

    /**
     * Sets a decimal numeric value to the numeric text box without any validation.
     */
    _setValue(value) {
        const that = this;

        that.value = value;
        that.$.input.value = value;

        that._number = that._numericProcessor.createDescriptor(value, true);

        that._setDropDownOptions();
    }

    /**
     * Changes the radix (numeral system).
     */
    _changeRadix(radix) {
        const that = this,
            newRadix = that._getRadix(radix),
            oldRadix = that.radix;

        if (newRadix === that._radixNumber) {
            return;
        }

        that.radix = radix;
        that._radixNumber = newRadix;

        const input = that.$.input,
            oldValue = input.value;
        let newValue, renderedValue;

        if (that.value !== null) {
            newValue = that._number.toString(newRadix, that._wordLengthNumber, that.leadingZeros);
            renderedValue = that._renderValue(newValue);
        }
        else {
            renderedValue = '';
        }

        input.value = renderedValue;
        that._cachedInputValue = renderedValue;

        that.$.radixDisplayButton.innerHTML = that._radixPrefixes[newRadix];

        that.$.fireEvent('radixChange', { 'radix': radix, 'oldRadix': oldRadix, 'displayedValue': renderedValue, 'oldDisplayedValue': oldValue });
    }

    /**
     * Opens the radix selection drop down.
     */
    _openRadix() {
        const that = this;

        if (that._initialDropDownOptionsSet === false) {
            that._setDropDownOptions();
            that._initialDropDownOptionsSet = true;
        }

        that.$radixDisplayButton.addClass('jqx-numeric-text-box-pressed-component');
        that.$dropDown.removeClass('moved');
        that.$dropDown.removeClass('jqx-visibility-hidden');
        that.$.dropDown.style.marginTop = null;

        const windowHeight = window.devicePixelRatio === 1 ? document.documentElement.clientHeight : window.innerHeight,
            dropDownBoundingRect = that.$.dropDown.getBoundingClientRect(),
            verticalCorrection = windowHeight - dropDownBoundingRect.top - that.$.dropDown.offsetHeight;

        if (verticalCorrection < 0) {
            that.$.dropDown.style.marginTop = verticalCorrection - parseFloat(getComputedStyle(that).getPropertyValue('--jqx-numeric-text-box-border-width')) + 'px';
            that.$dropDown.addClass('moved');
        }

        that.opened = true;
        that.$.fireEvent('open', { dropDown: that.$.dropDown });
    }

    /**
     * Closes the radix selection drop down.
     */
    _closeRadix() {
        const that = this;

        that.$radixDisplayButton.removeClass('jqx-numeric-text-box-pressed-component');
        that.$dropDown.addClass('jqx-visibility-hidden');

        that.opened = false;
        that.$.fireEvent('close', { dropDown: that.$.dropDown });
    }

    /**
     * Checks if left button is pressed.
     */
    _isLeftButtonPressed(event) {
        const buttons = event.buttons === 0 || event.which === 1;

        return event.detail.buttons === 1 || buttons;
    }

    /**
     * Checks if incrementation and decrementation are allowed
     */
    _isIncrementOrDecrementAllowed() {
        const that = this;

        return !that.disabled && !that.readonly && that._regexSpecial.nonNumericValue.test(that.$.input.value) === false;
    }

    /**
     * Up button mousedown event handler.
     */
    _upButtonClickHandler(event) {
        const that = this,
            isLeftButton = that._isLeftButtonPressed(event);

        if (isLeftButton && that._isIncrementOrDecrementAllowed()) {
            if (!that._up) {
                that.$upButton.addClass('jqx-numeric-text-box-pressed-component');
            }

            that._incrementOrDecrement('add');
        }
    }

    /**
     * Down button mousedown event handler.
     */
    _downButtonClickHandler(event) {
        const that = this,
            isLeftButton = that._isLeftButtonPressed(event);

        if (isLeftButton && that._isIncrementOrDecrementAllowed()) {
            if (!that._up) {
                that.$downButton.addClass('jqx-numeric-text-box-pressed-component');
            }

            that._incrementOrDecrement('subtract');
        }
    }

    /**
     * Document mousedown event handler.
     */
    _documentMousedownHandler(event) {
        const that = this;

        that._up = false;

        if (!that.opened) {
            return;
        }

        if (that.enableShadowDOM) {
            const shadowRootTarget = event.originalEvent.composedPath()[0],
                isInsideElement = function () {
                    let host = shadowRootTarget.getRootNode().host;

                    while (host) {
                        if (host === that) {
                            return host;
                        }

                        host = host.getRootNode().host;
                    }
                }();

            if (!isInsideElement) {
                that._closeRadix();
            }
        }
        else if (!that.contains(event.originalEvent.target)) {
            that._closeRadix();
        }
    }

    /**
     * Document mouseup event handler.
     */
    _documentMouseupHandler() {
        const that = this;

        that._up = true;
        that.$upButton.removeClass('jqx-numeric-text-box-pressed-component');
        that.$downButton.removeClass('jqx-numeric-text-box-pressed-component');
    }

    /**
     * Radix display button click event handler.
     */
    _radixDisplayButtonClickHandler() {
        const that = this;
        if (that.dropDownEnabled && !that.disabled && that.value !== null) {
            if (that.opened) {
                that._closeRadix();
            }
            else {
                that._openRadix();
            }
        }
    }

    /**
     * Dropdown item click event handler.
     */
    _dropDownItemClickHandler(event) {
        if (event.target.$.hasClass('jqx-list-item')) {
            const that = this;
            let radix = event.target.getAttribute('data-value');

            that._changeRadix(parseInt(radix, 10));
            that._closeRadix();
        }
    }

    /**
     * Spin button, radix display button and dropdown item mouseenter and mouseleave event handler.
     */
    _mouseenterMouseleaveHandler(event) {
        const that = this;

        if (event.target === that.$.dropDown || that.disabled || that.readonly) {
            return;
        }

        if (event.type === 'mouseenter') {
            event.target.setAttribute('hover', '');
        }
        else {
            event.target.removeAttribute('hover');
        }
    }

    /**
     * Input keydown event handler.
     */
    _inputKeydownHandler(event) {
        const that = this,
            keyCode = !event.charCode ? event.which : event.charCode;

        if (keyCode === 40 && that._isIncrementOrDecrementAllowed()) {
            // decrement when Down Arrow is pressed
            that._incrementOrDecrement('subtract');
        }
        else if (keyCode === 38 && that._isIncrementOrDecrementAllowed()) {
            // increment when Up Arrow is pressed
            that._incrementOrDecrement('add');
        }

        that._keydownInfo = { value: that.$.input.value, specialKey: event.altKey || event.ctrlKey || event.shiftKey };
    }

    /**
     * Input keyup event handler.
     */
    _inputKeyupHandler(event) {
        const that = this;

        if (event.keyCode === 13) {
            // when Enter is pressed, validation occurs
            that._suppressBlurEvent = true;

            if (that.$.input.value !== that._cachedInputValue) {
                that._triggerChangeEvent = true;
                that._validate();
                that._triggerChangeEvent = false;
                that.$.input.blur();
            }
        }
        else if (event.keyCode === 27) {
            // when Escape is pressed, changes are discarded
            that.$.input.value = that._editableValue;
        }
        else {
            const inputValue = that.$.input.value;

            if (inputValue !== '' && that._regex[that._radixNumber].test(inputValue)) {
                that.$.upButton.disabled = false;
                that.$.downButton.disabled = false;
            }
            else if (inputValue === '') {
                that.$.upButton.disabled = true;
                that.$.downButton.disabled = true;
            }

            if (that._keydownInfo &&
                that._keydownInfo.value !== inputValue &&
                !that._keydownInfo.specialKey &&
                !event.altKey && !event.ctrlKey && !event.shiftKey &&
                event.key !== 'Control') {
                that.$.fireEvent('changing', { 'currentValue': inputValue, 'validValue': that.value, 'radix': that._radixNumber });
            }
        }

        event.preventDefault();
    }

    /**
     * Input blur event handler.
     */
    _inputBlurHandler() {
        const that = this;

        if (that._suppressBlurEvent === true) {
            // suppresses validation because it was already handled in "_incrementOrDecrement" function
            that._suppressBlurEvent = false;

            if (that._formattedValue) {
                that._cachedInputValue = that._formattedValue;
                that.$.input.value = that._formattedValue;
                delete that._formattedValue;
            }
        }
        else if (that.$.input.value !== that._editableValue) {
            that._triggerChangeEvent = true;
            that._validate();
            that._triggerChangeEvent = false;
        }
        else {
            that.$.input.value = that._cachedInputValue;
        }

        if (that.radixDisplay) {
            that.$.radixDisplayButton.removeAttribute('focus');
        }

        if (that.opened) {
            that._closeRadix();
        }

        if (that.spinButtons) {
            that.$.spinButtonsContainer.removeAttribute('focus');
        }
        if (that.showUnit) {
            that.$.unitDisplay.removeAttribute('focus');
        }

        that.removeAttribute('focus');
    }

    /**
     * Input focus event handler.
     */
    _inputFocusHandler() {
        const that = this;

        if (that.spinButtons) {
            that.$.spinButtonsContainer.setAttribute('focus', '');
        }
        if (that.radixDisplay) {
            that.$.radixDisplayButton.setAttribute('focus', '');
        }
        if (that.showUnit) {
            that.$.unitDisplay.setAttribute('focus', '');
        }

        if (that.opened) {
            that._closeRadix();
        }

        that.setAttribute('focus', '');

        if (that.outputFormatString) {
            that.$.input.value = that._editableValue;
        }
    }

    /**
     * Input change event handler.
     */
    _inputChangeHandler(event) {
        event.stopPropagation();
        event.preventDefault();
    }

    /**
     * Input paste event handler.
     */
    _inputPasteHandler() {
        const that = this;

        requestAnimationFrame(() => that.$.fireEvent('changing', { 'currentValue': that.$.input.value, 'validValue': that.value, 'radix': that._radixNumber }));
    }

    /**
     * Input wheel event handler.
     */
    _inputWheelHandler(event) {
        const that = this,
            activeElement = that.enableShadowDOM ? (that.shadowRoot.activeElement || document.activeElement) : document.activeElement;

        if (that.$.input === activeElement && that.enableMouseWheelAction && that._isIncrementOrDecrementAllowed()) {
            event.stopPropagation();
            event.preventDefault();
            if (event.wheelDelta > 0) {
                that._incrementOrDecrement('add');
            }
            else {
                that._incrementOrDecrement('subtract');
            }
        }
    }

    /**
     * Gets the internal numeric radix based on the "radix" property.
     */
    _getRadix(radix) {
        switch (radix.toString()) {
            case '10':
            case 'decimal':
                return 10;
            case '2':
            case 'binary':
                return 2;
            case '8':
            case 'octal':
                return 8;
            case '16':
            case 'hexadecimal':
                return 16;
        }
    }

    /**
     * Sets the dropdown list radix options.
     */
    _setDropDownOptions() {
        const that = this;

        if (that.dropDownEnabled === false || that._number === null) {
            return;
        }

        const wordLength = that._wordLengthNumber,
            leadingZeros = that.leadingZeros;

        that.$.dropDownItem2.innerHTML = `${that._number.toString(2, wordLength, leadingZeros)} (${that.localize('binary')})`;
        that.$.dropDownItem8.innerHTML = `${that._number.toString(8, wordLength)} (${that.localize('octal')})`;
        that.$.dropDownItem10.innerHTML = `${that._renderValue(that._number.toString(10, wordLength), true)} (${that.localize('decimal')})`;
        that.$.dropDownItem16.innerHTML = `${that._number.toString(16, wordLength, leadingZeros)} (${that.localize('hexadecimal')})`;
    }

    /**
     * Increments or decrements the number in the numeric text box input.
     */
    _incrementOrDecrement(func) {
        const that = this,
            activeElement = that.enableShadowDOM ? (that.shadowRoot.activeElement || document.activeElement) : document.activeElement;
        let cachedInputValue = that._cachedInputValue;

        if (that.$.input === activeElement) {
            cachedInputValue = that._editableValue;
            that._suppressBlurEvent = true;
        }

        if (that.$.input.value !== cachedInputValue || that._programmaticValueIsSet && that.validation === 'interaction') {
            // validates the value before incrementing or decrementing
            that._triggerChangeEvent = true;
            that._validate();
            that._triggerChangeEvent = false;
            if (that._isIncrementOrDecrementAllowed() === false) {
                return;
            }
        }

        const currentNumber = that._numericProcessor.incrementDecrement(that._number, func, that._spinButtonsStepObject),
            validNumber = that._validateRange(currentNumber);
        that._triggerChangeEvent = true;
        that._updateValue(validNumber);
        that._triggerChangeEvent = false;
    }

    /**
     * Returns a BigNumber object from a binary, octal, decimal or hexadecimal value.
     */
    _toBigNumberDecimal(number, radix) {
        const that = this;
        let result;

        if (radix === 10) {
            result = new JQX.Utilities.BigNumber(number);
        }
        else {
            if (that._unsigned || that._isNegative(number, radix) === false) {
                if (that._wordLengthNumber < 64) {
                    result = parseInt(number, radix);
                    result = new JQX.Utilities.BigNumber(result);
                }
                else {
                    result = that._getBigNumberFrom64BitBinOctHex(number, radix);
                }
            }
            else {
                result = that._getNegativeDecimal(number, radix);
                result = new JQX.Utilities.BigNumber(result);
            }

        }
        return result;
    }

    /**
     * Checks if the passed binary, octal or hexadecimal value is negative based on the word length.
     */
    _isNegative(value, radix) {
        const that = this,
            valueLength = value.length,
            firstCharacter = value.charAt(0).toLowerCase();

        if (radix === 2) {
            return valueLength === that._wordLengthNumber && firstCharacter === '1';
        }
        else if (radix === 8) {
            switch (that._wordLengthNumber) {
                case 8:
                    return valueLength === 3 && (firstCharacter === '2' || firstCharacter === '3');
                case 16:
                    return valueLength === 5 && firstCharacter === '1';
                case 32:
                    return valueLength === 11 && (firstCharacter === '2' || firstCharacter === '3');
                case 64:
                    return valueLength === 22 && firstCharacter === '1';
            }
        }
        else {
            return valueLength === that._wordLengthNumber / 4 && ['8', '9', 'a', 'b', 'c', 'd', 'e', 'f'].indexOf(firstCharacter) !== -1;
        }
    }

    /**
     * Returns a BigNumber object from a positive binary, octal or hexadecimal value.
     */
    _getBigNumberFrom64BitBinOctHex(number, radix) {
        let result = new JQX.Utilities.BigNumber(0);
        for (let i = number.length - 1; i >= 0; i--) {
            let current = new JQX.Utilities.BigNumber(parseInt(number.charAt(i), radix));
            result = result.add((current.multiply(new JQX.Utilities.BigNumber(radix).pow(number.length - 1 - i))));
        }
        return result;
    }

    /**
     * Returns a BigNumber object from a negative binary, octal or hexadecimal value.
     */
    _getNegativeDecimal(value, radix) {
        const that = this;
        let negativeBinary = value;

        if (radix === 8) {
            let threeBits = [];
            for (let i = 0; i < value.length; i++) {
                let threeBit = parseInt(value.charAt(i), 8).toString(2);
                while (threeBit.length !== 3) {
                    threeBit = `0${threeBit}`;
                }
                threeBits.push(threeBit);
            }
            negativeBinary = threeBits.join('');
            while (negativeBinary.charAt(0) === '0') {
                negativeBinary = negativeBinary.slice(1);
            }
        }
        else if (radix === 16) {
            let bytes = [];
            for (let j = 0; j < value.length; j++) {
                let currentByte = parseInt(value.charAt(j), 16).toString(2);
                while (currentByte.length !== 4) {
                    currentByte = `0${currentByte}`;
                }
                bytes.push(currentByte);
            }
            negativeBinary = bytes.join('');
        }

        let negativeDecimal = negativeBinary.replace(/0/g, 'a');
        negativeDecimal = negativeDecimal.replace(/1/g, 'b');
        negativeDecimal = negativeDecimal.replace(/a/g, '1');
        negativeDecimal = negativeDecimal.replace(/b/g, '0');

        if (this._wordLengthNumber < 64) {
            negativeDecimal = (parseInt(negativeDecimal, 2) + 1) * -1;
        }
        else {
            negativeDecimal = that._getBigNumberFrom64BitBinOctHex(negativeDecimal, radix);
            negativeDecimal = negativeDecimal.add(1).negate();
        }

        return negativeDecimal;
    }

    /**
     * Replaces a custom decimal separator with the default one.
     */
    _discardDecimalSeparator(value, separator) {
        const that = this;

        if (separator === undefined) {
            separator = that.decimalSeparator;
        }

        if (separator !== '.' && value !== Infinity && value !== -Infinity) {
            let decimalSeparatorRegExp = new RegExp(separator, 'g');
            return value.replace(decimalSeparatorRegExp, '.');
        }
        else {
            return value;
        }
    }

    /**
     * Applies a custom decimal separator.
     */
    _applyDecimalSeparator(value) {
        const that = this;
        if (typeof value !== 'string') {
            value = value.toString();
        }

        if (that.decimalSeparator !== '.') {
            value = value.replace(/\./g, that.decimalSeparator);
        }

        return value;
    }

    /**
     * Applies the scientific notation, significant digits, precision digits and decimal separator settings.
     */
    _renderValue(renderedValue, valueInDropDown) {
        const that = this,
            value = renderedValue,
            ignoreRadixNumber = that._radixNumber === 10 || valueInDropDown === true;

        renderedValue = that._numericProcessor.render(renderedValue, ignoreRadixNumber);

        // decimal separator
        if (that.decimalSeparator !== '.' && ignoreRadixNumber) {
            renderedValue = that._applyDecimalSeparator(renderedValue);
        }

        if (valueInDropDown !== true) {
            that._editableValue = renderedValue;

            if (that.outputFormatString && that._radixNumber === 10) {
                const activeElement = that.enableShadowDOM ? (that.shadowRoot.activeElement || document.activeElement) : document.activeElement,
                    formattedValue = that._numberRenderer.formatNumber(value, that.outputFormatString);

                if (activeElement !== that.$.input) {
                    return formattedValue;
                }

                that._formattedValue = formattedValue;
            }
        }

        return renderedValue;
    }

    /**
     * Sets whether the element can be focused.
     */
    _setFocusable() {
        const that = this;

        if (that.disabled || that.unfocusable) {
            that.$.input.tabIndex = -1;

            return;
        }

        that.$.input.removeAttribute('tabindex');
    }

    /**
     * Disables or enables components.
     */
    _disableComponents() {
        const that = this;

        if (that.disabled) {
            return;
        }

        const value = that.value;

        if (value === null || value.toString() === 'NaN' || Math.abs(value) === Infinity) {
            that.$.upButton.disabled = true;
            that.$.downButton.disabled = true;
        }
        else {
            that.$.upButton.disabled = false;
            that.$.downButton.disabled = false;
        }
    }
});

/**
 * Pager custom element.
 */
JQX('jqx-pager', class Pager extends JQX.BaseElement {
    // Pager's properties.
    static get properties() {
        return {
            'autoEllipsis': {
                value: 'none',
                type: 'string',
                // After - displays AutoEllipsis only after the Numeric Buttons.
                // Before - displays AutoEllipsis only before the Numeric Buttons.
                // Both - displays AutoEllipsis before and after the Numeric Buttons.
                // None - doesn't display AutoEllipsis.
                allowedValues: ['none', 'before', 'after', 'both']
            },
            'messages': {
                value: {
                    'en': {
                        'firstButton': 'First',
                        'lastButton': 'Last',
                        'previousButton': 'Previous',
                        'nextButton': 'Next',
                        'navigateToLabel': 'Go to:',
                        'pageSizeLabel': 'Show:',
                        'navigateToInputPlaceholder': '',
                        'ellipsis': '...',
                        'summaryString': 'of',
                        'summaryPrefix': 'of',
                        'summarySuffix': ''
                    }
                },
                type: 'object',
                extend: true
            },
            'navigationButtonsPosition': {
                value: 'both',
                allowedValues: ['near', 'far', 'both'],
                type: 'string'
            },
            'navigationInputPosition': {
                value: 'far',
                allowedValues: ['near', 'far'],
                type: 'string'
            },
            'pageIndex': {
                value: 0,
                type: 'number'
            },
            'pageIndexSelectors': {
                value: 0,
                type: 'any'
            },
            'pagesCount': {
                value: 100,
                type: 'number'
            },
            'pageSize': {
                value: 10,
                type: 'number'
            },
            'pageSizeSelectorPosition': {
                value: 'far',
                allowedValues: ['near', 'far'],
                type: 'string'
            },
            'pageSizeSelectorDataSource': {
                value: [10, 25, 50],
                type: 'array'
            },
            'showPrevNextNavigationButtons': {
                value: false,
                type: 'boolean'
            },
            'showFirstLastNavigationButtons': {
                value: false,
                type: 'boolean'
            },
            'showNavigationButtonLabels': {
                value: false,
                type: 'boolean'
            },
            'showNavigationInput': {
                value: false,
                type: 'boolean'
            },
            'showSummary': {
                value: false,
                type: 'boolean'
            },
            'showPageSizeSelector': {
                value: false,
                type: 'boolean'
            },
            'showPageIndexSelectors': {
                value: false,
                type: 'boolean'
            },
            'summaryPosition': {
                value: 'far',
                allowedValues: ['near', 'far'],
                type: 'string'
            }
        };
    }

    /**
     * Pager's event listeners.
     */
    static get listeners() {
        return {
            'click': '_navigationButtonsClickHandler',
            'nextEllipsisButton.click': '_nextEllipsisButtonClickHandler',
            'previousEllipsisButton.click': '_previousEllipsisButtonClickHandler',
            'down': '_navigationButtonsDownHandler',
            'navigateToInput.change': '_navigateToInputChangeHandler',
            'nextButton.mouseenter': '_updateInBoundsFlag',
            'nextButton.mouseleave': '_updateInBoundsFlag',
            'pageIndexSelectorsContainer.click': '_pageIndexSelectorsContainerClickHandler',
            'pageSizeSelector.change': '_pageSizeSelectorChangeHandler',
            'previousButton.mouseenter': '_updateInBoundsFlag',
            'previousButton.mouseleave': '_updateInBoundsFlag',
            'keydown': '_keyDownHandler',
            'resize': '_resizeHandler',
            'document.up': '_stopRepeat'
        };
    }

    static get requires() {
        return {
            'JQX.DropDownList': 'jqxdropdownlist.js'
        }
    }

    /**
    * CSS files needed for the element (ShadowDOM)
    */
    static get styleUrls() {
        return [
            'jqx.pager.css'
        ]
    }

    /**
     * Pager's HTML template.
     */
    template() {
        return `<div id="container">
                    <div id="nearButtonsContainer" class="jqx-pager-near-buttons-container">
                        <div id="firstButton" class="jqx-first-button jqx-pager-button jqx-unselectable"></div>
                        <div id="previousButton" class="jqx-previous-page-button jqx-pager-button jqx-unselectable"></div>
                    </div>
                    <div id="middleButtonsContainer" class="jqx-pager-middle-buttons-container">
                           <span id="previousEllipsisButton" class="jqx-previous-ellipsis-button jqx-pager-page-index-selector"></span>
                           <div id="pageIndexSelectorsContainer" tabindex="0" class="jqx-pager-page-index-selectors-container"></div>
                           <span id="nextEllipsisButton" class="jqx-next-ellipsis-button jqx-pager-page-index-selector"></span>
                    </div>
                    <div id="farButtonsContainer" class="jqx-pager-far-buttons-container">
                        <div id="nextButton" class="jqx-next-page-button jqx-pager-button jqx-unselectable"></div>
                        <div id="lastButton" class="jqx-last-button jqx-pager-button jqx-unselectable"></div>
                    </div>
                    <div id="pagerInputAndLabelContainer" class="jqx-pager-input-and-label-container">
                        <span id="navigateToLabel" class="jqx-pager-label"></span>
                        <input type="text" id="navigateToInput" class="jqx-pager-input jqx-input" />
                   </div>
                 <div id="pagerSizeSelectorAndLabelContainer" class="jqx-pager-size-selector-and-label-container">
                        <span id="pageSizeLabel" class="jqx-pager-label"></span>
                        <jqx-drop-down-list id="pageSizeSelector" class="jqx-page-size-selector"
                                data-source="[[pageSizeSelectorDataSource]]"
                                drop-down-height="auto"
                                selection-mode="one"
                                selected-indexes=[0]
                                disabled="[[disabled]]">
                        </jqx-drop-down-list>
                    </div>
                  <span id="pagerSummaryContainer" class="jqx-pager-summary-container jqx-pager-label"></span>
                </div>`;
    }

    /**
     * Called when the element is ready.
     */
    ready() {
        super.ready();

        const that = this;

        that._render();
    }

    /**
     * Called when a property is changed.
     */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this;

        switch (propertyName) {
            case 'navigationButtonsPosition':
                that._renderButtons();
                return;
            case 'navigationInputPosition':
            case 'pageSizeSelectorPosition':
            case 'summaryPosition':
                that._renderSettings();
                return;
        }

        that._render();
    }

    /**
    * Moves to the next page.
    */
    next() {
        const that = this;

        that.navigateTo(that.pageIndex + 1);
    }

    /**
    * Moves to the previous page.
    */
    prev() {
        const that = this;

        that.navigateTo(that.pageIndex - 1);
    }

    beginUpdate() {
        const that = this;

        that._updating = true;
    }

    endUpdate() {
        const that = this;

        that._updating = false;
        that._render();
    }

    _render() {
        const that = this;

        if (that._updating) {
            return;
        }

        that.$.navigateToInput.value = (1 + that.pageIndex).toString();
        that._renderButtons();
        that._renderPageIndexSelectors();
        that._renderSettings();
        that._renderVisibility();
        that._localize();
    }


    _resizeHandler() {
        const that = this;

        that._renderVisibility();
    }

    _renderVisibility() {
        const that = this;
        const pagerWidth = that.offsetWidth - 20;

        if (that.showSummary) {
            that.$pagerSummaryContainer.removeClass('jqx-hidden');
        }
        else {
            that.$pagerSummaryContainer.addClass('jqx-hidden');
        }

        if (that.showPageIndexSelectors) {
            that.$middleButtonsContainer.removeClass('jqx-hidden');
        }
        else {
            that.$middleButtonsContainer.addClass('jqx-hidden');
        }

        if (that.showNavigationInput) {
            that.$navigateToLabel.removeClass('jqx-hidden');
            that.$navigateToInput.removeClass('jqx-hidden');
        }
        else {
            that.$navigateToLabel.addClass('jqx-hidden');
            that.$navigateToInput.addClass('jqx-hidden');
        }

        if (that.showPageSizeSelector) {
            that.$pageSizeLabel.removeClass('jqx-hidden');
            that.$pageSizeSelector.removeClass('jqx-hidden');
        }
        else {
            that.$pageSizeLabel.addClass('jqx-hidden');
            that.$pageSizeSelector.addClass('jqx-hidden');
        }

        if (that.showFirstLastNavigationButtons) {
            that.$firstButton.removeClass('jqx-hidden');
            that.$lastButton.removeClass('jqx-hidden');
        }
        else {
            that.$firstButton.addClass('jqx-hidden');
            that.$lastButton.addClass('jqx-hidden');
        }

        if (that.showPrevNextNavigationButtons) {
            that.$previousButton.removeClass('jqx-hidden');
            that.$nextButton.removeClass('jqx-hidden');
        }
        else {
            that.$previousButton.addClass('jqx-hidden');
            that.$nextButton.addClass('jqx-hidden');
        }

        that.$previousEllipsisButton.addClass('jqx-hidden');
        that.$nextEllipsisButton.addClass('jqx-hidden');

        if (that.autoEllipsis !== 'after' && that.autoEllipsis !== 'none' && that.pageIndex >= that._pageIndexSelectorsCount) {
            that.$previousEllipsisButton.removeClass('jqx-hidden');
        }

        if (that.autoEllipsis !== 'before' && that.autoEllipsis !== 'none' && that.pageIndex < that.pagesCount - that._pageIndexSelectorsCount) {
            that.$nextEllipsisButton.removeClass('jqx-hidden');
        }

        for (let i = 0; i < that._pageIndexSelectorsCount; i++) {
            if (!that.$.pageIndexSelectorsContainer.children[i]) {
                break;
            }

            that.$.pageIndexSelectorsContainer.children[i].classList.remove('jqx-hidden');
        }

        const pagerSummaryWidth = that.$.pagerSummaryContainer.offsetWidth ? Math.max(100, that.$.pagerSummaryContainer.offsetWidth) : 0;

        let totalWidth = that.$.nearButtonsContainer.offsetWidth + that.$.middleButtonsContainer.offsetWidth + that.$.farButtonsContainer.offsetWidth + pagerSummaryWidth + that.$.pagerInputAndLabelContainer.offsetWidth + that.$.pagerSizeSelectorAndLabelContainer.offsetWidth;

        if (totalWidth > 0 && totalWidth > pagerWidth) {
            totalWidth -= that.$.pagerSummaryContainer.offsetWidth;

            // hides summary.
            that.$pagerSummaryContainer.addClass('jqx-hidden');

            if (totalWidth > pagerWidth) {
                totalWidth -= that.$.navigateToLabel.offsetWidth;
                totalWidth -= that.$.navigateToInput.offsetWidth;

                // hides navigation input and label.
                that.$navigateToLabel.addClass('jqx-hidden');
                that.$navigateToInput.addClass('jqx-hidden');

                if (totalWidth > pagerWidth) {
                    totalWidth -= that.$.pageSizeLabel.offsetWidth;
                    totalWidth -= that.$.pageSizeSelector.offsetWidth;

                    // hides page size selector and label.
                    that.$pageSizeLabel.addClass('jqx-hidden');
                    that.$pageSizeSelector.addClass('jqx-hidden');

                    if (totalWidth > pagerWidth) {
                        that.$previousEllipsisButton.addClass('jqx-hidden');
                        that.$nextEllipsisButton.addClass('jqx-hidden');

                        totalWidth -= that.$.previousEllipsisButton.offsetWidth;
                        totalWidth -= that.$.nextEllipsisButton.offsetWidth;

                        for (let i = that._pageIndexSelectorsCount - 1; i >= 0; i--) {
                            const pageIndexSelector = that.$.pageIndexSelectorsContainer.children[i];

                            if (totalWidth < pagerWidth || !pageIndexSelector) {
                                break;
                            }

                            totalWidth -= pageIndexSelector.offsetWidth;
                            pageIndexSelector.classList.add('jqx-hidden');
                        }
                    }

                    if (totalWidth > pagerWidth && that.showFirstLastNavigationButtons) {
                        that.$firstButton.addClass('jqx-hidden');
                        that.$lastButton.addClass('jqx-hidden');
                    }
                }
            }
        }
    }

    _renderSettings() {
        const that = this;

        const summaryStart = that.pageIndex * that.pageSize;
        const summaryEnd = (that.pageIndex + 1) * that.pageSize;
        const totalSummaryEnd = that.pagesCount * that.pageSize;

        that.$pagerSummaryContainer.removeClass('near');
        that.$pagerSizeSelectorAndLabelContainer.removeClass('near');
        that.$pagerInputAndLabelContainer.removeClass('near');

        if (that.summaryPosition === 'near') {
            that.$pagerSummaryContainer.addClass('near');
        }

        if (that.pageSizeSelectorPosition === 'near') {
            that.$pagerSizeSelectorAndLabelContainer.addClass('near');
        }

        if (that.navigationInputPosition === 'near') {
            that.$pagerInputAndLabelContainer.addClass('near');
        }

        that.$.pagerSummaryContainer.innerHTML = '<span class="jqx-summary-start">' + (1 + summaryStart) + '</span> <span class="jqx-summary-hyphen">-</span> <span class="jqx-summary-end">' + (summaryEnd) + '</span>' +
            '<span class="jqx-summary-prefix">' + that.localize('summaryPrefix') + '</span> <span class="jqx-summary-total-end">' + totalSummaryEnd + '</span> <span class="jqx-summary-suffix">' + that.localize('summarySuffix') + '</span>';
    }

    get _pageIndexSelectorsCount() {
        const that = this;

        let pageIndexSelectorsCount = parseInt(that.pageIndexSelectors);

        if (Array.isArray(that.pageIndexSelectors)) {
            pageIndexSelectorsCount = that.pageIndexSelectors.length;
        }

        return pageIndexSelectorsCount;
    }

    /**
     * Creates page with pageIndexSelectors, based on pageIndexSelectors and pageIndexSelectors-per-page properties.
     */
    _renderPageIndexSelectors() {
        const that = this;

        if (that.pageIndex < 0 || that.pageIndex >= that.pagesCount) {
            return;
        }

        that.$.pageIndexSelectorsContainer.innerHTML = '';

        let isArray = false;

        if (Array.isArray(that.pageIndexSelectors)) {
            isArray = true;
        }

        let pageIndexSelectorStartIndex = Math.floor(that.pageIndex / that._pageIndexSelectorsCount) * that._pageIndexSelectorsCount;
        let pageIndexSelectorEndIndex = Math.min(that.pagesCount, pageIndexSelectorStartIndex + that._pageIndexSelectorsCount);
        let pageIndexSelectorIndex = 0;

        for (let i = pageIndexSelectorStartIndex; i < pageIndexSelectorEndIndex; i++) {
            const newPageIndexSelector = document.createElement('span');
            let newPageIndexSelectorContent = i + 1;

            newPageIndexSelector.className = 'jqx-pager-page-index-selector';

            if (isArray) {
                const pageIndexSelector = that.pageIndexSelectors[pageIndexSelectorIndex++];

                if (pageIndexSelector) {
                    if (pageIndexSelector.label) {
                        newPageIndexSelectorContent = that.pageIndexSelectors[i].label;
                    }
                    else if (typeof pageIndexSelector === 'string') {
                        newPageIndexSelectorContent = pageIndexSelector;
                    }

                    if (pageIndexSelector.value) {
                        newPageIndexSelector.setAttribute('value', that.pageIndexSelectors[i].value);
                    }
                }
            }

            newPageIndexSelector.index = i;
            newPageIndexSelector.innerHTML = newPageIndexSelectorContent;

            that.$.pageIndexSelectorsContainer.appendChild(newPageIndexSelector);

            if (i === that.pageIndex) {
                newPageIndexSelector.classList.add('jqx-selected');
                newPageIndexSelector.setAttribute('selected', '');
            }
        }
    }

    /**
    * Last button click handler.
    */
    _lastButtonClickHandler() {
        const that = this;

        that.last();
    }

    last() {
        const that = this;

        that.navigateTo(that.pagesCount - 1);
    }

    /**
    * First button click handler.
    */
    _firstButtonClickHandler() {
        const that = this;

        that.first();
    }

    first() {
        const that = this;

        that.navigateTo(0);
    }

    _renderButtons() {
        const that = this;

        if (that.pageIndex === 0) {
            that.$.firstButton.setAttribute('disabled', '');
            that.$.previousButton.setAttribute('disabled', '');
        }
        else {
            that.$.firstButton.removeAttribute('disabled');
            that.$.previousButton.removeAttribute('disabled');
        }

        if (that.pageIndex === that.pagesCount - 1) {
            that.$.nextButton.setAttribute('disabled', '');
            that.$.lastButton.setAttribute('disabled', '');
        }
        else {
            that.$.nextButton.removeAttribute('disabled');
            that.$.lastButton.removeAttribute('disabled');
        }

        that.$nearButtonsContainer.removeClass('far');
        that.$farButtonsContainer.removeClass('far');
        that.$nearButtonsContainer.removeClass('near');
        that.$farButtonsContainer.removeClass('near');

        switch (that.navigationButtonsPosition) {
            case 'near':
                that.$nearButtonsContainer.addClass('near');
                that.$farButtonsContainer.addClass('near');
                break;
            case 'far':
                that.$nearButtonsContainer.addClass('far');
                that.$farButtonsContainer.addClass('far');
                break;
            case 'both':
                that.$nearButtonsContainer.addClass('near');
                that.$farButtonsContainer.addClass('far');
                break;
        }
    }


    _navigateToInputChangeHandler() {
        const that = this;

        let pageIndex = parseInt(that.$.navigateToInput.value) - 1;

        if (isNaN(pageIndex)) {
            that.$.navigateToInput.value = '1';
            pageIndex = parseInt(that.$.navigateToInput.value - 1);
        }

        that.navigateTo(pageIndex);
    }

    _pageIndexSelectorsContainerClickHandler(event) {
        const that = this,
            closestPageIndexSelector = that.enableShadowDOM ? event.composedPath()[0].closest('.jqx-pager-page-index-selector') : event.target.closest('.jqx-pager-page-index-selector');

        if (!closestPageIndexSelector || closestPageIndexSelector.classList.contains('jqx-selected')) {
            return;
        }

        that.navigateTo(closestPageIndexSelector.index);
    }

    _pageSizeSelectorChangeHandler(event) {
        const that = this;

        if (!that.showPageSizeSelector || that.disabled || that._updating) {
            return;
        }

        that.pageSize = parseInt(event.detail.value);

        that.$.fireEvent('pageSizeChanged', {
            'value': parseInt(event.detail.value)
        });
    }

    /**
    * Pager's keydown event handler.
    */
    _keyDownHandler(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        if ((that.enableShadowDOM ? (that.shadowRoot.activeElement || document.activeElement) : document.activeElement) === that.$.navigateToInput) {
            return;
        }

        if (that.$.pageSizeSelector.getAttribute('focus') !== null) {
            return;
        }


        switch (event.key) {
            case 'End':
                that.last();
                event.preventDefault();
                break;
            case 'Home':
                that.first();
                event.preventDefault();
                break;
            case 'PageDown':
            case 'ArrowDown':
            case 'ArrowLeft':
                that.prev();
                event.preventDefault();
                break;
            case 'PageUp':
            case 'ArrowUp':
            case 'ArrowRight':
                that.next();
                event.preventDefault();
                break;
        }
    }

    /**
    * Next Page button click handler.
    */
    _nextButtonClickHandler() {
        const that = this;

        that.next();
    }

    /**
    * Previous Page button click handler.
    */
    _previousButtonClickHandler() {
        const that = this;

        that.prev();
    }

    navigateTo(pageIndex) {
        const that = this,
            oldIndex = that.pageIndex;

        if (that.disabled || that.pageIndex === pageIndex || pageIndex < 0 || pageIndex >= that.pagesCount) {
            return;
        }

        that.pageIndex = pageIndex;

        that._render();

        that.$.fireEvent('change', {
            'oldIndex': oldIndex,
            'index': pageIndex
        });
    }

    /**
    * Updates from-to summary block.
    */
    _localize() {
        const that = this,
            buttonsArray = ['firstButton', 'lastButton', 'previousButton', 'nextButton'];

        for (let i = 0; i < buttonsArray.length; i++) {
            const button = that.$[buttonsArray[i]];

            if (!that.showNavigationButtonLabels && i < 2) {
                button.innerHTML = '';
                if (i === 0) {
                    button.classList.add('jqx-arrow-left-first');
                }
                else {
                    button.classList.add('jqx-arrow-right-last');
                }
            }
            else if (!that.showNavigationButtonLabels && i >= 2) {
                button.innerHTML = '';
                if (i === 2) {
                    button.classList.add('jqx-arrow-left');
                }
                else {
                    button.classList.add('jqx-arrow-right');
                }
            }
            else {
                button.classList.remove('jqx-arrow-left');
                button.classList.remove('jqx-arrow-right');
                button.classList.remove('jqx-arrow-left-first');
                button.classList.remove('jqx-arrow-right-last');

                button.innerHTML = that.localize(buttonsArray[i]);
            }
        }

        that.$.pageSizeLabel.innerHTML = that.localize('pageSizeLabel');
        that.$.navigateToLabel.innerHTML = that.localize('navigateToLabel');
        that.$.previousEllipsisButton.innerHTML = that.localize('ellipsis');
        that.$.nextEllipsisButton.innerHTML = that.localize('ellipsis');
        that.$.navigateToInput.placeholder = that.localize('navigateToInputPlaceholder');
    }

    _nextEllipsisButtonClickHandler() {
        const that = this;

        that.navigateTo(that._pageIndexSelectorsCount + that.pageIndex);
    }

    _previousEllipsisButtonClickHandler() {
        const that = this;

        that.navigateTo(-that._pageIndexSelectorsCount + that.pageIndex);
    }

    /**
    * Updates from-to summary block.
    */
    _navigationButtonsClickHandler(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        const targetElement = that.enableShadowDOM ? event.composedPath()[0].closest('.jqx-pager-button') : event.target.closest('.jqx-pager-button');

        switch (targetElement) {
            case that.$.firstButton:
                that._firstButtonClickHandler(event);
                break;
            case that.$.lastButton:
                that._lastButtonClickHandler(event);
                break;
            case that.$.previousButton:
                that._previousButtonClickHandler(event);
                break;
            case that.$.nextButton:
                that._nextButtonClickHandler(event);
                break;
        }
    }

    _navigationButtonsDownHandler(event) {
        const that = this,
            targetElement = that.enableShadowDOM ? (event.originalEvent.composedPath()[0].closest('.jqx-pager-button') || event.originalEvent.composedPath()[0].closest('.jqx-pager-page-index-selector')) :
                (event.originalEvent.target.closest('.jqx-pager-button') || event.originalEvent.target.closest('.jqx-pager-page-index-selector'));

        if (that.disabled || !targetElement) {
            return;
        }

        if (that.hasRippleAnimation) {
            JQX.Utilities.Animation.Ripple.animate(targetElement, event.pageX, event.pageY);
        }

        if (targetElement === that.$.previousButton || targetElement === that.$.nextButton) {
            that._startRepeat(event, targetElement);
        }
    }

    _updateInBoundsFlag(event) {
        const that = this,
            button = that.enableShadowDOM ? event.composedPath()[0] : event.target;

        button._isPointerInBounds = true;

        if (event.type === 'mouseleave') {
            button._isPointerInBounds = false;
        }

        const buttons = ('buttons' in event) ? event.buttons : event.which;

        if (buttons !== 1) {
            that._stopRepeat(event);
        }
    }

    _startRepeat(event, button) {
        const that = this;

        if (!that._initialTimer) {
            that._initialTimer = setTimeout(function () {
                that._repeatTimer = setInterval(() => {
                    if (button._isPointerInBounds) {
                        if (button === that.$.previousButton) {
                            that._previousButtonClickHandler(event);
                        }
                        else {
                            that._nextButtonClickHandler(event);
                        }
                    }
                }, 50);
            }, 150);
        }
    }

    _stopRepeat() {
        const that = this;

        if (that._repeatTimer) {
            clearInterval(that._repeatTimer);
            that._repeatTimer = null;
        }

        if (that._initialTimer) {
            clearTimeout(that._initialTimer);
            that._initialTimer = null;
        }
    }
});

JQX('jqx-base-progress-bar', class BaseProgressBar extends JQX.BaseElement {

    /** Progressbar's properties */
    static get properties() {
        return {
            'indeterminate': {
                value: false,
                type: 'boolean'
            },
            'inverted': {
                value: false,
                type: 'boolean'
            },
            'formatFunction': {
                value: null,
                type: 'function'
            },
            'max': {
                value: 100,
                type: 'number'
            },
            'min': {
                value: 0,
                type: 'number'
            },
            'showProgressValue': {
                value: false,
                type: 'boolean'
            },
            'value': {
                value: 0,
                type: 'number?'
            }
        }
    }

    /**
    * CSS files needed for the element (ShadowDOM)
    */
    static get styleUrls() {
        return [
            'jqx.progressbar.css'
        ]
    }

    ready() {
        super.ready();

        const that = this;

        that._updateProgress();
    }

    /**
   * Updates the progressbar when a property is changed.
   * @param {string} propertyName The name of the property.
   * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
   * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
   */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this;

        that._updateProgress();
        if (propertyName === 'value') {
            that.$.fireEvent('change', { 'value': newValue, 'oldValue': oldValue, changeType: 'api' });
        }
    }

    _updateProgress() {

    }

    get _percentageValue() {
        const that = this;

        const max = Math.max(that.min, that.max);
        const min = Math.min(that.min, that.max);

        const validValue = (Math.min(max, Math.max(min, that.value)));
        const percentageValue = (validValue - min) / (max - min);

        return percentageValue;
    }
});

JQX('jqx-circular-progress-bar', class CircularProgressBar extends JQX.BaseProgressBar {
    /** progressbar's HTML template */
    template() {
        return `<div id="container">
                    <svg width="100%" height="100%" viewPort="0 0 100 100" viewBox="0 0 100 100">
                       <circle id="value" class ="jqx-value-path" r="50" cx="50" cy="50" transform="rotate(270 50 50)"></circle>
                       <circle id="value" class ="jqx-value" r="50" cx="50" cy="50" transform="rotate(270 50 50)"></circle>
                    </svg>
                    <div class ="jqx-label-container">
                        <content></content>
                        <span id="label" class ="jqx-label"></span>
                    </div>
                </div>`;
    }

    /**
    * Circular Progress bar's event listeners.
    */
    static get listeners() {
        return {
            'resize': '_resizeHandler'
        };
    }

    /**
    * Circular progress bar's ready method.
    **/
    ready() {
        super.ready();

        const that = this;

        that.$.container.style.width = that.$.container.style.height = Math.min(that.offsetWidth, that.offsetHeight) + 'px';

        if (that.$.hasClass('echo-animation')) {
            that.value = that.max;
            that._updateProgress();
        }
    }

    /**
    * Circular Progress Bar's resize handler. Ensures the Progress Bars always has the same proportions.
    **/
    _resizeHandler() {
        const that = this;

        that.$.container.style.width = that.$.container.style.height = Math.min(that.offsetWidth, that.offsetHeight) + 'px';
    }

    /** Updates the progress element. */
    _updateProgress() {
        super._updateProgress();

        const that = this,
            radius = that.indeterminate ? Math.PI * 100 : Math.PI * 100 - that._percentageValue * Math.PI * 100,
            isIE = /*@cc_on!@*/false || !!document.documentMode,
            isEdge = !isIE && !!window.StyleMedia;

        if (that.showProgressValue) {
            const percentage = parseInt(that._percentageValue * 100);

            that.$.label.innerHTML = that.formatFunction ? that.formatFunction(percentage) : percentage + '%';
        }
        else {
            that.$.label.innerHTML = '';
        }

        //Check if the browser is Edge to make the animation
        if (isIE || isEdge) {
            if (that.value === null || that.indeterminate) {
                that.$.value.style.strokeDashoffset = '';
                that.$.value.setAttribute('class', 'jqx-value jqx-value-animation-ms');
                return;
            }
            else {
                that.$.value.setAttribute('class', 'jqx-value');
                that.$.value.style.strokeDashoffset = that.inverted ? -radius : radius;
                return;
            }
        }

        that.$.value.style.strokeDashoffset = that.inverted ? -radius : radius;
        if (that.value === null || that.indeterminate) {
            that.$value.addClass('jqx-value-animation');
            return;
        }

        that.$value.removeClass('jqx-value-animation');
    }
});


JQX('jqx-progress-bar', class ProgressBar extends JQX.BaseProgressBar {

    /** Progressbar's properties */
    static get properties() {
        return {
            'orientation': {
                value: 'horizontal',
                allowedValues: ['horizontal', 'vertical'],
                type: 'string'
            }
        };
    }

    /** progressbar's HTML template. */
    template() {
        return `<div>
                    <div id="value" class="jqx-value"></div>
                    <div id="label" class ="jqx-label"></div>
                </div>`;
    }

    /** Updates the progress elements. */
    _updateProgress() {
        super._updateProgress();

        const that = this;

        //Label for Percentages
        if (that.showProgressValue) {
            const percentage = parseInt(that._percentageValue * 100);

            that.$.label.innerHTML = that.formatFunction ? that.formatFunction(percentage) : percentage + '%';
        }
        else {
            that.$.label.innerHTML = '';
        }

        if (that.value === null || that.indeterminate) {
            that.$value.addClass('jqx-value-animation');
        }
        else {
            that.$value.removeClass('jqx-value-animation');
        }

        that.$.value.style.transform = that.orientation === 'horizontal' ? 'scaleX(' + that._percentageValue + ')' : 'scaleY(' + that._percentageValue + ')';
    }
});

/**
* ScrollBar custom element.
*/
JQX('jqx-scroll-bar', class ScrollBar extends JQX.BaseElement {
    // ScrollBar's properties.
    static get properties() {
        return {
            'clickRepeatDelay': {
                type: 'integer',
                value: 50
            },
            'largeStep': {
                type: 'integer',
                value: 100
            },
            'min': {
                type: 'integer',
                value: 0
            },
            'max': {
                type: 'integer',
                value: 1000
            },
            'mechanicalAction': {
                value: 'switchWhileDragging',
                allowedValues: ['switchUntilReleased', 'switchWhenReleased', 'switchWhileDragging'],
                type: 'string'
            },
            'orientation': {
                type: 'string',
                value: 'horizontal',
                allowedValues: ['horizontal', 'vertical']
            },
            'step': {
                type: 'integer',
                value: 10
            },
            'showButtons': {
                type: 'boolean',
                value: true,
                defaultReflectToAttribute: true
            },
            'value': {
                type: 'integer',
                value: 0
            }
        };
    }

    static get styleUrls() {
        return [
            'jqx.scrollbar.css'
        ]
    }

    /** ScrollBar's template. */
    template() {
        const template =
            `<div id="container" class="jqx-container">
                    <div id="nearButton" class ="jqx-scroll-button jqx-arrow-left"></div>
                    <div  id="track" class ="jqx-track">
                        <div id="thumb" class="jqx-thumb"></div>
                    </div>
                    <div id="farButton" class ="jqx-scroll-button jqx-arrow-right"></div>
            </div>`;

        return template;
    }

    static get listeners() {
        return {
            'nearButton.click': '_nearButtonClickHandler',
            'nearButton.mousedown': '_startRepeat',
            'nearButton.mouseup': '_stopRepeat',
            'nearButton.mouseenter': '_updateInBoundsFlag',
            'nearButton.mouseleave': '_updateInBoundsFlag',
            'farButton.click': '_farButtonClickHandler',
            'farButton.mousedown': '_startRepeat',
            'farButton.mouseup': '_stopRepeat',
            'farButton.mouseenter': '_updateInBoundsFlag',
            'farButton.mouseleave': '_updateInBoundsFlag',
            'track.down': '_trackDownHandler',
            'track.click': '_trackClickHandler',
            'thumb.down': '_dragStartHandler',
            'document.move': '_dragHandler',
            'document.up': '_dragEndHandler',
            'up': '_dragEndHandler',
            'document.selectstart': '_selectStartHandler',
            'resize': '_resizeHandler'
        };
    }

    _updateInBoundsFlag(event) {
        const that = this;

        const button = event.target;

        button._isPointerInBounds = true;

        if (event.type === 'mouseleave') {
            button._isPointerInBounds = false;
        }

        const buttons = ('buttons' in event) ? event.buttons : event.which;
        if (buttons !== 1) {
            that._stopRepeat(event);
        }
    }

    _startRepeat(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        const button = event.target;

        if (!button._initialTimer) {
            button._initialTimer = setTimeout(function () {
                button._repeatTimer = setInterval(() => {
                    if (button._isPointerInBounds) {
                        const buttons = ('buttons' in event) ? event.buttons : event.which;

                        button.$.fireEvent('click', { buttons: buttons, clientX: event.clientX, clientY: event.clientY, pageX: event.pageX, pageY: event.pageY, screenX: event.screenX, screenY: event.screenY });
                    }
                }, that.clickRepeatDelay);
            }, 3 * that.clickRepeatDelay);
        }
    }

    _stopRepeat(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        const button = event.target;

        if (button._repeatTimer) {
            clearInterval(button._repeatTimer);
            button._repeatTimer = null;
        }

        if (button._initialTimer) {
            clearTimeout(button._initialTimer);
            button._initialTimer = null;
        }
    }

    _calculateThumbSize(scrollAreaSize) {
        const that = this;
        const positions = that.max - that.min;
        const enoughSpace = that.orientation === 'horizontal' ?
            that.$.track.offsetWidth > 10 : that.$.track.offsetHeight > 10;
        let size = 0;

        if (positions >= 1 && enoughSpace) {
            size = (scrollAreaSize / (positions + scrollAreaSize) * scrollAreaSize);

            if (that.$.thumb.className.indexOf('jqx-hidden') >= 0) {
                that.$thumb.removeClass('jqx-hidden');
            }
        }
        else {
            that.$thumb.addClass('jqx-hidden');
        }

        return Math.max(10, Math.min(size, scrollAreaSize));
    }

    _dragStartHandler(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        that.thumbCapture = true;
        that.dragStartX = event.clientX;
        that.dragStartY = event.clientY;

        that.dragStartValue = that.value;

        event.stopPropagation();
        event.preventDefault();
    }

    _dragHandler(event) {
        const that = this;

        if (that.thumbCapture !== true) {
            return;
        }

        that._isThumbDragged = true;

        const ratio = (that.max - that.min) / (that.scrollBarSize - that.thumbSize);
        const offsetValue = that.orientation === 'horizontal' ? (event.clientX - that.dragStartX) * ratio : (event.clientY - that.dragStartY) * ratio;
        let step = offsetValue;


        if (that.rightToLeft && that.orientation === 'horizontal') {
            step = -offsetValue;
        }

        that._updateValue(that.dragStartValue + step);

        event.stopPropagation();
        event.preventDefault();

        if (event.originalEvent) {
            event.originalEvent.stopPropagation();
            event.originalEvent.preventDefault();
        }
    }

    _dragEndHandler(event) {
        const that = this;

        if (that._trackDownTimer) {
            clearInterval(that._trackDownTimer);
            that._trackDownTimer = null;
        }

        if (!that.thumbCapture) {
            return;
        }


        that.thumbCapture = false;
        that._isThumbDragged = false;

        if (that.mechanicalAction === 'switchWhenReleased') {
            that._updateValue(that.dragStartValue, that.value);
        }
        else if (this.mechanicalAction === 'switchUntilReleased') {
            that._updateValue(that.dragStartValue);
        }

        event.preventDefault();
        event.stopPropagation();

        event.originalEvent.preventDefault();
        event.originalEvent.stopPropagation();
    }

    _farButtonClickHandler() {
        const that = this;

        if (that.disabled) {
            return;
        }

        const value = that.value;

        that._updateValue(that.value + that.step);

        if (that.mechanicalAction === 'switchUntilReleased') {
            that._updateValue(value);
        }
    }

    _nearButtonClickHandler() {
        const that = this;

        if (that.disabled) {
            return;
        }

        const value = that.value;

        that._updateValue(that.value - that.step);

        if (that.mechanicalAction === 'switchUntilReleased') {
            that._updateValue(value);
        }
    }

    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this;

        switch (propertyName) {
            case 'min':
            case 'max':
            case 'orientation':
            case 'showButtons': {
                that._layout();
                break;
            }
            case 'value':
                that._updateValue(oldValue, newValue);
                break;
        }
    }

    ready() {
        super.ready();

        const that = this;

        that._layout();
    }

    _resizeHandler() {
        const that = this;

        that._layout();
    }

    refresh() {
        const that = this;

        that._layout();
    }

    _layout() {
        const that = this;

        that.scrollBarSize = that.orientation === 'horizontal' ? that.$.track.offsetWidth : that.$.track.offsetHeight;
        that.thumbSize = that._calculateThumbSize(that.scrollBarSize);

        if (that.orientation === 'horizontal' && (that.$.thumb.style.width !== that.thumbSize + 'px')) {
            that.$.thumb.style.width = that.thumbSize + 'px';
        }
        else if (that.orientation === 'vertical' && (that.$.thumb.style.height !== that.thumbSize + 'px')) {
            that.$.thumb.style.height = that.thumbSize + 'px';
        }

        if (that.orientation === 'horizontal') {
            if (that.$.nearButton.classList.contains('jqx-arrow-up')) {
                that.$.nearButton.classList.remove('jqx-arrow-up');
            }

            if (that.$.farButton.classList.contains('jqx-arrow-down')) {
                that.$.farButton.classList.remove('jqx-arrow-down');
            }

            if (!that.$.nearButton.classList.contains('jqx-arrow-left')) {
                that.$.nearButton.classList.add('jqx-arrow-left');
            }

            if (!that.$.farButton.classList.contains('jqx-arrow-right')) {
                that.$.farButton.classList.add('jqx-arrow-right');
            }
        }
        else {
            if (that.$.nearButton.classList.contains('jqx-arrow-left')) {
                that.$.nearButton.classList.remove('jqx-arrow-left');
            }

            if (that.$.farButton.classList.contains('jqx-arrow-right')) {
                that.$.farButton.classList.remove('jqx-arrow-right');
            }

            if (!that.$.nearButton.classList.contains('jqx-arrow-up')) {
                that.$.nearButton.classList.add('jqx-arrow-up');
            }

            if (!that.$.farButton.classList.contains('jqx-arrow-down')) {
                that.$.farButton.classList.add('jqx-arrow-down');
            }
        }


        that._updateThumbPosition();

        if (that.value > that.max || that.value < that.min) {
            that._updateValue(that.value, that.value > that.max ? that.max : that.min);
        }
    }

    _selectStartHandler(event) {
        const that = this;

        if (that.thumbCapture) {
            event.preventDefault();
        }
    }

    _trackDownHandler(event) {
        const that = this;

        if (event.target !== that.$.track) {
            return;
        }

        that._trackDownTimer = setInterval(function () {
            that._trackClickHandler(event);
        }, that.clickRepeatDelay);

        event.stopPropagation();
        event.preventDefault();
    }

    _trackClickHandler(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        if (that._isThumbDragged) {
            clearInterval(that._trackDownTimer);
            that._trackDownTimer = null;
            return;
        }

        const thumbRect = that.$.thumb.getBoundingClientRect();
        const x = event.pageX - window.pageXOffset;
        const y = event.pageY - window.pageYOffset;

        const value = that.value;

        if (that.orientation === 'horizontal') {
            if (x > (that._isThumbDragged ? that.dragStartX : thumbRect.right)) {
                that._updateValue(that.value + that.largeStep);
            }
            else if (x < (that._isThumbDragged ? that.dragStartX : thumbRect.left)) {
                that._updateValue(that.value - that.largeStep);
            }
        }
        else {
            if (y > (that._isThumbDragged ? that.dragStartY : thumbRect.bottom)) {
                that._updateValue(that.value + that.largeStep);
            }
            else if (y < (that._isThumbDragged ? that.dragStartY : thumbRect.top)) {
                that._updateValue(that.value - that.largeStep);
            }
        }

        if (that.mechanicalAction === 'switchUntilReleased') {
            that._updateValue(value);
        }
    }

    _updateValue(oldValue, newValue) {
        const that = this;

        if (arguments.length === 1) {
            newValue = oldValue;
            oldValue = that.value;
        }

        if (newValue === undefined || isNaN(newValue)) {
            newValue = that.min;
        }

        if (newValue > that.max) {
            newValue = that.max;
        }

        if (newValue < that.min) {
            newValue = that.min;
        }

        that.value = newValue;

        if (oldValue !== newValue) {
            that._updateThumbPosition();

            if (that.thumbCapture && that.mechanicalAction === 'switchWhenReleased') {
                return;
            }

            if (that.onChange) {
                that.onChange({ 'value': that.value, 'oldValue': oldValue, min: that.min, max: that.max });
                return;
            }

            that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValue, min: that.min, max: that.max });
        }
    }

    _updateThumbPosition() {
        const that = this;

        const height = that.$.track.offsetHeight;
        const width = that.$.track.offsetWidth;

        const scrollBarSize = (that.orientation === 'horizontal') ? width : height;
        const thumbSize = that._calculateThumbSize(scrollBarSize);
        const maxThumbPosition = (that.orientation === 'horizontal') ? width - thumbSize : height - thumbSize;

        let thumbPosition = (scrollBarSize - thumbSize) / (that.max - that.min) * (that.value - that.min);

        if (that.rightToLeft && that.orientation === 'horizontal') {
            thumbPosition = (scrollBarSize - thumbSize) / (that.max - that.min) * (that.max - that.value - that.min);
        }

        thumbPosition = Math.min(maxThumbPosition, Math.max(0, thumbPosition));

        if (that.orientation === 'vertical' && (that.$.thumb.style.top !== thumbPosition + 'px')) {
            that.$.thumb.style.top = thumbPosition + 'px';
        }
        else if (that.orientation === 'horizontal' && (that.$.thumb.style.left !== thumbPosition + 'px')) {
            that.$.thumb.style.left = thumbPosition + 'px';
        }
    }
});



JQX('jqx-splitter-item', class SplitterItem extends JQX.ContentElement {

    /**
    * Element's properties
    */
    static get properties() {
        return {
            'collapsed': {
                value: false,
                type: 'boolean'
            },
            'collapsible': {
                value: false,
                type: 'boolean'
            },
            'locked': {
                value: false,
                type: 'boolean'
            },
            'max': {
                value: '',
                type: 'any',
                validator: '_propertyValidator'
            },
            'min': {
                value: '',
                type: 'any',
                validator: '_propertyValidator'
            },
            'size': {
                value: '',
                type: 'any',
                validator: '_propertyValidator'
            }
        }
    }

    /**
    * Disables ShadowDOM for the splitter items
    */
    get enableShadowDOM() {
        return false;
    }

    /**
    * Element's template
    */
    template() {
        return `<div id="container">
                    <div class="jqx-header" id="header"></div>
                    <div class="jqx-content" id="content" inner-H-T-M-L="[[innerHTML]]">
                        <content></content>
                    </div>
                </div>`;
    }

    /**
    * Element's event binding
    */
    static get listeners() {
        return {
            'mouseenter': '_mouseEventsHandler',
            'mouseleave': '_mouseEventsHandler',
            'styleChanged': '_styleChangedEventHandler'
        }
    }

    /**
   * Updates the SplitterItem when a property is  changed.
   * @param {string} propertyName The name of the property.
   * @param {number/string} oldValue The previously entered value.
   * @param {number/string} newValue The new entered value.
   */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        switch (propertyName) {
            case 'collapsed':
                that._ignorePropertyValue = true;
                newValue ? that.collapse() : that.expand();
                break;
            case 'collapsible':
                that._updateNearSplitterBars();
                break;
            case 'size':
            case 'min':
            case 'max':
                that._setSize(propertyName, newValue);
                break;
            default:
                super.propertyChangedHandler(propertyName, oldValue, newValue);
                break;
        }
    }

    /**
     * Called when the element is attached to the DOM
     */
    attached() {
        super.attached();

        const that = this;

        if (!that._sizeLimits) {
            that._sizeLimits = {};
        }

        const computedStyle = getComputedStyle(that);

        if (!that.min) {
            that._sizeLimits.minWidth = parseFloat(computedStyle.getPropertyValue('min-width')) || 0;
            that._sizeLimits.minHeight = parseFloat(computedStyle.getPropertyValue('min-height')) || 0;
        }

        if (!that.max) {
            that._sizeLimits.maxWidth = parseFloat(computedStyle.getPropertyValue('max-width')) || 0;
            that._sizeLimits.maxHeight = parseFloat(computedStyle.getPropertyValue('max-height')) || 0;
        }
    }

    /**
     * Called when the element is detached from the DOM
     */
    detached() {
        super.detached();

        const that = this;

        that.$.removeClass('animate');
    }

    /**
   * Appends a node to the splitter item.
   */
    appendChild(node) {
        const that = this;

        if (!node) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'appendChild', node: 'node' }));
            return
        }

        if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        that.$.content.appendChild(node);
    }

    /**
     * Collapses the item
     */
    collapse(far) {
        const that = this;

        if (!that.collapsible) {
            that.collapsed = false;
            return;
        }

        if (that._ignorePropertyValue || !that.collapsed) {
            const ownerElement = (that.getRootNode() ? that.getRootNode().host : null) || that.closest('jqx-splitter');

            if (!ownerElement) {
                return;
            }

            const itemIndex = ownerElement._items.indexOf(that);

            if (itemIndex === ownerElement._items.length - 1) {
                far = true;
            }
            else if (itemIndex === 0) {
                far = false;
            }

            const direction = far ? -1 : 1;
            let neighbourItemIndex = itemIndex + direction,
                neighbourItem = ownerElement._items[neighbourItemIndex];

            while (neighbourItem) {
                if (!neighbourItem.collapsed) {
                    break;
                }

                neighbourItemIndex += direction;
                neighbourItem = ownerElement._items[neighbourItemIndex];
            }

            if (!neighbourItem) {
                that.collapsed = false;
                return;
            }

            delete that._ignorePropertyValue;

            //Store the size before collapsing
            if (!that._sizeBeforeCollapse) {
                that._sizeBeforeCollapse = that[ownerElement._measurements.size];
            }

            if (!neighbourItem._sizeBeforeCollapse) {
                neighbourItem._sizeBeforeCollapse = neighbourItem[ownerElement._measurements.size];
            }

            let splitterBar;

            if (that.previousElementSibling instanceof JQX.SplitterBar) {
                splitterBar = that.previousElementSibling;
            }
            else if (that.nextElementSibling instanceof JQX.SplitterBar) {
                splitterBar = that.nextElementSibling;
            }

            const totalSpace = neighbourItem[ownerElement._measurements.size] + that[ownerElement._measurements.size],
                minSize = splitterBar ? splitterBar[ownerElement._measurements.size] : that._sizeLimits[ownerElement._measurements.minDimension],
                spaceAvailable = totalSpace - minSize;

            if (totalSpace && spaceAvailable < minSize) {
                that.collapsed = false;
                return;
            }

            //Add animation class
            if (that.hasAnimation && !ownerElement._isInitializing) {
                that.$.addClass('animate');
                neighbourItem.$.addClass('animate');

                that.addEventListener('transitionend', that._transitionEndHandler, { once: true });
                that.addEventListener('transitioncancel', that._transitionEndHandler, { once: true });
                neighbourItem.addEventListener('transitionend', that._transitionEndHandler, { once: true });
                neighbourItem.addEventListener('transitioncancel', that._transitionEndHandler, { once: true });
            }

            if (!that._paddings) {
                const computedStyle = getComputedStyle(that);

                that._paddings = (parseFloat(computedStyle.getPropertyValue('padding-' + ownerElement._measurements.position)) || 0) +
                    (parseFloat(computedStyle.getPropertyValue('padding-' + ownerElement._measurements.position2)) || 0);
            }

            if (neighbourItem._sizeBeforeCollapse) {
                neighbourItem._sizeBeforeCollapse = neighbourItem._sizeBeforeCollapse + that._sizeBeforeCollapse;
            }

            if (neighbourItem._sizeLimits && neighbourItem._sizeLimits[ownerElement._measurements.maxDimension] &&
                totalSpace > neighbourItem._sizeLimits[ownerElement._measurements.maxDimension]) {
                neighbourItem._sizeLimits.ignoreUpdate = true;

                if (neighbourItem._sizeBeforeCollapse) {
                    neighbourItem.style[ownerElement._measurements.maxDimension] = neighbourItem._sizeBeforeCollapse + 'px';
                }
                else {
                    neighbourItem.style[ownerElement._measurements.maxDimension] = '';
                }
            }

            if (neighbourItem._sizeBeforeCollapse) {
                neighbourItem.style[ownerElement._measurements.dimension] = neighbourItem._sizeBeforeCollapse + 'px';
            }

            that.style[ownerElement._measurements.dimension] = that.style[ownerElement._measurements.minDimension] = '0';
            that.style.padding = '0'; //Make sure no paddings interferes with the size of the collapsed item
            that._neighbourItem = neighbourItem;

            that.collapsed = true;
            ownerElement.$.fireEvent('collapse', { itemIndex: ownerElement._items.indexOf(that) });

            if (far) {
                that.previousElementSibling.itemCollapsed = true;
                that.previousElementSibling.showFarButton = !(that.previousElementSibling.showNearButton = false);
            }
            else {
                that.nextElementSibling.itemCollapsed = true;
                that.nextElementSibling.showNearButton = !(that.nextElementSibling.showFarButton = false);
            }
        }
    }

    /**
    * Expands a splitter item
    */
    expand() {
        const that = this;

        if (that._ignorePropertyValue || that.collapsed) {
            const ownerElement = (that.getRootNode() ? that.getRootNode().host : null) || that.closest('jqx-splitter');

            if (!ownerElement) {
                that.collapsed = true;
                return;
            }

            if (!that._neighbourItem) {
                that.collapsed = true;
                return;
            }

            delete that._ignorePropertyValue;

            if (!that._neighbourItem._ignorePropertyValue && that._neighbourItem.collapsed) {
                let neighbourItemIndex = ownerElement._items.indexOf(that._neighbourItem);
                const direction = ownerElement._items.indexOf(that) > ownerElement._items.indexOf(that._neighbourItem) ? -1 : 1;

                that._neighbourItem = ownerElement._items[neighbourItemIndex];

                while (that._neighbourItem) {
                    if (!that._neighbourItem.collapsed) {
                        break;
                    }

                    neighbourItemIndex += direction;
                    that._neighbourItem = ownerElement._items[neighbourItemIndex];
                }
            }

            if (!that._neighbourItem) {
                that.collapsed = true;
                return;
            }

            if (that.min) {
                that._setSize('min', that.min, true);
            }

            const totalSpace = that._neighbourItem._sizeBeforeCollapse,
                minSize = that._sizeLimits[ownerElement._measurements.minDimension],
                neighbourItemMin = that._neighbourItem._sizeLimits[ownerElement._measurements.minDimension],
                spaceAvailable = totalSpace - minSize;

            if (totalSpace && spaceAvailable < neighbourItemMin) {
                that.collapsed = true;
                return;
            }

            if (!that._neighbourItem._paddings) {
                const computedStyle = getComputedStyle(that._neighbourItem);

                that._neighbourItem._paddings = (parseFloat(computedStyle.getPropertyValue('padding-' + ownerElement._measurements.position)) || 0) +
                    (parseFloat(computedStyle.getPropertyValue('padding-' + ownerElement._measurements.position2)) || 0);
            }

            if (!that._paddings) {
                const computedStyle = getComputedStyle(that);

                that._paddings = (parseFloat(computedStyle.getPropertyValue('padding-' + ownerElement._measurements.position)) || 0) +
                    (parseFloat(computedStyle.getPropertyValue('padding-' + ownerElement._measurements.position2)) || 0);
            }

            if ((that.size + '').indexOf('%') > -1 && (!that._sizeBeforeCollapse || that._sizeBeforeCollapse === 0) && that._neighbourItem._sizeBeforeCollapse) {
                let totalItemSize = 0;

                ownerElement._items.map(item => totalItemSize += !item.collapsed ?
                    (item.style[ownerElement._measurements.dimension] && item.style[ownerElement._measurements.dimension].indexOf('%') < -1 && item._sizeBeforeCollapse ?
                        item._sizeBeforeCollapse : item.getBoundingClientRect()[ownerElement._measurements.dimension]) : 0);
                that._sizeBeforeCollapse = totalItemSize * parseFloat(that.size) / 100;
            }

            const previousSize = Math.min(Math.max(minSize, that._sizeBeforeCollapse), totalSpace - that._neighbourItem._paddings - that._paddings - neighbourItemMin);

            if (previousSize < 0) {
                that.collapsed = true;
                return;
            }

            //Add animation class
            if (that.hasAnimation && !ownerElement._isInitializing) {
                that.$.addClass('animate');
                that._neighbourItem.$.addClass('animate');

                that.addEventListener('transitionend', that._transitionEndHandler, { once: true });
                that.addEventListener('transitioncancel', that._transitionEndHandler, { once: true });
                that._neighbourItem.addEventListener('transitionend', that._transitionEndHandler, { once: true });
                that._neighbourItem.addEventListener('transitioncancel', that._transitionEndHandler, { once: true });
            }

            //Restore the size before collapsing
            that.style.padding = '';
            that.style[ownerElement._measurements.minDimension] = that.min ? that._sizeLimits[ownerElement._measurements.minDimension] + 'px' : '';
            that.style[ownerElement._measurements.dimension] = (that._sizeBeforeCollapse = previousSize) + 'px';

            that._neighbourItem.style[ownerElement._measurements.dimension] =
                (that._neighbourItem._sizeBeforeCollapse = Math.max(that._neighbourItem._sizeLimits[ownerElement._measurements.minDimension], totalSpace - previousSize)) + 'px';

            if (that._neighbourItem._sizeLimits[ownerElement._measurements.maxDimension]) {
                that._neighbourItem.style[ownerElement._measurements.maxDimension] = that._neighbourItem._sizeLimits[ownerElement._measurements.maxDimension] + 'px';
            }

            that.collapsed = false;
            ownerElement.$.fireEvent('expand', { itemIndex: ownerElement._items.indexOf(that) });

            if (ownerElement._items.indexOf(that) > ownerElement._items.indexOf(that._neighbourItem)) {
                that.previousElementSibling.itemCollapsed = false;
                that.previousElementSibling.showNearButton = that._neighbourItem.collapsible;
            }
            else {
                that.nextElementSibling.itemCollapsed = false;
                that.nextElementSibling.showFarButton = that._neighbourItem.collapsible;
            }

            const previousElement = ownerElement._items[ownerElement._items.indexOf(that) - 1],
                nextElement = ownerElement._items[ownerElement._items.indexOf(that) + 1];

            if (previousElement) {
                const previousSplitterBar = previousElement.nextElementSibling;

                if (previousSplitterBar && previousSplitterBar instanceof JQX.SplitterBar) {
                    if (!previousElement.collapsed) {
                        previousSplitterBar.itemCollapsed = false;
                        previousSplitterBar.showNearButton = previousElement.collapsible;
                        previousSplitterBar.showFarButton = that.collapsible;
                    }
                    else {
                        previousSplitterBar.showNearButton = that.collapsible;
                    }
                }
            }

            if (nextElement) {
                const nextSplitterBar = nextElement.previousElementSibling;

                if (nextSplitterBar && nextSplitterBar instanceof JQX.SplitterBar) {
                    if (!nextElement.collapsed) {
                        nextSplitterBar.itemCollapsed = false;
                        nextSplitterBar.showNearButton = that.collapsible;
                        nextSplitterBar.showFarButton = nextElement.collapsible;
                    }
                    else {
                        nextSplitterBar.showFarButton = nextElement.collapsed;
                    }
                }
            }

            delete that._neighbourItem;
        }
    }

    /**
  * Inserts a node before another node inside the splitter item.
  */
    insertBefore(node, referenceNode) {
        const that = this;

        if (!node) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'insertBefore', node: 'node' }));
            return
        }

        if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        that.$.content.insertBefore(node, referenceNode || null);
    }

    /**
    * Locks a splitter item so it's size can't change.
    */
    lock() {
        const that = this;

        that.locked = true;
    }

    /**
    * Unlocks a splitter item
    */
    unlock() {
        const that = this;

        that.locked = false;
    }

    /**
    * Invoked when an instance of custom element is attached to the DOM for the first time.
    */
    ready() {
        super.ready();

        const that = this,
            ownerElement = that.closest('jqx-splitter'),
            isOwnerReady = ownerElement && ownerElement.isCompleted;

        that._sizeLimits = {};

        let isPercentage = typeof that.min === 'string' && that.min.indexOf('%') > -1;
        const min = isNaN(parseFloat(that.min)) ? 0 : parseFloat(that.min),
            max = isNaN(parseFloat(that.max)) ? 0 : parseFloat(that.max);

        that._sizeLimits.minWidth = that._sizeLimits.minHeight = isPercentage && isOwnerReady ? min * ownerElement[ownerElement._measurements.size] / 100 : min;

        isPercentage = typeof that.max === 'string' && that.max.indexOf('%') > -1;

        that._sizeLimits.maxWidth = that._sizeLimits.maxHeight = isPercentage && isOwnerReady ? max * ownerElement[ownerElement._measurements.size] / 100 : max;

        if (that.size) {
            isPercentage = typeof that.size === 'string' && that.size.indexOf('%') > -1;

            const size = that.size === 'auto' ? that.size : isNaN(parseFloat(that.size)) ? 0 : parseFloat(that.size) + (isPercentage ? '%' : 'px');

            isOwnerReady ? that.style[ownerElement._measurements.dimension] = size : that.style.width = that.style.height = size;
        }

        that._updateNearSplitterBars();
    }

    /**
    * Removes a child from the Splitter item.
    */
    removeChild(node) {
        const that = this;

        if (!node) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'removeChild', node: 'node' }));
            return
        }

        if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        that.$.content.removeChild(node);
    }

    /**
     * Expands regardless of the neighbour item. Force expand
     */
    _expand() {
        const that = this;

        if (that._neighbourItem && that._neighbourItem.parentElement) {
            that.expand();
            return;
        }

        const ownerElement = that.closest('jqx-splitter');

        if (!ownerElement) {
            return;
        }

        delete that._neighbourItem;

        that.collapsed = false;
        ownerElement.$.fireEvent('expand', { itemIndex: ownerElement._items.indexOf(that) });

        that.style[ownerElement._measurements.minDimension] = that.min ? that._sizeLimits[ownerElement._measurements.minDimension] + 'px' : '';
        that.style[ownerElement._measurements.dimension] = that._sizeBeforeCollapse + 'px';

        if (ownerElement._items.length < 2) {
            return;
        }

        if (that.previousElementSibling instanceof JQX.SplitterBar) {
            that.previousElementSibling.itemCollapsed = false;
            that.previousElementSibling.showNearButton = ownerElement._items[ownerElement._items.indexOf(that) - 1].collapsible;
        }
    }

    /**
     * Mouse Enter/Leave event handler
     * @param {any} event
     */
    _mouseEventsHandler(event) {
        const that = this,
            ownerElement = (that.getRootNode() ? that.getRootNode().host : null) || that.closest('jqx-splitter');

        if (ownerElement && !ownerElement.disabled || JQX.Utilities.Core.isMobile) {
            event.type === 'mouseenter' ? this.setAttribute('hover', '') : this.removeAttribute('hover');
        }
    }

    /**
     * Validates the value of the property
     * @param {any} oldValue - the old value
     * @param {any} value - the new value
     */
    _propertyValidator(oldValue, newValue) {
        if (typeof newValue !== 'number' && typeof newValue !== 'string') {
            return oldValue;
        }

        return newValue;
    }

    /**
     * Set the width/height/min/max of the element
     */
    _setSize(propertyName, newValue, noSizeValidation) {
        const that = this;

        if (that.locked) {
            return;
        }

        const ownerElement = that.closest('jqx-splitter');

        if (!ownerElement) {
            return;
        }

        if (!ownerElement.isCompleted) {
            ownerElement.whenReady(() => that._setSize(propertyName, newValue));
            return;
        }

        const isPercentage = typeof newValue === 'string' && newValue.indexOf('%') > -1,
            ownerSize = function () {
                const bars = ownerElement.bars;
                let splitterBarsSize = 0;

                for (let b = 0; b < bars.length; b++) {
                    splitterBarsSize += bars[b][ownerElement._measurements.size];
                }

                return ownerElement.$.container[ownerElement._measurements.size] - splitterBarsSize;
            }();

        newValue = isNaN(parseFloat(newValue)) ? '' : parseFloat(newValue);

        switch (propertyName) {
            case 'size': {
                const oldSize = that[ownerElement._measurements.size];

                if (arguments[1] === 'auto' || !arguments[1]) {
                    that.style[ownerElement._measurements.dimension] = arguments[1];
                    that._sizeBeforeCollapse = that[ownerElement._measurements.size];
                }
                else {
                    if (isPercentage) {
                        that.style[ownerElement._measurements.dimension] = newValue + '%';
                        that._sizeBeforeCollapse = newValue * ownerSize / 100;
                    }
                    else {
                        that.style[ownerElement._measurements.dimension] = (that._sizeBeforeCollapse = newValue || 0) + 'px';
                    }
                }

                const sizeDifference = oldSize - that._sizeBeforeCollapse;

                if (that._originalSize) {
                    that._originalSize = that._sizeBeforeCollapse;
                }

                const lastSplitterItem = ownerElement._items[ownerElement._items.length - 1];

                if (that === lastSplitterItem) {
                    //Get the best fit item
                    let newLastItem = ownerElement._items.find(item => item !== that && !item.collapsed && !item.locked && !item.size)

                    //Get the first possible item
                    if (!newLastItem) {
                        for (let i = Math.max(0, ownerElement._items.length - 2); i >= 0; i--) {
                            if (!ownerElement._items[i].collapsed && !ownerElement._items[i].locked && ownerElement._items[i] !== that) {
                                newLastItem = ownerElement._items[i];
                                break;
                            }
                        }
                    }

                    if (newLastItem) {
                        newLastItem.style[ownerElement._measurements.dimension] = (newLastItem._sizeBeforeCollapse =
                            Math.max(0, newLastItem[ownerElement._measurements.size] + sizeDifference)) + 'px';
                    }
                }

                break;
            }
            case 'min':
                that._sizeLimits['minWidth'] = that._sizeLimits['minHeight'] = isPercentage ? newValue * ownerSize / 100 : newValue;
                that.style[ownerElement._measurements.minDimension] = (that.collapsed || !newValue ? '' : newValue + (isPercentage ? '%' : 'px'));
                that.style['min' + ownerElement._measurements.restricredDimension] = '';

                if (!newValue && !ownerElement._noNeighbourValidation) {
                    ownerElement._validateNeighbourSizeLimits(that);
                }

                break;
            case 'max':
                that._sizeLimits['maxWidth'] = that._sizeLimits['maxHeight'] = isPercentage ? newValue * ownerSize / 100 : newValue;
                that.style[ownerElement._measurements.maxDimension] = newValue ? newValue + (isPercentage ? '%' : 'px') : '';
                that.style['max' + ownerElement._measurements.restricredDimension] = '';

                if (!newValue && !ownerElement._noNeighbourValidation) {
                    ownerElement._validateNeighbourSizeLimits(that);
                }

                break;
        }

        if (!noSizeValidation) {
            ownerElement._validateItemSize(true);
        }
    }

    /**
     * StyleChanged event handler
     */
    _styleChangedEventHandler(event) {
        const that = this;

        if (that.locked) {
            return;
        }

        if (that._sizeLimits.ignoreUpdate) {
            delete that._sizeLimits.ignoreUpdate;
            return;
        }

        if (that.collapsed) {
            return;
        }

        const ownerElement = that.closest('jqx-splitter');
        let value;

        if (event.detail.styleProperties['min-width']) {
            value = event.detail.styleProperties['min-width'][ownerElement && ownerElement.orientation === 'horizontal' ? 'oldValue' : 'value'];
            that._sizeLimits['minWidth'] = (parseFloat(value) || 0) * (value && value.indexOf('%') > -1 ? ownerElement[ownerElement._measurements.size] / 100 : 1);
        }
        else if (event.detail.styleProperties['max-width']) {
            value = event.detail.styleProperties['max-width'][ownerElement && ownerElement.orientation === 'horizontal' ? 'oldValue' : 'value'];
            that._sizeLimits['maxWidth'] = (parseFloat(value) || 0) * (value && value.indexOf('%') > -1 ? ownerElement[ownerElement._measurements.size] / 100 : 1);
        }
        else if (event.detail.styleProperties['min-height']) {
            value = event.detail.styleProperties['min-height'][ownerElement && ownerElement.orientation === 'horizontal' ? 'value' : 'oldValue'];
            that._sizeLimits['minHeight'] = (parseFloat(value) || 0) * (value && value.indexOf('%') > -1 ? ownerElement[ownerElement._measurements.size] / 100 : 1);
        }
        else if (event.detail.styleProperties['max-height']) {
            value = event.detail.styleProperties['max-height'][ownerElement && ownerElement.orientation === 'horizontal' ? 'value' : 'oldValue'];
            that._sizeLimits['maxHeight'] = (parseFloat(value) || 0) * (value && value.indexOf('%') > -1 ? ownerElement[ownerElement._measurements.size] / 100 : 1);
        }
    }

    /**
     * Transitionend Event Handler
     */
    _transitionEndHandler() {
        const that = this;

        if (!that.isCompleted && that.$.hasClass('animate')) {
            return;
        }

        that.$.removeClass('animate');

        if (that._neighbourItem && that._neighbourItem.$.hasClass('animate')) {
            that._neighbourItem.$.removeClass('animate');
        }

        if ((that.size + '').indexOf('%') > -1 || (that._neighbourItem && (that._neighbourItem.size + '').indexOf('%') > -1)) {
            const ownerElement = (that.getRootNode() ? that.getRootNode().host : null) || that.closest('jqx-splitter');

            ownerElement._validateItemSize();
        }
    }

    /**
     * Show/Hide the arrows of the neighbour splitter bars
     */
    _updateNearSplitterBars() {
        const that = this;

        if (that.previousElementSibling instanceof JQX.SplitterBar) {
            that.previousElementSibling.showFarButton = that.collapsible;
        }

        if (that.nextElementSibling instanceof JQX.SplitterBar) {
            that.nextElementSibling.showNearButton = that.collapsible;
        }
    }
});

JQX('jqx-splitter-bar', class SplitterBar extends JQX.BaseElement {

    /**
    * Element's properties
    */
    static get properties() {
        return {
            'showNearButton': {
                value: false,
                type: 'boolean'
            },
            'showFarButton': {
                value: false,
                type: 'boolean'
            },
            'itemCollapsed': {
                value: false,
                type: 'boolean'
            },
            'locked': {
                value: false,
                type: 'boolean'
            }
        }
    }

    /**
    * Disables ShadowDOM for the splitter bars
    */
    get enableShadowDOM() {
        return false;
    }

    /**
    * Element's template
    */
    template() {
        return `<div id="container" >
                    <div class="jqx-splitter-far-collapse-button" id="farCollapseButton">
                        <span id="arrowNear" class="jqx-arrow"></span>
                    </div>
                    <div class="jqx-splitter-resize-button" id="resizeButton">
                        <span></span>
                    </div>
                    <div class="jqx-splitter-near-collapse-button" id="nearCollapseButton">
                        <span id="arrowFar" class="jqx-arrow"></span>
                    </div>
                </div>`;
    }

    /**
    * Element's event binding
    */
    static get listeners() {
        return {
            'mouseenter': '_mouseEventsHandler',
            'mouseleave': '_mouseEventsHandler',
            'mouseover': '_mouseEventsHandler',
            'mouseout': '_mouseEventsHandler',
            'focus': '_focusEventHandler',
            'blur': '_focusEventHandler'
        }
    }

    /**
   * Updates the SplitterBar when a property is  changed.
   * @param {string} propertyName The name of the property.
   * @param {number/string} oldValue The previously entered value.
   * @param {number/string} newValue The new entered value.
   */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        switch (propertyName) {
            case 'unfocusable':
                that._setFocusable();
                break;
            default:
                super.propertyChangedHandler(propertyName, oldValue, newValue);
                break;
        }
    }

    /**
  * Invoked when an instance of custom element is attached to the DOM for the first time.
  */
    ready() {
        super.ready();

        const that = this;

        that._setFocusable();
    }

    /**
     * Hides the Splitter Bar
     */
    hide() {
        const that = this,
            ownerElement = that.closest('jqx-splitter');

        that.$.addClass('jqx-hidden');

        if (ownerElement) {
            const ownerItems = ownerElement.items;

            if (ownerElement.hasAnimation) {
                let animatedItem;

                for (let i = 0; i < ownerItems.length; i++) {
                    if (ownerItems[i].$.hasClass('animate')) {
                        animatedItem = true;
                        ownerItems[i].addEventListener('transitionend', function () {
                            that.closest('jqx-splitter')._autoFitItems();
                        }, { once: true });
                    }
                }

                if (animatedItem) {
                    return;
                }
            }

            ownerElement._autoFitItems();
        }
    }

    /**
     * Shows the Splitter Bar
     */
    show() {
        const that = this,
            ownerElement = that.closest('jqx-splitter');

        that.$.removeClass('jqx-hidden');

        if (ownerElement) {
            const ownerItems = ownerElement.items;

            if (ownerElement.hasAnimation) {
                let animatedItem;

                for (let i = 0; i < ownerItems.length; i++) {
                    if (ownerItems[i].$.hasClass('animate')) {
                        animatedItem = true;
                        ownerItems[i].addEventListener('transitionend', function () {
                            that.closest('jqx-splitter')._autoFitItems();
                        }, { once: true });
                    }
                }

                if (animatedItem) {
                    return;
                }
            }

            ownerElement._autoFitItems();
        }
    }

    /**
    * Locks a splitter bar so it can't be dragged
    */
    lock() {
        const that = this;

        that.locked = that.unfocusable = true;

        if (that.showNearButton || that.showFarButton) {
            return;
        }

        that._setFocusable();
    }

    /**
    * Unlocks a splitter bar
    */
    unlock() {
        const that = this;

        that.locked = that.unfocusable = false;
        that._setFocusable();
    }

    /**
     * Focus/Blur event handler
     * @param {any} event
     */
    _focusEventHandler(event) {
        const that = this,
            ownerElement = (that.getRootNode() ? that.getRootNode().host : null) || that.closest('jqx-splitter');

        if (ownerElement && !ownerElement.disabled) {
            event.type === 'focus' ? this.setAttribute('focus', '') : this.removeAttribute('focus');
        }
    }

    /**
    * Sets tab index
    */
    _setFocusable() {
        const that = this;

        if (that.disabled || that.unfocusable) {
            that.removeAttribute('tabindex');
            return;
        }

        that.tabIndex = that.tabIndex > 0 ? that.tabIndex : 0;
    }

    /**
     * MouseEnter and MouseLeave event handler for the hover state of the Splitter Bar
     */
    _handleHoveredState(ownerElement, type) {
        const that = this;

        switch (type) {
            case 'mouseenter':
                if (!ownerElement._getTargetItem(that, 'previousElementSibling') || !(ownerElement.resizeMode === 'adjacent' ?
                    ownerElement._getTargetItem(that, 'nextElementSibling') : ownerElement._getTargetItem(that, 'previousElementSibling', true))) {
                    return;
                }

                that.setAttribute('hover', '');
                break;
            case 'mouseleave': {
                that.removeAttribute('hover');
                break;
            }
        }
    }

    /**
    * Mouse Over/Out event handler
    * @param {any} event
    */
    _mouseEventsHandler(event) {
        const that = this,
            ownerElement = (that.getRootNode() ? that.getRootNode().host : null) || that.closest('jqx-splitter');

        if (ownerElement && ownerElement.disabled || JQX.Utilities.Core.isMobile) {
            return;
        }

        if (event.type === 'mouseenter' || event.type === 'mouseleave') {
            that._handleHoveredState(ownerElement, event.type);
            return;
        }

        if (event.target.closest('.jqx-splitter-far-collapse-button') === that.$.farCollapseButton) {
            event.type === 'mouseover' ? that.$.farCollapseButton.setAttribute('hover', '') : that.$.farCollapseButton.removeAttribute('hover');
            return;
        }

        if (event.target.closest('.jqx-splitter-near-collapse-button') === that.$.nearCollapseButton) {
            event.type === 'mouseover' ? that.$.nearCollapseButton.setAttribute('hover', '') : that.$.nearCollapseButton.removeAttribute('hover');
            return;
        }

        if (event.target.closest('.jqx-splitter-resize-button') === that.$.resizeButton) {
            event.type === 'mouseover' ? that.$.resizeButton.setAttribute('hover', '') : that.$.resizeButton.removeAttribute('hover');
        }
    }
});

JQX('jqx-splitter', class Splitter extends JQX.ContentElement {

    /**
    * Splitter's properties
    */
    static get properties() {
        return {
            'autoFitMode': {
                allowedValues: ['end', 'proportional', 'overflow'],
                value: 'proportional',
                type: 'string'
            },
            'dataSource': {
                value: null,
                type: 'object?',
                reflectToAttribute: false
            },
            'orientation': {
                allowedValues: ['horizontal', 'vertical'],
                value: 'vertical',
                type: 'string'
            },
            'keepProportionsOnResize': {
                value: false,
                type: 'boolean'
            },
            'resizeMode': {
                allowedValues: ['none', 'adjacent', 'end', 'proportional'],
                value: 'adjacent',
                type: 'string'
            },
            'resizeStep': {
                value: 5,
                type: 'number'
            },
            'liveResize': {
                value: false,
                type: 'boolean'
            },
            'messages': {
                extend: true,
                value: {
                    'en': {
                        'invalidIndex': '{{elementType}}: "{{method}}" method accepts an index of type number.',
                        'indexOutOfBound': '{{elementType}}: Out of bound index/indexes in "{{method}}" method.',
                        'invalidNode': '{{elementType}}: "{{method}}" method accepts an object or an array of objects as it\'s second parameter.',
                        'invalidSettings': '{{elementType}}: "{{method}}" method accepts a string or an object as it\'s second parameter.',
                        'invalidType': '{{elementType}}: "{{propertyName}}" must be of type string or number.'
                    }
                },
                type: 'object'
            }
        };
    }

    /**
    * Splitter's event listeners
    */

    static get listeners() {
        return {
            'focus': '_focusHandler',
            'blur': '_focusHandler',
            'down': '_downHandler',
            'move': '_moveHandler',
            'document.dragstart': '_dragStartHandler',
            'document.move': '_documentMoveHandler',
            'document.up': '_documentUpHandler',
            'keydown': '_keyDownHandler',
            'resize': '_resizeEventHandler'
        }
    }

    /**
     * CSS files needed for the element (ShadowDOM)
     */
    static get styleUrls() {
        return [
            'jqx.button.css',
            'jqx.splitter.css'
        ]
    }

    /** 
    * Splitter's HTML template.
    */
    template() {
        return `<div id="container">
                    <content></content>
                </div>`;
    }

    /**
    * Updates the Splitter when a property is  changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value.
    * @param {number/string} newValue The new entered value.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        switch (propertyName) {
            case 'dataSource':
                that._createLayout();
                break;
            case 'resizeMode':
                delete that._dragDetails;
                break;
            case 'orientation': {
                that._setMeasurements();

                //Used to avoid the animation if enabled
                that.setAttribute('orientation-change', '');

                for (let i = 0; i < that._items.length; i++) {
                    that._items[i].style[that._measurements.dimension] = that._items[i]['offset' + that._measurements.restricredDimension] + 'px';
                    that._items[i].style[that._measurements.restricredDimension.toLowerCase()] = '100%';

                    //Remove previous min/max
                    that._items[i].style['max' + that._measurements.restricredDimension] = 'none';
                    that._items[i].style['min' + that._measurements.restricredDimension] = 'none';

                    //Apply new max
                    that._items[i].style[that._measurements.maxDimension] = that._items[i].max ?
                        that._items[i]._sizeLimits[that._measurements.maxDimension] + 'px' : '';

                    if (that._items[i].collapsed) {
                        that._items[i].style.minWidth = that._items[i].style.minHeight = '';
                        that._items[i].style[that._measurements.minDimension] = '0';
                    }
                    else {
                        that._items[i].style[that._measurements.minDimension] = that._items[i].min ? that._items[i]._sizeLimits[that._measurements.minDimension] + 'px' : '';
                    }
                }

                that._validateItemSize();

                //Used to avoid  the animation if enabled
                that.removeAttribute('orientation-change');
                break;
            }
            case 'unfocusable':
                that._setFocusable();
                break
            default:
                super.propertyChangedHandler(propertyName, oldValue, newValue);
                break;
        }
    }

    /**
    * Appends a node to the splitter.
    */
    appendChild(node) {
        const that = this;

        if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
            const args = Array.prototype.slice.call(arguments, 2);

            return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!node || !(node instanceof JQX.SplitterItem)) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'appendChild', node: 'node' }));
            return
        }

        that.insertBefore(node, null);
    }

    /**
    * Called when the element is attached to the DOM
    */
    attached() {
        super.attached();

        const that = this;

        //Make sure items are calculated properly on attached
        if (that.isCompleted) {
            that._validateItemSize();
        }
    }

    /**
    * Collapses a splitter item
    * item - Number indicating the index of the item / An isntance of JQX.SplitterItem
    * far - indicates whether the item should collapse to it's far or near side
    */
    collapse(item, far) {
        const that = this;

        if (typeof item === 'number') {
            item = that._items[item];
        }

        if (!item) {
            return;
        }

        const closestSplitter = (that.enableShadowDOM ? item.getRootNode().host : item).closest('jqx-splitter');

        if (item instanceof JQX.SplitterItem && closestSplitter === that) {
            item.collapse(far);
            return;
        }

        if (typeof item !== 'number' || !that._items[item]) {
            that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'collapse' }));
            return;
        }

        item.collapse(far);
    }

    /**
    * Expands a splitter item
    */
    expand(item) {
        const that = this;

        if (typeof item === 'number') {
            item = that._items[item];
        }

        if (!item) {
            return;
        }

        const closestSplitter = (that.enableShadowDOM ? item.getRootNode().host : item).closest('jqx-splitter')

        if (item instanceof JQX.SplitterItem && closestSplitter === that) {
            item.expand();
            return;
        }

        if (typeof item !== 'number' || !that._items[item]) {
            that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'expand' }));
            return;
        }

        item.expand();
    }

    /**
     * Hides a splitter bar
     * index - the valid index of a jqxSplitterBar or its instance
     */
    hideBar(item) {
        const that = this;

        if (typeof item === 'number') {
            item = that.bars[item];
        }

        if (!(item instanceof JQX.SplitterBar)) {
            that.error(that.localize('indexOutOfBound', { elementType: that.nodeName.toLowerCase(), method: 'hideBar' }));
            return;
        }

        if (item instanceof JQX.SplitterBar && (that.enableShadowDOM ? item.getRootNode().host : item.closest('jqx-splitter')) === that) {
            item.hide();
        }
    }

    /**
    * Returns an array of Splitter items that are inside the element
    */
    get items() {
        const that = this;

        if (!that.isReady) {
            return;
        }

        const children = that.$.container.children;

        let items = [];

        for (let i = 0; i < children.length; i++) {
            if (children[i] instanceof JQX.SplitterItem || children[i].tagName === 'JQX-SPLITTER-ITEM') {
                items.push(children[i]);
            }
        }

        return items;
    }

    /**
     * Insert a new Splitter item at a given position
     * index - indicates the index at which a new item will be inserted
     */
    insert(index, details) {
        const that = this;

        if (typeof details === 'string') {
            details = { content: details };
        }

        if (!details || typeof details !== 'object') {
            that.error(that.localize('invalidSettings', { elementType: that.nodeName.toLowerCase(), method: 'insert' }));
            return;
        }

        if (typeof index !== 'number') {
            that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'insert' }));
            return;
        }

        const item = details instanceof JQX.SplitterItem ? details : that._createItem(details);

        if (index >= that._items.length || that._items.length === 0) {
            that.appendChild(item);
        }
        else {
            that.insertBefore(item, that._items[index]);
        }
    }

    /**
    * Inserts a new node after another node in the splitter.
    */
    insertBefore(node, referenceNode) {
        const that = this;

        function validateNodeSize() {
            const previousItem = function () {
                let item = node.previousElementSibling;

                while (item) {
                    if (item instanceof JQX.SplitterItem) {
                        return item;
                    }

                    item = item.previousElementSibling;
                }
            }();
            const isPreviousItemLocked = previousItem ? previousItem.locked : undefined;

            if (previousItem) {
                previousItem.locked = false;
            }

            that._resizeHostItemOnInsert(previousItem, node, splitterBar);

            if (that._items) {
                that._items.splice(referenceNode ? that._items.indexOf(referenceNode) : that._items.length, 0, node);
            }

            if (previousItem) {
                if (previousItem.max) {
                    previousItem._setSize('max', previousItem.max, true);
                }

                if (previousItem.min) {
                    previousItem._setSize('min', previousItem.min, true);
                }

                if (isPreviousItemLocked) {
                    previousItem.locked = true;
                }
            }

            that._validateItemSize();
        }

        if (!that.isCompleted) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!node || !(node instanceof JQX.SplitterItem)) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'insertBefore', node: 'newNode/referenceNode' }));
            return;
        }

        if (referenceNode && !(referenceNode instanceof JQX.SplitterItem)) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'insertBefore', node: 'newNode/referenceNode' }));
            return;
        }

        //Set the restricted to fill the Splitter
        node.style[that._measurements.restricredDimension.toLowerCase()] = '100%';

        if (node.size) {
            const unit = typeof node.size === 'string' && node.size.indexOf('%') > -1 ? '%' : 'px';

            node.style[that._measurements.dimension] = node.size === 'auto' ? node.size : isNaN(parseFloat(node.size)) ? '' : parseFloat(node.size) + unit;

            if (that._items.length === 1) {
                that._items[0].size = '';
            }
        }
        else {
            node.style[that._measurements.dimension] = '';
        }

        if (node._sizeBeforeCollapse) {
            if (node.size) {
                const unit = typeof node.size === 'string' && node.size.indexOf('%') > -1 ? '%' : 'px';

                node.style[that._measurements.dimension] = (node.size === 'auto' ? node.size : isNaN(parseFloat(node.size)) ? 0 : parseFloat(node.size) + unit);
                node._sizeBeforeCollapse = node[that._measurements.size];
            }
            else {
                delete node._sizeBeforeCollapse;
            }
        }

        node.style['max' + that._measurements.restricredDimension] = 'none';

        node.style[that._measurements.maxDimension] = node._sizeLimits && node.max ? node._sizeLimits[that._measurements.maxDimension] + 'px' : '';

        if (node.collapsed) {
            node.style.minWidth = node.style.minHeight = '';
            node.style[that._measurements.minDimension] = node.style[that._measurements.dimension] = '0';
        }
        else {
            node.style[that._measurements.minDimension] = node._sizeLimits && node.min ? node._sizeLimits[that._measurements.minDimension] + 'px' : '';
        }

        for (let i = 0; i < that._items.length; i++) {
            if (!that._items[i]._sizeBeforeCollapse) {
                that._items[i]._sizeBeforeCollapse = that._items[i][that._measurements.size];
            }
        }

        that.$.container.insertBefore(node, referenceNode || null);

        let splitterBar;
        const currentSplitterBars = that.bars;

        if (node.previousElementSibling instanceof JQX.SplitterItem) {
            splitterBar = that._createBar(node, node.previousElementSibling);
            that.$.container.insertBefore(splitterBar, node);
        }
        else if (node.nextElementSibling instanceof JQX.SplitterItem) {
            splitterBar = that._createBar(node, node.nextElementSibling);
            that.$.container.insertBefore(splitterBar, node.nextElementSibling);
        }

        if (splitterBar && currentSplitterBars.length > 0) {
            splitterBar.style[that._measurements.restricredDimension.toLowerCase()] = currentSplitterBars[0].style[that._measurements.restricredDimension.toLowerCase()];
        }

        //MS EDGE specific code. In EDGE browser _validateItemSize() is called before the attached method is called
        if (!node.isCompleted) {
            node.__onCompleted = node._onCompleted;

            node._onCompleted = function () {
                if (node.__onCompleted) {
                    node.__onCompleted();
                    delete node.__onCompleted;
                }

                validateNodeSize();

            }
        }
        else {
            validateNodeSize();
        }
    }

    /**
     * Locks a splitter item so it's size can't change.
     * @param {any} item - the index of a Splitter Item or it's instance
     */
    lockItem(item) {
        const that = this;

        if (item instanceof JQX.SplitterItem) {
            item.lock();
            return;
        }

        if (typeof item !== 'number' || !that._items[item]) {
            that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'lockItem' }));
            return;
        }

        item = that._items[item];

        if (item) {
            item.lock();
        }
    }

    /**
    * Locks a splitter bar so it can't be dragged.
    * @param {any} item - the index of a Splitter Bar or it's instance
    */
    lockBar(item) {
        const that = this;

        if (item instanceof JQX.SplitterBar) {
            item.lock();
            return;
        }

        if (typeof item !== 'number') {
            that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'lockBar' }));
            return;
        }

        item = that.bars[item];

        if (item) {
            item.lock();
        }
    }

    /**
    * Set the styleObserver to listen only for resizing
    */
    get hasStyleObserver() {
        return 'resize';
    }

    /**
    * Called when the element is ready
    */
    ready() {
        super.ready();

        const that = this;

        //a flag used to avoid animations on startup
        that._isInitializing = true;

        that._createLayout();
        that._setFocusable();

        delete that._isInitializing;
    }

    /**
     * Refreshes the layout of the element
     */
    refresh() {
        this._resizeEventHandler();
    }

    /**
     * Removes a Splitter item at a given position
     * index - indicates the index at which a new item will be inserted
     */
    remove(index) {
        const that = this;

        if (index instanceof JQX.SplitterItem && index.closest('jqx-splitter') === that) {
            that.removeChild(index);
            return;
        }

        if (typeof index !== 'number') {
            that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'remove' }));
            return;
        }

        if (index > that._items.length || index < 0) {
            that.error(that.localize('indexOutOfBound', { elementType: that.nodeName.toLowerCase(), method: 'remove' }));
            return;
        }

        that.removeChild(that._items[index]);
    }

    /**
     * Remove all items
     */
    removeAll() {
        const that = this;

        that._items = [];
        that.$.container.innerHTML = '';
    }

    /**
    * Removes a node from the splitter.
    */
    removeChild(node) {
        const that = this;

        function getNewNeighbourItem(deletedItemIndex, item, direction) {
            let index = deletedItemIndex,
                newNeighbourItem = that._items[index];

            while (newNeighbourItem) {
                if (!newNeighbourItem.collapsed) {
                    break;
                }

                newNeighbourItem = that._items[index += direction]
            }

            return newNeighbourItem;
        }

        if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!node || !(node instanceof JQX.SplitterItem)) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'removeChild', node: 'node' }));
            return
        }

        if (!that._items) {
            return;
        }

        let itemIndex = that._items.indexOf(node);

        if (node.collapsed) {
            that.$.container.removeChild(that._items.indexOf(node._neighbourItem) > itemIndex ? node.nextElementSibling : node.previousElementSibling);
        }
        else {
            if (node.previousElementSibling instanceof JQX.SplitterBar) {
                that.$.container.removeChild(node.previousElementSibling);
            }
            else if (node.nextElementSibling instanceof JQX.SplitterBar) {
                that.$.container.removeChild(node.nextElementSibling);
            }
        }

        that._items.splice(itemIndex, 1);
        itemIndex = Math.max(0, itemIndex - 1);

        let totalItemSize = 0
        const uncollapsedItems = that._items.filter(item => !item.collapsed && !item.locked),
            nodeSize = node._sizeBeforeCollapse || node[that._measurements.size];

        uncollapsedItems.map(item => totalItemSize += ((item.style[that._measurements.dimension] ? item._sizeBeforeCollapse : 0) || item[that._measurements.size]));

        that.$.content.removeChild(node);

        //If all left items are collapsed, force uncollapsing of the last item
        if ((that._items.length === 1 && that._items[0].collapsed) || (that._items.length > 0 && that._items.map(item => item.collapsed).indexOf(false) < 0)) {
            const lastItem = that._items[that._items.length - 1];
            let context = lastItem.context;

            lastItem.context = lastItem;
            lastItem._expand();
            lastItem.context = context;
        }

        for (let i = 0; i < that._items.length; i++) {
            if (that._items[i].collapsed && that._items[i]._neighbourItem === node) {
                let splitterBar, splitterBarContext;

                that._items[i]._neighbourItem = getNewNeighbourItem(itemIndex, that._items[i], 1);

                if (!that._items[i]._neighbourItem) {
                    that._items[i]._neighbourItem = getNewNeighbourItem(itemIndex, that._items[i], -1);
                    splitterBar = that._items[i].previousElementSibling;

                    if (splitterBar) {
                        splitterBarContext = splitterBar.context;
                        splitterBar.context = splitterBar;
                        splitterBar.itemCollapsed = true;
                        splitterBar.showFarButton = !(splitterBar.showNearButton = false);
                        splitterBar.context = splitterBarContext;
                    }
                }
                else {
                    splitterBar = that._items[i].nextElementSibling;

                    if (splitterBar) {
                        splitterBarContext = splitterBar.context;
                        splitterBar.context = splitterBar;
                        splitterBar.itemCollapsed = true;
                        splitterBar.showNearButton = !(splitterBar.showFarButton = false);
                        splitterBar.context = splitterBarContext;
                    }
                }
            }
        }

        if (that.autoFitMode === 'proportional') {
            let currentItemSize, newSize, itemMinSize;

            for (let i = 0; i < uncollapsedItems.length; i++) {
                currentItemSize = uncollapsedItems[i]._sizeBeforeCollapse || uncollapsedItems[i][that._measurements.size];
                newSize = currentItemSize + (nodeSize * (currentItemSize / totalItemSize));

                //Check for item min size
                itemMinSize = uncollapsedItems[i]._sizeLimits[that._measurements.minDimension] || 0;
                uncollapsedItems[i].style[that._measurements.dimension] = (uncollapsedItems[i]._sizeBeforeCollapse = Math.max(0, newSize)) + 'px';

                if (itemMinSize > currentItemSize) {
                    uncollapsedItems[i][that._measurements.minDimension] = newSize + 'px';
                }
            }
        }

        that._autoFitItems();
    }

    /**
     * Unhides a Splitter Bar
     * item - the index of the splitter bar or it's instance
     */
    showBar(item) {
        const that = this;

        if (item instanceof JQX.SplitterBar) {
            item.show();
            return;
        }

        if (typeof item !== 'number') {
            that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'showBar' }));
            return;
        }

        item = that.bars[item];

        if (!(item instanceof JQX.SplitterBar)) {
            that.error(that.localize('indexOutOfBound', { elementType: that.nodeName.toLowerCase(), method: 'showBar' }));
            return;
        }

        item.show();
    }

    /**
    * Returns an array of Splitter items that are inside the element
    */
    get bars() {
        const that = this;

        if (!that.isReady) {
            return;
        }

        const children = that.$.container.children;

        let items = [];

        for (let i = 0; i < children.length; i++) {
            if (children[i] instanceof JQX.SplitterBar || children[i].tagName === 'JQX-SPLITTER-BAR') {
                items.push(children[i]);
            }
        }

        return items;
    }

    /**
    * Unlocks a previously locked splitter item
    * @param {any} item - the index of a Splitter Item or it's instance
    */
    unlockItem(item) {
        const that = this;

        if (item instanceof JQX.SplitterItem) {
            item.unlock();
            return;
        }

        if (typeof item !== 'number' || !that._items[item]) {
            that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'unlockItem' }));
            return;
        }

        item = that._items[item];

        if (item) {
            item.unlock();
        }
    }

    /**
    * Unlocks a previously locked splitter bar
    * @param {any} item - the index of a Splitter Bar or it's instance
    */
    unlockBar(item) {
        const that = this;

        if (item instanceof JQX.SplitterBar) {
            item.unlock();
            return;
        }

        if (typeof item !== 'number') {
            that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'unlockBar' }));
            return;
        }

        item = that.bars[item];

        if (item) {
            item.unlock();
        }
    }

    /**
     * Updates the Splitter item's properties
     * @param {any} index - index of the splitter item
     * @param {any} settings - object of properties and value
     */
    update(item, settings) {
        const that = this;

        if (typeof item === 'number') {
            item = that._items[item];

            if (!item) {
                that.error(that.localize('invalidIndex', { elementType: that.nodeName.toLowerCase(), method: 'update' }));
                return;
            }
        }

        if (!(item instanceof JQX.SplitterItem) || !settings || (that.enableShadowDOM ? item.getRootNode().host : that.closest('jqx-splitter')) !== that) {
            return;
        }

        for (let key in settings) {
            if (item[key] !== undefined) {
                item[key] = settings[key];
            }
        }
    }

    /**
    * Fits the last item according to the free space left in the Splitter.
    */
    _autoFitItems() {
        const that = this,
            itemsCount = that._items.length;

        if (itemsCount === 0 || that.autoFitMode === 'overflow') {
            return;
        }

        let lastItem,
            lockedItems = [],
            collapsedItems = [],
            itemsWithoutSize = [];

        for (let i = itemsCount - 1; i >= 0; i--) {
            if (that._items[i].collapsed) {
                collapsedItems.push(that._items[i]);
            }
            else if (that._items[i].locked) {
                lockedItems.push(that._items[i]);
            }
            else if (!lastItem) {
                lastItem = that._items[i];
            }
            else if (!that._items[i].size) {
                itemsWithoutSize.push(that._items[i]);
            }
        }

        if (lastItem && lastItem.size && itemsWithoutSize.length > 0) {
            lastItem = itemsWithoutSize.filter(item => !item.max && !item._sizeLimits[that._measurements.maxDimension])[0] || lastItem;
        }

        if (collapsedItems.length === itemsCount) {
            lastItem = collapsedItems[0];
            lastItem.expand();
            lastItem.unlock();
        }

        that._autoFitLastItem(lastItem, collapsedItems, lockedItems);
    }

    /**
     * AutoFits the items by shrinking the last item.
     */
    _autoFitLastItem(lastItem, collapsedItems, lockedItems) {
        const that = this,
            itemsCount = that._items.length;
        let lastLockedItem;

        if (itemsCount === 1 && that._items[0].locked) {
            lastLockedItem = that._items[0];
            lastLockedItem.locked = false;
        }

        if (lockedItems.length === itemsCount) {
            lockedItems[0].unlock();
        }

        if (!lastItem) {
            lastItem = lockedItems[0];
            lastItem.unlock();
        }

        let totalItemSize = 0,
            totalBarsSize = 0;

        that._items.map(item => totalItemSize += !item.collapsed ?
            (item.style[that._measurements.dimension] && item.style[that._measurements.dimension].indexOf('%') < -1 && item._sizeBeforeCollapse ?
                item._sizeBeforeCollapse : item.getBoundingClientRect()[that._measurements.dimension]) : 0);

        that.bars.map(bar => totalBarsSize += bar[that._measurements.size]);

        const currentSplitterSize = totalItemSize + totalBarsSize,
            containerSize = that.$.container.getBoundingClientRect()[that._measurements.dimension];

        if (currentSplitterSize !== containerSize) {
            let lastItemSize;

            if (lastItem.style[that._measurements.dimension].indexOf('%') < -1) {
                lastItemSize = lastItem._sizeBeforeCollapse ? lastItem._sizeBeforeCollapse : lastItem.getBoundingClientRect()[that._measurements.dimension];
            }
            else {
                lastItemSize = lastItem.getBoundingClientRect()[that._measurements.dimension];
            }

            let sizeDifference = Math.abs(containerSize - currentSplitterSize),
                sign = currentSplitterSize < containerSize ? 1 : -1;

            lastItem.style[that._measurements.dimension] =
                (lastItem._sizeBeforeCollapse = Math.max(0, (lastItemSize + sign * sizeDifference))) + 'px';

            if (lastItem._sizeLimits[that._measurements.maxDimension] && lastItem._sizeBeforeCollapse > lastItem._sizeLimits[that._measurements.maxDimension]) {
                lastItem.style[that._measurements.maxDimension] = (lastItem._sizeLimits[that._measurements.maxDimension] = lastItem._sizeBeforeCollapse) + 'px';
            }
        }

        if (lastLockedItem) {
            lastLockedItem.locked = true;
        }
    }

    /**
     * AutoFits the items by proportionally reducing the size of all items
     */
    _autoFitItemsProportionally(newItem, splitterBar) {
        const that = this,
            uncollapsedItems = that._items.filter(item => !item.collapsed);
        let newItemSize = newItem[that._measurements.size],
            totalItemSize = 0;

        uncollapsedItems.map(item => totalItemSize += item._sizeBeforeCollapse || item[that._measurements.size]);

        if (splitterBar) {
            totalItemSize -= splitterBar[that._measurements.size];
        }

        if (newItem.size && !newItem.isCompleted) {
            newItem._setSize('size', newItemSize);
            newItemSize = newItem._sizeBeforeCollapse;
        }

        newItemSize = Math.min(that.$.container[that._measurements.size] / 2, newItem[that._measurements.size]);
        newItem.style[that._measurements.dimension] = newItemSize + 'px';

        let currentItemSize, newSize, itemMinSize;

        for (let i = 0; i < uncollapsedItems.length; i++) {
            currentItemSize = uncollapsedItems[i]._sizeBeforeCollapse || uncollapsedItems[i][that._measurements.size];
            newSize = (totalItemSize - newItemSize) * (currentItemSize / totalItemSize);

            //Check for item min size
            itemMinSize = uncollapsedItems[i]._sizeLimits[that._measurements.minDimension] || 0;
            uncollapsedItems[i].style[that._measurements.dimension] = (uncollapsedItems[i]._sizeBeforeCollapse = Math.max(itemMinSize, newSize)) + 'px';
        }
    }

    /**
     * Reads the dataSource and populates the Splitter with items.
     */
    _createLayout() {
        const that = this;

        that._items = [];

        if (typeof that.dataSource === 'string') {
            that.dataSource = JSON.parse(that.dataSource);
        }

        if (that.dataSource !== null && Array.isArray(that.dataSource)) {
            that.$.container.innerHTML = '';

            let fragment = document.createDocumentFragment(), item;

            for (let i = 0; i < that.dataSource.length; i++) {
                item = that._createItem(that.dataSource[i]);
                fragment.appendChild(item);
            }

            that._handleSplitterBars(fragment);
            return;
        }

        that._handleSplitterBars(that.$.container);
    }

    /**
     * Creates a splitter bar
     * @param {any} item - the item that precedes a splitter item
     */
    _createBar(item, neighbourItem) {
        const that = this,
            splitBar = document.createElement('jqx-splitter-bar');

        if (item.collapsed) {
            splitBar.itemCollapsed = true;

            if (that._items.indexOf(item) === that._items.length - 1) {
                splitBar.showNearButton = true;
            }
            else {
                splitBar.showFarButton = true;
            }
        }
        else {
            if (item.collapsible) {
                splitBar.showNearButton = true;
            }

            if (neighbourItem && neighbourItem instanceof JQX.SplitterItem && neighbourItem.collapsible) {
                neighbourItem === item.nextElementSibling ? splitBar.showFarButton = true : splitBar.showNearButton = true;
            }
        }

        return splitBar;
    }

    /**
     * Creates a splitter item
     */
    _createItem(data) {
        const item = document.createElement('jqx-splitter-item');

        if (data.id) {
            item.id = data.id;
        }

        item.innerHTML = data.content || '';
        item.collapsible = data.collapsible || false;
        item.collapsed = data.collapsed || false;
        item.locked = data.locked || false;

        if (data.max) {
            item.max = data.max;
        }

        if (data.min) {
            item.min = data.min;
        }

        if (data.size) {
            item.size = data.size;
        }

        return item;
    }

    /**
    * Finishes the resizing operation
    */
    _completeResizing(canceled) {
        const that = this;

        if (that._dragDetails) {
            if (that._splitBarDummy && that._splitBarDummy.parentElement) {
                if (!canceled) {
                    that._dragDetails.firstItem.style[that._measurements.dimension] =
                        (that._dragDetails.firstItem._sizeBeforeCollapse = that._dragDetails.firstItem.currentSize + that._dragDetails.firstItem._paddings) + 'px';
                    delete that._dragDetails.firstItem._originalSize;

                    if (that.resizeMode !== 'proportional') {
                        that._dragDetails.secondItem.style[that._measurements.dimension] =
                            (that._dragDetails.secondItem._sizeBeforeCollapse = that._dragDetails.splitAreaSize -
                                that._dragDetails.firstItem.currentSize + that._dragDetails.secondItem._paddings) + 'px';
                        delete that._dragDetails.secondItem._originalSize;
                    }
                    else {
                        const itemCount = that._dragDetails.itemProportions.length;

                        if (itemCount > 1) {
                            for (let p = 0; p < itemCount; p++) {
                                that._dragDetails.itemProportions[p].item.style[that._measurements.dimension] =
                                    (that._dragDetails.itemProportions[p].item._sizeBeforeCollapse = that._dragDetails.itemProportions[p].currentSize +
                                        that._dragDetails.itemProportions[p].item._paddings) + 'px';
                                delete that._dragDetails.itemProportions[p]._originalSize;
                            }
                        }
                        else {
                            that._dragDetails.secondItem[0].style[that._measurements.dimension] =
                                (that._dragDetails.secondItem[0]._sizeBeforeCollapse = Math.floor(that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize +
                                    that._dragDetails.firstItem._paddings)) + 'px';
                            delete that._dragDetails.secondItem[0]._originalSize;
                        }
                    }

                }

                that.$.fireEvent('resizeEnd', {
                    firstItem: {
                        index: that._items.indexOf(that._dragDetails.firstItem),
                        oldSize: that._dragDetails.firstItem.originalSize,
                        newSize: that._dragDetails.firstItem[that._measurements.size]
                    },
                    secondItem: Array.isArray(that._dragDetails.secondItem) ?
                        {
                            index: that._dragDetails.secondItem.map(item => that._items.indexOf(item)),
                            oldSize: that._dragDetails.secondItem.map(item => item.originalSize),
                            newSize: that._dragDetails.secondItem.map(item => item[that._measurements.size])
                        } :
                        {
                            index: that._items.indexOf(that._dragDetails.secondItem),
                            oldSize: that._dragDetails.secondItem.originalSize,
                            newSize: that._dragDetails.secondItem[that._measurements.size]
                        }
                });

                that._splitBarDummy.classList.remove('limit-reached');
                that._splitBarDummy.parentElement.removeChild(that._splitBarDummy);
            }

            that.removeAttribute('dragged');

            delete that._dragDetails;
            delete that._keyboardResizing;
        }
    }

    /**
     * Document DragStart event handler
     * @param {any} event
     */
    _dragStartHandler(event) {
        const that = this;

        if (that._dragDetails) {
            event.preventDefault();
        }
    }

    /**
     * Splitter mouse down event handler
     */
    _downHandler(event) {
        const that = this;

        event.stopPropagation();

        if (that.disabled) {
            return;
        }

        if (that._keyboardResizing) {
            that._completeResizing();
            return;
        }

        let target, closestSplitter;

        if (that.enableShadowDOM) {
            target = event.originalEvent.composedPath()[0]
            closestSplitter = target.getRootNode().host;
        }
        else {
            target = event.originalEvent.target;
            closestSplitter = target.closest('jqx-splitter');
        }

        const closestSplitterBar = target && target.closest ? target.closest('jqx-splitter-bar') : null;

        if (closestSplitterBar && closestSplitter === that) {
            //Collapse Near item
            if (target.closest('.jqx-splitter-near-collapse-button') === closestSplitterBar.$.nearCollapseButton) {
                that._collapseButtonPressed = {
                    splitBar: closestSplitterBar,
                    item: closestSplitterBar.previousElementSibling,
                    target: closestSplitterBar.$.nearCollapseButton,
                    farCollapse: false
                };
                return;
            }

            //Collapse far item
            if (target.closest('.jqx-splitter-far-collapse-button') === closestSplitterBar.$.farCollapseButton) {
                that._collapseButtonPressed = {
                    splitBar: closestSplitterBar,
                    item: closestSplitterBar.nextElementSibling,
                    target: closestSplitterBar.$.farCollapseButton,
                    farCollapse: true
                };
                return;
            }

            if (!closestSplitterBar.itemCollapsed && !closestSplitterBar.locked && that.resizeMode !== 'none') {
                that._setDragDetails(closestSplitterBar, event);
            }
        }
    }

    /**
     * iOS Safari bug fix. (iOS Safari doesn't support 'touch-action: none')
     */
    _moveHandler() {
        if (this.hasAttribute('dragged') && JQX.Utilities.Core.isMobile) {
            event.originalEvent.preventDefault();
        }
    }

    /**
     * Document move event handler
     */
    _documentMoveHandler(event) {
        const that = this;

        if (that._keyboardResizing) {
            return;
        }

        that._resize(event);
    }

    /**
     * Document move event handler
     */
    _documentUpHandler(event) {
        const that = this;

        that.removeAttribute('dragging-not-allowed');
        that.removeAttribute('show-locked-items');

        if (that.disabled) {
            delete that._dragDetails;
            delete that._collapseButtonPressed;
            return;
        }

        const target = that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target;

        that._completeResizing();

        if (that._collapseButtonPressed &&
            target.closest('.' + that._collapseButtonPressed.target.classList[0]) === that._collapseButtonPressed.target) {
            if (that._collapseButtonPressed.item.collapsed) {
                that.expand(that._collapseButtonPressed.item);
            }
            else {
                that.collapse(that._collapseButtonPressed.item, that._collapseButtonPressed.farCollapse);
            }

            delete that._collapseButtonPressed;
            return;
        }
    }

    /**
     * Ensures that all items are attached and ready.
     * @param {any} nodes - nodes that are not ready
     * @param {any} callback - a function to be called when all items are ready
     */
    _ensureItemsReady(nodes, callback) {
        const that = this;

        const contextCallback = function () {
            const setContext = function (context) {
                for (let i = 0; i < nodes.length; i++) {
                    nodes[i].context = context === 'node' ? nodes[i] : document;
                }
            }

            setContext('node');
            callback();
            setContext();
        }

        if (nodes.length === 0) {
            contextCallback();
        }
        else {
            that._nodesReadyListeners = 0;

            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];

                const readyEventHandler = function () {
                    that._nodesReadyListeners--;
                    if (that._nodesReadyListeners === 0) {
                        contextCallback();

                        delete that._nodesReadyListeners;
                    }
                }.bind(that);

                if (!node.isCompleted) {
                    that._nodesReadyListeners++;
                    node._onCompleted = readyEventHandler;
                }
            }

            if (that._nodesReadyListeners === 0) {
                contextCallback();
            }
        }
    }

    /**
     * Element's focus handler
     */
    _focusHandler(event) {
        const that = this;

        event.type === 'focus' ? that.setAttribute('focus', '') : that.removeAttribute('focus');
    }

    /**
     * Used in _setDragDetails() method to get the desired item ( first and second )
     * @param {any} sibling - next item
     * @param {any} reverse - reverse order flag
     */
    _getTargetItem(splitter, sibling, reverse) {
        const that = this;
        let previousItem = reverse ? that._items[that._items.length - 1] : splitter[sibling];

        while (previousItem) {

            if (previousItem instanceof JQX.SplitterItem && !previousItem.collapsed) {
                if (!previousItem.locked) {
                    return previousItem;
                }

                if (that._dragDetails && !that._dragDetails.firstItem) {
                    that._dragDetails.lockedItemsSize += previousItem[that._measurements.size] + (previousItem.previousElementSibling instanceof JQX.SplitterBar ?
                        previousItem.previousElementSibling[that._measurements.size] : 0);
                }
            }

            previousItem = previousItem[sibling];
        }
    }

    /**
     * Adds/Removes split bars
     */
    _handleSplitterBars(itemContainer) {
        const that = this;

        if (that._items.length < 1) {
            //IE11 has no support for DocumentFragment.children. Use childNodes instead if no polyfill is provided
            that._items = itemContainer.parentElement ? that.items : Array.from(itemContainer.children);
        }

        if (!that._measurements) {
            that._setMeasurements();
        }

        if (that._items.length < 2) {
            const splitBars = that.bars;

            for (let i = 0; i < splitBars.length; i++) {
                itemContainer.removeChild(splitBars[i]);
            }
        }

        if (!itemContainer.parentElement && itemContainer !== that.$.container) {
            that.$.container.appendChild(itemContainer);
        }

        for (let i = 0; i < that._items.length; i++) {
            that._items[i].style[that._measurements.restricredDimension.toLowerCase()] = '100%';
            that._items[i].style['max' + that._measurements.restricredDimension] = 'none';

            if (!that._items[i].size) {
                that._items[i].style[that._measurements.dimension] = that._items[i]._sizeBeforeCollapse ? that._items[i]._sizeBeforeCollapse + 'px' : '';
            }

            const min = that._items[i].min,
                max = that._items[i].max;

            if (typeof min === 'string' && min.indexOf('%') > -1) {
                that._items[i]._setSize('min', min);
            }

            if (typeof max === 'string' && max.indexOf('%') > -1) {
                that._items[i]._setSize('max', max);
            }

            that._items[i].style[that._measurements.maxDimension] = that._items[i].max ?
                that._items[i]._sizeLimits[that._measurements.maxDimension] + 'px' : '';

            if (that._items[i].nextElementSibling) {
                const nextElementSibling = that._items[i].nextElementSibling;

                if (nextElementSibling instanceof JQX.SplitterItem || nextElementSibling.tagName.toLowerCase() === 'jqx-splitter-item') {
                    that._items[i].parentNode.insertBefore(that._createBar(that._items[i], that._items[i].nextElementSibling), that._items[i].nextElementSibling);
                }
                else {
                    that._items[i].parentNode.removeChild(that._items[i].nextElementSibling);
                }
            }

            if (that._items[i].collapsed) {
                const collapsible = that._items[i].collapsible;

                that._items[i].style.minWidth = that._items[i].style.minHeight = '';
                that._items[i].style[that._measurements.minDimension] = '0';
                that._items[i]._ignorePropertyValue = true;

                //Force collapse it
                that._items[i].collapsible = true;
                that._items[i].collapse();

                //Return original proeprty value
                that._items[i].collapsible = collapsible;
            }
            else {
                that._items[i].style[that._measurements.minDimension] = that._items[i]._sizeLimits && that._items[i].min ?
                    that._items[i]._sizeLimits[that._measurements.minDimension] + 'px' : '';
            }
        }

        //if (!itemContainer.parentElement && itemContainer !== that.$.container) {
        //    that.$.container.appendChild(itemContainer);
        //}

        //MS EDGE fix when items are supposed to be ready but they are not yet
        that._ensureItemsReady(that._items, that._validateItemSize.bind(that));
    }

    /**
     * Key down event handler
     * @param {any} event
     */
    _keyDownHandler(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        let splitterBar = that.enableShadowDOM ? that.shadowRoot.activeElement : document.activeElement;

        if (event.key === 'w' && event.altKey) {
            //Prevents container scrolling
            event.preventDefault();

            const firstItem = that.enableShadowDOM ? that.shadowRoot.querySelector('jqx-splitter-bar') : that.querySelector('jqx-splitter-bar');

            if (splitterBar !== firstItem) {
                that._completeResizing(true);
            }

            firstItem.focus();
            return;
        }

        if (!event.ctrlKey && that._splitBarDummy && that._splitBarDummy.parentElement) {
            splitterBar = that._splitBarDummy;
        }
        else if (!(splitterBar instanceof JQX.SplitterBar)) {
            return;
        }

        if ((that.enableShadowDOM ? splitterBar.getRootNode().host : splitterBar.closest('jqx-splitter')) !== that) {
            return;
        }

        switch (event.key) {
            case 'ArrowLeft':
            case 'ArrowRight':
            case 'ArrowUp':
            case 'ArrowDown': {
                if ((event.key === 'ArrowUp' || event.key === 'ArrowDown') && that.orientation === 'vertical') {
                    return;
                }

                if ((event.key === 'ArrowLeft' || event.key === 'ArrowRight') && that.orientation === 'horizontal') {
                    return;
                }

                //Prevents container scrolling
                event.preventDefault();

                const direction = event.key === 'ArrowLeft' || event.key === 'ArrowUp' ? -1 : 1;

                if (event.ctrlKey) {

                    //Cancel resizing if it's in motion
                    that._completeResizing(true);

                    let neighbourItem, targetItem;

                    if (direction < 0) {
                        targetItem = splitterBar.previousElementSibling;
                        neighbourItem = splitterBar.nextElementSibling;
                    }
                    else {
                        neighbourItem = splitterBar.previousElementSibling;
                        targetItem = splitterBar.nextElementSibling;
                    }

                    neighbourItem.collapsed ? neighbourItem.expand() : targetItem.collapse(direction > 0);
                    return;
                }

                if (splitterBar.locked) {
                    return;
                }

                if (that.resizeMode === 'none') {
                    return;
                }

                that._keyboardResizing = true;

                let currentPosition;

                if (!that._dragDetails) {
                    that._setDragDetails(splitterBar);
                    currentPosition = splitterBar[that._measurements.offset] + direction * that.resizeStep;
                }
                else {
                    currentPosition = that._dragDetails.position + direction * that.resizeStep;
                }

                //Requires event parameter so we imitate it with an object
                that._resize({ pageX: currentPosition, pageY: currentPosition });
                break;
            }
            case 'Enter':
                that._completeResizing();
                break;
            case 'Escape':
            case 'Tab':
                that._completeResizing(true);
                break;
        }
    }

    /**
     * Mouse Enter/Leave event handler
     * @param {any} event
     */
    _mouseEventsHandler(event) {
        event.type === 'mouseenter' && !JQX.Utilities.Core.isMobile ? this.setAttribute('hover', '') : this.removeAttribute('hover');
    }

    /**
    * Used to recalculate the Proportions during resizing when resizeMode is 'proportional'
    * @param {any} amount - amount of size that has changed since the start of the operation till now
    * @param {any} totalItemsCount - total number of all items that are being resized
    * @param {any} resizableItemsCount - the number of items that can be resized.
    */
    _recalcItemSize(amount, totalItemsCount, resizableItemsCount) {
        const that = this;
        let usedSize, minSize;

        if (!resizableItemsCount) {
            resizableItemsCount = totalItemsCount;
        }

        if (amount > 0) {
            for (let p = 0; p < totalItemsCount; p++) {
                minSize = that._dragDetails.itemProportions[p].item._sizeLimits[that._measurements.minDimension];

                if (that._dragDetails.itemProportions[p].currentSize > minSize) {
                    if (that._dragDetails.itemProportions[p].currentSize - minSize < amount / resizableItemsCount) {
                        usedSize = that._dragDetails.itemProportions[p].currentSize - minSize;
                    }
                    else {
                        usedSize = amount / resizableItemsCount;
                    }

                    amount -= usedSize;
                    that._dragDetails.itemProportions[p].currentSize = Math.max(minSize, that._dragDetails.itemProportions[p].currentSize - usedSize);
                    delete that._dragDetails.itemProportions[p]._originalSize;
                }

                resizableItemsCount = Math.max(1, resizableItemsCount - 1);
            }
        }
        else {
            const maxSize = (that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize) -
                (totalItemsCount > 1 ? that._dragDetails.secondItemTotalMinSize - that._dragDetails.itemProportions[0].item._sizeLimits[that._measurements.minDimension] : 0);
            let itemMaxSize;

            for (let p = 0; p < totalItemsCount; p++) {
                if (that._dragDetails.itemProportions[p].item._sizeLimits[that._measurements.maxDimension]) {
                    itemMaxSize = Math.min(that._dragDetails.itemProportions[p].item._sizeLimits[that._measurements.maxDimension], maxSize);
                }
                else {
                    itemMaxSize = maxSize;
                }

                if (that._dragDetails.itemProportions[p].currentSize < itemMaxSize) {
                    if (that._dragDetails.itemProportions[p].currentSize - amount / resizableItemsCount > itemMaxSize) {
                        usedSize = -1 * (itemMaxSize - that._dragDetails.itemProportions[p].currentSize);
                    }
                    else {
                        usedSize = amount / resizableItemsCount;
                    }

                    amount -= usedSize;
                    that._dragDetails.itemProportions[p].currentSize = Math.min(itemMaxSize, that._dragDetails.itemProportions[p].currentSize - usedSize);
                    delete that._dragDetails.itemProportions[p]._originalSize;
                }

                resizableItemsCount = Math.max(1, resizableItemsCount - 1);
            }
        }

        //size less than 0.1 is too small to care. JS can't compute properly with too small values
        if (Math.abs(amount) > 0.1) {
            that._recalcItemSize(amount, totalItemsCount, resizableItemsCount);
        }
    }

    /**
    * Resizes the splitter items
    */
    _resize(event) {
        const that = this;

        if (!that._dragDetails) {
            return;
        }

        let distance = event[that._measurements.pagePosition] - that._dragDetails.position, isLimitReached;

        const direction = Math.sign(distance),
            firstItemMinSize = that._dragDetails.firstItem._sizeLimits[that._measurements.minDimension],
            firstItemMaxSize = that._dragDetails.firstItem._sizeLimits[that._measurements.maxDimension];

        let sizeAvailable, isPossibleToResize;

        if (!that.hasAttribute('dragged')) {
            that.$.fireEvent('resizeStart', {
                firstItem: {
                    index: that._items.indexOf(that._dragDetails.firstItem),
                    size: that._dragDetails.firstItem[that._measurements.size]
                },
                secondItem: Array.isArray(that._dragDetails.secondItem) ?
                    {
                        index: that._dragDetails.secondItem.map(item => that._items.indexOf(item)),
                        size: that._dragDetails.secondItem.map(item => item[that._measurements.size])
                    } :
                    {
                        index: that._items.indexOf(that._dragDetails.secondItem),
                        size: that._dragDetails.secondItem[that._measurements.size]
                    }
            });
        }

        that.setAttribute('dragged', '');

        if (Math.abs(distance) < that.resizeStep) {
            return;
        }

        let coercedDistance = Math.max(that.resizeStep, Math.floor(Math.abs(distance) / that.resizeStep) * that.resizeStep);
        const offset = distance - (direction * coercedDistance);

        switch (that.resizeMode) {
            case 'adjacent':
            case 'end':
                if (direction > 0) {
                    sizeAvailable = that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize;
                    isPossibleToResize = () => sizeAvailable - that._dragDetails.secondItemTotalMinSize >= coercedDistance ||
                        (firstItemMaxSize && that._dragDetails.firstItem.currentSize + that.resizeStep <= firstItemMaxSize);
                    isLimitReached = () => (firstItemMaxSize && that._dragDetails.firstItem.currentSize === firstItemMaxSize) ||
                        sizeAvailable - that.resizeStep <= that._dragDetails.secondItemTotalMinSize;
                }
                else {
                    sizeAvailable = that._dragDetails.firstItem.currentSize;
                    isPossibleToResize = () => sizeAvailable - firstItemMinSize >= coercedDistance ||
                        (that._dragDetails.secondItemTotalMaxSize &&
                            that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize + that.resizeStep <= that._dragDetails.secondItemTotalMaxSize);
                    isLimitReached = () => (that._dragDetails.secondItemTotalMaxSize &&
                        that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize === that._dragDetails.secondItemTotalMaxSize) ||
                        sizeAvailable - that.resizeStep <= firstItemMinSize;
                }

                distance = 0;

                while (coercedDistance > 0) {
                    if (isPossibleToResize()) {
                        distance += direction * that.resizeStep;
                    }

                    coercedDistance -= that.resizeStep;
                }

                that._resizeItem(event, distance, offset);
                break;
            case 'proportional': {
                const initialRemainingSpace = (that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize);

                if (direction > 0) {
                    sizeAvailable = Math.abs(initialRemainingSpace - that._dragDetails.secondItemTotalMinSize);
                    isPossibleToResize = () => sizeAvailable >= coercedDistance ||
                        (firstItemMaxSize && that._dragDetails.firstItem.currentSize + that.resizeStep <= firstItemMaxSize);
                    isLimitReached = () => (firstItemMaxSize && that._dragDetails.firstItem.currentSize === firstItemMaxSize) ||
                        that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize - that.resizeStep < that._dragDetails.secondItemTotalMinSize;
                }
                else {
                    sizeAvailable = that._dragDetails.firstItem.currentSize;
                    //TODO: ResizeStep is not taken into account properly
                    isPossibleToResize = () => sizeAvailable - firstItemMinSize >= coercedDistance &&
                        (that._dragDetails.secondItemTotalMaxSize ? that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize +
                            that.resizeStep <= that._dragDetails.secondItemTotalMaxSize : true);
                    isLimitReached = () => (that._dragDetails.secondItemTotalMaxSize &&
                        that._dragDetails.splitAreaSize + that.resizeStep - that._dragDetails.firstItem.currentSize >= that._dragDetails.secondItemTotalMaxSize) ||
                        that._dragDetails.firstItem.currentSize - that.resizeStep < firstItemMinSize;
                }

                let newSize, isResized;

                while (coercedDistance > 0) {
                    if (isPossibleToResize()) {
                        isResized = true;
                        newSize = Math.min(firstItemMaxSize ?
                            Math.min(firstItemMaxSize, that._dragDetails.splitAreaSize - that._dragDetails.secondItemTotalMinSize) :
                            that._dragDetails.splitAreaSize - that._dragDetails.secondItemTotalMinSize,
                            Math.max(firstItemMinSize, that._dragDetails.firstItem.currentSize + direction * that.resizeStep));

                        that._dragDetails.firstItem.currentSize = that._dragDetails.firstItem._sizeBeforeCollapse = Math.floor(newSize);
                    }

                    coercedDistance -= that.resizeStep;
                }

                if (!isResized) {
                    break;
                }

                const remaningSpaceAfterResize = that._dragDetails.splitAreaSize - that._dragDetails.firstItem.currentSize,
                    itemCount = that._dragDetails.itemProportions.length;

                //Recalculate the proportions
                that._recalcItemSize(initialRemainingSpace - remaningSpaceAfterResize, itemCount);

                if (that.liveResize) {
                    that._dragDetails.firstItem.style[that._measurements.dimension] = (that._dragDetails.firstItem.currentSize + that._dragDetails.firstItem._paddings) + 'px';

                    if (itemCount > 1) {
                        for (let p = 0; p < itemCount; p++) {
                            that._dragDetails.itemProportions[p].item.style[that._measurements.dimension] =
                                that._dragDetails.itemProportions[p].item._sizeBeforeCollapse =
                                (that._dragDetails.itemProportions[p].currentSize + that._dragDetails.itemProportions[p].item._paddings) + 'px';
                        }
                    }
                    else {
                        that._dragDetails.secondItem[0].style[that._measurements.dimension] =
                            (that._dragDetails.secondItem[0]._sizeBeforeCollapse = Math.floor(remaningSpaceAfterResize + that._dragDetails.itemProportions[0].item._paddings)) + 'px';
                    }
                }
                else {
                    that._splitBarDummy.style[that._measurements.position] = (that._dragDetails.firstItem[that._measurements.offset] +
                        that._dragDetails.firstItem.currentSize + that._dragDetails.lockedItemsSize + that._dragDetails.firstItem._paddings) + 'px';
                }

                const edge = that._dragDetails.firstItem.getBoundingClientRect()[that.orientation === 'vertical' ? 'left' : 'top'] + that._dragDetails.splitBarOffset;

                const maxPosition = firstItemMaxSize &&
                    that._dragDetails.splitAreaSize - firstItemMaxSize > that._dragDetails.secondItemTotalMinSize ?
                    firstItemMaxSize : that._dragDetails.splitAreaSize - that._dragDetails.secondItemTotalMinSize;

                that._dragDetails.position = Math.max(edge + (that._dragDetails.secondItemTotalMaxSize ?
                    Math.max(that._dragDetails.splitAreaSize - that._dragDetails.secondItemTotalMaxSize, firstItemMinSize) : firstItemMinSize) +
                    that._dragDetails.lockedItemsSize + that._dragDetails.firstItem._paddings,
                    Math.min(edge + maxPosition + that._dragDetails.lockedItemsSize + that._dragDetails.firstItem._paddings, event[that._measurements.pagePosition] - offset));
                break;
            }
        }

        if (!that.liveResize) {
            isLimitReached() ? that._splitBarDummy.classList.add('limit-reached') : that._splitBarDummy.classList.remove('limit-reached');
        }

        //Should be called only when Splitter's width is auto
        that._validateBarsSize();
    }

    /**
     * Style Changed Event Handler - Refits the items if necessary
     */
    _resizeEventHandler() {
        const that = this;

        that._resizeEventFired = true;
        that._validateItemSize();
        that._resizeEventFired = false
    }

    /**
     * Resize the host item when inserting a new one inside it
     * @param {any} hostItem
     */
    _resizeHostItemOnInsert(hostItem, newItem, splitterBar) {
        const that = this;

        if (that.autoFitMode === 'proportional') {
            that._autoFitItemsProportionally(newItem, splitterBar);
            return;
        }

        if (!hostItem || hostItem.locked) {
            return;
        }

        if (newItem.size) {
            const itemWithoutSize = function () {
                let item = newItem.previousElementSibling;

                while (item) {
                    if (item instanceof JQX.SplitterItem && !item.size) {
                        return item;
                    }

                    item = item.previousElementSibling;
                }
            }();

            hostItem = itemWithoutSize || hostItem;
        }

        const hostItemNewSize = hostItem[that._measurements.size] - newItem[that._measurements.size] - splitterBar[that._measurements.size],
            hostItemSize = Math.max(hostItem._sizeLimits[that._measurements.minDimension], hostItemNewSize);

        hostItem.style[that._measurements.maxDimension] = hostItem.max ?
            isNaN(parseFloat(hostItem.max)) ? '' : (parseFloat(hostItem.max) + typeof hostItem.max === 'string' && hostItem.max.indexOf('%') > -1 ? '%' : 'px') : '';

        //StyleChanged not fired yet
        const hostItemMax = hostItem.style[that._measurements.maxDimension] ? parseFloat(hostItem.style[that._measurements.maxDimension]) : 0;

        if (newItem.size) {
            hostItem.style[that._measurements.dimension] = (hostItem._sizeBeforeCollapse = hostItemMax ?
                Math.min(hostItemMax, hostItemSize) : hostItemSize) + 'px';
        }
        else {
            hostItem.style[that._measurements.dimension] = hostItem.size ? (hostItem.size === 'auto' ? hostItem.size :
                isNaN(parseFloat(hostItem.size)) ? 0 : parseFloat(hostItem.size) + (typeof hostItem.size === 'string' && hostItem.size.indexOf('%') > -1 ? '%' : 'px')) : '';
            hostItem._sizeBeforeCollapse = hostItem[that._measurements.size];
        }
    }

    /**
     * Resize a single item
     * @param {any} event
     * @param {any} distance
     * @param {any} offset
     */
    _resizeItem(event, distance, offset) {
        const that = this;

        //Validate min accoridng to first Item
        let newSize = Math.max(that._dragDetails.firstItem._sizeLimits[that._measurements.minDimension],
            Math.min(that._dragDetails.splitAreaSize - that._dragDetails.secondItem._sizeLimits[that._measurements.minDimension],
                that._dragDetails.firstItem._sizeLimits[that._measurements.maxDimension] ?
                    Math.min(that._dragDetails.firstItem._sizeLimits[that._measurements.maxDimension],
                        that._dragDetails.firstItem.currentSize + distance) : that._dragDetails.firstItem.currentSize + distance));
        let minSize = that._dragDetails.firstItem._sizeLimits[that._measurements.minDimension];

        if (that._dragDetails.secondItem._sizeLimits[that._measurements.maxDimension] &&
            that._dragDetails.splitAreaSize - newSize > that._dragDetails.secondItem._sizeLimits[that._measurements.maxDimension]) {
            minSize = newSize = that._dragDetails.splitAreaSize - that._dragDetails.secondItem._sizeLimits[that._measurements.maxDimension];
        }

        that._dragDetails.firstItem.currentSize = newSize;

        if (that.liveResize) {
            that._dragDetails.firstItem.style[that._measurements.dimension] = (that._dragDetails.firstItem._sizeBeforeCollapse = newSize + that._dragDetails.firstItem._paddings) + 'px';
            that._dragDetails.secondItem.style[that._measurements.dimension] =
                (that._dragDetails.secondItem._sizeBeforeCollapse = that._dragDetails.splitAreaSize - newSize + that._dragDetails.firstItem._paddings) + 'px';

            //Reset the original size
            delete that._dragDetails.firstItem._originalSize;
            delete that._dragDetails._originalSize;
        }
        else {
            //TODO: Doesn't include collpased items offset
            that._splitBarDummy.style[that._measurements.position] = (that._dragDetails.firstItem[that._measurements.offset] + newSize + that._dragDetails.lockedItemsSize + that._dragDetails.firstItem._paddings) + 'px';
        }

        const edge = that._dragDetails.firstItem.getBoundingClientRect()[that.orientation === 'vertical' ? 'left' : 'top'] + that._dragDetails.splitBarOffset;

        that._dragDetails.position = Math.max(edge + minSize + that._dragDetails.firstItem._paddings,
            Math.min(edge + that._dragDetails.splitAreaSize - that._dragDetails.secondItem._sizeLimits[that._measurements.minDimension]
                + that._dragDetails.lockedItemsSize + that._dragDetails.firstItem._paddings,
                event[that._measurements.pagePosition] - offset));

        if (that._dragDetails.firstItem._sizeLimits[that._measurements.maxDimension]) {
            that._dragDetails.position = Math.min(edge + that._dragDetails.firstItem._sizeLimits[that._measurements.maxDimension], that._dragDetails.position)
        }
    }

    /**
    * Sets tab index
    */
    _setFocusable() {
        const that = this;

        if (that.disabled || that.unfocusable) {
            that.removeAttribute('tabindex');
            return;
        }

        that.tabIndex = that.tabIndex > 0 ? that.tabIndex : 0;
    }

    /**
     * Set drag details for a splitter item
     * @param {any} event
     */
    _setDragDetails(target, event) {
        const that = this;

        that._dragDetails = {};

        if (!that._measurements) {
            that._setMeasurements();
        }

        that._dragDetails.scrollAmount = target.parentElement[that._measurements.scroll];
        that._dragDetails.lockedItemsSize = 0;

        that.setAttribute('show-locked-items', '');

        if (!(that._dragDetails.firstItem = that._getTargetItem(target, 'previousElementSibling'))) {
            delete that._dragDetails;
            that.setAttribute('dragging-not-allowed', '');
            return;
        }

        that._dragDetails.firstItem.set('size', '');

        that._dragDetails.firstItem.currentSize = that._dragDetails.firstItem[that._measurements.size];
        that._dragDetails.firstItem.originalSize = that._dragDetails.firstItem.currentSize;

        let computedStyle = getComputedStyle(that._dragDetails.firstItem);

        that._dragDetails.firstItem._paddings = (parseFloat(computedStyle.getPropertyValue('padding-' + that._measurements.position)) || 0) +
            (parseFloat(computedStyle.getPropertyValue('padding-' + that._measurements.position2)) || 0);

        if (that._dragDetails.firstItem.currentSize < that._dragDetails.firstItem._sizeLimits[that._measurements.minDimension]) {
            delete that._dragDetails;
            return;
        }

        that._dragDetails.firstItem.currentSize -= that._dragDetails.firstItem._paddings;

        that._dragDetails.splitAreaSize = 0;
        that._dragDetails.secondItemTotalMaxSize = 0;
        that._dragDetails.secondItemTotalMinSize = 0;

        if (that.resizeMode === 'proportional') {
            if (that._setProportionalDetails()) {
                return;
            }
        }
        else {
            if (that._setAdjacentOrEndDetails(target)) {
                return;
            }
        }

        let splitterBarPagePosition;

        if (!event || typeof (event) !== 'object') {
            event = { pageX: target[that._measurements.offset], pageY: target[that._measurements.offset] };
            splitterBarPagePosition = target[that._measurements.offset];
        }
        else {
            splitterBarPagePosition = target.getBoundingClientRect()[that._measurements.position];
        }

        that._dragDetails.position = event[that._measurements.pagePosition];
        that._dragDetails.splitBarOffset = that._dragDetails.position - splitterBarPagePosition;

        if (that.liveResize) {
            return;
        }

        if (!that._splitBarDummy) {
            that._splitBarDummy = document.createElement('div');
            that._splitBarDummy.classList.add('jqx-splitter-bar-feedback');
        }

        that._splitBarDummy.style.width = target.offsetWidth + 'px';
        that._splitBarDummy.style.height = target.offsetHeight + 'px';
        that._splitBarDummy.style.top = target.offsetTop + 'px';
        that._splitBarDummy.style.left = target.offsetLeft + 'px';
        target.parentElement.appendChild(that._splitBarDummy);
    }

    /**
     * Sets the drag details when resizeMode === 'adjacent' or 'end'
     */
    _setAdjacentOrEndDetails(target) {
        const that = this;

        if (!(that._dragDetails.secondItem = (that.resizeMode === 'adjacent' ?
            that._getTargetItem(target, 'nextElementSibling') : that._getTargetItem(target, 'previousElementSibling', true)))) {
            delete that._dragDetails;
            that.setAttribute('dragging-not-allowed', '');
            return true;
        }

        that._dragDetails.secondItem.set('size', '');

        that._dragDetails.secondItem.currentSize = that._dragDetails.secondItem[that._measurements.size];
        that._dragDetails.secondItem.originalSize = that._dragDetails.secondItem.currentSize;

        const computedStyle = getComputedStyle(that._dragDetails.secondItem);

        that._dragDetails.secondItem._paddings = (parseFloat(computedStyle.getPropertyValue('padding-' + that._measurements.position)) || 0) +
            (parseFloat(computedStyle.getPropertyValue('padding-' + that._measurements.position2)) || 0);

        that._dragDetails.secondItem.currentSize -= that._dragDetails.secondItem._paddings;

        that._dragDetails.splitAreaSize = that._dragDetails.firstItem.currentSize + that._dragDetails.secondItem.currentSize;
        that._dragDetails.secondItemTotalMaxSize = that._dragDetails.secondItem._sizeLimits[that._measurements.maxDimension];
        that._dragDetails.secondItemTotalMinSize = that._dragDetails.secondItem._sizeLimits[that._measurements.minDimension];
    }

    /**
     * Sets the measurement object that will be used during resizing
     */
    _setMeasurements() {
        const that = this;

        that._measurements = {};

        if (that.orientation === 'horizontal') {
            that._measurements.dimension = 'height';
            that._measurements.minDimension = 'minHeight';
            that._measurements.maxDimension = 'maxHeight';
            that._measurements.restricredDimension = 'Width';
            that._measurements.size = 'offsetHeight';
            that._measurements.offset = 'offsetTop';
            that._measurements.position = 'top';
            that._measurements.position2 = 'bottom';
            that._measurements.pagePosition = 'pageY';
            that._measurements.scroll = 'scrollTop';
        }
        else {
            that._measurements.dimension = 'width';
            that._measurements.minDimension = 'minWidth';
            that._measurements.maxDimension = 'maxWidth';
            that._measurements.restricredDimension = 'Height';
            that._measurements.size = 'offsetWidth';
            that._measurements.offset = 'offsetLeft';
            that._measurements.position = 'left';
            that._measurements.position2 = 'right';
            that._measurements.pagePosition = 'pageX';
            that._measurements.scroll = 'scrollLeft';
        }

        that._measurements.overflow = getComputedStyle(that).getPropertyValue('overflow');
    }

    /**
     * Sets the dragging details when resizeMode = 'proportional'
     */
    _setProportionalDetails() {
        const that = this;

        that._dragDetails.secondItem = that._items.slice(that._items.indexOf(that._dragDetails.firstItem) + 1).filter(item => !item.collapsed && !item.locked);

        if (that._dragDetails.secondItem.length === 0) {
            delete that._dragDetails;
            return true;
        }

        that._dragDetails.splitAreaSize += that._dragDetails.firstItem.currentSize;
        that._dragDetails.itemProportions = [];

        let noMaxLimit;

        for (let i = 0; i < that._dragDetails.secondItem.length; i++) {
            that._dragDetails.secondItem[i].set('size', '');
            that._dragDetails.secondItem[i].currentSize = that._dragDetails.secondItem[i][that._measurements.size];
            that._dragDetails.secondItem[i].originalSize = that._dragDetails.secondItem[i].currentSize

            const computedStyle = getComputedStyle(that._dragDetails.secondItem[i]);

            that._dragDetails.secondItem[i]._paddings = (parseFloat(computedStyle.getPropertyValue('padding-' + that._measurements.position)) || 0) +
                (parseFloat(computedStyle.getPropertyValue('padding-' + that._measurements.position2)) || 0);

            that._dragDetails.secondItem[i].currentSize -= that._dragDetails.secondItem[i]._paddings;

            that._dragDetails.splitAreaSize += that._dragDetails.secondItem[i].currentSize;
            that._dragDetails.itemProportions.push({
                item: that._dragDetails.secondItem[i],
                currentSize: that._dragDetails.secondItem[i].currentSize
            });

            if (!that._dragDetails.secondItem[i]._sizeLimits[that._measurements.maxDimension]) {
                noMaxLimit = true;
            }

            that._dragDetails.secondItemTotalMinSize += that._dragDetails.secondItem[i]._sizeLimits[that._measurements.minDimension];
            that._dragDetails.secondItemTotalMaxSize += that._dragDetails.secondItem[i]._sizeLimits[that._measurements.maxDimension];
        }

        if (noMaxLimit) {
            that._dragDetails.secondItemTotalMaxSize = 0;
        }
    }

    /**
     * Validates the size of the Splitter Bars inside the Splitter
     */
    _validateBarsSize() {
        const that = this;

        //Check if size of the SplitterBar is explicitly set
        if ((getComputedStyle(that).getPropertyValue('--jqx-splitter-bar-fit-size') + '').trim() !== '100%') {
            return;
        }

        let biggestItem = that._items[0];
        const size = 'offset' + that._measurements.restricredDimension,
            bars = that.bars;

        if (bars.length === 0) {
            return;
        }

        for (let i = 0; i < that._items.length; i++) {
            if (that._items[i][size] > biggestItem[size]) {
                biggestItem = that._items[i];
            }
        }

        if (!biggestItem) {
            return;
        }

        if (biggestItem[size] !== bars[0][size]) {
            bars.map(bar => bar.style[that._measurements.restricredDimension.toLowerCase()] = biggestItem[size] + 'px');
        }
    }

    /**
    * Validates the sizes of the Splitter items and resizes them to fit if the overflow is set to 'none' or 'visible'
    */
    _validateItemSize(noStyleChangedIgnoring) {
        const that = this;

        if (that.autoFitMode === 'overflow') {
            return;
        }

        if (that.keepProportionsOnResize && that._resizeEventFired) {
            that._keepItemProportionsOnResize();
        }
        else {
            let totalItemSize = 0,
                totalBarsSize = 0;

            that._items.map(item => totalItemSize += !item.collapsed ?
                (item.style[that._measurements.dimension] && item.style[that._measurements.dimension].indexOf('%') < -1 && item._sizeBeforeCollapse ?
                    item._sizeBeforeCollapse : item.getBoundingClientRect()[that._measurements.dimension]) : 0);

            that.bars.map(bar => totalBarsSize += bar[that._measurements.size]);

            let sizeDifference = totalItemSize + totalBarsSize - that.$.container.getBoundingClientRect()[that._measurements.dimension];

            if (sizeDifference > 0) {
                that._validateItemsSizeOverflowing(sizeDifference, noStyleChangedIgnoring);
            }
            else {
                that._validateItemsSizeUnderflowing(sizeDifference, noStyleChangedIgnoring);
            }
        }

        that._autoFitItems();

        //Should be called only when Splitter's width is 'auto'
        that._validateBarsSize();

        //Keeping the last valid splitter size
        that._splitterSize = that[that._measurements.size];

        //NOTE: Elements in ShadowDOM get initialized in reverse order ( from outher to inner elements). That's why this is necessary.
        if (that.enableShadowDOM) {
            const host = that.getRootNode().host;

            if (host && host.enableShadowDOM && host.isCompleted && host._validateItemSize) {
                host._validateItemSize();
            }
        }
    }

    /**
     * Validates the min/max properties of the neighbour items
     * @param {any} item
     */
    _validateNeighbourSizeLimits(item) {
        const that = this;

        function checkLimits(neighbourItem) {
            if (!neighbourItem) {
                return;
            }

            if (neighbourItem.min) {
                neighbourItem._setSize('min', neighbourItem.min, true);
            }

            if (neighbourItem.max) {
                neighbourItem._setSize('max', neighbourItem.max, true);
            }
        }

        if (!that._items || !that._items.length) {
            return;
        }

        that._noNeighbourValidation = true;

        const itemIndex = that._items.indexOf(item);

        //Previous item
        checkLimits(that._items[itemIndex - 1]);

        //Next item
        checkLimits(that._items[itemIndex + 1]);

        delete that._noNeighbourValidation;
    }

    /**
     * Keeps the same proportion of the items during resizing. Handles the keepProportionsOnResize proeprty
     */
    _keepItemProportionsOnResize() {
        const that = this;
        let splitterBarsSize = 0,
            currentItemsSize = 0,
            resizableItems = [];

        that.bars.map(bar => splitterBarsSize += bar[that._measurements.size]);

        for (let i = 0; i < that._items.length; i++) {
            if (that._items[i].collapsed) {
                continue;
            }

            resizableItems.push(that._items[i]);
            currentItemsSize += that._items[i]._sizeBeforeCollapse || that._items[i][that._measurements.size];
        }

        if (that._splitterSize) {
            currentItemsSize = that._splitterSize;
        }

        const splitterSizeAfterResize = that[that._measurements.size];

        for (let i = 0; i < resizableItems.length; i++) {
            if (resizableItems[i].style[that._measurements.dimension].indexOf('%') > -1) {
                continue;
            }

            resizableItems[i].style[that._measurements.dimension] = (resizableItems[i]._sizeBeforeCollapse =
                (resizableItems[i]._sizeBeforeCollapse || resizableItems[i][that._measurements.size]) / currentItemsSize * splitterSizeAfterResize) + 'px';
        }
    }

    /**
     * Validates and recalculates the sizes of the items if they overflow the container
     */
    _validateItemsSizeOverflowing(sizeDifference, noStyleChangedIgnoring) {
        const that = this,
            itemsCount = that._items.length;
        let newSize = 0,
            initialSize, itemsLocked = [], currentSize, currentlySetSize, lastLockedItem,
            containerRect = that.$.container.getBoundingClientRect();

        for (let i = 0; i < that._items.length; i++) {
            //Note: If the size is set in percentages via CSS, it's not possible check if it's really percentages or not 
            //because even getComputedStyle returns the computed size not the original.
            //The only way to work is by setting the size property to a percentage value !
            currentlySetSize = that._items[i].style[that._measurements.dimension];
            currentSize = currentlySetSize.indexOf('%') > -1 ? currentlySetSize : that._items[i][that._measurements.size];

            if (!currentlySetSize && !that._items[i].size && that._items[i].size !== 0) {
                delete that._items[i]._originalSize;
            }

            that._items[i]._originalSize = that._items[i]._originalSize ? that._items[i]._originalSize : currentSize;
            itemsLocked.push(that._items[i].locked);
        }

        if (itemsLocked.indexOf(false) < 0) {
            lastLockedItem = that._items[that._items.length - 1];
            lastLockedItem.locked = false;
        }

        //Check how many items should be resized to fit
        for (let i = itemsCount - 1; i >= 0; i--) {
            if (that._items[i].collapsed || that._items[i].locked) {
                continue;
            }

            if ((that._items[i]._originalSize + '').indexOf('%') > -1) {
                that._items[i].style[that._measurements.dimension] = that._items[i]._originalSize;
                that._items[i]._sizeBeforeCollapse = containerRect[that._measurements.dimension] * parseFloat(that._items[i]._originalSize) / 100;
                continue;
            }

            if (sizeDifference === 0) {
                continue;
            }

            //Doesn't include the item paddings
            initialSize = that._items[i].getBoundingClientRect()[that._measurements.dimension];

            newSize = initialSize - sizeDifference;

            //May trigger the styleChanged event
            that._items[i].style[that._measurements.dimension] =
                (that._items[i]._sizeBeforeCollapse = Math.max(that._items[i]._sizeLimits ? that._items[i]._sizeLimits[that._measurements.minDimension] : 0, newSize)) + 'px';

            sizeDifference -= initialSize - that._items[i]._sizeBeforeCollapse;
        }

        //Reduce the min-sizes if necessary
        if (sizeDifference > 0) {
            for (let i = itemsCount - 1; i >= 0; i--) {
                if (that._items[i].collapsed) {
                    continue;
                }

                initialSize = that._items[i].getBoundingClientRect()[that._measurements.dimension];
                newSize = initialSize - sizeDifference;

                let itemMin = that._items[i]._sizeLimits[that._measurements.minDimension] || that._items[i].min;

                if (itemMin) {
                    if ((itemMin + '').indexOf('%') > -1) {
                        itemMin = parseFloat(itemMin) / 100 * that._items[i].parentElement[that._measurements.size];
                    }
                    else {
                        itemMin = parseFloat(itemMin);
                    }

                    if (itemMin > newSize) {
                        //Ignore the StyleChanged event
                        that._items[i]._sizeLimits.ignoreUpdate = noStyleChangedIgnoring ? false : true;
                        that._items[i].style[that._measurements.minDimension] = Math.max(0, newSize) + 'px';
                    }
                }

                if (that._items[i]._originalSize && (that._items[i]._originalSize + '').indexOf('%') > -1) {
                    continue;
                }

                that._items[i]._sizeLimits.ignoreUpdate = noStyleChangedIgnoring ? false : true;
                that._items[i].style[that._measurements.dimension] = (that._items[i]._sizeBeforeCollapse = Math.max(0, newSize)) + 'px';

                sizeDifference -= initialSize - that._items[i]._sizeBeforeCollapse;
            }
        }

        if (lastLockedItem) {
            lastLockedItem.locked = true;
        }
    }

    /**
     * Validates the sizes of the items if the're underflowing the container ( should fit )
     */
    _validateItemsSizeUnderflowing(sizeDifference, noStyleChangedIgnoring) {
        const that = this,
            itemsCount = that._items.length;
        let newSize = 0,
            initialSize, lastLockedItem;

        sizeDifference = Math.abs(sizeDifference);

        if (that._items.length > 0 && that._items.map(item => item.locked).indexOf(false) < 0) {
            lastLockedItem = that._items[that._items.length - 1];
            lastLockedItem.locked = false;
        }

        //Increase the min-size of the items if it has been changed
        for (let i = 0; i < itemsCount; i++) {
            if (that._items[i].collapsed || that._items[i][that._measurements.size] >= (that._items[i]._sizeLimits ? that._items[i]._sizeLimits[that._measurements.minDimension] : 0)) {
                continue;
            }

            initialSize = that._items[i][that._measurements.size];
            newSize = that._items[i][that._measurements.size] + sizeDifference;

            if (that._items[i][that._measurements.size] < that._items[i]._sizeLimits[that._measurements.minDimension]) {
                //Ignore the StyleChanged event
                that._items[i]._sizeLimits.ignoreUpdate = noStyleChangedIgnoring ? false : true;
                that._items[i].style[that._measurements.minDimension] =
                    (that._items[i]._sizeBeforeCollapse = Math.max(0, Math.min(that._items[i]._sizeLimits[that._measurements.minDimension], newSize))) + 'px';
            }

            sizeDifference -= (that._items[i]._sizeBeforeCollapse || that._items[i][that._measurements.size]) - initialSize;

            if (sizeDifference <= 0) {
                break;
            }
        }

        const containerSize = that.$.container.getBoundingClientRect()[that._measurements.dimension];

        if (sizeDifference > 0) {
            for (let i = 0; i < itemsCount; i++) {
                if (that._items[i].collapsed || that._items[i].locked) {
                    continue;
                }

                if (that._items[i]._originalSize !== undefined) {
                    if ((that._items[i]._originalSize + '').indexOf('%') > -1) {
                        that._items[i].style[that._measurements.dimension] = that._items[i]._originalSize;
                        that._items[i]._sizeBeforeCollapse = (parseFloat(that._items[i]._originalSize) * containerSize) / 100;
                        //delete that._items[i]._originalSize;
                    }
                    else if (that._items[i][that._measurements.size] >= that._items[i]._originalSize) {
                        sizeDifference += that._items[i][that._measurements.size] - that._items[i]._originalSize;
                        that._items[i].style[that._measurements.dimension] = (that._items[i]._sizeBeforeCollapse = that._items[i]._originalSize) + 'px';
                    }
                    else {
                        newSize = Math.min(that._items[i]._originalSize, that._items[i][that._measurements.size] + sizeDifference);

                        const usedSize = newSize - that._items[i][that._measurements.size];

                        if (that._items[i][that._measurements.minDimension] < that._items[i]._sizeLimits[that._measurements.minDimension]) {
                            that._items[i].style[that._measurements.minDimension] = Math.min(that._items[i]._sizeLimits[that._measurements.minDimension], newSize) + 'px';
                        }

                        that._items[i].style[that._measurements.dimension] = (that._items[i]._sizeBeforeCollapse = Math.max(0, Math.min(newSize, that._items[i]._originalSize))) + 'px';
                        sizeDifference -= usedSize;
                    }

                    if (sizeDifference <= 0) {
                        break;
                    }
                }
            }
        }

        if (lastLockedItem) {
            lastLockedItem.locked = true;
        }
    }
});
/**
 * Tab Item custom element.
 */
JQX('jqx-tab-item', class TabItem extends JQX.ContentElement {
    // Tab Item's properties.
    static get properties() {
        return {
            'closeButtonHidden': {
                value: false,
                type: 'boolean'
            },
            'index': {
                value: null,
                type: 'number?'
            },
            'selected': {
                value: false,
                type: 'boolean'
            },
            'label': {
                value: '',
                type: 'string'
            },
            'labelSize': {
                value: null,
                type: 'number?'
            }
        };
    }

    get enableShadowDOM() {
        return false;
    }

    /**
     * Called when the element is attached to the DOM.
     */
    attached() {
        const that = this;

        super.attached();

        if (!that.isCompleted) {
            return;
        }

        that.$.removeClass('right');
        that.$.removeClass('left');
        that.$.removeClass('top');
        that.$.removeClass('bottom');
        that.$.removeClass('animate');
    }

    /**
     * Called when a property is changed.
     */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this;

        if (that._preventPropertyChangedHandler) {
            delete that._preventPropertyChangedHandler;
            return;
        }

        switch (propertyName) {
            case 'closeButtonHidden':
                that.$.fireEvent('closeButtonVisibilityChange', { 'hidden': newValue });
                break;
            case 'index':
                that.$.fireEvent('indexChange', { 'newIndex': newValue, 'oldIndex': oldValue, 'tabItem': that });
                break;
            case 'label':
                break;
            case 'labelSize':
                that.$.fireEvent('labelSizeChange', { 'size': newValue });
                break;
        }
    }

    /**
     * Appends a child node directly to the jqx-tab-item's container.
     *
     * @param {HTMLElement} node The node to append.
     */
    appendChild(node) {
        const that = this;

        if (!that.isCompleted) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        that.firstElementChild.appendChild(node);
    }

    /**
     * Sets the index without "propertyChangedHandler" being called
     */
    _setIndex(index) {
        const that = this,
            oldContext = that.context;

        that.context = that;
        that.index = index;
        that.context = oldContext;

    }
});

/**
 * Tab Items Group custom element.
 */
JQX('jqx-tab-items-group', class TabItemsGroup extends JQX.ContentElement {
    // Tab Items Group's properties.
    static get properties() {
        return {
            'label': {
                value: '',
                type: 'string'
            },
            'labelSize': {
                value: null,
                type: 'number?'
            }
        };
    }

    get enableShadowDOM() {
        return false;
    }

    /**
     * Tab Items Group's HTML template.
     */
    template() {
        return '';
    }

    /**
     * Called when a property is changed.
     */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this;

        if (that._preventPropertyChangedHandler) {
            delete that._preventPropertyChangedHandler;
            return;
        }

        switch (propertyName) {
            case 'label':
                break;
            case 'labelSize':
                this.$.fireEvent('labelSizeChange', { 'size': newValue });
                break;
        }
    }
});

/**
 * Tabs custom element.
 */
JQX('jqx-tabs', class Tabs extends JQX.BaseElement {
    // Tabs's properties.
    static get properties() {
        return {
            'addNewTab': {
                value: false,
                type: 'boolean'
            },
            'allowToggle': {
                value: false,
                type: 'boolean'
            },
            'closeButtonMode': {
                value: 'default',
                allowedValues: ['default', 'selected'],
                type: 'string'
            },
            'closeButtons': {
                value: false,
                type: 'boolean'
            },
            'collapsed': {
                value: false,
                type: 'boolean'
            },
            'collapsible': {
                value: false,
                type: 'boolean'
            },
            'dataSource': {
                value: null,
                type: 'array?',
                reflectToAttribute: false
            },
            'enableMouseWheelAction': {
                value: false,
                type: 'boolean'
            },
            'messages': {
                value: {
                    'en': {
                        'ambiguousIndexes': 'jqx-tabs: Initially set jqx-tab-item indexes are ambiguous and are ignored in favour of the HTML structure.',
                        'detailsObjectRequired': 'jqx-tabs: The method "insert" requires a details Object to be passed as a second argument.',
                        'invalidIndex': 'jqx-tabs: "{{method}}" method accepts an index of type number.',
                        'referenceNodeNotChild': 'jqx-tabs: Passed {{argument}} is not part of this jqx-tabs element.',
                        'tabItemRequired': 'jqx-tabs: The method "{{method}}" requires a "jqx-tab-item" element to be passed as an argument.'
                    }
                },
                type: 'object',
                extend: true
            },
            'name': {
                value: '',
                type: 'string'
            },
            'overflow': {
                value: 'auto',
                allowedValues: ['auto', 'hidden', 'scroll'],
                type: 'string'
            },
            'reorder': {
                value: false,
                type: 'boolean'
            },
            'resize': {
                value: false,
                type: 'boolean'
            },
            'scrollButtonsPosition': {
                value: 'both',
                allowedValues: ['near', 'far', 'both'],
                type: 'string'
            },
            'scrollMode': {
                value: 'paging',
                allowedValues: ['paging', 'continuous'],
                type: 'string'
            },
            'selectedIndex': {
                value: null,
                type: 'number?'
            },
            'selectionMode': {
                value: 'click',
                allowedValues: ['click', 'dblclick', 'mouseenter', 'none'],
                type: 'string'
            },
            'tabLayout': {
                value: 'scroll',
                allowedValues: ['scroll', 'dropDown', 'wrap', 'shrink'],
                type: 'string',
                defaultReflectToAttribute: true
            },
            'tabPosition': {
                value: 'top',
                allowedValues: ['top', 'bottom', 'left', 'right', 'hidden'],
                type: 'string'
            },
            'tabTextOrientation': {
                value: 'horizontal',
                allowedValues: ['horizontal', 'vertical'],
                type: 'string'
            }
        };
    }

    /**
     * Tabs's event listeners.
     */

    static get listeners() {
        return {
            'closeButtonVisibilityChange': '_closeButtonVisibilityChangeHandler',
            'indexChange': '_indexChangeHandler',
            'keydown': '_keydownHandler',
            'labelSizeChange': '_labelSizeChangeHandler',
            'resize': '_applyTabOverflow',
            'styleChanged': '_applyTabOverflow',
            'container.dblclick': '_containerHandler',
            'container.down': '_containerHandler',
            'container.mouseout': '_containerHandler',
            'container.mouseover': '_containerHandler',
            'container.up': '_containerHandler',
            'scrollButtonFar.click': '_scrollButtonClickHandler',
            'scrollButtonNear.click': '_scrollButtonClickHandler',
            'tabContentSection.transitionend': '_tabContentSectionTransitionendHandler',
            'tabsHeaderItems.wheel': '_tabsHeaderItemsWheelHandler',
            'tabStrip.mouseleave': '_tabStripMouseleaveHandler',
            'tabStrip.move': '_tabStripMoveHandler',
            'document.move': '_documentMoveHandler',
            'document.selectstart': '_selectStartHandler',
            'document.up': '_documentUpHandler'
        };
    }

    /**
     * Tabs's required files.
     */
    static get requires() {
        return {
            'JQX.RepeatButton': 'jqxbutton.js'
        }
    }

    static get styleUrls() {
        return [
            'jqx.tabs.css'
        ]
    }

    /**
     * Tabs's HTML template.
     */
    template() {
        return `<div id="container">
                    <div id="tabsHeaderSection" class="jqx-header jqx-tabs-header-section">
                        <div id="tabsHeaderItems" class="jqx-tabs-header-items">
                            <jqx-repeat-button id="scrollButtonNear" class="jqx-tabs-scroll-button jqx-nav-button jqx-spin-button jqx-hidden" animation="[[animation]]" unfocusable>
                                <div id="arrowNear" class="jqx-arrow"></div>
                            </jqx-repeat-button>
                            <div id="tabStrip" class="jqx-tab-strip"></div>
                            <jqx-repeat-button id="scrollButtonFar" class="jqx-tabs-scroll-button jqx-nav-button jqx-spin-button jqx-hidden" animation="[[animation]]" unfocusable>
                                <div id="arrowFar" class="jqx-arrow"></div>
                            </jqx-repeat-button>
                            <div id="dropDownButton" class="jqx-drop-down-button">
                                <div id="dropDownButtonArrow" class="jqx-drop-down-button-arrow jqx-unselectable"></div>
                            </div>
                            <span id="tabSelectionBar" class="jqx-tabs-selection-bar"></span>
                            <div id="resizeToken" class="jqx-tabs-resize-token jqx-hidden"></div>
                        </div>
                        <div id="tabHeaderControls" class="jqx-tabs-header-controls"></div>
                    </div>
                    <div id="tabContentSection" class="jqx-tabs-content-section">
                       <content></content>
                    </div>
                    <div id="dropDownButtonDropDown" class="jqx-drop-down-button-drop-down jqx-hidden"></div>
                    <input id="hiddenInput" type="hidden" name="[[name]]">
                </div>`;
    }

    /**
     * Called when the element is attached to the DOM.
     */
    attached() {
        const that = this;

        super.attached();

        if (!that.isCompleted) {
            return;
        }

        that._applyTabOverflow();
    }

    /**
     * Called when the element is ready. Used for one-time configuration of the Tab.
     */
    ready() {
        super.ready();

        const that = this;

        that._flexWritingModeNoFullSupport = true; // !JQX.Utilities.Core.Browser.Chrome;
        that._arrowCodes = { top: '&#xe804', bottom: '&#xe801', left: '&#xe802', right: '&#xe803' };

        that._createElement();
    }

    /**
     * Appends a "jqx-tab-item" node as the last tab of the Tabs.
     *
     * @param {HTMLElement} node The "jqx-tab-item" node to append.
     */
    appendChild(node) {
        const that = this;

        if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!(node instanceof JQX.TabItem)) {
            that.error(that.localize('tabItemRequired', { method: 'appendChild' }));
        }

        that.insert(that._tabs.length, { node: node });
    }

    /**
     * Collapses the content section.
     */
    collapse() {
        const that = this;

        if (!that.collapsible || that.collapsed) {
            return;
        }

        that.collapsed = true;
    }

    /**
     * Makes sure a tab is visible by scrolling to it.
     *
     * @param {Number} index The index of the tab to scroll to.
     */
    ensureVisible(index) {
        const that = this;

        if (index === null || that.tabLayout === 'wrap' || that.tabLayout === 'shrink' || that.tabPosition === 'hidden') {
            return;
        }

        that._validateIndex(index, 'ensureVisible');
        index = Math.max(0, Math.min(index, that._tabs.length - 1));

        const group = that._tabs[index].group,
            tabStrip = that.$.tabStrip,
            tabStripBoundingRect = tabStrip.getBoundingClientRect(),
            scrollTarget = group === null ? that._tabLabelContainers[index] : that._groupLabels[that._groups.indexOf(group)],
            scrollTargetBoundingRect = scrollTarget.getBoundingClientRect();

        if ((that.tabPosition === 'top' || that.tabPosition === 'bottom') && (tabStripBoundingRect.left > scrollTargetBoundingRect.left || tabStripBoundingRect.right < scrollTargetBoundingRect.right)) {
            tabStrip.scrollLeft += Math.round(scrollTargetBoundingRect.right - tabStrip.offsetWidth - tabStripBoundingRect.left);
        }
        else if ((that.tabPosition === 'left' || that.tabPosition === 'right') && (tabStripBoundingRect.top > scrollTargetBoundingRect.top || tabStripBoundingRect.bottom < scrollTargetBoundingRect.bottom)) {
            tabStrip.scrollTop += Math.round(scrollTargetBoundingRect.bottom - tabStrip.offsetHeight - tabStripBoundingRect.top);
        }

        that._updateScrollButtonVisibility();

        if (that.resize) {
            that._getTabCoordinates();
        }
    }

    /**
     * Expands the content section.
     */
    expand() {
        const that = this;

        if (!that.collapsible || !that.collapsed) {
            return;
        }

        that.collapsed = false;
    }

    /**
     * Returns the offset of the tab item container (jqx-tab-item element) from the edge of the Tabs (jqx-tabs element) where the tab strip is positioned.
     *
     * @param {Number} index The index of the tab item.
     */
    getOffsetFromEdgeOfElement(index) {
        const that = this;

        that._validateIndex(index, 'getOffsetFromEdgeOfElement');

        index = Math.max(0, Math.min(index, that._tabs.length - 1));

        const tabItem = that._tabs[index],
            position = that.tabPosition;

        if (position !== 'hidden') {
            return Math.abs(tabItem.getBoundingClientRect()[position] - that.getBoundingClientRect()[position]);
        }

        return tabItem.getBoundingClientRect().top - that.getBoundingClientRect().top;
    }

    /**
     * Inserts a new tab and an associated content section.
     *
     * @param {Number} index The index to insert a new tab at.
     * @param {Object} details An Object with the fields "label", "labelSize", "content" and "group".
     */
    insert(index, details) {
        const that = this;
        let group, tab;

        that._validateIndex(index, 'insert');
        if (details === undefined || (details.label === undefined && details.content === undefined && details.node === undefined)) {
            that.error(that.localize('detailsObjectRequired'));
        }

        if (details.node === undefined) {
            group = details.group;
            tab = document.createElement('jqx-tab-item');

            tab.label = details.label !== undefined ? details.label : '';
            tab.labelSize = details.labelSize !== undefined ? details.labelSize : null;
            tab.content = details.content;
        }
        else {
            tab = details.node;

            if (tab.index !== undefined && tab.index !== null) {
                const oldContext = tab.context;

                tab.context = tab;
                tab.index = null;
                tab.context = oldContext;
            }
        }

        tab.$.addClass('jqx-visibility-hidden');

        tab.group = null;

        const labelContainers = that._addTabLabelContainer(tab),
            tabLabelContainer = labelContainers.tabLabelContainer,
            dropDownLabelContainer = labelContainers.dropDownLabelContainer;

        tabLabelContainer.tab = tab;
        tab.tabLabelContainer = tabLabelContainer;

        const tabDetails = { index: index, tab: tab, tabLabelContainer: tabLabelContainer, dropDownLabelContainer: dropDownLabelContainer };

        if (that._groups.length === 0 && group === undefined) {
            that._insertNoGrouping(tabDetails);
        }
        else {
            if (group !== undefined && group !== null) {
                tabDetails.group = group;
                const jqxTabItemsGroup = that.$.tabContentSection.querySelector('jqx-tab-items-group[label="' + group + '"]');

                if (jqxTabItemsGroup !== null) {
                    // group exists
                    tabDetails.jqxTabItemsGroup = jqxTabItemsGroup;
                    that._insertIntoExistingGroup(tabDetails);
                }
                else {
                    // group does not exist
                    that._insertIntoNewGroup(tabDetails);
                }
            }
            else {
                that._insertNearAGroup(tabDetails);
            }
        }

        that._getReorderItems();

        if (that.selectedIndex === null && !that.allowToggle && that._tabs.length) {
            that._select(0, true);
        }

        if (tab.group !== null && tab.labelSize !== null && that.tabLayout !== 'shrink') {
            tabLabelContainer.style.removeProperty([that._orientationSettings.dimension]);
        }

        that._applyTabOverflow();
    }

    /**
     * Inserts the specified "jqx-tab-item" node before the reference "jqx-tab-item" node.
     *
     * @param {HTMLElement} newNode The "jqx-tab-item" node to insert.
     * @param {HTMLElement} referenceNode The "jqx-tab-item" node before which newNode is inserted.
     */
    insertBefore(newNode, referenceNode) {
        const that = this;

        if (!that.isCompleted) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!(newNode instanceof JQX.TabItem) || referenceNode !== undefined && referenceNode !== null && !(referenceNode instanceof JQX.TabItem)) {
            that.error(that.localize('tabItemRequired', { method: 'insertBefore' }));
        }

        let reselectIndex;

        if (that.contains(newNode)) {
            if (newNode.selected) {
                reselectIndex = true;
            }

            that.remove(newNode.index);
        }

        if (referenceNode !== undefined && referenceNode !== null) {
            if (!that.contains(referenceNode)) {
                that.error(that.localize('referenceNodeNotChild', { argument: 'referenceNode' }));
            }

            that.insert(referenceNode.index, { node: newNode });
        }
        else {
            that.insert(that._tabs.length, { node: newNode });
        }

        if (reselectIndex) {
            that._select(newNode.index, false);
        }
    }

    /**
     * Refreshes the Tabs header section.
     */
    refreshTabHeader() {
        const that = this;

        if (that.tabLayout === 'scroll') {
            that._checkOverflowScroll();
        }

        that._positionTabSelectionBar(that._tabLabelContainers[that.selectedIndex], true);
    }

    /**
     * Removes a tab and its associated content section.
     *
     * @param {Number} index The index of the tab to remove.
     */
    remove(index) {
        const that = this,
            initialNumberOfTabs = that._tabs.length;

        if (initialNumberOfTabs === 0) {
            return;
        }

        that._validateIndex(index, 'remove');

        index = Math.max(0, Math.min(index, initialNumberOfTabs - 1));

        const tab = that._tabs[index],
            tabLabelContainer = that._tabLabelContainers[index];


        //Fixes a iOS issue where removing the labelContainer breaks touchmove event
        //Used inside DockingLayout to indicate that the lableContainer shouldn't be removed during dragging operation.
        if (tabLabelContainer._lazyRemove) {
            tabLabelContainer.classList.add('jqx-hidden');
        }
        else {
            tabLabelContainer.parentElement.removeChild(tabLabelContainer); //Breaks Layout on iOS
        }

        tab.parentElement.removeChild(tab);

        if (tab.group !== null) {
            const jqxTabItemsGroup = that.$.tabContentSection.querySelector('jqx-tab-items-group[label="' + tab.group + '"]');

            if (jqxTabItemsGroup.childElementCount === 0) {
                const groupIndex = that._groups.indexOf(tab.group);

                that.$.tabStrip.removeChild(that._groupLabels[groupIndex]);

                that._groups.splice(groupIndex, 1);
                that.$.container.removeChild(that._groupLabels[0].dropDown);
                that._groupLabels.splice(groupIndex, 1);

                that.$.tabContentSection.removeChild(jqxTabItemsGroup);
            }
        }

        if (initialNumberOfTabs > 1) {
            if (index < that.selectedIndex) {
                that.selectedIndex--;
            }
            else if (index === that.selectedIndex) {
                if (index === initialNumberOfTabs - 1) {
                    that._select(index - 1, false);
                }
                else {
                    that._select(index + 1, false);
                    that.selectedIndex--;
                }
            }
        }
        else {
            that.selectedIndex = null;
            that.$.tabContentSection.innerHTML = '';
        }

        that._tabLabelContainers.splice(index, 1);
        that.$.dropDownButtonDropDown.removeChild(that.$.dropDownButtonDropDown.children[index]);
        that._tabs.splice(index, 1);

        if (that._focusedItem === tab) {
            that._focusedItem = that._tabs[that._focusedItem.index];
        }

        that._updateTabIndexes();
        that._getReorderItems();
        that._applyTabOverflow();
        that.ensureVisible(that.selectedIndex);
    }

    /**
     * Removes a child "jqx-tab-item" node.
     *
     * @param {HTMLElement} node The "jqx-tab-item" node to remove.
     */
    removeChild(node) {
        const that = this;

        if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!(node instanceof JQX.TabItem)) {
            that.error(that.localize('tabItemRequired', { method: 'removeChild' }));
        }

        if (!that.contains(node)) {
            that.error(that.localize('referenceNodeNotChild', { argument: 'node' }));
        }

        that.remove(node.index);
    }

    /**
     * Selects a tab.
     *
     * @param {Number} index The index of the tab to select.
     */
    select(index) {
        const that = this;

        if (that._tabs.length === 0) {
            return;
        }

        that._validateIndex(index, 'select');

        index = Math.max(0, Math.min(index, that._tabs.length - 1));

        that.ensureVisible(index);

        that._select(index, true);
    }

    /**
     * Sets whether the element can be focused.
     *
     * @param {Boolean} focusable Whether the element can be focused.
     */
    _setFocusable() {
        const that = this;

        if (that.disabled || that.unfocusable) {
            that.removeAttribute('tabindex');
            return;
        }

        if (that.getAttribute('tabindex') === null || that.getAttribute('tabindex') < 0) {
            that.setAttribute('tabindex', 0);
        }
    }

    /**
     * Updates a tab and its associated content section.
     *
     * @param {Number} index The index of the tab to update.
     * @param {String} label The new label of the tab. The value can be the id of an HTMLTemplateElement.
     * @param {String/HTMLElement} content The new content of the tab.
     */
    update(index, label, content) {
        const that = this;

        if (that._tabs.length === 0) {
            return;
        }

        that._validateIndex(index, 'update');

        index = Math.max(0, Math.min(index, that._tabs.length - 1));

        const tab = that._tabs[index];

        if (label !== undefined && tab.label !== label) {
            const labelTextContainer = that._tabLabelContainers[index].firstElementChild.children[0],
                dropDownLabelContainer = that.$.dropDownButtonDropDown.children[index];

            tab.label = label;
            labelTextContainer.innerHTML = '';
            dropDownLabelContainer.innerHTML = '';
            that._setLabel(label, labelTextContainer, dropDownLabelContainer);

            that._applyTabOverflow();
        }

        if (content !== undefined) {
            tab.content = content;
        }
    }

    /**
     * Applies initial settings to the Tabs element.
     */
    _createElement() {
        const that = this;

        if (that.disabled) {
            that.$.scrollButtonNear.disabled = true;
            that.$.scrollButtonFar.disabled = true;
        }

        that._handlePosition(that.tabPosition);
        that._handleScrollButtonsPosition(that.scrollButtonsPosition, 'both');

        if (that.dataSource !== null) {
            that._processDataSource();
        }

        that._setFocusable();

        if (that.collapsed && !that.collapsible) {
            that.collapsed = false;
        }

        if (that.collapsible) {
            if (that.allowToggle) {
                that.allowToggle = false;
            }
        }

        that._processHTML();

        if (that.selectedIndex === null) {
            that.$.tabContentSection.setAttribute('show-placeholder', '');
        }

        setTimeout(() => that.refreshTabHeader(), 300);
    }

    /**
     * Called when a property is changed.
     */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this;

        switch (propertyName) {
            case 'addNewTab':
                if (newValue) {
                    that._insertAddNewTab();
                }
                else {
                    that.$.tabStrip.removeChild(that._addNewTab);
                    delete that._addNewTab;
                }

                that._applyTabOverflow();
                break;
            case 'allowToggle':
                if (newValue && that.collapsible) {
                    if (that.collapsed) {
                        that._toggleCollapsedState();
                    }

                    that.collapsible = false;
                }
                else if (!newValue && that.selectedIndex === null) {
                    that.ensureVisible(that.selectedIndex = 0);
                    that._select(that.selectedIndex, true, null);
                }

                break;
            case 'closeButtonMode':
                if (newValue === 'selected') {
                    for (let i = 0; i < that._tabs.length; i++) {
                        that._disableCloseButton(i);
                    }

                    that._enableCloseButton(that.selectedIndex);
                }
                else {
                    that._disableCloseButton(that.selectedIndex);

                    const tabLabelContainers = that._tabLabelContainers;

                    for (let i = 0; i < tabLabelContainers.length; i++) {
                        const tabLabelContainer = tabLabelContainers[i];

                        tabLabelContainer.closeButtonEnabled = that._tabs[i].closeButtonHidden !== true;
                        that._showCloseButton(tabLabelContainer);
                    }
                }

                that._applyTabOverflow();
                break;
            case 'closeButtons': {
                const tabLabelContainers = that._tabLabelContainers,
                    fn = newValue ? that._showCloseButton : that._hideCloseButton;

                for (let i = 0; i < tabLabelContainers.length; i++) {
                    const tabLabelContainer = tabLabelContainers[i];

                    fn(tabLabelContainer);
                }

                that._applyTabOverflow();
                break;
            }
            case 'collapsed':
                if (!that.collapsible && newValue) {
                    that.collapsed = false;
                    return;
                }

                break;
            case 'collapsible':
                if (!newValue && that.collapsed) {
                    that.collapsed = false;
                }

                that.allowToggle = false;

                if (that.selectedIndex === undefined) {
                    that.select(that._focusedItem.index);
                }

                break;
            case 'dataSource':
                that.selectedIndex = null;

                for (let i = 0; i < that._groupLabels.length; i++) {
                    that.$.container.removeChild(that._groupLabels[i].dropDown);
                }

                that.$.tabStrip.innerHTML = '';
                that._processDataSource();
                that._processHTML();
                break;
            case 'disabled':
                that._setFocusable();
                that.$.scrollButtonNear.disabled = newValue;
                that.$.scrollButtonFar.disabled = newValue;

                if (!newValue) {
                    that._updateScrollButtonVisibility();
                }

                that._closeDropDownButtonDropDown();
                break;
            case 'messages':
            case 'scrollMode':
            case 'selectionMode':
            case 'readonly':
            case 'reorder':
                break;
            case 'overflow':
                if (that.tabLayout !== 'scroll') {
                    return;
                }

                that.$.tabStrip.scrollLeft = 0;
                that.$.tabStrip.scrollTop = 0;

                if (newValue === 'hidden') {
                    that.$tabsHeaderSection.removeClass('scroll-buttons-shown');
                    that.$scrollButtonNear.addClass('jqx-hidden');
                    that.$scrollButtonFar.addClass('jqx-hidden');
                }
                else {
                    that._checkOverflowScroll();
                }

                that._getTabCoordinates();
                break;
            case 'tabPosition': {
                that.$.tabSelectionBar.style.transition = 'none';
                that._tabPositionChanging = true;
                that._closeGroupDropDown();
                that._handlePosition(newValue, oldValue);

                if (that.tabLayout !== 'shrink') {
                    that._applyLabelSizes('tabPosition');
                }

                that._applyTabOverflow();

                if (newValue !== 'hidden') {
                    const arrows = that.getElementsByClassName('jqx-tab-group-arrow');

                    for (let i = 0; i < arrows.length; i++) {
                        arrows[i].innerHTML = that._arrowCodes[that.tabPosition];
                    }
                }

                delete that._tabPositionChanging;
                requestAnimationFrame(function () {
                    that.$.tabSelectionBar.style.transition = null;
                });
                break;
            }
            case 'resize':
                if (newValue) {
                    that._getTabCoordinates();
                }

                break;
            case 'scrollButtonsPosition':
                that._handleScrollButtonsPosition(newValue, oldValue);
                break;
            case 'selectedIndex': {
                if (isNaN(newValue)) {
                    that.selectedIndex = newValue = oldValue;
                }

                if ((!that.allowToggle && newValue === null)) {
                    that.selectedIndex = oldValue;
                    return;
                }

                let validIndex = newValue;

                if (newValue !== null) {
                    validIndex = Math.max(0, Math.min(newValue, that._tabs.length - 1));

                    that.ensureVisible(validIndex);
                }

                that._select(validIndex, true, oldValue);
                break;
            }
            case 'tabLayout':
                if (oldValue === 'scroll') {
                    that.$tabsHeaderSection.removeClass('scroll-buttons-shown');
                    that.$scrollButtonNear.addClass('jqx-hidden');
                    that.$scrollButtonFar.addClass('jqx-hidden');
                }

                if (newValue === 'shrink') {
                    that._applyLabelSizes('shrink', true);
                }
                else if (oldValue === 'shrink') {
                    that._applyLabelSizes('shrink', false);
                }

                that._applyTabOverflow();

                if (newValue === 'scroll' && that.disabled) {
                    that.$.scrollButtonNear.disabled = true;
                    that.$.scrollButtonFar.disabled = true;
                }

                that.ensureVisible(that.selectedIndex);
                break;
            case 'tabTextOrientation':
                that._applyTabOverflow();
                that.ensureVisible(that.selectedIndex);
                break;
            case 'unfocusable':
                that._setFocusable();
                break;
        }
    }

    /**
     * Adds a tab group container.
     */
    _addGroupContainer(label, labelSize) {
        const that = this,
            groupContainer = document.createElement('div'),
            labelTextWrapper = document.createElement('div'),
            labelTextContainer = document.createElement('div'),
            arrow = document.createElement('div'),
            dropDown = document.createElement('div');

        groupContainer.className = 'jqx-tab-group-container jqx-unselectable';
        groupContainer.$ = JQX.Utilities.Extend(groupContainer);
        labelTextWrapper.className = 'jqx-tab-label-text-wrapper';

        if (labelSize !== null && that.tabLayout !== 'shrink') {
            groupContainer.style[that._orientationSettings.dimension] = parseInt(labelSize, 10) + 'px';
        }

        // label
        labelTextContainer.className = 'jqx-tab-label-text-container';
        labelTextContainer.innerHTML = label;

        // down arrow
        arrow.className = 'jqx-tab-group-arrow';
        arrow.innerHTML = that._arrowCodes[that.tabPosition];

        // dropdown
        dropDown.className = 'jqx-tab-group-drop-down jqx-hidden';
        dropDown.$ = JQX.Utilities.Extend(dropDown);

        labelTextWrapper.appendChild(labelTextContainer);
        labelTextWrapper.appendChild(arrow);
        groupContainer.appendChild(labelTextWrapper);
        that.$.container.appendChild(dropDown);

        groupContainer.group = label;
        groupContainer.dropDown = dropDown;
        dropDown.groupContainer = groupContainer;

        return { label: groupContainer, dropDown: dropDown };
    }

    /**
     * Adds group-related elements to the tabstrip.
     */
    _addGroupElements(details) {
        const that = this,
            groups = details.groups,
            groupLabels = details.groupLabels,
            group = details.group,
            groupIndex = groups.indexOf(group),
            tabLabelContainer = details.tabLabelContainer;
        let groupLabel;

        if (groupIndex !== -1) {
            // group exists
            groupLabel = groupLabels[groupIndex];
            groupLabel.dropDown.appendChild(tabLabelContainer);
        }
        else {
            // group does not exist
            groups.push(group);

            const groupContainers = that._addGroupContainer(group, details.jqxTabItemsGroup.labelSize),
                groupDropDown = groupContainers.dropDown;

            groupLabel = groupContainers.label;

            groupDropDown.appendChild(tabLabelContainer);
            groupDropDown.groupContainer = groupContainers.label;

            details.documentFragment.appendChild(groupLabel);

            groupLabels.push(groupLabel);
        }

        if (that.selectedIndex === details.i) {
            that._selectedGroup = groupLabel;
            groupLabel.$.addClass('jqx-tab-group-selected');
        }
    }

    /**
     * "add new" tab event handler.
     */
    _addNewTabHandler(currentElement, eventType, click) {
        const that = this;

        if (that._swiping) {
            return;
        }

        if (click) {
            currentElement.removeAttribute('hover');

            that.insert(that._tabs.length, { label: 'New Tab', content: '' });
            that._select(that._tabs.length - 1, true);
        }
        else if (!that._reordering && !that._swiping) {
            if (eventType === 'mouseover') {
                currentElement.setAttribute('hover', '');
            }
            else if (eventType === 'mouseout') {
                currentElement.removeAttribute('hover');
            }
        }
    }

    /**
     * Adds a tab label container.
     */
    _addTabLabelContainer(tab, addNewTab) {
        const that = this,
            tabLabelContainer = document.createElement('div'),
            labelTextWrapper = document.createElement('div'),
            labelTextContainer = document.createElement('div'),
            closeButton = document.createElement('div');
        let dropDownLabelContainer;

        tabLabelContainer.className = 'jqx-tab-label-container jqx-unselectable';
        labelTextWrapper.className = 'jqx-tab-label-text-wrapper';

        // label
        labelTextContainer.className = 'jqx-tab-label-text-container';

        // close button
        closeButton.className = 'jqx-tab-close-button';
        closeButton.innerHTML = '&#xe81f';

        if (addNewTab === undefined) {
            if (that.closeButtons) {
                if (that.closeButtonMode === 'default' && tab.closeButtonHidden ||
                    that.closeButtonMode === 'selected' && !tab.selected) {
                    closeButton.classList.add('jqx-hidden');
                    tabLabelContainer.closeButtonEnabled = false;
                }
                else {
                    labelTextContainer.classList.add('jqx-close-button-enabled');
                    tabLabelContainer.closeButtonEnabled = true;
                }

            }
            else {
                closeButton.classList.add('jqx-hidden');
                tabLabelContainer.closeButtonEnabled = true;
            }

            dropDownLabelContainer = document.createElement('div');
            dropDownLabelContainer.className = 'jqx-tab-label-container jqx-unselectable';

            if (tab.group === null && tab.labelSize !== null && that.tabLayout !== 'shrink') {
                tabLabelContainer.style[that._orientationSettings.dimension] = parseInt(tab.labelSize, 10) + 'px';
            }
        }
        else {
            closeButton.classList.add('jqx-hidden');
            tabLabelContainer.closeButtonEnabled = false;
        }

        that._setLabel(tab ? tab.label : '+', labelTextContainer, dropDownLabelContainer);

        labelTextContainer.$ = JQX.Utilities.Extend(labelTextContainer);
        closeButton.$ = JQX.Utilities.Extend(closeButton);

        labelTextWrapper.appendChild(labelTextContainer);
        labelTextWrapper.appendChild(closeButton);

        tabLabelContainer.appendChild(labelTextWrapper);

        tabLabelContainer.$ = JQX.Utilities.Extend(tabLabelContainer);

        return { tabLabelContainer: tabLabelContainer, dropDownLabelContainer: dropDownLabelContainer };
    }

    /**
     * Animates selection.
     */
    _animateSelection(tab, oldTab, indexGreaterThanOldIndex) {
        const that = this;
        let side1 = 'right',
            side2 = 'left';

        that._animatedTab = tab;
        that._animatedOldTab = oldTab;

        if (!that._animatedTab || !that._animatedOldTab) {
            return;
        }

        if (that.tabPosition === 'left' || that.tabPosition === 'right') {
            side1 = 'top';
            side2 = 'bottom';
        }

        for (let i = 0; i < that._tabs.length; i++) {
            that._tabs[i].$.removeClass(side1);
            that._tabs[i].$.removeClass(side2);
            that._tabs[i].$.removeClass('animate');
        }

        if (tab === oldTab) {
            tab.$.hasClass('jqx-visibility-hidden') ? tab.$.removeClass('jqx-visibility-hidden') : tab.$.addClass('jqx-visibility-hidden');
            that._animatedOldTab.classToRemove = side1;
            return;
        }

        if (indexGreaterThanOldIndex) {
            tab.$.addClass(side1);
            tab.$.removeClass('jqx-visibility-hidden');

            oldTab.$.addClass('animate');
            tab.$.addClass('animate');

            oldTab.$.addClass(side2);
            oldTab.$.addClass('jqx-visibility-hidden');
            tab.$.removeClass(side1);

            that._animatedOldTab.classToRemove = side2;
        }
        else {
            tab.$.addClass(side2);
            tab.$.removeClass('jqx-visibility-hidden');

            oldTab.$.addClass('animate');
            tab.$.addClass('animate');

            oldTab.$.addClass(side1);
            oldTab.$.addClass('jqx-visibility-hidden');
            tab.$.removeClass(side2);

            that._animatedOldTab.classToRemove = side1;
        }
    }

    /**
     * Shows or hides the scroll buttons.
     */
    _applyConditionalTabOverflow() {
        const that = this,
            verticalPosition = that.tabPosition === 'left' || that.tabPosition === 'right',
            tabStrip = that.$.tabStrip;

        if (that.tabLayout === 'scroll') {
            that._checkOverflowScroll();
            return;
        }

        if (that._flexWritingModeNoFullSupport && that.tabLayout === 'shrink' && verticalPosition &&
            tabStrip.scrollHeight > tabStrip.offsetHeight) {

            const tabStripChildren = tabStrip.children,
                height = 100 / tabStripChildren.length + '%';

            tabStrip.$.addClass('shrink-tabs-vertical');

            for (let i = 0; i < tabStripChildren.length; i++) {
                tabStripChildren[i].style.height = height;
                tabStripChildren[i].firstElementChild.firstElementChild.classList.add('jqx-tab-label-text-container-full-height');
            }

            that._inlineStyleTabStripChildren = true;
        }
    }

    /**
     * Applies label sizes.
     */
    _applyLabelSizes(condition, removeLabelSize) {
        const that = this,
            newDimension = that._orientationSettings.dimension,
            oldDimension = newDimension === 'width' ? 'height' : 'width';

        for (let i = 0; i < that._reorderItems.length; i++) {
            const currentItem = that._reorderItems[i],
                correspondingCustomElement = that._getCorrespondingCustomElement(currentItem);

            if (correspondingCustomElement.labelSize !== null) {
                if (condition === 'tabPosition') {
                    currentItem.style.removeProperty(oldDimension);
                }

                if (!removeLabelSize) {
                    currentItem.style[newDimension] = parseInt(correspondingCustomElement.labelSize, 10) + 'px';
                }
                else {
                    currentItem.style.removeProperty(newDimension);
                }
            }
        }
    }

    /**
     * Applies the necessary adjustments in order to achieve the chosen tab overflow.
     */
    _applyTabOverflow() {
        const that = this;

        that._removeInlineStyle();

        if (that._tabs.length === 0) {
            that._toggleNavigationElementsVisibility();
            return;
        }

        const tabLayout = that.tabLayout,
            position = that.tabPosition,
            verticalPosition = position === 'left' || position === 'right',
            tabStrip = that.$.tabStrip;

        that._closeDropDownButtonDropDown();

        switch (tabLayout) {
            case 'scroll':
            case 'dropDown':
                if (that._flexWritingModeNoFullSupport && that.tabTextOrientation === 'vertical' && verticalPosition) {
                    that._fixTabStripNotChrome(tabStrip);
                }

                break;
            case 'wrap':
                if (that.tabTextOrientation === 'vertical') {
                    if (that._flexWritingModeNoFullSupport) {
                        // fix for flexbox-related issues in Firefox, Edge, and Safari
                        if (verticalPosition) {
                            that._fixTabStripNotChrome(tabStrip);
                        }
                        else {
                            const tabStripChildren = tabStrip.children;
                            let greatestHeight = tabStripChildren[0].offsetHeight;

                            for (let i = 1; i < tabStripChildren.length; i++) {
                                greatestHeight = Math.max(greatestHeight, tabStripChildren[i].offsetHeight);
                            }

                            for (let i = 1; i < tabStripChildren.length; i++) {
                                tabStripChildren[i].style.height = greatestHeight + 'px';
                            }

                            that._inlineStyleTabStripChildren = true;
                        }
                    }
                    else if (!verticalPosition) {
                        if (tabStrip.scrollHeight > tabStrip.offsetHeight) {
                            tabStrip.style.height = tabStrip.scrollHeight + 'px';
                            that._inlineStyleTabStrip = true;
                        }
                    }
                }
                else if (verticalPosition && (tabStrip.scrollWidth > tabStrip.offsetWidth)) {
                    tabStrip.style.width = tabStrip.scrollWidth + 'px';

                    if (position === 'right') {
                        tabStrip.style.flexWrap = 'wrap-reverse';
                    }

                    that._inlineStyleTabStrip = true;
                }

                break;
            case 'shrink': {
                if (!verticalPosition) {
                    if (tabStrip.scrollWidth > tabStrip.offsetWidth) {
                        tabStrip.$.addClass('shrink-tabs');
                    }
                }
                else if (that._flexWritingModeNoFullSupport && that.tabTextOrientation === 'vertical') {
                    const tabStripChildren = tabStrip.children,
                        computedStyle = window.getComputedStyle(tabStripChildren[0].firstElementChild),
                        paddings = parseInt(computedStyle.paddingLeft, 10) + parseInt(computedStyle.paddingRight, 10);
                    let maxWidth = 0;

                    for (let i = 0; i < tabStripChildren.length; i++) {
                        maxWidth = Math.max(maxWidth, tabStripChildren[i].firstElementChild.firstElementChild.offsetWidth);
                    }

                    tabStrip.style.width = (paddings + maxWidth) + 'px';
                    that._inlineStyleTabStrip = true;
                    break;
                }
            }
        }

        that._applyConditionalTabOverflow();
        that._getTabCoordinates();
        that._fixTabStripFlex(tabLayout);
        that._toggleNavigationElementsVisibility();
        that._positionTabSelectionBar(that._tabLabelContainers[that.selectedIndex], true);
    }

    /**
     * Checks if items overflow and shows/hides scroll buttons.
     */
    _checkOverflowScroll() {
        const that = this,
            tabsHeaderSection = that.$tabsHeaderSection,
            tabStrip = that.$.tabStrip,
            overflow = that.overflow;

        if (overflow === 'hidden') {
            return;
        }

        let overflowing, showNear, showFar;

        if (!(that.tabPosition === 'left' || that.tabPosition === 'right')) {
            overflowing = Math.round(tabStrip.scrollWidth) > Math.round(tabStrip.offsetWidth);
            showNear = Math.round(tabStrip.scrollLeft) > 0;
            showFar = Math.round(tabStrip.offsetWidth + tabStrip.scrollLeft) < Math.round(tabStrip.scrollWidth);
        }
        else {
            overflowing = Math.round(tabStrip.scrollHeight) > Math.round(tabStrip.offsetHeight);
            showNear = Math.round(tabStrip.scrollTop) > 0;
            showFar = Math.round(tabStrip.offsetHeight + tabStrip.scrollTop) < Math.round(tabStrip.scrollHeight);
        }

        if (overflow === 'scroll') {
            tabsHeaderSection.addClass('scroll-buttons-shown');
            that.$scrollButtonNear.removeClass('jqx-hidden');
            that.$scrollButtonFar.removeClass('jqx-hidden');
        }

        if (overflowing) {
            if (overflow === 'auto') {
                if (!tabsHeaderSection.hasClass('scroll-buttons-shown')) {
                    tabsHeaderSection.addClass('scroll-buttons-shown');
                }

                if (showNear) {
                    that.$scrollButtonNear.removeClass('jqx-hidden');
                }
                else {
                    that.$scrollButtonNear.addClass('jqx-hidden');
                }

                if (showFar) {
                    that.$scrollButtonFar.removeClass('jqx-hidden');
                }
                else {
                    that.$scrollButtonFar.addClass('jqx-hidden');
                }

                if ((showNear && showFar) === false) {
                    tabsHeaderSection.addClass('one-button-shown');
                }
                else {
                    tabsHeaderSection.removeClass('one-button-shown');
                }

                if (!that.disabled) {
                    that.$.scrollButtonNear.disabled = false;
                    that.$.scrollButtonFar.disabled = false;
                }
            }
            else {
                tabsHeaderSection.removeClass('one-button-shown');

                if (that.disabled) {
                    that.$.scrollButtonNear.disabled = true;
                    that.$.scrollButtonFar.disabled = true;
                }
                else {
                    that.$.scrollButtonNear.disabled = !showNear;
                    that.$.scrollButtonFar.disabled = !showFar;
                }
            }
        }
        else if (!overflowing && overflow === 'auto' && tabsHeaderSection.hasClass('scroll-buttons-shown')) {
            tabsHeaderSection.removeClass('scroll-buttons-shown');
            tabsHeaderSection.removeClass('one-button-shown');
            that.$scrollButtonNear.addClass('jqx-hidden');
            that.$scrollButtonFar.addClass('jqx-hidden');
        }
        else if (!overflowing && overflow === 'scroll') {
            that.$.scrollButtonNear.disabled = true;
            that.$.scrollButtonFar.disabled = true;
        }
    }

    /**
     * jqx-tab-item closeButtonVisibilityChange event handler.
     */
    _closeButtonVisibilityChangeHandler(event) {
        const that = this,
            index = event.target.index;

        if (that.closeButtonMode === 'selected') {
            that._tabLabelContainers[index].closeButtonEnabled = event.detail.hidden;
            return;
        }

        if (event.detail.hidden) {
            that._disableCloseButton(index);
        }
        else {
            that._enableCloseButton(index);
        }
    }

    /**
     * Closes the dropdown in mode 'dropDown'.
     */
    _closeDropDownButtonDropDown() {
        const that = this;

        if (that._dropDownButtonDropDownOpened) {
            that.$dropDownButtonDropDown.addClass('jqx-hidden');
            that._dropDownButtonDropDownOpened = false;
        }
    }

    /**
     * Closes the open group dropdown.
     */
    _closeGroupDropDown() {
        const that = this;

        if (!that._openDropDown) {
            return;
        }

        if (that._openDropDown.rippleInProgress) {
            setTimeout(function () {
                if (that._openDropDown) {
                    that._openDropDown.$.addClass('jqx-hidden');
                    delete that._openDropDown.rippleInProgress;
                    that._openDropDown = undefined;
                }
            }, 450);
        }
        else {
            that._openDropDown.$.addClass('jqx-hidden');
            that._openDropDown = undefined;
        }
    }

    /**
     * Container event handler.
     */
    _containerHandler(event) {
        const that = this,
            eventType = event.type;

        if (that.disabled ||
            that.readonly ||
            (that._resizing && eventType !== 'mouseout') ||
            ((eventType === 'down' || eventType === 'up') && event.which !== 1 && !JQX.Utilities.Core.isMobile)) {
            return;
        }

        if (eventType === 'up') {
            event.stopPropagation();
        }

        const target = event.originalEvent ? event.originalEvent.target : event.target;

        if (that.$.tabContentSection.contains(target)) {
            return;
        }

        if (that.$.dropDownButton.contains(target)) {
            that._dropDownButtonHandler(target, event);
            return;
        }

        if (that.$.dropDownButtonDropDown.contains(target)) {
            that._dropDownButtonHandler(target, event, true);
            return;
        }

        that._tabStripHandler(target, event);
    }

    /**
     * Disables the close button of a tab.
     *
     * @param {Number} index The index of which tab's close button to hide.
     */
    _disableCloseButton(index) {
        const that = this,
            tabLabelContainer = that._tabLabelContainers[index];

        tabLabelContainer.closeButtonEnabled = false;

        if (that.closeButtons) {
            that._hideCloseButton(tabLabelContainer);
        }
    }

    /**
     * Document (mouse)move handler.
     */
    _documentMoveHandler(event) {
        const that = this,
            orientationSettings = that._orientationSettings;

        if (that._reordering) {
            if (!that._reorderStartThrown) {
                that._fireDragEvent(event, 'dragStart');
                that._reorderStartThrown = true;
            }

            const mouseCoordinate = event[orientationSettings.coordinate],
                condition = that.tabLayout !== 'wrap' ?
                    function (currentCoordinateSet) {
                        return mouseCoordinate >= currentCoordinateSet[orientationSettings.from] && mouseCoordinate <= currentCoordinateSet[orientationSettings.to];
                    } :
                    function (currentCoordinateSet) {
                        return event.pageX >= currentCoordinateSet.fromX && event.pageX <= currentCoordinateSet.toX && event.pageY >= currentCoordinateSet.fromY && event.pageY <= currentCoordinateSet.toY;
                    };
            let inTab = false;

            for (let i = 0; i < that._tabCoordinates.length; i++) {
                const currentCoordinateSet = that._tabCoordinates[i];

                if (condition(currentCoordinateSet)) {
                    inTab = i;
                    break;
                }
            }

            if (that._preventReorder !== true && inTab !== false && inTab !== that._draggedIndex) {
                that._reorderTabs(that._draggedIndex, inTab);

                that._closeGroupDropDown();

                that._draggedIndex = inTab;
                that._getReorderItems();
                that._getTabCoordinates();
            }

            const draggedIndexCoordinates = that._tabCoordinates[that._draggedIndex];

            if (that.tabLayout !== 'wrap' &&
                (mouseCoordinate < draggedIndexCoordinates[orientationSettings.from] || mouseCoordinate > draggedIndexCoordinates[orientationSettings.to]) ||
                that.tabLayout === 'wrap' &&
                (event.originalEvent.target.closest('.jqx-tab-label-container') !== null ||
                    event.originalEvent.target.closest('.jqx-tab-group-container') !== null) &&
                !(event.pageX >= draggedIndexCoordinates.fromX && event.pageX <= draggedIndexCoordinates.toX && event.pageY >= draggedIndexCoordinates.fromY && event.pageY <= draggedIndexCoordinates.toY)) {
                that._preventReorder = true;
            }
            else {
                that._preventReorder = false;
            }
        }
        else if (that._resizing) {
            that.$.resizeToken.style[orientationSettings.edge] = event[orientationSettings.coordinate] - that._tabsHeaderSectionCoordinate + 'px';
            that.$resizeToken.removeClass('jqx-hidden');
        }
    }

    /**
     * Document (mouse)up handler.
     */
    _documentUpHandler(event) {
        const that = this;
        let target = event.originalEvent.target;

        that._endSwiping(event, Date.now());

        if (that._openDropDown && !that._openDropDown.rippleInProgress &&
            (target === document || target.closest('.jqx-tab-group-container') !== that._openDropDown.groupContainer)) {
            that._closeGroupDropDown();
        }

        if (!that.$.dropDownButton.contains(target)) {
            that._closeDropDownButtonDropDown();
        }

        that._endReordering(event, target);

        that._resize(event);

        if (that._tabToResize !== undefined) {
            that._tabToResize = undefined;
        }
    }

    /**
     * Dropdown button and dropdown event handler.
     */
    _dropDownButtonHandler(target, event, dropDown) {
        const that = this,
            eventType = event.type;

        if (dropDown) {
            if (target.classList.contains('jqx-tab-label-container')) {
                switch (eventType) {
                    case 'down':
                        that._downTarget = target;
                        break;
                    case 'mouseout':
                        target.removeAttribute('hover');
                        break;
                    case 'mouseover':
                        target.setAttribute('hover', '');
                        break;
                    case 'up':
                        if (target === that._downTarget) {
                            that.select(Array.from(that.$.dropDownButtonDropDown.children).indexOf(target));
                            that._closeDropDownButtonDropDown();
                        }
                        break;
                }
            }
            return;
        }

        if (eventType === 'down') {
            that._downTarget = that.$.dropDownButton;
        }
        else if (eventType === 'up' && that._downTarget === that.$.dropDownButton) {
            if (!that._dropDownButtonDropDownOpened) {
                const tabPosition = that.tabPosition;
                let left, top;

                switch (tabPosition) {
                    case 'top':
                        left = that.$.dropDownButton.offsetLeft;
                        top = that.$.tabsHeaderSection.offsetTop + that.$.dropDownButton.offsetHeight;
                        break;
                    case 'bottom':
                        left = that.$.dropDownButton.offsetLeft;
                        top = that.$.tabsHeaderSection.offsetTop;
                        break;
                    case 'left':
                        left = that.$.dropDownButton.offsetWidth;
                        top = that.$.dropDownButton.offsetTop;
                        break;
                    case 'right':
                        left = that.$.tabsHeaderSection.offsetLeft;
                        top = that.$.dropDownButton.offsetTop;
                        break;
                }

                that.$.dropDownButtonDropDown.style.left = left + 'px';
                that.$.dropDownButtonDropDown.style.top = top + 'px';
                that.$dropDownButtonDropDown.removeClass('jqx-hidden');
                that._dropDownButtonDropDownOpened = true;
            }
            else {
                that._closeDropDownButtonDropDown();
            }
        }
    }

    /**
     * Enables the close button of a tab.
     *
     * @param {Number} index The index of which tab's close button to show.
     */
    _enableCloseButton(index) {
        const that = this,
            tabLabelContainer = that._tabLabelContainers[index];

        tabLabelContainer.closeButtonEnabled = true;

        if (that.closeButtons) {
            that._showCloseButton(tabLabelContainer);
        }
    }

    /**
     * Ends reordering operation.
     */
    _endReordering(event, target) {
        const that = this;

        if (!that._reordering) {
            return;
        }

        if (that._draggedHoveredTab) {
            if (!that._draggedHoveredTab.contains(target)) {
                that._draggedHoveredTab.removeAttribute('hover');

            }

            delete that._draggedHoveredTab;
        }

        that._reorderedIndex = undefined;
        that._reordering = false;
        that._reorderStartThrown = false;
        that.removeAttribute('dragged');

        if (event) {
            that._fireDragEvent(event, 'dragEnd');
        }
    }

    /**
     * Ends swiping and scrolls kinetically.
     */
    _endSwiping(event, now) {
        const that = this;

        if (!that._dragStartDetails) {
            return;
        }

        const orientationSettings = that._orientationSettings,
            tabStrip = that.$.tabStrip,
            timeDifference = Math.abs(that._dragStartDetails.startTime - now),
            speed = 200 / timeDifference,
            distanceDifference = (that._dragStartDetails[orientationSettings.startCoordinate] - event[orientationSettings.coordinate]) * speed;
        let remaining = Math.abs(distanceDifference);

        const scrollable = function () {
            if (distanceDifference > 0 &&
                tabStrip[orientationSettings.scrollDirection] === tabStrip[orientationSettings.scrollSize] - tabStrip[orientationSettings.size] ||
                distanceDifference < 0 && tabStrip[orientationSettings.scrollDirection] === 0) {
                return false;
            }

            return true;
        }

        let scrollStep = 0.03 * Math.abs(distanceDifference) * speed;

        const kineticScrolling = function () {
            if (scrollStep > 5) {
                const remainingPart = (remaining - scrollStep) / Math.abs(distanceDifference);

                if (remainingPart < 0.1) {
                    scrollStep /= 1.25;
                }
                else if (remainingPart < 0.15) {
                    scrollStep /= 1.2;
                }
                else if (remainingPart < 0.2) {
                    scrollStep /= 1.15;
                }
                else if (remainingPart < 0.25) {
                    scrollStep /= 1.1;
                }
                else if (remainingPart < 0.3) {
                    scrollStep /= 1.05;
                }
            }

            scrollStep = Math.round(scrollStep);

            const oldScrollDirection = tabStrip[orientationSettings.scrollDirection];

            if (distanceDifference > 0) {
                tabStrip[orientationSettings.scrollDirection] = Math.min(oldScrollDirection + scrollStep, tabStrip[orientationSettings.scrollSize] - tabStrip[orientationSettings.size]);
            }
            else {
                tabStrip[orientationSettings.scrollDirection] = Math.max(oldScrollDirection - scrollStep, 0);
            }

            remaining -= scrollStep;

            that._updateScrollButtonVisibility(true);

            const canBeScrolled = scrollable();

            if (remaining > 0 && canBeScrolled) {
                that._scrollingAnimationFrame = window.requestAnimationFrame(kineticScrolling);
            }
            else {
                that._wheelInProgress = false;
            }
        };

        if (that._scrollingAnimationFrame) {
            cancelAnimationFrame(that._scrollingAnimationFrame);
        }

        if (timeDifference < 500 && scrollable()) {
            that._scrollingAnimationFrame = window.requestAnimationFrame(kineticScrolling);
        }
        else {
            that._wheelInProgress = false;
        }

        delete that._dragStartDetails;

        if (that._swiping) {
            delete that._swiping;
        }
    }

    /**
     * Fires the "dragStart" or "dragEnd" event.
     */
    _fireDragEvent(event, eventToFire) {
        const that = this,
            target = that.$.tabStrip.children[that._draggedIndex],
            tab = target.tab;
        let selected, index, label;

        if (tab) {
            selected = tab.selected;
            index = tab.index;
            label = tab.label;
        }
        else {
            label = target.group;
        }

        that.$.fireEvent(eventToFire, {
            'position': { left: event.pageX, top: event.pageY }, 'target': target, 'selected': selected, 'index': index, 'label': label
        });
    }

    /**
     * Fix for the tab strip layout in Firefox, Edge, and Safari when the position and text orientation are vertical.
     */
    _fixTabStripNotChrome(tabStrip) {
        const that = this;

        function recalcTabStripWidth() {
            const tabStripChildren = [].slice.call(tabStrip.children).filter(item => !item._lazyRemove);
            let rect = tabStripChildren[0].getBoundingClientRect(),
                leastStartX = rect.left,
                greatestEndX = leastStartX + tabStripChildren[0].offsetWidth;

            for (let i = 1; i < tabStripChildren.length; i++) {
                rect = tabStripChildren[i].getBoundingClientRect();
                leastStartX = Math.min(leastStartX, rect.left);
                greatestEndX = Math.max(greatestEndX, rect.left + tabStripChildren[i].offsetWidth);
            }

            tabStrip.style.width = greatestEndX - leastStartX + 'px';
            that._inlineStyleTabStrip = true;
        }

        if (that._tabs.length === 0) {
            return;
        }

        recalcTabStripWidth();

        if (JQX.Utilities.Core.Browser.Safari) {
            setTimeout(function () {
                tabStrip.parentElement.classList.add('jqx-hidden');
                setTimeout(function () {
                    tabStrip.parentElement.classList.remove('jqx-hidden');
                    recalcTabStripWidth();
                }, 10);
            }, 10);
        }

        //Necessary for cases where the tab is nested for example in a Layout and resize has to be called on the Layout.
        that.$.fireEvent('tabStripResize');
    }

    /**
     * Fix for a flexbox-related issue in Chrome.
     */
    _fixTabStripFlex(tabLayout) {
        const that = this;

        if (!that._flexWritingModeNoFullSupport && that.tabTextOrientation === 'vertical' && (that.tabPosition === 'left' || that.tabPosition === 'right')) {
            setTimeout(function () {
                that.$tabsHeaderSection.addClass('jqx-hidden');
                setTimeout(function () {
                    that.$tabsHeaderSection.removeClass('jqx-hidden');
                    that._getTabCoordinates();

                    if (tabLayout === 'scroll') {
                        that._checkOverflowScroll();
                    }
                }, 10);
            }, 10);
        }
    }

    /**
     * Returns the custom element corresponding to the passed tab strip element.
     */
    _getCorrespondingCustomElement(currentItem) {
        if (currentItem.$.hasClass('jqx-tab-label-container')) {
            return currentItem.tab;
        }
        else {
            return this.$.tabContentSection.querySelector('jqx-tab-items-group[label="' + currentItem.group + '"]');
        }
    }

    /**
     * Stores the items that can be reordered in an Array.
     */
    _getReorderItems() {
        const that = this;
        let reorderItems;

        if (that._groups.length === 0) {
            reorderItems = that._tabLabelContainers;
        }
        else {
            reorderItems = Array.from(that.$.tabStrip.children);

            if (that.addNewTab) {
                reorderItems.pop();
            }
        }

        that._reorderItems = reorderItems;
    }

    /**
     * Stores the coordinates of tab label containers in an Array (for use in reorder and resize functionalities).
     */
    _getTabCoordinates() {
        const that = this;

        if ((!that.reorder && !that.resize) || that.tabPosition === 'hidden') {
            return;
        }

        const coordinates = [],
            windowScrollX = window.scrollX || window.pageXOffset,
            windowScrollY = window.scrollY || window.pageYOffset;

        for (let i = 0; i < that._reorderItems.length; i++) {
            const currentTabLabelContainer = that._reorderItems[i],
                boundingClientRect = currentTabLabelContainer.getBoundingClientRect(),
                style = window.getComputedStyle(currentTabLabelContainer),
                marginLeft = parseFloat(style.marginLeft),
                marginRight = parseFloat(style.marginRight),
                marginTop = parseFloat(style.marginTop),
                marginBottom = parseFloat(style.marginBottom);

            coordinates.push({
                fromX: boundingClientRect.left - marginLeft + windowScrollX,
                toX: boundingClientRect.right + marginRight + windowScrollX,
                fromY: boundingClientRect.top - marginTop + windowScrollY,
                toY: boundingClientRect.bottom + marginBottom + windowScrollY
            });
        }

        that._tabCoordinates = coordinates;
    }

    /**
     * Stores tabs in an Array.
     */
    _getTabs() {
        const that = this;
        let tabs = that.enableShadowDOM ? that.shadowRoot.querySelectorAll('jqx-tab-item') : that.getElementsByTagName('jqx-tab-item');

        if (that.selectedIndex !== null) {
            if (tabs.length === 0) {
                that.selectedIndex = null;
            }
            else {
                that.selectedIndex = Math.max(0, Math.min(that.selectedIndex, tabs.length - 1));
            }
        }

        that._tabs = Array.from(tabs);
    }

    /**
     * Group container event handler.
     */
    _groupContainerHandler(currentElement, eventType) {
        const that = this,
            dropDown = currentElement.dropDown;

        if (eventType === 'down') {
            that._downTarget = currentElement;

            if (that.reorder && that._reorderItems.length > 1) {
                that._getTabCoordinates();
                that._reordering = true;
                that.setAttribute('dragged', '');
                that._draggedIndex = Array.from(that.$.tabStrip.children).indexOf(currentElement);
            }

            return;
        }

        if (!that._reordering && !that._swiping) {
            if (dropDown !== that._openDropDown && eventType === 'mouseover' && !currentElement.classList.contains('jqx-tab-group-selected')) {
                currentElement.setAttribute('hover', '');
            }
            else if (eventType === 'mouseout') {
                currentElement.removeAttribute('hover');
            }
        }

        if (eventType !== 'up' || that._downTarget !== currentElement || that._reorderedIndex !== undefined || that._swiping) {
            return;
        }

        if (dropDown === that._openDropDown) {
            that._closeGroupDropDown();

            if (!currentElement.classList.contains('jqx-tab-group-selected')) {
                currentElement.setAttribute('hover', '');
            }
        }
        else {
            that._openGroupDropDown(currentElement);
        }
    }

    /**
     * Handles changes to the "tabPosition" property.
     */
    _handlePosition(newPosition, oldPosition) {
        const that = this;

        if ([undefined, 'top', 'left', 'hidden'].indexOf(oldPosition) !== -1 && (newPosition === 'bottom' || newPosition === 'right')) {
            that.$.container.insertBefore(that.$.tabContentSection, that.$.tabsHeaderSection);
        }
        else if ((oldPosition === 'bottom' || oldPosition === 'right') && ['top', 'left', 'hidden'].indexOf(newPosition) !== -1) {
            that.$.container.insertBefore(that.$.tabsHeaderSection, that.$.tabContentSection);
        }

        if (newPosition === 'hidden') {
            that._orientationSettings = { coordinate: 'pageY', dimension: 'height', edge: 'top', from: 'fromY', size: 'offsetHeight', to: 'toY', scrollDirection: 'scrollTop', scrollSize: 'scrollHeight', startCoordinate: 'startY', wheelOffset: 35 };
            that.removeAttribute('horizontal');
            that.removeAttribute('vertical');
            return;
        }

        if (newPosition === 'top' || newPosition === 'bottom') {
            that._orientationSettings = { coordinate: 'pageX', dimension: 'width', edge: 'left', from: 'fromX', size: 'offsetWidth', to: 'toX', scrollDirection: 'scrollLeft', scrollSize: 'scrollWidth', startCoordinate: 'startX', wheelOffset: 70 };
            that.removeAttribute('vertical');
            that.setAttribute('horizontal', '');

            that.$arrowNear.removeClass('jqx-arrow-up');
            that.$arrowNear.addClass('jqx-arrow-left');
            that.$arrowFar.removeClass('jqx-arrow-down');
            that.$arrowFar.addClass('jqx-arrow-right');
        }
        else {
            that._orientationSettings = { coordinate: 'pageY', dimension: 'height', edge: 'top', from: 'fromY', size: 'offsetHeight', to: 'toY', scrollDirection: 'scrollTop', scrollSize: 'scrollHeight', startCoordinate: 'startY', wheelOffset: 35 };
            that.removeAttribute('horizontal');
            that.setAttribute('vertical', '');

            that.$arrowNear.removeClass('jqx-arrow-left');
            that.$arrowNear.addClass('jqx-arrow-up');
            that.$arrowFar.removeClass('jqx-arrow-right');
            that.$arrowFar.addClass('jqx-arrow-down');
        }

        that.$.dropDownButtonArrow.innerHTML = that._arrowCodes[that.tabPosition];
    }

    /**
     * Handles changes to the "scrollButtonsPosition" property.
     */
    _handleScrollButtonsPosition(newScrollButtonsPosition, oldScrollButtonsPosition) {
        const that = this,
            tabsHeaderItems = that.$.tabsHeaderItems;

        if (newScrollButtonsPosition === oldScrollButtonsPosition) {
            return;
        }

        if (newScrollButtonsPosition === 'both') {
            if (oldScrollButtonsPosition === 'near') {
                tabsHeaderItems.insertBefore(that.$.scrollButtonFar, that.$.dropDownButton);
            }
            else {
                tabsHeaderItems.insertBefore(that.$.scrollButtonNear, that.$.tabStrip);
            }
        }
        else if (newScrollButtonsPosition === 'near') {
            if (oldScrollButtonsPosition === 'far') {
                tabsHeaderItems.insertBefore(that.$.scrollButtonNear, that.$.tabStrip);
            }

            tabsHeaderItems.insertBefore(that.$.scrollButtonFar, that.$.tabStrip);
        }
        else {
            if (oldScrollButtonsPosition === 'near') {
                tabsHeaderItems.insertBefore(that.$.scrollButtonFar, that.$.dropDownButton);
            }

            tabsHeaderItems.insertBefore(that.$.scrollButtonNear, that.$.scrollButtonFar);
        }
    }

    /**
     * Hides the close button of a tab.
     */
    _hideCloseButton(tabLabelContainer) {
        tabLabelContainer.firstElementChild.children[0].$.removeClass('jqx-close-button-enabled');
        tabLabelContainer.firstElementChild.children[1].$.addClass('jqx-hidden');
    }

    /**
     * jqx-tab-item indexChange event handler.
     */
    _indexChangeHandler(event) {
        const that = this,
            oldIndex = event.detail.oldIndex,
            validNewIndex = Math.max(0, Math.min(event.detail.newIndex, that._tabs.length - 1));

        if (oldIndex !== validNewIndex) {
            if (that._groups.length === 0) {
                that._reorderTabs(oldIndex, validNewIndex);
            }
            else {
                const tabItem = event.detail.tabItem;

                tabItem._setIndex(oldIndex);
                that.remove(oldIndex);
                that.insert(validNewIndex, { node: tabItem });

                if (that.selectedIndex === oldIndex) {
                    that._select(validNewIndex, false);
                }
            }

            that._reorderedIndex = undefined;
        }
    }

    /**
     * Inserts the "add new" tab.
     */
    _insertAddNewTab() {
        const that = this,
            tabLabelContainer = that._addTabLabelContainer(undefined, true).tabLabelContainer;

        tabLabelContainer.$.addClass('jqx-add-new-tab');

        that.$.tabStrip.appendChild(tabLabelContainer);

        that._addNewTab = tabLabelContainer;
    }

    /**
     * Inserts a tab into an existing group.
     */
    _insertIntoExistingGroup(details) {
        const that = this,
            jqxTabItemsGroup = details.jqxTabItemsGroup,
            tab = details.tab,
            tabLabelContainer = details.tabLabelContainer,
            group = details.group,
            groupLabel = that._groupLabels[that._groups.indexOf(group)],
            groupDropDown = groupLabel.dropDown;
        let index = details.index;

        index = Math.max(0, Math.min(index, jqxTabItemsGroup.childElementCount));

        groupDropDown.insertBefore(tabLabelContainer, groupDropDown.children[index]);

        const sibling = jqxTabItemsGroup.children[index];
        let overallIndex;

        if (sibling) {
            overallIndex = sibling.index;
        }
        else {
            overallIndex = jqxTabItemsGroup.children[index - 1].index + 1;
        }

        jqxTabItemsGroup.insertBefore(tab, sibling);

        that._tabLabelContainers.splice(overallIndex, 0, tabLabelContainer);
        that.$.dropDownButtonDropDown.insertBefore(details.dropDownLabelContainer, that.$.dropDownButtonDropDown.children[overallIndex] || null);
        that._tabs.splice(overallIndex, 0, tab);

        index = overallIndex;

        tab.group = group;

        that._updateIndexes(index);
    }

    /**
     * Inserts a tab into a new group.
     */
    _insertIntoNewGroup(details) {
        const that = this,
            tab = details.tab,
            tabLabelContainer = details.tabLabelContainer,
            group = details.group,
            groupContainers = that._addGroupContainer(group),
            groupLabel = groupContainers.label,
            groupDropDown = groupContainers.dropDown;

        groupDropDown.appendChild(tabLabelContainer);

        that._groups.push(group);

        let index = Math.max(0, Math.min(details.index, that.$.tabStrip.childElementCount)),
            tabStripIndex = index;

        if (that._addNewTab && tabStripIndex === that.$.tabStrip.childElementCount) {
            tabStripIndex--;
        }

        that.$.tabStrip.insertBefore(groupLabel, that.$.tabStrip.children[tabStripIndex] || null);

        that._groupLabels.push(groupLabel);

        const newJqxTabItemsGroup = document.createElement('jqx-tab-items-group');

        newJqxTabItemsGroup.appendChild(tab);
        that.$.tabContentSection.insertBefore(newJqxTabItemsGroup, that.$.tabContentSection.children[index]);
        newJqxTabItemsGroup.label = group;

        const previousSibling = newJqxTabItemsGroup.previousElementSibling;
        let overallIndex = 0;

        if (previousSibling) {
            if (previousSibling instanceof JQX.TabItem) {
                overallIndex = previousSibling.index + 1;
            }
            else if (previousSibling) {
                overallIndex = previousSibling.lastElementChild.index + 1;
            }
        }

        that._tabLabelContainers.splice(overallIndex, 0, tabLabelContainer);
        that.$.dropDownButtonDropDown.insertBefore(details.dropDownLabelContainer, that.$.dropDownButtonDropDown.children[overallIndex] || null);
        that._tabs.splice(overallIndex, 0, tab);

        index = overallIndex;

        tab.group = group;

        that._updateIndexes(index);
    }

    /**
     * Inserts a stand-alone tab when there are groups.
     */
    _insertNearAGroup(details) {
        const that = this,
            tab = details.tab,
            tabLabelContainer = details.tabLabelContainer;
        let index = details.index;

        index = Math.max(0, Math.min(index, that._tabs.length));

        const previous = that._tabs[index - 1],
            next = that._tabs[index],
            groupOfNext = next ? next.group : undefined;

        if (previous && previous.group !== null && next && groupOfNext !== null) {
            // insert into group
            next.tabLabelContainer.parentElement.insertBefore(tabLabelContainer, next.tabLabelContainer);
            next.parentElement.insertBefore(tab, next);

            tab.group = groupOfNext;
        }
        else {
            if (next) {
                if (groupOfNext !== null) {
                    that.$.tabStrip.insertBefore(tabLabelContainer, that._groupLabels[that._groups.indexOf(groupOfNext)]);
                    that.$.tabContentSection.insertBefore(tab, that.$.tabContentSection.querySelector('jqx-tab-items-group[label="' + groupOfNext + '"]'));
                }
                else {
                    that.$.tabStrip.insertBefore(tabLabelContainer, next.tabLabelContainer);
                    that.$.tabContentSection.insertBefore(tab, next);
                }
            }
            else {
                that.$.tabStrip.insertBefore(tabLabelContainer, that._addNewTab || null);
                that.$.tabContentSection.appendChild(tab);
            }
        }

        that._tabLabelContainers.splice(index, 0, tabLabelContainer);
        that.$.dropDownButtonDropDown.insertBefore(details.dropDownLabelContainer, that.$.dropDownButtonDropDown.children[index] || null);
        that._tabs.splice(index, 0, tab);

        that._updateIndexes(index);
    }

    /**
     * Inserts a tab when there are no groups.
     */
    _insertNoGrouping(tabDetails) {
        const that = this,
            index = Math.max(0, Math.min(tabDetails.index, that._tabs.length)),
            tab = tabDetails.tab,
            tabLabelContainer = tabDetails.tabLabelContainer;

        that.$.tabStrip.insertBefore(tabLabelContainer, that._tabLabelContainers[index] || that._addNewTab || null);
        that.$.tabContentSection.insertBefore(tab, that._tabs[index] || null);
        that._tabLabelContainers.splice(index, 0, tabLabelContainer);
        that.$.dropDownButtonDropDown.insertBefore(tabDetails.dropDownLabelContainer, that.$.dropDownButtonDropDown.children[index] || null);
        that._tabs.splice(index, 0, tab);

        that._updateIndexes(index);
    }

    /**
     * keydown event handler.
     */
    _keydownHandler(event) {
        const that = this,
            key = event.key;

        if (document.activeElement !== that || ['ArrowLeft', 'ArrowDown', 'ArrowRight', 'ArrowUp', 'End', 'Home', 'Enter', ' ', 'Escape'].indexOf(key) === -1 ||
            that.disabled || that.readonly || that.selectionMode === 'none' || (!that.allowToggle && that.selectedIndex === null) || that._reordering || that._swiping) {
            return;
        }

        event.preventDefault();

        const lastTabIndex = that._tabs.length - 1;
        let indexToSelect, noSelect, step = 0;

        switch (key) {
            case 'ArrowLeft':
            case 'ArrowUp':
                if (that.collapsible && event.ctrlKey) {
                    if (key === 'ArrowLeft') {
                        if (that.tabPosition === 'right') {
                            that.expand();
                        }
                        else if (that.tabPosition === 'left') {
                            that.collapse();
                        }
                    }
                    else if (key === 'ArrowUp') {
                        if (that.tabPosition === 'bottom') {
                            that.expand();
                        }
                        else if (that.tabPosition === 'top') {
                            that.collapse();
                        }
                    }

                    return;
                }

                step = -1;
                // selects previous tab
                if (that.selectedIndex === 0) {
                    noSelect = true;
                    break;
                }

                indexToSelect = that.selectedIndex + step;
                break;
            case 'ArrowRight':
            case 'ArrowDown':
                if (that.collapsible && event.ctrlKey) {
                    if (key === 'ArrowRight') {
                        if (that.tabPosition === 'right') {
                            that.collapse();
                        }
                        else if (that.tabPosition === 'left') {
                            that.expand();
                        }
                    }
                    else if (key === 'ArrowDown') {
                        if (that.tabPosition === 'bottom') {
                            that.collapse();
                        }
                        else if (that.tabPosition === 'top') {
                            that.expand();
                        }
                    }

                    return;
                }

                step = 1;
                // selects next tab
                if (that.selectedIndex === lastTabIndex) {
                    noSelect = true;
                    break;
                }

                indexToSelect = that.selectedIndex + step;
                break;
            case 'End':
                if (that.selectedIndex === lastTabIndex) {
                    noSelect = true;
                    break;
                }

                indexToSelect = lastTabIndex;
                break;
            case 'Home':
                if (that.selectedIndex === 0) {
                    noSelect = true;
                    break;
                }

                indexToSelect = 0;
                break;
            case 'Enter':
            case ' ':
                if (!that.allowToggle) {
                    return;
                }

                if (that._focusedItem) {
                    that.select(that._focusedItem.index);

                    const closestGroupContainer = that._focusedItem.tabLabelContainer.closest('.jqx-tab-group-drop-down');

                    if (closestGroupContainer) {
                        that._openGroupDropDown(closestGroupContainer.groupContainer);
                    }
                }

                return;
            case 'Escape':
                if (that._openDropDown) {
                    that._closeGroupDropDown();
                }

                return;
        }

        if (that.allowToggle && that._tabs.length > 0) {
            if (that._focusedItem) {
                that._focusedItem.tabLabelContainer.removeAttribute('focus');
            }
            else {
                that._focusedItem = that._focusedItem || that._tabs[that.selectedIndex] || that._tabs[0];
            }

            that._focusedItem = that._tabs[Math.min(Math.max(0, that._focusedItem.index + step), lastTabIndex)];
            that._focusedItem.tabLabelContainer.setAttribute('focus', '');
            that.ensureVisible(that._focusedItem.index);

            const closestGroupContainer = that._focusedItem.tabLabelContainer.closest('.jqx-tab-group-drop-down');

            if (closestGroupContainer && closestGroupContainer.groupContainer) {
                if (that._openDropDown && that._openDropDown !== closestGroupContainer.dropDown) {
                    that._closeGroupDropDown();
                }

                that._openGroupDropDown(closestGroupContainer.groupContainer);
            }
            else if (that._openDropDown) {
                that._closeGroupDropDown();
            }

            return;
        }

        if (!noSelect) {
            that.select(indexToSelect);
        }
    }

    /**
     * Tab label container/label text container event handler.
     */
    _labelContainerHandler(currentElement, event, eventType) {
        const that = this,
            click = eventType === 'up' && that._downTarget === currentElement;

        if (eventType === 'down') {
            that._downTarget = currentElement;

            if (that.selectionMode === 'click' && currentElement !== that._addNewTab) {
                if (JQX.Utilities.Core.isMobile && currentElement.tab.group === null) {
                    const scrollDirection = that.$.tabStrip[that._orientationSettings.scrollDirection];

                    setTimeout(function () {
                        if (scrollDirection === that.$.tabStrip[that._orientationSettings.scrollDirection]) {
                            const rippleInProgress = that._ripple(event, currentElement);

                            if (rippleInProgress && that._openDropDown && that._openDropDown.contains(currentElement)) {
                                that._openDropDown.rippleInProgress = true;
                            }
                        }
                    }, 100);
                }
                else {
                    const rippleInProgress = that._ripple(event, currentElement);

                    if (rippleInProgress && that._openDropDown && that._openDropDown.contains(currentElement)) {
                        that._openDropDown.rippleInProgress = true;
                    }
                }
            }
        }

        if (currentElement === that._addNewTab) {
            that._addNewTabHandler(currentElement, eventType, click);
            return;
        }

        const index = currentElement.tab.index,
            currentElementStatic = !(that._reordering && that._reorderedIndex !== undefined);

        if (click && index === that.selectedIndex) {
            that._closeGroupDropDown();

            if (currentElementStatic && currentElement.tab.group === null) {
                that._toggleCollapsedState();
            }
        }

        if (!that._swiping && (currentElementStatic && that.selectionMode === 'click' && click ||
            !that._reordering && (that.selectionMode === eventType || that.selectionMode === 'mouseenter' && eventType === 'mouseover'))) {
            that._select(index, true);
        }

        if (!that._reordering && !that._swiping && (that.selectionMode === 'click' || that.selectionMode === 'dblclick')) {
            if (eventType === 'mouseover' && !currentElement.hasAttribute('selected')) {
                currentElement.setAttribute('hover', '');
            }
            else if (eventType === 'mouseout') {
                currentElement.removeAttribute('hover');
            }
        }

        if (that.reorder && eventType === 'down' && currentElement.tab.group === null && that._reorderItems.length > 1) {
            that._getTabCoordinates();
            that._reordering = true;
            that.setAttribute('dragged', '');

            if (currentElement.hasAttribute('hover')) {
                that._draggedHoveredTab = currentElement;
            }

            if (that._groups.length === 0) {
                that._draggedIndex = currentElement.tab.index;
            }
            else {
                that._draggedIndex = Array.from(that.$.tabStrip.children).indexOf(currentElement);
            }
        }
    }

    /**
     * jqx-tab-item labelSizeChange event handler.
     */
    _labelSizeChangeHandler(event) {
        const that = this,
            newSize = event.detail.size;
        let correspondingLabelContainer;

        if (that.tabLayout === 'shrink') {
            return;
        }

        if (event.target instanceof JQX.TabItem) {
            correspondingLabelContainer = event.target.tabLabelContainer;
        }
        else {
            correspondingLabelContainer = that._groupLabels[that._groups.indexOf(event.target.label)];
        }

        if (newSize !== null) {
            correspondingLabelContainer.style[that._orientationSettings.dimension] = parseInt(newSize, 10) + 'px';
        }
        else {
            correspondingLabelContainer.style.removeProperty(that._orientationSettings.dimension);
        }

        that._applyTabOverflow();
    }

    /**
    * Opens the open group dropdown.
    */
    _openGroupDropDown(currentElement) {
        const that = this;

        if (!currentElement) {
            return;
        }

        if (that._openDropDown) {
            that._openDropDown.$.addClass('jqx-hidden');
        }

        currentElement.dropDown.$.removeClass('jqx-hidden');
        that._positionGroupDropDown(currentElement);
        that._openDropDown = currentElement.dropDown;

        currentElement.removeAttribute('hover');
    }

    /**
     * Orders tabs initially.
     */
    _orderTabs() {
        const that = this,
            groups = that.getElementsByTagName('jqx-tab-items-group'),
            indexes = [], list = [];
        let unset = true,
            ambiguous = false;

        if (groups.length === 0) {
            for (let i = 0; i < that._tabs.length; i++) {
                const tab = that._tabs[i],
                    index = tab.index;

                if (unset && index !== null) {
                    unset = false;
                }

                if (indexes.indexOf(index || 0) !== -1) {
                    ambiguous = true;

                    if (index !== null) {
                        break;
                    }
                }

                indexes.push(index || 0);
                list.push({ tab: tab, index: index });
            }
        }

        if (!ambiguous) {
            const sortedIndexes = indexes.slice(0).sort(function (a, b) {
                return a - b;
            });

            if (JSON.stringify(indexes) === JSON.stringify(sortedIndexes)) {
                unset = true;
            }
        }

        if (!unset && !ambiguous) {
            list.sort(function (a, b) {
                return a.index - b.index;
            });

            for (let i = 0; i < list.length; i++) {
                const tab = list[i].tab;

                tab._setIndex(i);
                that.$.tabContentSection.removeChild(tab);
            }

            for (let i = 0; i < list.length; i++) {
                const tab = list[i].tab;

                that.$.tabContentSection.appendChild(tab);
                that._tabs[i] = tab;
            }
        }
        else {
            if (!unset) {
                that.warn(that.localize('ambiguousIndexes'));
            }

            for (let i = 0; i < that._tabs.length; i++) {
                that._tabs[i]._setIndex(i);
            }
        }
    }

    /**
     * Populates the tab strip.
     */
    _populateTabStrip() {
        const that = this,
            documentFragment = document.createDocumentFragment(),
            tabLabelContainers = [],
            groups = [],
            groupLabels = [];

        let selectedTabLabelContainer = null;

        for (let i = 0; i < that._tabs.length; i++) {
            const tab = that._tabs[i],
                tabParentElement = tab.parentElement,
                group = tabParentElement instanceof JQX.TabItemsGroup ? tabParentElement.label : null;

            tab.group = group;

            const labelContainers = that._addTabLabelContainer(tab),
                tabLabelContainer = labelContainers.tabLabelContainer,
                dropDownLabelContainer = labelContainers.dropDownLabelContainer;

            if (that.selectedIndex === i) {
                tabLabelContainer.$.addClass('jqx-tab-selected');
                tabLabelContainer.setAttribute('selected', '');
                selectedTabLabelContainer = tabLabelContainer;
            }

            tab.tabLabelContainer = tabLabelContainer;
            tabLabelContainer.tab = tab;

            tabLabelContainers.push(tabLabelContainer);

            if (group === null) {
                documentFragment.appendChild(tabLabelContainer);
            }
            else {
                that._addGroupElements({ documentFragment: documentFragment, groups: groups, groupLabels: groupLabels, i: i, group: group, tabLabelContainer: tabLabelContainer, jqxTabItemsGroup: tabParentElement });
            }

            that.$.dropDownButtonDropDown.appendChild(dropDownLabelContainer);
        }

        that.$.tabStrip.appendChild(documentFragment);

        that._tabLabelContainers = tabLabelContainers;
        that._groups = groups;
        that._groupLabels = groupLabels;

        that._positionTabSelectionBar(selectedTabLabelContainer, true);
    }

    _positionTabSelectionBar(selectedTabLabelContainer, noAnimation) {
        const that = this;

        if (!selectedTabLabelContainer) {
            return;
        }

        const tabPosition = that.tabPosition;
        let left, top, width, height;

        if (noAnimation) {
            that.$.tabSelectionBar.style.transition = 'none';
        }

        if (selectedTabLabelContainer.tab.group) {
            selectedTabLabelContainer = that._groupLabels[that._groups.indexOf(selectedTabLabelContainer.tab.group)];
        }

        if (tabPosition === 'top' || tabPosition === 'bottom') {
            if (that.tabLayout === 'wrap') {
                top = selectedTabLabelContainer.offsetTop;

                if (tabPosition === 'top') {
                    top += selectedTabLabelContainer.offsetHeight - that.$.tabSelectionBar.offsetHeight;
                }

                top += 'px';
            }
            else {
                top = null;
            }

            height = null;
            left = -that.$.tabStrip.scrollLeft + selectedTabLabelContainer.offsetLeft + 'px';
            width = selectedTabLabelContainer.offsetWidth + 'px';
        }
        else if (tabPosition === 'left' || tabPosition === 'right') {
            if (that.tabLayout === 'wrap') {
                left = selectedTabLabelContainer.offsetLeft;

                if (tabPosition === 'left') {
                    left += selectedTabLabelContainer.offsetWidth - that.$.tabSelectionBar.offsetWidth;
                }

                left += 'px';
            }
            else {
                left = null;
            }

            width = null;
            top = -that.$.tabStrip.scrollTop + selectedTabLabelContainer.offsetTop + 'px';
            height = selectedTabLabelContainer.offsetHeight + 'px';
        }

        function updateStyle() {
            that.$.tabSelectionBar.style.top = top;
            that.$.tabSelectionBar.style.height = height;
            that.$.tabSelectionBar.style.left = left;
            that.$.tabSelectionBar.style.width = width;
        }

        if (JQX.Utilities.Core.isMobile && that.hasAnimation && !noAnimation) {
            requestAnimationFrame(function () {
                requestAnimationFrame(updateStyle);
            });
        }
        else {
            updateStyle();
        }

        if (noAnimation && !that._tabPositionChanging) {
            requestAnimationFrame(() => that.$.tabSelectionBar.style.transition = null);
        }
    }

    /**
     * Positions a group dropdown.
     */
    _positionGroupDropDown(groupLabel) {
        const that = this,
            position = that.tabPosition,
            dropDown = groupLabel.dropDown,
            headerSectionStyle = window.getComputedStyle(that.$.tabsHeaderSection),
            headerSectionPaddingLeft = parseFloat(headerSectionStyle.paddingLeft),
            headerSectionPaddingTop = parseFloat(headerSectionStyle.paddingTop);

        if (position === 'top' || position === 'bottom') {
            const material = false; //that.hasAnimation;

            dropDown.style.left = groupLabel.offsetLeft - that.$.tabStrip.scrollLeft + headerSectionPaddingLeft + 'px';

            if (position === 'top') {
                if (!material) {
                    dropDown.style.top = groupLabel.offsetTop + groupLabel.offsetHeight + headerSectionPaddingTop + 'px';
                }
            }
            else {
                let top = groupLabel.getBoundingClientRect().top - that.$.container.getBoundingClientRect().top + headerSectionPaddingTop;

                if (material) {
                    top += that.$.tabStrip.offsetHeight;
                }

                dropDown.style.top = top + 'px';
            }
        }
        else {
            dropDown.style.top = groupLabel.offsetTop - that.$.tabStrip.scrollTop + headerSectionPaddingTop + 'px';

            if (position === 'left') {
                dropDown.style.left = groupLabel.offsetLeft + groupLabel.offsetWidth + headerSectionPaddingLeft + 'px';
            }
            else {
                dropDown.style.left = (groupLabel.getBoundingClientRect().left - that.$.container.getBoundingClientRect().left + headerSectionPaddingLeft) + 'px';
            }
        }
    }

    /**
     * Processes "dataSource" object.
     */
    _processDataSource() {
        const that = this,
            dataSource = that.dataSource;

        function processItem(item, parent) {
            let element;

            if (Array.isArray(item.items) && item.items.length > 0) {
                element = document.createElement('jqx-tab-items-group');

                for (let i = 0; i < item.items.length; i++) {
                    if (item.items[i].items) {
                        continue;
                    }

                    processItem(item.items[i], element);
                }
            }
            else {
                element = document.createElement('jqx-tab-item');

                if (item.closeButtonHidden === true) {
                    element.closeButtonHidden = true;
                }

                if (item.content !== undefined) {
                    element.innerHTML = item.content;
                }

                if (item.index !== undefined) {
                    element.index = item.index;
                }

                if (item.selected === true) {
                    element.selected = item.selected;
                }
            }

            if (item.label !== undefined) {
                element.label = item.label;
            }

            if (item.labelSize !== undefined) {
                element.labelSize = item.labelSize;
            }

            parent.appendChild(element);
        }

        that.$.tabContentSection.innerHTML = '';

        if (dataSource === null) {
            return;
        }

        for (let i = 0; i < dataSource.length; i++) {
            const currentItem = dataSource[i];

            processItem(currentItem, that.$.tabContentSection);
        }
    }

    /**
     * Processes HTML structure.
     */
    _processHTML() {
        const that = this;

        that._getTabs();
        that._orderTabs();

        that._validateInitialSelection();
        that._populateTabStrip();

        if (that.addNewTab) {
            that._insertAddNewTab();
        }

        that._getReorderItems();

        that._applyTabOverflow();

        that.ensureVisible(that.selectedIndex);
    }

    /**
     * Removes set inline style.
     */
    _removeInlineStyle() {
        const that = this,
            tabStrip = that.$.tabStrip;

        if (that._inlineStyleTabStripChildren) {
            const tabStripChildren = tabStrip.children;

            for (let i = 0; i < tabStripChildren.length; i++) {
                tabStripChildren[i].removeAttribute('style');
                tabStripChildren[i].firstElementChild.firstElementChild.classList.remove('jqx-tab-label-text-container-full-height');
            }

            delete that._inlineStyleTabStripChildren;
        }

        if (that._inlineStyleTabStrip) {
            tabStrip.removeAttribute('style');
            delete that._inlineStyleTabStrip;
        }

        tabStrip.$.removeClass('shrink-tabs');
        tabStrip.$.removeClass('shrink-tabs-vertical');
    }

    /**
     * Positions a tab before or after another tab.
     */
    _reorderTabs(firstTabIndex, secondTabIndex) {
        function reorderList(list, x, y) {
            const temp = list[x];

            list.splice(x, 1);
            list.splice(y, 0, temp);
        }

        const that = this;

        if (that._groups.length === 0) {
            const tabs = that._tabs,
                tabLabelContainers = that._tabLabelContainers,
                referenceNodeIndex = firstTabIndex > secondTabIndex ? secondTabIndex : secondTabIndex + 1;

            if (that.selectedIndex === firstTabIndex) {
                that.selectedIndex = secondTabIndex;
            }
            else if (that.selectedIndex <= secondTabIndex && that.selectedIndex > firstTabIndex) {
                that.selectedIndex--;
            }
            else if (that.selectedIndex >= secondTabIndex && that.selectedIndex < firstTabIndex) {
                that.selectedIndex++;
            }

            let tabStripInsertBefore;

            if (tabLabelContainers[referenceNodeIndex]) {
                tabStripInsertBefore = tabLabelContainers[referenceNodeIndex];
            }
            else if (that.addNewTab) {
                tabStripInsertBefore = that._addNewTab;
            }
            else {
                tabStripInsertBefore = null;
            }

            that.$.tabStrip.insertBefore(tabLabelContainers[firstTabIndex], tabStripInsertBefore);
            that.$.dropDownButtonDropDown.insertBefore(that.$.dropDownButtonDropDown.children[firstTabIndex], that.$.dropDownButtonDropDown.children[referenceNodeIndex] || null);
            that.$.tabContentSection.insertBefore(tabs[firstTabIndex], tabs[referenceNodeIndex] || null);

            reorderList(tabs, firstTabIndex, secondTabIndex);
            reorderList(tabLabelContainers, firstTabIndex, secondTabIndex);

            that._updateTabIndexes();
        }
        else {
            that._reorderTabsGrouping(firstTabIndex, secondTabIndex);
        }

        that.$.fireEvent('reorder', { 'newIndex': secondTabIndex, 'originalIndex': firstTabIndex });

        that._reorderedIndex = secondTabIndex;

        that._positionTabSelectionBar(that._tabLabelContainers[that.selectedIndex], true);
    }

    /**
     * Positions a tab before or after another tab when there are groups.
     */
    _reorderTabsGrouping(firstTabIndex, secondTabIndex) {
        const that = this,
            tabStripChildren = that.$.tabStrip.children,
            tabContentSectionChildren = that.$.tabContentSection.children,
            referenceNodeIndex = firstTabIndex > secondTabIndex ? secondTabIndex : secondTabIndex + 1,
            selectedTab = that._tabs[that.selectedIndex];

        that.$.tabStrip.insertBefore(tabStripChildren[firstTabIndex], tabStripChildren[referenceNodeIndex] || null);
        that.$.tabContentSection.insertBefore(tabContentSectionChildren[firstTabIndex], tabContentSectionChildren[referenceNodeIndex] || null);

        that._groupLabels = Array.from(that.$.tabStrip.getElementsByClassName('jqx-tab-group-container'));
        that._groups = [];

        for (let i = 0; i < that._groupLabels.length; i++) {
            that._groups.push(that._groupLabels[i].group);
        }

        that._tabs = Array.from(that.$.tabContentSection.getElementsByTagName('jqx-tab-item'));

        const dropDownContentFragment = document.createDocumentFragment();
        let tabLabelContainers = [];

        for (let i = 0; i < that._tabs.length; i++) {
            dropDownContentFragment.appendChild(that.$.dropDownButtonDropDown.children[that._tabs[i].index].cloneNode(true));
        }

        that.$.dropDownButtonDropDown.innerHTML = '';
        that.$.dropDownButtonDropDown.appendChild(dropDownContentFragment);

        for (let i = 0; i < that.$.tabStrip.childElementCount; i++) {
            const currentChild = that.$.tabStrip.children[i];

            if (currentChild.$.hasClass('jqx-tab-label-container') && currentChild !== that._addNewTab) {
                tabLabelContainers.push(currentChild);
            }
            else if (currentChild.$.hasClass('jqx-tab-group-container')) {
                tabLabelContainers = tabLabelContainers.concat(Array.from(currentChild.dropDown.children));
            }
        }

        that._tabLabelContainers = tabLabelContainers;

        that._updateTabIndexes();

        if (selectedTab) {
            that.selectedIndex = selectedTab.index;
        }
    }

    /**
     * Resizes a tab strip element.
     */
    _resize(event) {
        const that = this;

        if (!that._resizing) {
            return;
        }

        const orientationSettings = that._orientationSettings,
            sizeChange = event[orientationSettings.coordinate] - that._resizeFrom,
            customElement = that._getCorrespondingCustomElement(that._tabToResize);
        let oldSize;

        if (customElement.labelSize === null) {
            oldSize = that._tabToResize[orientationSettings.size];
        }
        else {
            oldSize = customElement.labelSize;
        }

        const newSize = Math.max(10, oldSize + sizeChange);

        if (newSize !== oldSize) {
            customElement._preventPropertyChangedHandler = true;
            customElement.labelSize = newSize;
            that._tabToResize.style[orientationSettings.dimension] = parseInt(newSize, 10) + 'px';
        }

        that.$resizeToken.addClass('jqx-hidden');
        that._applyTabOverflow();
        that._resizing = false;
        that.removeAttribute('resizing');
    }

    /**
     * Triggers ripple effect.
     */
    _ripple(event, target) {
        const that = this;

        if (that.hasRippleAnimation) {
            const rippleAgent = document.createElement('div');

            rippleAgent.className = 'ripple-agent';
            target.firstElementChild.appendChild(rippleAgent);

            setTimeout(function () {
                target.firstElementChild.removeChild(rippleAgent);
            }, 1000);

            JQX.Utilities.Animation.Ripple.animate(rippleAgent, event.pageX, event.pageY);

            return true;
        }
    }

    /**
     * Scroll button click handler.
     */
    _scrollButtonClickHandler(event) {
        const that = this,
            tabStrip = that.$.tabStrip;
        let modifier = event.target.closest('jqx-repeat-button') === that.$.scrollButtonNear ? -1 : 1;

        if (that.scrollMode === 'paging') {
            const orientationSettings = that._orientationSettings,
                swipeInfo = {};

            that._dragStartDetails = { startX: 0, startY: 0, pageX: 0, pageY: 0, startTime: Date.now(), target: event.target };
            that._wheelInProgress = true;
            swipeInfo[orientationSettings.coordinate] = -modifier * (tabStrip[orientationSettings.size] / 1.1428571428571428);
            that._endSwiping(swipeInfo, that._dragStartDetails.startTime + 175);
            return;
        }

        if (that.hasAttribute('horizontal')) {
            tabStrip.scrollLeft += 10 * modifier;
        }
        else {
            tabStrip.scrollTop += 10 * modifier;
        }

        that._updateScrollButtonVisibility(true);
    }

    /**
     * Selects a tab.
     */
    _select(index, fireEvent, oldIndex) {
        const that = this,
            hasAnimation = that.hasAnimation;

        if (oldIndex === undefined) {
            oldIndex = that.selectedIndex;
        }

        if (index === oldIndex && ((!that.allowToggle) || (that.allowToggle && that.selectionMode === 'mouseenter'))) {
            return;
        }

        const tab = that._tabs[index];

        if (that._focusedItem) {
            that._focusedItem.tabLabelContainer.removeAttribute('focus');
        }

        if (oldIndex !== null) {
            const oldTab = that._tabs[oldIndex];

            if (hasAnimation) {
                that._animateSelection(tab, oldTab, index > oldIndex);
            }
            else {
                oldTab.$.addClass('jqx-visibility-hidden');
            }

            oldTab.selected = false;
            that._tabLabelContainers[oldIndex].$.removeClass('jqx-tab-selected');
            that._tabLabelContainers[oldIndex].removeAttribute('selected');

            if (that.closeButtons && that.closeButtonMode === 'selected') {
                that._disableCloseButton(oldIndex);
            }
        }

        if (!that.allowToggle || (index !== null && (arguments[2] !== undefined ? oldIndex : that.selectedIndex) !== index)) {
            tab.selected = true;
            that.$.tabContentSection.removeAttribute('show-placeholder');

            if (oldIndex === null || !hasAnimation) {
                tab.$.removeClass('jqx-visibility-hidden');
            }

            that.selectedIndex = index;
            that._focusedItem = that._tabs[index];
            that._focusedItem.tabLabelContainer.$.addClass('jqx-tab-selected');
            that._focusedItem.tabLabelContainer.setAttribute('selected', '');

            that._positionTabSelectionBar(that._focusedItem.tabLabelContainer, oldIndex === null);
        }
        else {
            that.selectedIndex = null;
            that.$.tabContentSection.setAttribute('show-placeholder', '');

            if (that.allowToggle) {
                that._focusedItem = that._tabs[index === null ? oldIndex : index];

                if (that._focusedItem) {
                    that._focusedItem.tabLabelContainer.setAttribute('focus', '');
                }
            }
        }

        if (index !== null) {
            that._tabLabelContainers[index].removeAttribute('hover');

            if (that.closeButtons && that.closeButtonMode === 'selected') {
                that._enableCloseButton(index);
            }

        }

        if (fireEvent) {

            //Upate hidden input
            that.$.hiddenInput.value = that.selectedIndex;

            that.$.fireEvent('change', { 'index': that.selectedIndex, 'oldIndex': oldIndex });
        }

        that._closeGroupDropDown();

        if (tab && tab.group !== null) {
            if (that._selectedGroup) {
                that._selectedGroup.$.removeClass('jqx-tab-group-selected');
            }

            if (that.selectedIndex !== null) {
                that._selectedGroup = that._groupLabels[that._groups.indexOf(tab.group)];
                that._selectedGroup.$.addClass('jqx-tab-group-selected');
            }
        }
        else if (that._selectedGroup) {
            that._selectedGroup.$.removeClass('jqx-tab-group-selected');
            delete that._selectedGroup;
        }
    }

    /**
     * Document select start handler.
     */
    _selectStartHandler(event) {
        const that = this;

        if (that._reordering || that._resizing) {
            event.preventDefault();
        }
    }

    /**
     * Sets the label of a tab.
     */
    _setLabel(label, labelTextContainer, dropDownLabelContainer) {
        const potentialHTMLTemplate = label ? document.getElementById(label) : null;

        if (potentialHTMLTemplate !== null && potentialHTMLTemplate.tagName.toLowerCase() === 'template') {
            // label is the id of an HTML template
            const templateContent = document.importNode(potentialHTMLTemplate.content, true);

            labelTextContainer.appendChild(templateContent);

            if (dropDownLabelContainer) {
                const templateContent = document.importNode(potentialHTMLTemplate.content, true);

                dropDownLabelContainer.appendChild(templateContent);
            }
        }
        else {
            // label is string
            if (label === '') {
                label = '&nbsp;';
            }

            labelTextContainer.innerHTML = label;

            if (dropDownLabelContainer) {
                dropDownLabelContainer.innerHTML = label;
            }
        }
    }

    /**
     * Shows the close button of a tab.
     */
    _showCloseButton(tabLabelContainer) {
        if (tabLabelContainer.closeButtonEnabled) {
            tabLabelContainer.firstElementChild.children[0].$.addClass('jqx-close-button-enabled');
            tabLabelContainer.firstElementChild.children[1].$.removeClass('jqx-hidden');
        }
    }

    /**
     * tabContentSection transitionend handler.
     */
    _tabContentSectionTransitionendHandler(event) {
        const that = this,
            target = event.target;

        if (!(target instanceof JQX.TabItem)) {
            return;
        }

        if (target === that._animatedOldTab) {
            target.$.addClass('jqx-hidden');
            target.$.removeClass('animate');
            target.$.removeClass(that._animatedOldTab.classToRemove);
            target.$.removeClass('jqx-hidden');
            delete that._animatedOldTab;
        }
        else if (target === that._animatedTab) {
            target.$.removeClass('animate');
            delete that._animatedTab;
        }

        target.classList.remove('left');
        target.classList.remove('right');
        target.classList.remove('top');
        target.classList.remove('bottom');
    }

    /**
     * tabsHeaderItems wheel handler.
     */
    _tabsHeaderItemsWheelHandler(event) {
        const that = this,
            orientationSettings = that._orientationSettings;

        if (!that.enableMouseWheelAction || that._wheelInProgress || that.disabled ||
            that.$.tabStrip[orientationSettings.size] === that.$.tabStrip[orientationSettings.scrollSize]) {
            return;
        }

        event.preventDefault();

        that._dragStartDetails = { startX: event.pageX, startY: event.pageY, pageX: event.pageX, pageY: event.pageY, startTime: Date.now(), target: event.target };
        that._wheelInProgress = true;

        const swipeInfo = {};

        swipeInfo[orientationSettings.coordinate] = event[orientationSettings.coordinate] + (event.deltaY > 0 ? -1 : 1) * orientationSettings.wheelOffset;
        that._endSwiping(swipeInfo, that._dragStartDetails.startTime + 100);
    }

    /**
     * Tab strip event handler.
     */
    _tabStripHandler(target, event) {
        const that = this,
            eventType = event.type;

        if (eventType === 'down' && that._tabToResize !== undefined) {
            that._resizing = true;
            that._tabsHeaderSectionCoordinate = that.$.tabsHeaderSection.getBoundingClientRect()[that._orientationSettings.edge];
            return;
        }

        if (eventType === 'down' && JQX.Utilities.Core.isMobile) {
            that._dragStartDetails = {
                startX: event.pageX,
                startY: event.pageY,
                pageX: event.pageX,
                pageY: event.pageY,
                startTime: Date.now(),
                originalTime: Date.now(),
                target: event.originalEvent.target
            };
        }

        const scrollButton = target.closest('jqx-repeat-button');

        if (eventType === 'up' && scrollButton) {
            that.focus();

            if (that.resize) {
                that._getTabCoordinates();
            }
            return;
        }

        if (target.classList.contains('jqx-tab-close-button')) {
            // close button
            if (eventType === 'up') {
                if (target === that._downTarget) {
                    const indexToClose = target.parentElement.parentElement.tab.index,
                        closingEvent = that.$.fireEvent('closing', { 'index': indexToClose });

                    if (!closingEvent.defaultPrevented) {
                        that.remove(indexToClose);

                        that.$.fireEvent('close', { 'index': indexToClose });
                    }
                    return;
                }
            }
            else if (eventType === 'down') {
                that._downTarget = target;
                return;
            }
            else if (!that._reordering && !that._swiping) {
                if (eventType === 'mouseover') {
                    target.setAttribute('hover', '');
                }
                else if (eventType === 'mouseout') {
                    target.removeAttribute('hover');
                }
            }
        }

        const closestLabelContainer = target.closest('.jqx-tab-label-container');

        if (closestLabelContainer !== null) {
            that._labelContainerHandler(closestLabelContainer, event, eventType);
            return;
        }

        const closestGroupContainer = target.closest('.jqx-tab-group-container');

        if (closestGroupContainer !== null) {
            that._groupContainerHandler(closestGroupContainer, eventType);
        }
    }

    /**
     * Tab strip mouseleave handler.
     */
    _tabStripMouseleaveHandler() {
        const that = this;

        if (that.resize && !that._resizing && that.hasAttribute('resizing')) {
            that.removeAttribute('resizing');
        }
    }

    /**
     * Tab strip (mouse)move handler.
     */
    _tabStripMoveHandler(event) {
        const that = this;

        if (that._dragStartDetails && !that._dragStartDetails.checked) {
            if (Date.now() - that._dragStartDetails.originalTime < 500) {
                that._endReordering(undefined, undefined);
                that._dragStartDetails.checked = true;
            }
            else {
                delete that._dragStartDetails;
            }
        }

        if (that._dragStartDetails &&
            (Math.abs(that._dragStartDetails.pageX - event.pageX) >= 5 ||
                Math.abs(that._dragStartDetails.pageY - event.pageY) >= 5)) {
            const orientationSettings = that._orientationSettings,
                difference = that._dragStartDetails[orientationSettings.coordinate] - event[orientationSettings.coordinate],
                oldScrollDirection = that.$.tabStrip[orientationSettings.scrollDirection];

            that.$.tabStrip[orientationSettings.scrollDirection] += difference;

            if (oldScrollDirection !== that.$.tabStrip[orientationSettings.scrollDirection]) {
                that._updateScrollButtonVisibility();
            }

            that._dragStartDetails = {
                startX: that._dragStartDetails.startX,
                startY: that._dragStartDetails.startY,
                pageX: event.pageX,
                pageY: event.pageY,
                startTime: that._dragStartDetails.startTime,
                originalTime: that._dragStartDetails.originalTime,
                target: event.originalEvent.target,
                checked: that._dragStartDetails.checked
            };
            that._swiping = true;

            return;
        }

        if (!that.resize || that._resizing || that._reordering || that.tabLayout === 'shrink') {
            return;
        }

        const orientationSettings = that._orientationSettings,
            currentCoordinate = event[orientationSettings.coordinate],
            tabCoordinates = that._tabCoordinates;
        let tabToResize;

        for (let i = 0; i < tabCoordinates.length; i++) {
            const currentTabCoordinate = tabCoordinates[i][orientationSettings.to];

            if (currentCoordinate >= currentTabCoordinate - 4 && currentCoordinate <= currentTabCoordinate + 4) {
                tabToResize = that._reorderItems[i];
                that._resizeFrom = currentCoordinate;
                break;
            }
        }

        if (tabToResize !== undefined) {
            that._tabToResize = tabToResize;
            that.setAttribute('resizing', '');
        }
        else {
            that._tabToResize = undefined;
            that.removeAttribute('resizing');
        }
    }

    /**
     * Toggles the collapsed state on click.
     */
    _toggleCollapsedState() {
        const that = this;

        if (!that.collapsible) {
            return;
        }

        if (!that.collapsed) {
            that.collapse();
        }
        else {
            that.expand();
        }
    }

    /**
     * Toggles the visibility of navigation elements.
     */
    _toggleNavigationElementsVisibility() {
        const that = this,
            numberOfTabs = that._tabs.length;
        let action;

        if (numberOfTabs === 0) {
            action = 'addClass';
        }
        else if (numberOfTabs === 1) {
            action = 'removeClass';
        }
        else {
            return;
        }

        if (that.tabLayout === 'scroll' && that.overflow === 'scroll') {
            that.$scrollButtonNear[action]('jqx-hidden');
            that.$scrollButtonFar[action]('jqx-hidden');
        }
        else if (that.tabLayout === 'dropDown') {
            that.$dropDownButton[action]('jqx-hidden');
        }
    }

    /**
     * Updates the selected index and the index of each tab.
     */
    _updateIndexes(index) {
        const that = this;

        if (that.selectedIndex !== null && index <= that.selectedIndex) {
            that.selectedIndex++;
        }

        that._updateTabIndexes();
    }

    /**
     * Updates scroll button visibility.
     */
    _updateScrollButtonVisibility(noTabSelectionBarAnimation) {
        const that = this;

        if (that.tabLayout !== 'scroll' || that.overflow === 'hidden') {
            that._positionTabSelectionBar(that._tabLabelContainers[that.selectedIndex], noTabSelectionBarAnimation);
            return;
        }

        const tabsHeaderSection = that.$tabsHeaderSection,
            tabStrip = that.$.tabStrip,
            orientationSettings = that._orientationSettings;
        let showNear = true,
            showFar = true;

        if (Math.round(tabStrip[orientationSettings.scrollDirection]) === 0) {
            showNear = false;
        }

        if (Math.round(tabStrip[orientationSettings.size] + tabStrip[orientationSettings.scrollDirection]) >= Math.round(tabStrip[orientationSettings.scrollSize]) - 1) {
            showFar = false;
        }

        if (that.overflow === 'auto') {
            if (showNear && showFar) {
                that.$scrollButtonNear.removeClass('jqx-hidden');
                that.$scrollButtonFar.removeClass('jqx-hidden');
                tabsHeaderSection.removeClass('one-button-shown');
                if (that._tabLabelContainers[that.selectedIndex]) {
                    that._positionTabSelectionBar(that._tabLabelContainers[that.selectedIndex], noTabSelectionBarAnimation);
                }
                return;
            }

            if (showNear) {
                that.$scrollButtonNear.removeClass('jqx-hidden');
            }
            else {
                that.$scrollButtonNear.addClass('jqx-hidden');
            }

            if (showFar) {
                that.$scrollButtonFar.removeClass('jqx-hidden');
            }
            else {
                that.$scrollButtonFar.addClass('jqx-hidden');
            }

            tabsHeaderSection.addClass('one-button-shown');
            that._getTabCoordinates();
        }
        else if (that.overflow === 'scroll' && !that.disabled) {
            that.$.scrollButtonNear.disabled = !showNear;
            that.$.scrollButtonFar.disabled = !showFar;
        }

        if (that._tabLabelContainers[that.selectedIndex]) {
            that._positionTabSelectionBar(that._tabLabelContainers[that.selectedIndex], noTabSelectionBarAnimation);
        }
    }

    /**
     * Updates the indexes of all tabs.
     */
    _updateTabIndexes() {
        const that = this;

        if (that._tabs.length > 0) {
            for (let i = 0; i < that._tabs.length; i++) {
                that._tabs[i]._setIndex(i);
            }
        }
        else {
            that.selectedIndex = null;
        }
    }

    /**
     * Validates the index passed to the methods "ensureVisible", "getOffsetFromEdgeOfElement", "insert", "remove", "select" and "update".
     */
    _validateIndex(index, method) {
        if (isNaN(parseInt(index, 10)) || typeof index === 'object') {
            const that = this;

            that.error(that.localize('invalidIndex', { method: method }));
        }
    }

    /**
     * Validates the initial selection.
     */
    _validateInitialSelection() {
        const that = this;
        let selectedIndex = that.selectedIndex;

        for (let i = 0; i < that._tabs.length; i++) {
            const currentTab = that._tabs[i];

            if (selectedIndex === i) {
                currentTab.selected = true;
                currentTab.$.removeClass('jqx-visibility-hidden');
            }
            else if (currentTab.selected) {
                if (selectedIndex === null) {
                    selectedIndex = i;
                    currentTab.$.removeClass('jqx-visibility-hidden');
                }
                else {
                    currentTab.selected = false;
                    currentTab.$.addClass('jqx-visibility-hidden');
                }
            }
            else {
                currentTab.$.addClass('jqx-visibility-hidden');
            }
        }

        if (that._tabs.length > 0 && selectedIndex === null && !that.allowToggle) {
            selectedIndex = 0;

            that._tabs[0].selected = true;
            that._tabs[0].$.removeClass('jqx-visibility-hidden');
        }

        that.selectedIndex = selectedIndex;

        if (that.selectedIndex !== null) {
            that._focusedItem = that._tabs[that.selectedIndex];
        }
    }
});

/**
 * TimePicker custom element.
 */
JQX('jqx-time-picker', class TimePicker extends JQX.BaseElement {
    /**
     * TimePicker's properties.
     */
    static get properties() {
        return {
            'autoSwitchToMinutes': {
                value: false,
                type: 'boolean'
            },
            'footer': {
                value: false,
                type: 'boolean'
            },
            'footerTemplate': {
                value: null,
                type: 'any?'
            },
            'format': {
                value: '12-hour',
                allowedValues: ['12-hour', '24-hour'],
                type: 'string'
            },
            'minuteInterval': {
                value: 1,
                type: 'number'
            },
            'name': {
                value: '',
                type: 'string'
            },
            'selection': {
                value: 'hour',
                allowedValues: ['hour', 'minute'],
                type: 'string'
            },
            'value': {
                value: new Date(),
                type: 'any',
                reflectToAttribute: false
            },
            'view': {
                value: 'portrait',
                allowedValues: ['landscape', 'portrait'],
                type: 'string'
            }
        };
    }

    /**
     * TimePicker's event listeners.
     */
    static get listeners() {
        return {
            'keydown': '_keydownHandler',
            'resize': '_resizeHandler',
            'header.click': '_headerClickHandler',
            'picker.down': '_pickerDownHandler',
            'picker.move': '_pickerMoveHandler',
            'document.move': '_documentMoveHandler',
            'document.up': '_documentUpHandler'
        };
    }

    /**
     * TimePicker's required files.
     */
    static get requires() {
        return {
            'JQX.Utilities.NumericProcessor': 'jqxnumeric.js',
            'JQX.Utilities.BigNumber': 'jqxmath.js',
            'JQX.Utilities.Draw': 'jqxdraw.js'
        }
    }

    /**
     * CSS files needed for the element (ShadowDOM)
     */
    static get styleUrls() {
        return [
            'jqx.timepicker.css'
        ]
    }

    /**
     * TimePicker's HTML template.
     */
    template() {
        const template =
            `<div id="container">
                <div id="header" class="jqx-header jqx-unselectable">
                    <div id="hourMinuteContainer" class="jqx-hour-minute-container">
                        <div id="hourContainer" class ="jqx-hour-container"></div>
                        <div>:</div>
                        <div id="minuteContainer" class="jqx-minute-container"></div>
                    </div>
                    <div id="ampmContainer" class="jqx-am-pm-container">
                        <div id="amContainer" class="jqx-am-container">AM</div>
                        <div id="pmContainer" class="jqx-pm-container">PM</div>
                    </div>
                </div>
                <div id="main" class="jqx-main-container">
                    <div id="svgContainer" class="jqx-svg-container">
                        <div id="picker" class="jqx-svg-picker"></div>
                    </div>
                    <div id="footer" class="jqx-footer"></div>
                </div>
                <input id="hiddenInput" type="hidden" name="[[name]]">
            </div>`;

        return template;
    }

    /**
     * Called when the element is ready. Used for one-time configuration of the TimePicker.
     */
    ready() {
        super.ready();
        this._createElement();
    }

    /**
     * Sets the hours.
     *
     * @param {Number} hours The hours to set.
     */
    setHours(hours) {
        const that = this;

        if (hours === 24) {
            hours = 0;
        }
        else {
            hours = Math.max(0, Math.min(hours, 23));
        }

        if (hours < 12) {
            that._selectAmPm('am');
        }
        else {
            that._selectAmPm('pm');
        }

        if (that.format === '12-hour') {
            if (hours === 0) {
                hours = 12
            }
            else if (hours > 12) {
                hours -= 12;
            }
        }

        that._updateHours(hours, arguments[1]);

        if (that.selection === 'hour') {
            that._inInnerCircle = that.format === '24-hour' && (hours === 0 || hours > 12);

            that._drawArrow(true, hours, arguments[2]);

            if (!that.hasAnimation) {
                that._inInnerCircle = false;
            }
        }
    }

    /**
     * Sets the minutes.
     *
     * @param {Number} minutes The minutes to set.
     */
    setMinutes(minutes) {
        const that = this;

        if (minutes === 60) {
            minutes = 0;
        }
        else {
            minutes = Math.max(0, Math.min(minutes, 59));
        }

        that._updateMinutes(minutes);

        if (that.selection === 'minute') {
            that._drawArrow(true, minutes, arguments[1]);
        }
    }

    /**
     * Invoked when the value of a public property has been changed by the user.
     */
    propertyChangedHandler(key, oldValue, value) {
        super.propertyChangedHandler(key, oldValue, value);

        const that = this;

        switch (key) {
            case 'disabled':
            case 'unfocusable':
                that._setFocusable();
                break;
            case 'footer':
            case 'view':
                that._resizeHandler();
                break;
            case 'footerTemplate':
                that._validateFooterTemplate();
                break;
            case 'format': {
                let hours = that.value.getHours();

                if (value === '12-hour') {
                    that.$ampmContainer.removeClass('jqx-hidden');

                    if (that.value.getHours() < 12) {
                        that._selectAmPm('am');
                    }
                    else {
                        that._selectAmPm('pm');
                    }

                    if (hours === 0) {
                        hours = 12;
                    }
                    else if (hours > 12) {
                        hours -= 12;
                    }
                }
                else {
                    that.$ampmContainer.addClass('jqx-hidden');
                }

                that.$.hourContainer.innerHTML = hours;

                if (that.selection === 'hour') {
                    that._draw.clear();
                    that._renderSVG();
                }

                break;
            }
            case 'minuteInterval': {
                const validValue = Math.max(1, Math.min(value, 60));

                if (validValue !== value) {
                    that.minuteInterval = validValue;
                }

                if (that.selection === 'minute') {
                    that.interval = validValue;
                }

                break;
            }
            case 'selection':
                if (value === 'hour') {
                    that._changeToHourSelection();
                }
                else {
                    that._changeToMinuteSelection();
                }

                break;
            case 'value': {
                that._oldValue = oldValue;
                that._validateValue();

                const equalHours = that.value.getHours() === oldValue.getHours(),
                    equalMinutes = that.value.getMinutes() === oldValue.getMinutes();

                if (!(equalHours && equalMinutes)) {
                    if (equalMinutes) {
                        that.setHours(that.value.getHours());
                    }
                    else {
                        if (!equalHours) {
                            that.setHours(that.value.getHours(), true);
                        }

                        that.setMinutes(that.value.getMinutes());
                    }
                }

                delete that._oldValue;
                break;
            }
        }
    }

    /**
     * Applies initial settings to the TimePicker element.
     */
    _applyInitialSettings() {
        const that = this,
            value = that.value;
        let hours, minutes;

        hours = value.getHours();
        minutes = value.getMinutes();

        if (that.format === '12-hour') {
            if (hours < 12) {
                that._ampm = 'am';
                that.$amContainer.addClass('jqx-selected');

                if (hours === 0) {
                    hours = 12;
                }
            }
            else {
                that._ampm = 'pm';
                that.$pmContainer.addClass('jqx-selected');

                if (hours > 12) {
                    hours -= 12;
                }
            }
        }
        else {
            that.$ampmContainer.addClass('jqx-hidden');
        }

        minutes = minutes.toString();

        if (minutes.length === 1) {
            minutes = '0' + minutes;
        }

        that.$.hourContainer.innerHTML = hours;
        that.$.minuteContainer.innerHTML = minutes;

        if (that.selection === 'hour') {
            that.$hourContainer.addClass('jqx-selected');
        }
        else {
            that.$minuteContainer.addClass('jqx-selected');
        }
    }

    /**
     * Changes the TimePicker selection when the user interacts with it.
     */
    _changeSelection(event, noAnimation) {
        const that = this,
            x = event.pageX,
            y = event.pageY,
            center = that._getCenterCoordinates(),
            distanceFromCenter = Math.sqrt(Math.pow(center.x - x, 2) + Math.pow(center.y - y, 2));

        that._measurements.center = center;

        if (event.type === 'down') {
            if (distanceFromCenter > that._measurements.radius) {
                event.stopPropagation();
                return;
            }
            else {
                that._dragging = true;
            }
        }

        if (that.format === '24-hour' && that.selection === 'hour' && distanceFromCenter < that._measurements.radius - 50) {
            that._inInnerCircle = true;
        }
        else {
            that._inInnerCircle = false;
        }

        const angleRadians = Math.atan2(y - center.y, x - center.x);
        let angleDeg = -1 * angleRadians * 180 / Math.PI;

        if (angleDeg < 0) {
            angleDeg += 360;
        }

        that._angle = angleDeg;

        let newValue = that._numericProcessor.getValueByAngle(that._angle);

        if (that.selection === 'hour') {
            if (that.format === '24-hour') {
                if (that._inInnerCircle) {
                    if (newValue !== 0 && newValue !== 12) {
                        newValue += 12;
                    }
                    else {
                        newValue = 0;
                    }
                }
                else if (newValue === 0) {
                    newValue = 12;
                }
            }
            else {
                if (newValue === 0) {
                    newValue = 12;
                }
            }

            that._updateHours(newValue);
        }
        else {
            if (newValue === 60) {
                newValue = 0;
            }

            that._updateMinutes(newValue);
        }

        if (that._oldTimePart === undefined) {
            return;
        }

        cancelAnimationFrame(that._animationFrameId);
        that._drawArrow(true, newValue, noAnimation);
    }

    /**
     * Changes to hour selection.
     */
    _changeToHourSelection() {
        const that = this,
            svgCanvas = that._centralCircle.parentElement || that._centralCircle.parentNode;

        cancelAnimationFrame(that._animationFrameId);
        that.interval = 1;

        that.$hourContainer.addClass('jqx-selected');
        that.$minuteContainer.removeClass('jqx-selected');

        svgCanvas.removeChild(that._centralCircle);
        svgCanvas.removeChild(that._arrow);
        svgCanvas.removeChild(that._head);

        that._getMeasurements();
        that._numericProcessor.getAngleRangeCoefficient();
        that._draw.clear();

        svgCanvas.appendChild(that._centralCircle);
        svgCanvas.appendChild(that._arrow);
        svgCanvas.appendChild(that._head);

        that._renderHours();

        if (that.format === '24-hour' && (that.value.getHours() === 0 || that.value.getHours() > 12)) {
            that._inInnerCircle = true;
        }

        that._drawArrow(true, undefined, true);
        that._inInnerCircle = false;
    }

    /**
     * Changes to minute selection.
     */
    _changeToMinuteSelection() {
        const that = this,
            svgCanvas = that._centralCircle.parentElement || that._centralCircle.parentNode;

        that._inInnerCircle = false;

        cancelAnimationFrame(that._animationFrameId);
        that.interval = that.minuteInterval;

        that.$hourContainer.removeClass('jqx-selected');
        that.$minuteContainer.addClass('jqx-selected');

        svgCanvas.removeChild(that._centralCircle);
        svgCanvas.removeChild(that._arrow);
        svgCanvas.removeChild(that._head);

        that._getMeasurements();
        that._numericProcessor.getAngleRangeCoefficient();
        that._draw.clear();

        svgCanvas.appendChild(that._centralCircle);
        svgCanvas.appendChild(that._arrow);
        svgCanvas.appendChild(that._head);

        that._renderMinutes();

        that._drawArrow(true, undefined, true);
    }

    /**
     * Computes arrow body points.
     */
    _computeArrowBodyPoints(radius, angle, width, length) {
        const that = this,
            sin = Math.sin(angle),
            cos = Math.cos(angle),
            endX1 = radius - width * cos + length * sin,
            endY1 = radius + width * sin + length * cos,
            endX2 = radius + width * cos + length * sin,
            endY2 = radius - width * sin + length * cos,
            startX1 = radius + width * cos,
            startY1 = radius - width * sin,
            startX2 = radius - width * cos,
            startY2 = radius + width * sin,

            points = 'M ' + startX1 + ',' + startY1 + ' L ' + startX2 + ',' + startY2 + ' L ' + endX1 + ',' + endY1 + ' ' + endX2 + ',' + endY2;

        that._headCenter = { x: (endX1 + endX2) / 2, y: (endY1 + endY2) / 2 };

        return points;
    }

    /**
     * Applies initial settings to the TimePicker element.
     */
    _createElement() {
        const that = this;

        that.coerce = true;
        that.min = 0;
        that._drawMin = '0';
        that.startAngle = -270;
        that.endAngle = 90;
        that._angleDifference = that.endAngle - that.startAngle;
        that.ticksVisibility = 'none';
        that._tickIntervalHandler = {};
        that._tickIntervalHandler.labelsSize = {};
        that._distance = { majorTickDistance: 0, minorTickDistance: 0, labelDistance: 10 };
        that._measurements = {};

        that._validateInitialPropertyValues();
        that._applyInitialSettings();

        that._numericProcessor = new JQX.Utilities.DecimalNumericProcessor(that);
        that._draw = new JQX.Utilities.Draw(that.$.picker);


        if (!that._isVisible()) {
            that._renderingSuspended = true;
            return;
        }

        that._setPickerSize();
        that._getMeasurements();
        that._numericProcessor.getAngleRangeCoefficient();
        that._renderSVG();

        that._setFocusable();
    }

    /**
     * Document move handler.
     */
    _documentMoveHandler(event) {
        const that = this;

        if (that._dragging) {
            that._changeSelection(event, true);
        }
    }

    /**
     * Document up handler.
     */
    _documentUpHandler() {
        const that = this;

        if (that._dragging) {
            that._inInnerCircle = false;
            that._dragging = false;

            if (that.autoSwitchToMinutes && that.selection === 'hour') {
                if (that.hasAnimation) {
                    that.$picker.addClass('animate');

                    setTimeout(function () {
                        that.selection = 'minute';
                        that._changeToMinuteSelection();
                    }, 250);

                    setTimeout(function () {
                        that.$picker.removeClass('animate');
                    }, 550);
                }
                else {
                    that.selection = 'minute';
                    that._changeToMinuteSelection();
                }
            }
        }
    }

    /**
     * Draws/updates the arrow.
     */
    _drawArrow(update, value, noAnimation) {
        const that = this,
            hourSelection = that.selection === 'hour',
            twelveHourFormat = that.format === '12-hour';
        let current = that._oldTimePart;

        delete that._oldTimePart;

        if (value === undefined) {
            if (hourSelection) {
                value = that.value.getHours();

                if (twelveHourFormat && value > 12) {
                    value -= 12;
                }
            }
            else {
                value = that.value.getMinutes();
            }
        }

        if (current === undefined || noAnimation || !that.hasAnimation) {
            that._drawArrowSVG(update, value);
            return;
        }

        if (hourSelection && !twelveHourFormat) {
            that._animate24HourView(current, value);
            return;
        }

        let step, max;

        if (hourSelection) {
            step = 0.2;
            max = 12;
            value = value % max;
            current = current % max;
        }
        else {
            step = 1;
            max = 60;
        }

        let distanceCW = value - current,
            distanceCCW = current - value;

        if (distanceCW < 0) {
            distanceCW += max;
        }

        if (distanceCCW < 0) {
            distanceCCW += max;
        }

        if (distanceCCW < distanceCW) {
            step *= -1;
        }

        function animate() {
            current += step;
            current = parseFloat((current % max).toFixed(1));

            if (current < 0) {
                current += max;
            }

            that._drawArrowSVG(update, current);

            if (current !== value % max) {
                that._animationFrameId = requestAnimationFrame(animate);
            }
        }

        that._animationFrameId = requestAnimationFrame(animate);
    }

    /**
     * Animates selection in 24-hour view.
     */
    _animate24HourView(current, value) {
        const that = this;
        let step = 0.2;

        that._inInnerCircle = false;

        const currentInnerCircle = current === 0 || current > 12,
            valueInnerCircle = value === 0 || value > 12;

        if (currentInnerCircle !== valueInnerCircle) {
            if (currentInnerCircle) {
                current = Math.abs(current - 12);
            }
            else {
                current = (current + 12) % 24;
            }

            that._inInnerCircle = valueInnerCircle;
            that._drawArrowSVG(true, current);

            if (current === value) {
                return;
            }
        }
        else {
            that._inInnerCircle = valueInnerCircle;
        }

        let start = current,
            end = value;

        if (that._inInnerCircle) {
            if (end === 0 && start < 18) {
                end = 12;
            }
            else if (start === 0 && end < 18) {
                start = 12;
            }
        }

        let distanceCW = end - start,
            distanceCCW = start - end;

        if (distanceCW < 0) {
            distanceCW += 12;
        }

        if (distanceCCW < 0) {
            distanceCCW += 12;
        }

        if (distanceCCW < distanceCW) {
            step *= -1;
        }

        function animate(inInnerCircle) {
            that._inInnerCircle = inInnerCircle;

            if (inInnerCircle) {
                current = parseFloat((current + step).toFixed(1));

                if (current < 0) {
                    current += 24;
                }
                else if (current < 1) {
                    current = current + 12;
                }

                if (current === 12 || current === 24) {
                    current = 0;
                }
            }
            else {
                current += step;

                if (current !== 12) {
                    current = parseFloat((current % 12).toFixed(1));
                }

                if (current <= 0) {
                    current += 12;
                }
            }

            that._drawArrowSVG(true, current);

            if (current !== value) {
                that._animationFrameId = requestAnimationFrame(function () {
                    animate(inInnerCircle);
                });
            }
            else {
                that._inInnerCircle = false;
            }
        }

        that._animationFrameId = requestAnimationFrame(function () {
            animate(that._inInnerCircle);
        });
    }

    /**
     * Draws/updates the arrow.
     */
    _drawArrowSVG(update, value) {
        const that = this,
            measurements = that._measurements,
            angle = that._numericProcessor.getAngleByValue(value);
        let arrowBodyPoints;

        if (!that._inInnerCircle) {
            arrowBodyPoints = that._computeArrowBodyPoints(measurements.radius, angle, 1, measurements.innerRadius - that._largestLabelSize / 2);
        }
        else {
            arrowBodyPoints = that._computeArrowBodyPoints(measurements.radius, angle, 1, measurements.innerRadius - that._largestLabelSize / 2 - 45);
        }

        if (update) {
            that._arrow.setAttribute('d', arrowBodyPoints);

            that._head.setAttribute('cx', that._headCenter.x);
            that._head.setAttribute('cy', that._headCenter.y);
            that._head.setAttribute('r', that._largestLabelSize);
            that._headRect = that._head.getBoundingClientRect();

            if (value % 1 === 0) {
                that._highlightLabel(value);
            }
        }
        else {
            that._arrow = that._draw.path(arrowBodyPoints, { 'class': 'jqx-needle' });
            that._head = that._draw.circle(that._headCenter.x, that._headCenter.y, that._largestLabelSize, { 'class': 'jqx-needle-central-circle' });
            that._headRect = that._head.getBoundingClientRect();
        }
    }

    /**
     * Draws a label.
     */
    _drawLabel(angle, value, distance) {
        const that = this,
            measurements = that._measurements,
            r = measurements.radius,
            stylingObj = {
                'class': 'jqx-label jqx-unselectable',
                'font-size': measurements.fontSize,
                'font-family': measurements.fontFamily,
                'font-weight': measurements.fontWeight,
                'font-style': measurements.fontStyle
            };

        if (that.selection === 'hour') {
            if (that._plotInnerCircle) {
                if (value > 0) {
                    value += 12;
                }
                else {
                    value = '00';
                }
            }
            else {
                if (value === 0) {
                    value = 12;
                }
            }
        }
        else {
            if (value.toString().length === 1) {
                value = '0' + value;
            }
        }

        const textSize = that._draw.measureText(value, 0, stylingObj),
            w = r - distance - that._largestLabelSize / 2,
            x = r + w * Math.sin(angle),
            y = r + w * Math.cos(angle),
            label = that._draw.text(value, Math.round(x) - textSize.width / 2, Math.round(y) - textSize.height / 2, textSize.width, textSize.height, 0, stylingObj);

        label.setAttribute('value', parseFloat(value));
    }

    /**
     * Gets the center coordinates.
     */
    _getCenterCoordinates() {
        const that = this,
            offset = that.$.picker.getBoundingClientRect(),
            radius = that._measurements.radius,
            scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft,
            scrollTop = document.body.scrollTop || document.documentElement.scrollTop;

        return { x: offset.left + scrollLeft + radius, y: offset.top + scrollTop + radius };
    }

    /**
     * Measures some elements of the TimePicker and stores the results.
     */
    _getMeasurements() {
        const that = this,
            measurements = that._measurements,
            measureLabel = document.createElement('div');
        let minLabel, maxLabel, minLabelWidth, maxLabelWidth, minLabelHeight, maxLabelHeight;

        measureLabel.className = 'jqx-label';
        measureLabel.style.position = 'absolute';
        measureLabel.style.visibility = 'hidden';
        that.$.svgContainer.appendChild(measureLabel);

        if (that.selection === 'hour') {
            minLabel = '1';
            maxLabel = '23';

            that.max = 12;
            that._drawMax = '12';
            that._range = 12;
        }
        else {
            minLabel = '00';
            maxLabel = '55';

            that.max = 60;
            that._drawMax = '60';
            that._range = 60;
        }

        measureLabel.innerHTML = minLabel;
        minLabelWidth = measureLabel.offsetWidth;
        minLabelHeight = measureLabel.offsetHeight;
        measureLabel.innerHTML = maxLabel;
        maxLabelWidth = measureLabel.offsetWidth;
        maxLabelHeight = measureLabel.offsetHeight;

        that._largestLabelSize = Math.max(minLabelWidth, minLabelHeight, maxLabelWidth, maxLabelHeight);
        that._tickIntervalHandler.labelsSize.minLabelSize = minLabelHeight;
        that._tickIntervalHandler.labelsSize.maxLabelSize = maxLabelHeight;

        const measureElementStyle = window.getComputedStyle(measureLabel);

        measurements.fontSize = measureElementStyle.fontSize;
        measurements.fontFamily = measureElementStyle.fontFamily;
        measurements.fontWeight = measureElementStyle.fontWeight;
        measurements.fontStyle = measureElementStyle.fontStyle;
        that.$.svgContainer.removeChild(measureLabel);
    }

    /**
     * Header click handler.
     */
    _headerClickHandler(event) {
        const that = this;

        if (that.disabled || that.readonly) {
            return;
        }

        switch (event.target) {
            case that.$.hourContainer:
                if (that.selection !== 'hour') {
                    that.selection = 'hour';
                    that._changeToHourSelection();
                }

                break;
            case that.$.minuteContainer:
                if (that.selection !== 'minute') {
                    that.selection = 'minute';
                    that._changeToMinuteSelection();
                }

                break;
            case that.$.amContainer:
                if (!that.$amContainer.hasClass('jqx-selected')) {
                    that._selectAmPm('am');

                    const oldValue = new Date(that.value.getTime());

                    that.value.setHours(that.value.getHours() - 12);

                    // Update the hidden input 
                    that.$.hiddenInput.value = that.value;

                    that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValue });
                }

                break;
            case that.$.pmContainer:
                if (!that.$pmContainer.hasClass('jqx-selected')) {
                    that._selectAmPm('pm');

                    const oldValue = new Date(that.value.getTime());

                    that.value.setHours(that.value.getHours() + 12);

                    // Update the hidden input 
                    that.$.hiddenInput.value = that.value;

                    that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValue });
                }

                break;
        }
    }

    /**
     * Highlights a label.
     */
    _highlightLabel(value) {
        const that = this;

        if (that._highlightedLabel) {
            if (parseFloat(that._highlightedLabel.getAttribute('value')) === value) {
                return;
            }

            that._highlightedLabel.classList.remove('jqx-selected');
            that._highlightedLabel = undefined;
        }

        let roundedValue;

        if (that.selection === 'hour') {
            if (value === undefined) {
                value = that.value.getHours();
            }

            if (that.format === '12-hour') {
                if (value === 0) {
                    value = 12;
                }
                else if (value > 12) {
                    value -= 12;
                }
            }

            roundedValue = value;
        }
        else {
            if (value === undefined) {
                value = that.value.getMinutes();
            }

            roundedValue = Math.round(value / 5) * 5;

            if (roundedValue === 60) {
                roundedValue = 0;
            }
        }

        const labelAtValue = that.$.picker.querySelector('.jqx-label[value="' + roundedValue + '"]');

        if (labelAtValue && (roundedValue === value || that._overlapsLabel(labelAtValue))) {
            that._highlightedLabel = labelAtValue;
            labelAtValue.classList.add('jqx-selected');
        }
    }

    /**
     * Checks if the element is visible.
     */
    _isVisible() {
        const that = this;

        return !!(that.offsetWidth || that.offsetHeight || that.getClientRects().length);
    }

    /**
     * keydown handler.
     */
    _keydownHandler(event) {
        const that = this;

        if (that._dragging) {
            return;
        }

        const activeElement = that.enableShadowDOM ? (that.shadowRoot.activeElement || document.activeElement) : document.activeElement,
            key = event.key;

        if (that.$.header.contains(activeElement) && (key === 'Enter' || key === ' ')) {
            event.preventDefault();
            that._headerClickHandler({ target: activeElement });
        }
        else if (activeElement === that.$.picker && !event.altKey) {
            let coefficient;

            if (key === 'ArrowRight' || key === 'ArrowUp') {
                coefficient = 1;
            }
            else if (key === 'ArrowLeft' || key === 'ArrowDown') {
                coefficient = -1;
            }

            if (coefficient) {
                event.preventDefault();

                if (that.selection === 'hour') {
                    let hours = that.value.getHours();

                    if (hours === 0 && coefficient === -1) {
                        hours = 23;
                    }
                    else if (hours === 23 && coefficient === 1) {
                        hours = 0;
                    }
                    else {
                        hours += coefficient;
                    }

                    if (that.format === '12-hour') {
                        if (hours >= 12 && that.$amContainer.hasClass('jqx-selected')) {
                            hours -= 12;
                        }
                        else if (hours < 12 && that.$pmContainer.hasClass('jqx-selected')) {
                            hours += 12;
                        }
                    }

                    that.setHours(hours, undefined, true);
                }
                else {
                    let minutes = that.value.getMinutes();

                    coefficient *= that.minuteInterval;

                    if (minutes + coefficient >= 60) {
                        minutes = 0;
                    }
                    else if (minutes < coefficient * -1) {
                        if (60 % coefficient === 0) {
                            minutes = 60 + coefficient;
                        }
                        else {
                            minutes = 60 - (60 % coefficient);
                        }
                    }
                    else {
                        minutes += coefficient;
                    }

                    that.setMinutes(minutes, true);
                }
            }
        }
    }

    /**
     * Returns if the arrow head overlaps a label.
     */
    _overlapsLabel(label) {
        const that = this,
            labelRect = label.getBoundingClientRect();
        let headRect = that._headRect;

        if (headRect.height === 0) {
            headRect = that._headRect = that._head.getBoundingClientRect();
        }

        return !(labelRect.right - 10 < headRect.left ||
            labelRect.left + 10 > headRect.right ||
            labelRect.bottom - 10 < headRect.top ||
            labelRect.top + 10 > headRect.bottom);
    }

    /**
     * Parses a date string.
     */
    _parseDateString(value, referenceValue) {
        const indexOfDate = value.indexOf('Date('),
            indexOfBracket = value.indexOf(')');
        let validValue = value;

        if (indexOfDate !== -1 && indexOfBracket !== -1) {
            validValue = value.slice(indexOfDate + 5, indexOfBracket);
            validValue = validValue.replace(/'/g, '').replace(/"/g, '').replace(/^\s+|\s+$|\s+(?=\s)/g, '');

            if (validValue.trim() === '') {
                return new Date();
            }

            if (new RegExp(/(^(\d+)(\s*,\s*\d+)+$)/g).test(validValue)) {
                validValue = validValue.replace(/\s/g, '');
                validValue = validValue.split(',');

                validValue.map(function (argument, index) {
                    validValue[index] = parseInt(argument);
                });

                validValue.unshift(null);
                validValue = new (Function.prototype.bind.apply(Date, validValue));

                return validValue;
            }
        }

        if (validValue.trim() === '') {
            return referenceValue;
        }

        if (!isNaN(validValue)) {
            return new Date(parseInt(validValue, 10));
        }

        try {
            validValue = new Date(validValue);
        }
        catch (error) {
            validValue = referenceValue;
        }

        if (isNaN(validValue.getTime())) {
            return referenceValue;
        }

        return validValue;
    }

    /**
     * SVG picker (mouse)down event handler.
     */
    _pickerDownHandler(event) {
        const that = this;

        if (that.disabled || that.readonly || !JQX.Utilities.Core.isMobile && event.which !== 1) {
            return;
        }

        that._changeSelection(event);
    }

    /**
     * SVG picker move event handler.
     */
    _pickerMoveHandler(event) {
        if (event.originalEvent.type === 'touchmove') {
            event.originalEvent.preventDefault();
        }
    }

    /**
     * Renders hours view.
     */
    _renderHours() {
        const that = this;

        that._highlightedLabel = undefined;

        that._majorTicksInterval = 1;

        that._numericProcessor.addGaugeTicksAndLabels();

        if (that.format === '24-hour') {
            that._plotInnerCircle = true;
            that._distance.labelDistance = 55;
            that._numericProcessor.addGaugeTicksAndLabels();
            that._plotInnerCircle = false;
            that._distance.labelDistance = 10;
        }
    }

    /**
     * Renders minutes view.
     */
    _renderMinutes() {
        const that = this;

        that._highlightedLabel = undefined;

        that._majorTicksInterval = 5;

        that._numericProcessor.addGaugeTicksAndLabels();
    }

    /**
     * Renders all SVG elements.
     */
    _renderSVG() {
        const that = this;

        if (!that._isVisible() || that._renderingSuspended) {
            that._renderingSuspended = true;
            return;
        }

        that._centralCircle = that._draw.circle(that._measurements.radius, that._measurements.radius, 4, { 'class': 'jqx-needle-central-circle' });

        if (that.selection === 'hour' && that.format === '24-hour' && (that.value.getHours() === 0 || that.value.getHours() > 12)) {
            that._inInnerCircle = true;
        }

        that._drawArrow(false);
        that._inInnerCircle = false;

        if (that.selection === 'hour') {
            that.interval = 1;
            that._renderHours();

            let hours = that.value.getHours();

            if (that.format === '12-hour' && hours > 12) {
                hours -= 12;
            }

            that._highlightLabel(hours);
        }
        else {
            that.interval = that.minuteInterval;
            that._renderMinutes();
            that._highlightLabel(that.value.getMinutes());
        }
    }

    /**
     * Gauge resize handler.
     */
    _resizeHandler() {
        const that = this;
        let shown = false;

        if (!that._isVisible()) {
            that._renderingSuspended = true;
            return;
        }
        else {
            that._renderingSuspended = false;
            shown = true;

            that._getMeasurements();
            that._numericProcessor.getAngleRangeCoefficient();
        }

        that._setPickerSize();

        if (that._sizeChanged || shown) {
            that._draw.clear();
            that._renderSVG();
            that._sizeChanged = false;
        }
        else {
            that._headRect = that._head.getBoundingClientRect();
            that._highlightLabel();
        }
    }

    /**
     * Selects the appropriate AM/PM label.
     */
    _selectAmPm(which) {
        const that = this;

        if (which === 'am') {
            that._ampm = 'am';
            that.$pmContainer.removeClass('jqx-selected');
            that.$amContainer.addClass('jqx-selected');
        }
        else {
            that._ampm = 'pm';
            that.$amContainer.removeClass('jqx-selected');
            that.$pmContainer.addClass('jqx-selected');
        }
    }

    /**
     * Sets whether the element can be focused.
     */
    _setFocusable() {
        const that = this;

        if (that.disabled || that.unfocusable) {
            that.$.hourContainer.removeAttribute('tabindex');
            that.$.minuteContainer.removeAttribute('tabindex');
            that.$.amContainer.removeAttribute('tabindex');
            that.$.pmContainer.removeAttribute('tabindex');
            that.$.picker.removeAttribute('tabindex');
            return;
        }

        const index = that.tabIndex > 0 ? that.tabIndex : 0;

        that.$.hourContainer.tabIndex = index;
        that.$.minuteContainer.tabIndex = index;
        that.$.amContainer.tabIndex = index;
        that.$.pmContainer.tabIndex = index;
        that.$.picker.tabIndex = index;
    }

    /**
     * Sets the SVG picker's size.
     */
    _setPickerSize() {
        const that = this,
            parentWidth = that.$.svgContainer.offsetWidth,
            parentHeight = that.$.svgContainer.offsetHeight;
        let size = Math.min(parentWidth, parentHeight) * 0.9;

        if (that._pickerSize !== undefined && that._pickerSize !== size) {
            that._sizeChanged = true;
        }
        else {
            that._sizeChanged = false;
        }

        that._pickerSize = size;
        that._measurements.radius = size / 2;
        that._measurements.innerRadius = that._measurements.radius - 10;

        size += 'px';
        that.$.picker.style.width = size;
        that.$.picker.style.height = size;
    }

    /**
     * Updates the hours.
     */
    _updateHours(hours, suppressEvent) {
        const that = this;
        let actualHours = hours;

        if (that.format === '12-hour') {
            if (that._ampm === 'am') {
                if (actualHours === 12) {
                    actualHours = 0;
                }
            }
            else if (actualHours < 12) {
                actualHours += 12;
            }
        }
        else {
            actualHours = hours;
        }

        const oldValue = that._oldValue !== undefined ? that._oldValue : new Date(that.value.getTime()),
            oldHours = oldValue.getHours();

        if (actualHours === oldHours) {
            delete that._oldTimePart;
            return;
        }

        that._oldTimePart = oldHours;

        if (that._oldValue === undefined) {
            that.value.setHours(actualHours);
        }

        that.$.hourContainer.innerHTML = hours;

        if (suppressEvent !== true) {
            // Update the hidden input 
            that.$.hiddenInput.value = that.value;

            that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValue });
        }
    }

    /**
     * Updates the minutes.
     */
    _updateMinutes(minutes) {
        const that = this,
            oldValue = that._oldValue !== undefined ? that._oldValue : new Date(that.value.getTime()),
            oldMinutes = oldValue.getMinutes();

        if (minutes === oldMinutes) {
            delete that._oldTimePart;
            return;
        }

        that._oldTimePart = oldMinutes;

        if (that._oldValue === undefined) {
            that.value.setMinutes(minutes);
        }

        minutes = minutes.toString();

        if (minutes.length === 1) {
            minutes = '0' + minutes;
        }

        that.$.minuteContainer.innerHTML = minutes;

        // Update the hidden input 
        that.$.hiddenInput.value = that.value;

        that.$.fireEvent('change', { 'value': that.value, 'oldValue': oldValue });
    }

    /**
     * Validates the "footerTemplate" property.
     */
    _validateFooterTemplate() {
        const that = this,
            footerTemplate = that.footerTemplate;

        if (footerTemplate === null) {
            that.$.footer.innerHTML = '';
            return;
        }

        let potentialHTMLTemplate;

        if (footerTemplate instanceof HTMLTemplateElement) {
            potentialHTMLTemplate = footerTemplate;
        }
        else if (typeof footerTemplate === 'string') {
            potentialHTMLTemplate = document.getElementById(footerTemplate);

            if (!(potentialHTMLTemplate instanceof HTMLTemplateElement)) {
                potentialHTMLTemplate = undefined;
            }
        }

        if (potentialHTMLTemplate === undefined) {
            that.footerTemplate = null;
            that.$.footer.innerHTML = '';
            return;
        }

        const templateContent = document.importNode(potentialHTMLTemplate.content, true);

        if (that.enableShadowDOM) {
            that.$.footer.innerHTML = '<slot></slot>';
            that.appendChild(templateContent);
            return;
        }

        that.$.footer.appendChild(templateContent);
    }

    /**
     * Validates initial property values.
     */
    _validateInitialPropertyValues() {
        const that = this;

        that._validateFooterTemplate();

        that.minuteInterval = Math.max(1, Math.min(that.minuteInterval, 60));

        that._validateValue();
    }

    /**
     * Validates the "value" property.
     */
    _validateValue() {
        const that = this,
            value = that.value,
            referenceValue = that._oldValue !== undefined ? this._oldValue : new Date();

        if (value instanceof Date) {
            return;
        }
        else if (typeof value === 'string') {
            if (/^\d{1,2}:\d{1,2}$/.test(value)) {
                const timeParts = value.split(':');

                that.value = new Date(
                    referenceValue.getFullYear(),
                    referenceValue.getMonth(),
                    referenceValue.getDate(),
                    parseFloat(timeParts[0]),
                    parseFloat(timeParts[1]));
                return;
            }

            that.value = that._parseDateString(value, referenceValue);
        }
        else {
            that.value = referenceValue;
        }
    }
});

/**
* jqxToast custom element.
*/
JQX('jqx-toast', class Toast extends JQX.ContentElement {

    /**
    * Element's properties
    */
    static get properties() {
        return {
            'appendTo': {
                value: null,
                type: 'any'
            },
            'autoClose': {
                value: false,
                type: 'boolean'
            },
            'autoCloseDelay': {
                value: 3000,
                type: 'number'
            },
            'autoOpen': {
                value: false,
                type: 'boolean'
            },
            'itemTemplate': {
                value: null,
                type: 'string?'
            },
            'modal': {
                value: false,
                type: 'boolean'
            },
            'position': {
                allowedValues: ['top-left', 'top-right', 'bottom-left', 'bottom-right'],
                value: 'top-right',
                type: 'string'
            },
            'showCloseButton': {
                value: false,
                type: 'boolean'
            },
            'type': {
                allowedValues: ['info', 'warning', 'success', 'error', 'mail', 'time', null],
                value: 'info',
                type: 'string?'
            },
            'value': {
                value: '',
                type: 'any'
            }
        }
    }

    /**
    * CSS files needed for the element (ShadowDOM)
    */
    static get styleUrls() {
        return [
            'jqx.toast.css'
        ]
    }

    /**
    * Tab Items Group's HTML template.
    */
    template() {
        return '';
    }

    /**
    * Updates the element when a property is changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
    * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;        

        switch (propertyName) {
            case 'value': {
                const item = that._instances[that._instances.length - 1];

                if (item) {
                    (that.enableShadowDOM ? item.shadowRoot : item).querySelector('.jqx-toast-item-content').innerHTML = newValue;
                }

                break;
            }
            case 'appendTo':
            case 'modal':
            case 'position':
                that._handleContainers();
                break;
            default:
                super.propertyChangedHandler(propertyName, oldValue, newValue);
                break;
        }
    }

    /**
     * Called when the element is attached to the DOM.
     */
    attached() {
        super.attached();

        const that = this,
            containers = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight', 'Custom', 'Modal'];

        for (let i = 0; i < containers.length; i++) {
            const itemContainer = that.$['toastContainer' + containers[i]];

            if (itemContainer && itemContainer.children.length) {
                if (containers[i] === 'Custom') {
                    that._appendTo.appendChild(that._container);
                }
                else {
                    document.body.appendChild(itemContainer);
                }
            }
        }
    }

    /**
    * Called when the element is detached from the DOM.
    */
    detached() {
        super.detached();

        const that = this,
            containers = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight', 'Custom', 'Modal'];

        for (let i = 0; i < containers.length; i++) {
            const itemContainer = that.$['toastContainer' + containers[i]];

            if (itemContainer) {
                that._removeContainerListeners(itemContainer);
                itemContainer.parentElement.removeChild(itemContainer);
            }

            that.closeAll();
        }
    }

    /**
    * Element's ready method.
    */
    ready() {
        super.ready();

        const that = this;

        that.value = that.innerHTML = that.value ? that.value : that.innerHTML;
        that._instances = [];

        if (that.autoOpen) {
            that.open();
        }
    }

    /**
    * Closes all opened toast items
    */
    closeAll() {
        const that = this;

        for (var i = that._instances.length - 1; i > -1; i--) {
            that._close(that._instances[i]);
        }
    }

    /**
    * Closes particular item
    */
    closeItem(instance) {
        const that = this;

        if (!instance || that._instances.length === 0) {
            return;
        }

        if (typeof instance === 'string') {
            instance = document.getElementById(instance);
        }
        else if (instance instanceof HTMLElement) {
            instance = instance.closest('.jqx-toast-item');
        }

        if (!instance || that._instances.indexOf(instance) === -1) {
            return;
        }

        that._close(instance);
    }

    /**
    * Closes the last opened toast item
    */
    closeLast() {
        const that = this;

        if (that._instances.length > 0) {
            that._close(that._instances[that._instances.length - 1]);
        }
    }

    /**
     * Opens a new toast item instance
     */
    open() {
        const that = this;

        if (that.disabled) {
            return;
        }

        that._handleContainers();

        let item = document.createElement('div');

        item.className = 'jqx-toast-item';

        if (that.value instanceof HTMLElement) {
            item.innerHTML = that._defaultItemTemplate('');
            item.getElementsByClassName('jqx-toast-item-content')[0].appendChild(that.value);
        }
        else {
            item.innerHTML = that._handleItemTemplate() || that._defaultItemTemplate(that.value);
        }

        if (that.showCloseButton) {
            item.setAttribute('show-close-button', '');
        }

        for (let i = 0; i < that.classList.length; i++) {
            if (that.classList[i].indexOf('jqx-') < 0) {
                item.classList.add(that.classList[i]);
            }
        }

        if (that.type) {
            item.classList.add(that.type);
        }

        item.setAttribute('animation', that.animation);

        if (that.enableShadowDOM) {
            if (!item.shadowRoot) {
                const itemContent = document.createDocumentFragment();

                while (item.childNodes.length) {
                    itemContent.appendChild(item.firstChild);
                }

                //Create ShadowRoot
                item.attachShadow({ mode: 'open' });

                //Append Styles
                const styleUrls = [].slice.call(that.shadowRoot.children).filter(el => el.tagName === 'LINK');

                for (let i = 0; i < styleUrls.length; i++) {
                    item.shadowRoot.insertBefore(styleUrls[i].cloneNode(), item.shadowRoot.firstChild);
                }

                item.shadowRoot.appendChild(itemContent);
            }
        }

        that._container.appendChild(item);

        item._parent = that._container;

        that._instances.push(item);

        that.$.fireEvent('open', { 'instance': item });

        setTimeout(function () {
            item.setAttribute('opened', '');
        }, 10);

        if (that.autoClose) {
            item._autoCloseTimeout = setTimeout(function () {
                that._close(item);
            }, that.autoCloseDelay);
        }
    }

    /**
     * Container's click handler. Common for all toast containers
     */
    _containerClickHandler(event) {
        const that = this,
            target = that.enableShadowDOM ? event.composedPath()[0] : event.target,
            clickedButton = target.closest('.jqx-toast-item-close-button'),
            clickedItem = (target.getRootNode().host || target).closest('.jqx-toast-item');

        if (clickedButton || clickedItem) {
            that.$.fireEvent('click', { 'instance': clickedItem });

            if (clickedButton) {
                that._close(clickedItem);
            }
        }
        else if (that.modal) {
            that.closeAll();
        }
    }

    /**
     * Closes (removes) an toast item instance
     */
    _close(instance) {
        const that = this;

        if (that._instances.indexOf(instance) > -1) {
            const closeTransitionDuration = window.getComputedStyle(instance, null).getPropertyValue('transition-duration'),
                interval = closeTransitionDuration.indexOf('ms') > -1 ? parseInt(closeTransitionDuration) : parseFloat(closeTransitionDuration) * 1000;

            instance.removeAttribute('opened');
            that._instances.splice(that._instances.indexOf(instance), 1);

            setTimeout(function () {
                clearTimeout(instance._autoCloseTimeout);
                that.$.fireEvent('close', { 'instance': instance });

                if (instance.parentNode) {
                    instance.parentNode.removeChild(instance);
                }

                const parentContainer = instance._parent;

                if (parentContainer && !parentContainer.children.length && parentContainer.parentElement) {
                    that._removeContainerListeners(parentContainer);
                    parentContainer.parentElement.removeChild(parentContainer);
                }
            }, interval);
        }
    }

    /**
    * Returns the default item template
    */
    _defaultItemTemplate(value) {
        return `<div class ="jqx-toast-item-header">
                    <span class ="jqx-toast-item-close-button"></span>
                </div>
                <div class ="jqx-toast-item-container">
                    <span class ="jqx-toast-item-icon"></span><span class ="jqx-toast-item-content">${value}</span>
                </div>`;
    }

    /**
     * Handles the contaner in use, where all new items will be stored
     */
    _handleContainers() {
        const that = this;
        let customContainer;

        if (typeof that.appendTo === 'string') {
            customContainer = document.getElementById(that.appendTo);
        }
        else if (that.appendTo instanceof HTMLElement) {
            customContainer = that.appendTo;
        }

        //Get or create the toast items container
        that._container = that._getToastContainer(customContainer);

        if (customContainer) {
            that._appendTo = customContainer;

            if (!that._container.parentElement) {
                //Add events listeners
                that._addContainerListeners(that._container);
                that._appendTo.appendChild(that._container);
            }

            return;
        }

        if (!customContainer && that.$.toastContainerCustom && !that.$.toastContainerCustom.children.length) {
            that._removeContainerListeners(that.$.toastContainerCustom);

            if (that.$.toastContainerCustom.parentElement) {
                that.$.toastContainerCustom.parentElement.removeChild(that.$.toastContainerCustom);
            }
        }

        if (!that._container.parentElement) {
            //Add events listeners
            that._addContainerListeners(that._container);
            document.body.appendChild(that._container);
        }
    }

    /**
     * Adds event listeners to the toast item container
     * @param {any} container
     */
    _addContainerListeners(container) {
        const that = this;

        if (!container) {
            return;
        }

        const containerId = container.getAttribute('jqx-id'),
            containerEvents = that['$' + containerId];

        if (containerEvents) {
            containerEvents.listen('click', that._containerClickHandler.bind(that));
            containerEvents.listen('swipeleft', that._swipeHandler.bind(that));
            containerEvents.listen('swiperight', that._swipeHandler.bind(that));
            containerEvents.listen('swipetop', that._swipeHandler.bind(that));
            containerEvents.listen('swipebottom', that._swipeHandler.bind(that));
        }
    }

    /**
     * Removes the event listeners from the toast item container
     * @param {any} container
     */
    _removeContainerListeners(container) {
        const that = this;

        if (!container) {
            return;
        }

        const containerId = container.getAttribute('jqx-id'),
            containerEvents = that['$' + containerId];

        if (containerEvents) {
            containerEvents.unlisten('click');
            containerEvents.unlisten('swipeleft');
            containerEvents.unlisten('swiperight');
            containerEvents.unlisten('swipetop');
            containerEvents.unlisten('swipebottom');
        }
    }

    /**
     * Returns a toast items container
     * @param {any} customContainer
     */
    _getToastContainer(customContainer) {
        const that = this;

        let type;

        if (customContainer) {
            type = 'Custom';
        }
        else if (that.modal) {
            type = 'Modal';
        }
        else {
            type = JQX.Utilities.Core.toCamelCase(that.position);
            type = type.charAt(0).toUpperCase() + type.slice(1);
        }

        const containerName = 'toastContainer' + type;

        if (!that.$[containerName]) {
            //Create it
            let container = document.createElement('div');

            container.setAttribute('jqx-id', containerName);
            container.classList.add('jqx-toast-container');
            container.classList.add('jqx-toast-container-' + JQX.Utilities.Core.toDash(type));

            that.$['toastContainer' + type] = container;
            that['$toastContainer' + type] = JQX.Utilities.Extend(container);
        }

        return that.$[containerName];
    }

    /**
    * Apply the template to the toast.
    */
    _handleItemTemplate() {
        const that = this;
        let template = that.itemTemplate;

        if (!('content' in document.createElement('template'))) {
            that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() }));
            return;
        }

        if (!template) {
            return that._defaultItemTemplate(that.value);
        }

        template = document.getElementById(template);

        if (template === null || !('content' in template)) {
            that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: 'template' }));
            return;
        }

        const content = template.innerHTML,
            regex = /{{\w+}}/g;

        return content.replace(regex, that.value);
    }

    /**
    * SwipeLeft and SwipeRight event handler.
    **/
    _swipeHandler(event) {
        const that = this,
            instance = event.originalEvent.target.closest('.jqx-toast-item');

        event.stopPropagation();

        if (!instance) {
            return;
        }

        that.$.fireEvent(event.type, { 'instance': instance });
    }
});
/**
* Tooltip custom element.
*/
JQX('jqx-tooltip', class Tooltip extends JQX.ContentElement {

    // Tooltip's properties.
    static get properties() {
        return {
            'arrow': {
                value: false,
                type: 'boolean'
            },
            'arrowDirection': {
                allowedValues: ['bottom', 'top', 'left', 'right'],
                value: 'bottom',
                type: 'string'
            },
            'delay': {
                value: 0,
                type: 'number'
            },
            'messages': {
                extend: true,
                value: {
                    'en': {
                        'invalidSelector': '{{elementType}}: "{{property}}" must be a String, an HTMLElement or null.',
                        'htmlTemplateNotSuported': '{{elementType}}: Browser doesn\'t support HTMLTemplate elements.',
                        'invalidTemplate': '{{elementType}}: "{{property}}" property accepts a string that must match the id of an HTMLTemplate element from the DOM.',
                        'invalidNode': '{{elementType}}: Invalid parameter "{{node}}" when calling {{method}}.'
                    }
                },
                type: 'object'
            },
            'offset': {
                value: [0, 0],
                type: 'array'
            },
            'openMode': {
                allowedValues: ['click', 'focus', 'hover', 'manual'],
                value: 'hover',
                type: 'string'
            },
            'position': {
                allowedValues: ['bottom', 'top', 'left', 'right', 'absolute', 'auto'],
                value: 'top',
                type: 'string'
            },
            'selector': {
                value: null,
                type: 'any?'
            },
            'tooltipTemplate': {
                value: null,
                type: 'any'
            },
            'value': {
                value: '',
                type: 'string',
                reflectToAttribute: false
            },
            'visible': {
                value: false,
                type: 'boolean'
            }
        };
    }

    /**
   * CSS files needed for the element (ShadowDOM)
   */
    static get styleUrls() {
        return [
            'jqx.tooltip.css'
        ]
    }

    /** 
    * Tooltip's HTML template.
    */
    template() {
        return `<div id="container">
                    <div id="content" class="jqx-tooltip-content" inner-h-t-m-l="[[innerHTML]]">
                        <content></content>
                    </div>
                </div>`;
    }

    /**
    * Updates the Tooltip when a property is  changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value.
    * @param {number/string} newValue The new entered value.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this;
        let eventType;

        switch (propertyName) {
            case 'openMode':
                that.close();
                that._handleEventListeners(oldValue);
                that._handleResize();
                break;
            case 'selector':
                that._oldOwnerElement = that._ownerElement;
                that._handleSelector(newValue);
                that._handleEventListeners();
                break;
            case 'tooltipTemplate':
                that._handleTemplate(oldValue);
                break;
            case 'value':
                that.tooltipTemplate ? that._handleTemplate() : that.$.content.innerHTML = that.value;
                break;
            case 'visible':
                eventType = newValue ? 'open' : 'close';

                that.$.fireEvent(eventType, {
                    'owner': that._ownerElement
                });
                break;
        }

        that._applyPosition();
    }

    /**
    * Called when the element is ready
    */
    ready() {
        const that = this;

        super.ready();

        that._isParentPositionStatic = window.getComputedStyle(that.parentElement || document.querySelector('body')).position === 'static';
        that._handleSelector(that.selector);

        if (that.visible) {
            that._applyPosition();
        }

        that._handleEventListeners();
        that._handleResize();

        that.value = that.$.content.innerHTML = that.value ? that.value : that.innerHTML;
        that._handleTemplate();
    }

    /**
    * Appends a node to the tooltip.
    */
    appendChild(node) {
        const that = this;

        if (!that.isCompleted) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!node) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'appendChild', node: 'node' }));
            return
        }

        that.$.content.appendChild(node);
        that._applyPosition();
    }

    /**
     * Closes the tooltip
     */
    close() {
        const that = this;

        if (that._isOpening) {
            clearTimeout(that._isOpening);
        }

        if (!that.visible) {
            return;
        }

        that.$.fireEvent('close', {
            'owner': that._ownerElement
        });
        that.visible = false;
    }

    /**
    * Inserts a new node after another node in the tooltip.
    */
    insertBefore(newNode, referenceNode) {
        const that = this;

        if (!that.isCompleted) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!newNode || !referenceNode) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'insertBefore', node: 'newNode/referenceNode' }));
            return;
        }

        that.$.content.insertBefore(newNode, referenceNode);
        that._applyPosition();
    }

    /**
     * Open the tooltip
     */
    open() {
        const that = this;

        if (that.disabled || that.readonly || that.visible) {
            return;
        }

        that._isOpening = setTimeout(function () {
            that._applyPosition();
            that.$.fireEvent('open', {
                'owner': that._ownerElement
            });

            //Avoid unnecessaty propertyChangedHandler call
            const context = that.context;

            that.context = that;
            that.visible = true;
            that.context = context;
        }, that.delay);
    }

    /**
    * Removes a node from the tooltip.
    */
    removeChild(node) {
        const that = this;

        if (!that.isCompleted) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!node) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'removeChild', node: 'node' }));
            return
        }

        that.$.content.removeChild(node);
        that._applyPosition();
    }


    /**
     * Toggle the tooltip
     */
    toggle() {
        const that = this;

        that.visible ? that.close() : that.open();
    }

    /**
      * Selector property handler.
      */
    _applyPosition() {
        const that = this;

        if (!that._ownerElement) {
            return;
        }

        function getDomElementPosition(domElement) {
            let arrayWithParentNodes = [],
                testedElement = domElement.parentElement;

            while (testedElement && testedElement.nodeName !== 'BODY') {
                arrayWithParentNodes.push(testedElement);

                if (that.enableShadowDOM && !testedElement.parentElement) {
                    testedElement = testedElement.getRootNode().host;
                    continue;
                }

                testedElement = testedElement.parentElement;
            }

            return arrayWithParentNodes;
        }

        function getElementAndOwnerRelation() {
            const tooltipDistanceToBody = getDomElementPosition(that),
                tooltipLevelsNumber = tooltipDistanceToBody.length;
            let itemWithNonStaticPosition = null,
                rect = that._ownerElement.getBoundingClientRect();

            for (let i = 0; i < tooltipLevelsNumber; i++) {
                let style = window.getComputedStyle(tooltipDistanceToBody[i]);

                if (style.getPropertyValue('position') !== 'static') {
                    itemWithNonStaticPosition = tooltipDistanceToBody[i];
                    break;
                }
            }

            return { top: rect.top, left: rect.left, nonStaticParent: itemWithNonStaticPosition };
        }

        if (!that.parentElement) {
            return;
        }

        that._isParentPositionStatic = window.getComputedStyle(that.parentElement).position === 'static';

        const ownerRectData = that._ownerElement.getBoundingClientRect(),
            parentRectData = that.parentElement ? that.parentElement.getBoundingClientRect() : { top: 0, left: 0 };
        let topPosition,
            leftPosition;

        if (that.parentElement && (that.parentElement.nodeName.toUpperCase() === 'BODY')) {
            topPosition = ownerRectData.top + window.scrollY + parseInt(that.offset[1]);
            leftPosition = ownerRectData.left + window.scrollX + parseInt(that.offset[0]);
        }
        else {
            topPosition = ownerRectData.top - parentRectData.top + parseInt(that.offset[1]);
            leftPosition = ownerRectData.left - parentRectData.left + parseInt(that.offset[0]);
        }

        const positionObject = getElementAndOwnerRelation(),
            position = that.position;
        let translate;

        switch (position) {
            case 'auto':
            case 'bottom':
            case 'top':
            case 'left':
            case 'right':
                {
                    const pos = that['_position' + position.charAt(0).toUpperCase() + position.slice(1)](leftPosition, topPosition, positionObject);

                    topPosition = pos.top;
                    leftPosition = pos.left;
                    translate = pos.translate;
                    break;
                }
            case 'absolute':
                topPosition = (parseInt(that.offset[1]) || 0);
                leftPosition = (parseInt(that.offset[0]) || 0);
                break;
        }

        //Arrow Translation is applied when position='auto'
        if (translate) {
            that.$.container.style.setProperty('--jqx-tooltip-arrow-translate', translate + 'px');
        }
        else {
            that.$.container.style.removeProperty('--jqx-tooltip-arrow-translate');
        }

        that.style.top = topPosition + 'px';
        that.style.left = leftPosition + 'px';
    }

    /**
     * Handles the auto positioning of the element
     * @param {any} leftPosition - left position
     * @param {any} topPosition - right position
     * @param {any} positionObject - positionObject with details of it's first relative parent
     */
    _positionAuto(leftPosition, topPosition, positionObject) {
        const that = this;
        let parentElement = that._ownerElement.parentElement, overflowParent;

        while (parentElement) {
            if (getComputedStyle(parentElement).getPropertyValue('overflow') === 'hidden') {
                overflowParent = parentElement;
                break;
            }

            parentElement = parentElement.parentElement;
        }

        if (!overflowParent) {
            overflowParent = document.body;
        }

        const overFlowParentRect = overflowParent.getBoundingClientRect(),
            arrowWidth = parseFloat(window.getComputedStyle(that).getPropertyValue('--jqx-tooltip-arrow-width')) || 0;
        let possiblePosition = that._positionTop(leftPosition, topPosition, positionObject),
            nonStaticParent = positionObject.nonStaticParent,
            minTranslate = that.offsetWidth / 2 - arrowWidth,
            nonStaticParentTop = 0,
            nonStaticParentLeft = 0;

        if (nonStaticParent) {
            const nonStaticParentRect = nonStaticParent.getBoundingClientRect();

            nonStaticParentTop = nonStaticParentRect.top;
            nonStaticParentLeft = nonStaticParentRect.left;
        }

        if (possiblePosition.top + nonStaticParentTop >= overFlowParentRect.top) {
            topPosition = possiblePosition.top;
            leftPosition = Math.max(overFlowParentRect.left - nonStaticParentLeft, possiblePosition.left +
                Math.min(0, overFlowParentRect.right - (possiblePosition.left + nonStaticParentLeft + that.offsetWidth)));
            return { left: leftPosition, top: topPosition, translate: Math.max(-minTranslate, Math.min(minTranslate, possiblePosition.left - leftPosition)) };
        }

        possiblePosition = that._positionBottom(leftPosition, topPosition, positionObject);

        if (possiblePosition.top + that.offsetHeight + nonStaticParentTop <= overFlowParentRect.bottom) {
            topPosition = possiblePosition.top;
            leftPosition = Math.max(overFlowParentRect.left - nonStaticParentLeft, possiblePosition.left +
                Math.min(0, overFlowParentRect.right - (possiblePosition.left + nonStaticParentLeft + that.offsetWidth)));
            return { left: leftPosition, top: topPosition, translate: Math.max(-minTranslate, Math.min(minTranslate, possiblePosition.left - leftPosition)) };
        }

        possiblePosition = that._positionLeft(leftPosition, topPosition, positionObject);

        topPosition = possiblePosition.top;
        minTranslate = that.offsetHeight / 2 - arrowWidth;

        topPosition = Math.max(overFlowParentRect.top - nonStaticParentTop, possiblePosition.top +
            Math.min(0, overFlowParentRect.bottom - (possiblePosition.top + nonStaticParentTop + that.offsetHeight)));

        if (possiblePosition.left + nonStaticParentLeft >= overFlowParentRect.left) {
            leftPosition = possiblePosition.left;
        }
        else {
            possiblePosition = that._positionRight(leftPosition, topPosition, positionObject);
            leftPosition = possiblePosition.left;
        }

        return { left: leftPosition, top: topPosition, translate: Math.max(-minTranslate, Math.min(minTranslate, possiblePosition.top - topPosition)) };
    }

    /**
     * Position the Tooltip Above the ownerElement
     * @param {any} leftPosition - left position
     * @param {any} topPosition - right position
     * @param {any} positionObject - positionObject with details of it's first relative parent
     */
    _positionTop(leftPosition, topPosition, positionObject) {
        const that = this;

        that.set('arrowDirection', 'bottom');

        if (positionObject.nonStaticParent === null) {
            topPosition = (positionObject.top + window.scrollY - that.offsetHeight);
            leftPosition = (positionObject.left + window.scrollX - that.offsetWidth / 2 + that._ownerElement.offsetWidth / 2);
            return { left: leftPosition, top: topPosition };
        }

        if (that._isParentPositionStatic) {
            topPosition = (that._ownerElement.offsetTop - that.offsetHeight);
            leftPosition = (that._ownerElement.offsetLeft - that.offsetWidth / 2 + that._ownerElement.offsetWidth / 2);

            if (that._ownerElement instanceof SVGElement) { // to be applied in all modes
                const rect = that._ownerElement.getBoundingClientRect(),
                    rectParent = that._ownerElement.parentNode.getBoundingClientRect();

                topPosition = (rect.top - rectParent.top - that.offsetHeight / 2);
                leftPosition = (rect.left - that.offsetWidth / 2 + rectParent.left / 2);
            }

            return { left: leftPosition, top: topPosition };
        }

        if (that._ownerElement instanceof SVGElement && that._ownerElement.parentElement) { // to be applied in all modes; position to be recalculated
            const rect = that._ownerElement.getBoundingClientRect(),
                rectParent = that._ownerElement.parentNode.getBoundingClientRect();

            topPosition = (rect.top - rectParent.top - that.offsetHeight);
            leftPosition = (rect.left - rectParent.left - (that.offsetWidth / 2)) + (rect.width / 2);

            return { left: leftPosition, top: topPosition };
        }

        topPosition = (topPosition - that.offsetHeight);
        leftPosition = (leftPosition - that.offsetWidth / 2 + that._ownerElement.offsetWidth / 2);

        return { left: leftPosition, top: topPosition };
    }

    /**
     * Position the Tooltip Below the ownerElement
     * @param {any} leftPosition - left position
     * @param {any} topPosition - right position
     * @param {any} positionObject - positionObject with details of it's first relative parent
     */
    _positionBottom(leftPosition, topPosition, positionObject) {
        const that = this;

        that.set('arrowDirection', 'top');

        if (positionObject.nonStaticParent === null) {
            topPosition = (positionObject.top + window.scrollY + that._ownerElement.offsetHeight);
            leftPosition = (positionObject.left + window.scrollX - that.offsetWidth / 2 + that._ownerElement.offsetWidth / 2);
            return { left: leftPosition, top: topPosition };
        }

        if (that._isParentPositionStatic) {
            topPosition = (that._ownerElement.offsetTop + that._ownerElement.offsetHeight);
            leftPosition = (that._ownerElement.offsetLeft - that.offsetWidth / 2 + that._ownerElement.offsetWidth / 2);
            return { left: leftPosition, top: topPosition };
        }

        topPosition = (topPosition + that._ownerElement.offsetHeight);
        leftPosition = (leftPosition - that.offsetWidth / 2 + that._ownerElement.offsetWidth / 2);

        return { left: leftPosition, top: topPosition };
    }

    /**
     * Position the Tooltip to the Left of the ownerElement
     * @param {any} leftPosition - left position
     * @param {any} topPosition - right position
     * @param {any} positionObject - positionObject with details of it's first relative parent
     */
    _positionLeft(leftPosition, topPosition, positionObject) {
        const that = this;

        that.set('arrowDirection', 'right');

        if (positionObject.nonStaticParent === null) {
            topPosition = (positionObject.top + window.scrollY + that._ownerElement.offsetHeight / 2 - that.$.content.offsetHeight / 2);
            leftPosition = (positionObject.left + window.scrollX - that.offsetWidth);
            return { left: leftPosition, top: topPosition };
        }

        if (that._isParentPositionStatic) {
            topPosition = (that._ownerElement.offsetTop + that._ownerElement.offsetHeight / 2 - that.$.content.offsetHeight / 2);
            leftPosition = (that._ownerElement.offsetLeft - that.offsetWidth);
            return { left: leftPosition, top: topPosition };
        }

        topPosition = (topPosition + that._ownerElement.offsetHeight / 2 - that.$.content.offsetHeight / 2);
        leftPosition = (leftPosition - that.offsetWidth);

        return { left: leftPosition, top: topPosition };
    }

    /**
     * Position the Tooltip to the Right of the ownerElement
     * @param {any} leftPosition - left position
     * @param {any} topPosition - right position
     * @param {any} positionObject - positionObject with details of it's first relative parent
     */
    _positionRight(leftPosition, topPosition, positionObject) {
        const that = this;

        that.set('arrowDirection', 'left');

        if (positionObject.nonStaticParent === null) {
            topPosition = (positionObject.top + window.scrollY + that._ownerElement.offsetHeight / 2 - that.$.content.offsetHeight / 2);
            leftPosition = (positionObject.left + window.scrollX + that._ownerElement.offsetWidth);

            return { left: leftPosition, top: topPosition };
        }

        if (that._isParentPositionStatic) {
            topPosition = (that._ownerElement.offsetTop + that._ownerElement.offsetHeight / 2 - that.$.content.offsetHeight / 2);
            leftPosition = (that._ownerElement.offsetLeft + that._ownerElement.offsetWidth);

            return { left: leftPosition, top: topPosition };
        }

        topPosition = (topPosition + that._ownerElement.offsetHeight / 2 - that.$.content.offsetHeight / 2);
        leftPosition = (leftPosition + that._ownerElement.offsetWidth);

        return { left: leftPosition, top: topPosition };
    }

    /**
     * Events Handller.
    * @param {any} event
     */
    _eventsHandler(event) {
        const that = this;

        if (that.disabled || that.readonly) {
            return;
        }

        if (event.type === 'click') {
            that.visible ? this.close() : this.open();
            return;
        }

        event.type === 'mouseenter' || event.type === 'focus' ? this.open() : this.close();
    }

    /**
    * Adds event listeners to owner
    */
    _handleEventListeners(oldValue) {
        const that = this;

        if (that._oldOwnerElement && that.openMode !== 'manual') {
            that._oldOwnerElement.$.unlisten('mouseenter.tooltip');
            that._oldOwnerElement.$.unlisten('mouseleave.tooltip');
            that._oldOwnerElement.$.unlisten('focus.tooltip');
            that._oldOwnerElement.$.unlisten('blur.tooltip');
            that._oldOwnerElement.$.unlisten('click.tooltip');
            that._oldOwnerElement = null;
        }

        if (!that._ownerElement) {
            return;
        }

        if (oldValue) {
            //unlisten from previous event.
            switch (oldValue) {
                case 'hover':
                    that._ownerElement.$.unlisten('mouseenter.tooltip');
                    that._ownerElement.$.unlisten('mouseleave.tooltip');
                    break;
                case 'focus':
                    that._ownerElement.$.unlisten('focus.tooltip');
                    that._ownerElement.$.unlisten('blur.tooltip');
                    break;
                case 'click':
                    that._ownerElement.$.unlisten('click.tooltip');
                    break;
            }
        }

        if (that.openMode === 'manual') {
            return;
        }

        if (!(that._ownerElement instanceof JQX.BaseElement)) {
            that._ownerElement.$ = JQX.Utilities.Extend(that._ownerElement);
        }

        //listen to appropriate event
        switch (that.openMode) {
            case 'hover':
                that._ownerElement.$.listen('mouseenter.tooltip', that._eventsHandler.bind(that));
                that._ownerElement.$.listen('mouseleave.tooltip', that._eventsHandler.bind(that));
                break;
            case 'focus':
                that._ownerElement.$.listen('focus.tooltip', that._eventsHandler.bind(that));
                that._ownerElement.$.listen('blur.tooltip', that._eventsHandler.bind(that));
                break;
            case 'click':
                that._ownerElement.$.listen('click.tooltip', that._eventsHandler.bind(that));
                break;
            default:
                break;
        }
    }

    /**
     * Updates the position of the tooltip on window resize.
     */
    _handleResize() {
        const that = this;

        function applyPosition() {
            that._applyPosition();
        }

        if (that.openMode === 'click') {
            window.addEventListener('resize', applyPosition);
        }
        else {
            window.removeEventListener('resize', applyPosition);
        }
    }

    /**
     * Selector property handler.
     */
    _handleSelector(newValue) {
        const that = this;

        if (typeof newValue === 'string') {
            that._ownerElement = newValue.length > 0 ? document.getElementById(newValue) : undefined;
            return;
        }

        if (newValue instanceof HTMLElement || newValue instanceof SVGElement) {
            that._ownerElement = newValue;
            return;
        }

        if (newValue === null) {
            that._ownerElement = undefined;
            return;
        }

        that.error(that.localize('invalidSelector', { elementType: that.nodeName.toLowerCase(), property: 'selector' }));
    }

    /**
    * Apply the template to the tooltip.
    */
    _handleTemplate(oldValue) {
        const that = this;
        let template = that.tooltipTemplate;

        if (oldValue) {
            that.$.content.innerHTML = that.value ? that.value : '';
        }

        if (template === null || !template) {
            return;
        }

        if (typeof that.tooltipTemplate === 'function') {
            that.tooltipTemplate(that.$.content, { value: that.value });
            return;
        }

        if (!('content' in document.createElement('template'))) {
            that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() }));
            return;
        }

        template = document.getElementById(template);
        if (template === null || !('content' in template)) {
            that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: 'template' }));
            return;
        }

        const content = template.content,
            childrenCount = content.childNodes.length,
            regex = /{{\w+}}/g;
        let bindingString,
            bindingDetails = [];

        for (let i = 0; i < childrenCount; i++) {
            bindingString = regex.exec(content.childNodes[i].innerHTML);
            while (bindingString) {
                bindingDetails.push({ childNodeIndex: i, bindingString: bindingString[0] });
                bindingString = regex.exec(content.childNodes[i].innerHTML);
            }
        }

        const bindingsCount = bindingDetails.length;
        let clone = document.importNode(template.content, true),
            bindingHolderElement,
            bindingStringsCount;

        for (let b = 0; b < bindingsCount; b++) {
            bindingHolderElement = clone.childNodes[bindingDetails[b].childNodeIndex];
            bindingStringsCount = bindingDetails.length;
            for (let i = 0; i < bindingStringsCount; i++) {
                bindingHolderElement.innerHTML = bindingHolderElement.innerHTML.replace(bindingDetails[b].bindingString, that.value);
            }
        }

        that.$.content.innerHTML = '';
        for (let i = 0; i < clone.childNodes.length; i++) {
            if (clone.childNodes[i].outerHTML) {
                that.$.content.innerHTML += clone.childNodes[i].outerHTML;
            }
        }
    }
});

/**
 * Tree Item custom element.
 */
JQX('jqx-tree-item', class TreeItem extends JQX.MenuItem {
    // Tree Item's properties.
    static get properties() {
        return {
            'selected': {
                value: false,
                type: 'boolean'
            }
        };
    }

    ready() {
        Object.defineProperty(this, 'hasStyleObserver', {
            get: function () {
                return false;
            }
        });

        super.ready();
    }

    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this,
            parentTree = that.menu;

        if (propertyName === 'level') {
            that.level = oldValue;
            return;
        }

        if (propertyName === 'disabled' || propertyName === 'separator' || !parentTree) {
            return;
        }

        const oldContext = parentTree.context;

        parentTree.context = parentTree;

        switch (propertyName) {
            case 'label': {
                const restoreSorting = parentTree.sorted && parentTree.autoSort;

                that.firstElementChild.firstElementChild.firstElementChild.innerHTML = newValue;

                if (restoreSorting) {
                    parentTree._unsortItems(parentTree.$.mainContainer);
                    parentTree._applyGrouping(parentTree.$.mainContainer);
                }

                if (parentTree._state.filter) {
                    parentTree._applyFilter(parentTree._state.filter);
                }

                break;
            }
            case 'selected':
                that.selected = oldValue;

                if (newValue) {
                    parentTree.select(that);
                }
                else {
                    parentTree.unselect(that);
                }

                break;
            case 'shortcut': {
                let shortcutElement = that.firstElementChild.children[1];

                if (!shortcutElement) {
                    shortcutElement = document.createElement('div');
                    shortcutElement.className = 'jqx-tree-item-shortcut';
                    that.firstElementChild.appendChild(shortcutElement);
                }

                shortcutElement.innerHTML = newValue;
                break;
            }
            case 'value':
                if (parentTree.sort && parentTree.sorted && parentTree.autoSort) {
                    parentTree._refreshSorting();
                }

                break;
        }

        parentTree.context = oldContext;
    }
});

/**
 * Tree Items Group custom element.
 */
JQX('jqx-tree-items-group', class TreeItemsGroup extends JQX.MenuItemsGroup {
    // Tree Items Group's properties.
    static get properties() {
        return {
            'selected': {
                value: false,
                type: 'boolean'
            }
        };
    }

    ready() {
        Object.defineProperty(this, 'hasStyleObserver', {
            get: function () {
                return false;
            }
        });

        super.ready();
    }

    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this,
            parentTree = that.menu;

        if (propertyName === 'level') {
            that.level = oldValue;
            return;
        }

        if (propertyName === 'disabled' || propertyName === 'separator' || !parentTree) {
            return;
        }

        const oldContext = parentTree.context;

        parentTree.context = parentTree;

        switch (propertyName) {
            case 'expanded': {
                that.expanded = oldValue;

                if (newValue) {
                    parentTree.expandItem(that);
                }
                else {
                    parentTree.collapseItem(that);
                }

                break;
            }
            case 'label': {
                const restoreSorting = parentTree.sorted && parentTree.autoSort;

                that.firstElementChild.firstElementChild.firstElementChild.innerHTML = newValue;

                if (restoreSorting) {
                    parentTree._unsortItems(parentTree.$.mainContainer);
                    parentTree._applyGrouping(parentTree.$.mainContainer);
                }

                if (parentTree._state.filter) {
                    parentTree._applyFilter(parentTree._state.filter);
                }

                break;
            }
            case 'selected':
                that.selected = oldValue;

                if (newValue) {
                    parentTree.select(that);
                }
                else {
                    parentTree.unselect(that);
                }

                break;
            case 'value':
                if (parentTree.sort && parentTree.sorted && parentTree.autoSort) {
                    parentTree._refreshSorting();
                }

                break;
        }

        parentTree.context = oldContext;
    }
});

/**
 * Tree custom element.
 */
JQX('jqx-tree', class Tree extends JQX.Menu {
    // Tree's properties.
    static get properties() {
        return {
            'allowDrag': {
                value: false,
                type: 'boolean'
            },
            'allowDrop': {
                value: false,
                type: 'boolean'
            },
            'autoHideToggleElement': {
                value: false,
                type: 'boolean'
            },
            'autoLoadState': {
                value: false,
                type: 'boolean'
            },
            'autoSaveState': {
                value: false,
                type: 'boolean'
            },
            'autoSort': {
                value: true,
                type: 'boolean'
            },
            'displayLoadingIndicator': {
                value: false,
                type: 'boolean'
            },
            'dragFeedbackFormatFunction': {
                value: null,
                type: 'function?'
            },
            'dragOffset': {
                value: [10, 10],
                type: 'array'
            },
            'editable': {
                value: false,
                type: 'boolean'
            },
            'filterable': {
                value: false,
                type: 'boolean'
            },
            'filterInputPlaceholder': {
                value: '',
                type: 'string'
            },
            'filterMode': {
                value: 'containsIgnoreCase',
                allowedValues: ['contains', 'containsIgnoreCase', 'doesNotContain', 'doesNotContainIgnoreCase', 'equals', 'equalsIgnoreCase', 'startsWith', 'startsWithIgnoreCase', 'endsWith', 'endsWithIgnoreCase'],
                type: 'string'
            },
            'hasThreeStates': {
                value: false,
                type: 'boolean'
            },
            'loadingIndicatorPlaceholder': {
                value: 'Loading...',
                type: 'string'
            },
            'loadingIndicatorPosition': {
                value: 'center',
                allowedValues: ['bottom', 'center', 'top'],
                type: 'string'
            },
            'messages': {
                value: {
                    'en': {
                        'noId': 'jqx-tree: Saving and loading the element\'s state are not available if the element has no id.'
                    }
                },
                type: 'object',
                extend: true
            },
            'scrollMode': {
                value: 'scrollbar',
                allowedValues: ['scrollbar', 'scrollButtons'],
                type: 'string'
            },
            'selectedIndexes': {
                value: [],
                type: 'array'
            },
            'selectionDisplayMode': {
                value: 'row',
                allowedValues: ['row', 'label'],
                type: 'string'
            },
            'selectionMode': {
                value: 'one',
                allowedValues: ['none', 'oneOrManyExtended', 'zeroOrMany', 'oneOrMany', 'zeroOrOne', 'one', 'checkBox', 'radioButton'],
                type: 'string'
            },
            'showLines': {
                value: false,
                type: 'boolean'
            },
            'showRootLines': {
                value: false,
                type: 'boolean'
            },
            'sort': {
                value: null,
                type: 'function?'
            },
            'sortDirection': {
                value: 'asc',
                allowedValues: ['asc', 'desc'],
                type: 'string'
            },
            'sorted': {
                value: false,
                type: 'boolean'
            },
            'toggleElementPosition': {
                value: 'near',
                allowedValues: ['near', 'far'],
                type: 'string'
            },
            'toggleMode': {
                value: 'dblclick',
                allowedValues: ['click', 'dblclick', 'arrow'],
                type: 'string'
            }
        };
    }

    /**
     * Tree's event listeners.
     */
    static get listeners() {
        return {
            'blur': '_blurHandler',
            'focus': '_focusHandler',
            'keydown': '_keydownHandler',
            'mouseenter': '_mouseenterHandler',
            'mouseleave': '_mouseleaveHandler',
            'resize': '_checkOverflow',
            'styleChanged': '_styleChangedHandler',
            'transitionend': '_overriddenMenuHandler',
            'container.click': '_overriddenMenuHandler',
            'container.mouseout': '_overriddenMenuHandler',
            'container.mouseover': '_overriddenMenuHandler',
            'editInput.blur': '_editInputBlurHandler',
            'filterInput.keydown': '_filterInputKeydownHandler',
            'filterInput.keyup': '_filterInputKeyupHandler',
            'mainContainer.click': '_overriddenMenuHandler',
            'mainContainer.mouseleave': '_overriddenMenuHandler',
            'mainContainer.mouseout': '_overriddenMenuHandler',
            'mainContainer.mouseover': '_overriddenMenuHandler',
            'mainContainer.swipeleft': '_mainContainerSwipeHandler',
            'mainContainer.swiperight': '_mainContainerSwipeHandler',
            'scrollButtonFar.click': '_scrollButtonFarClickHandler',
            'scrollButtonNear.click': '_scrollButtonNearClickHandler',
            'scrollViewer.down': '_scrollViewerDownHandler',
            'scrollViewer.kineticScroll': '_scrollViewerWheelHandler',
            'mainContainer.wheel': '_scrollViewerWheelHandler',
            'document.move': '_moveHandler',
            'document.up': '_documentUpHandler'
        };
    }

    /**
     * Tree's required files.
     */
    static get requires() {
        return {
            'JQX.ScrollBar': 'jqxscrollbar.js'
        }
    }

    /**
    * CSS files needed for the element (ShadowDOM)
    */
    static get styleUrls() {
        return [
            'jqx.scrollbar.css',
            'jqx.scrollviewer.css',
            'jqx.tree.css'
        ]
    }

    /**
     * Tree's HTML template.
     */
    template() {
        return `<div id="container">
                    <div class="jqx-tree-filter-input-container">
                        <input id="filterInput" class="jqx-filter-input" disabled="[[disabled]]" placeholder="[[filterInputPlaceholder]]" type="text" />
                    </div>
                    <jqx-repeat-button id="scrollButtonNear" class="jqx-tree-scroll-button jqx-spin-button jqx-scroll-button-near jqx-hidden" animation="[[animation]]" unfocusable>
                        <div id="arrowNear" class="jqx-arrow jqx-arrow-up"></div>
                    </jqx-repeat-button>
                    <jqx-scroll-viewer id="scrollViewer" animation="[[animation]]" horizontal-scroll-bar-visibility="hidden" right-to-left="[[right-to-left]]">
                        <div id="mainContainer" class="jqx-tree-main-container">
                            <content></content>
                        </div>
                        <input type="text" id="editInput" class="jqx-tree-edit-input jqx-hidden" />
                    </jqx-scroll-viewer>
                    <jqx-repeat-button id="scrollButtonFar" class="jqx-tree-scroll-button jqx-spin-button jqx-scroll-button-far jqx-hidden" animation="[[animation]]" unfocusable>
                        <div id="arrowFar" class="jqx-arrow jqx-arrow-down"></div>
                    </jqx-repeat-button>
                    <div id="loadingIndicatorContainer" class="jqx-loader-container jqx-hidden">
                        <span id="loadingIndicator" class="jqx-loader"></span>
                        <span id="loadingIndicatorPlaceHolder" class="jqx-loader-label jqx-hidden">[[loadingIndicatorPlaceholder]]</span>
                    </div>
                </div>`;
    }

    /**
     * Adds an item after another item as a sibling.
     *
     * @param {HTMLElement} item A jqx-tree-item/jqx-tree-items-group to add to the Tree.
     * @param {HTMLElement/String} sibling The jqx-tree-item/jqx-tree-items-group (or its id or numeric path) to add the item after.
     */
    addAfter(item, sibling) {
        const that = this;

        sibling = that.getItem(sibling);

        if (sibling === undefined) {
            return;
        }

        that.addTo(item, sibling.parentItem, sibling, true);
    }

    /**
     * Adds an item before another item as a sibling.
     *
     * @param {HTMLElement} item A jqx-tree-item/jqx-tree-items-group to add to the Tree.
     * @param {HTMLElement/String} sibling The jqx-tree-item/jqx-tree-items-group (or its id or numeric path) to add the item before.
     */
    addBefore(item, sibling) {
        const that = this;

        sibling = that.getItem(sibling);

        if (sibling === undefined) {
            return;
        }

        that.addTo(item, sibling.parentItem, sibling);
    }

    /**
     * Adds an item as the last child of a parent item.
     *
     * @param {HTMLElement} item A jqx-tree-item/jqx-tree-items-group to add to the Tree.
     * @param {HTMLElement/String} parent Optional The jqx-tree-items-group (or its id or numeric path) to add the item to.
     */
    addTo(item, parent) {
        const that = this;

        if (!(item instanceof JQX.TreeItem || item instanceof JQX.TreeItemsGroup)) {
            return;
        }

        let level, container;

        if (parent === undefined) {
            parent = that.$.mainContainer;
            level = 1;
            container = parent;
        }
        else {
            parent = that.getItem(parent);

            if (parent instanceof JQX.TreeItemsGroup === false) {
                return;
            }

            level = parent.level + 1;
            container = parent.itemContainer;
        }

        that._createItemHTMLStructure(item, level, parent, container.childElementCount, 0);

        const restoreSorting = that.sorted && that.autoSort,
            filterQuery = that._state.filter,
            oldSelectedIndexes = that.selectedIndexes.slice(0);

        if (restoreSorting) {
            that._unsortItems(that.$.mainContainer);
        }

        if (item instanceof JQX.TreeItemsGroup) {
            that._processHTML(item, level + 1, false);
        }

        let sibling = arguments[2];

        if (sibling && arguments[3]) {
            sibling = sibling.nextElementSibling;
        }

        if (sibling) {
            container.insertBefore(item, sibling);
            that._menuItems = {};
            that._refreshItemPaths(that.$.mainContainer, true, undefined, that.sorted && !that.autoSort);
        }
        else {
            container.appendChild(item);
        }

        if (restoreSorting) {
            that._applyGrouping(that.$.mainContainer);
        }

        if (filterQuery) {
            that._applyFilter(filterQuery);
        }

        that._checkOverflow();
        that._expandItemsByDefault();

        that.selectedIndexes = [];
        that._applySelection(true, oldSelectedIndexes);
    }

    /**
     * Clears selection.
     */
    clearSelection() {
        const that = this,
            oldSelectedIndexes = that.selectedIndexes.slice(0);

        that.selectedIndexes = [];
        that._applySelection(false, oldSelectedIndexes);
    }

    /**
     * Collapses all items.
     *
     * @param {Boolean} animation Optional If set to false, disables collapse animation even if animation is enabled for the element.
     */
    collapseAll(animation) {
        const that = this,
            animationType = that.animation,
            restoreAnimation = animation === false && that.hasAnimation;

        if (restoreAnimation) {
            that.animation = 'none';
        }

        that._collapseAll(true);

        if (restoreAnimation) {
            that.animation = animationType;
        }
    }

    /**
     * Makes sure an item is visible by scrolling to it.
     *
     * @param {HTMLElement/String} item jqx-tree-item/jqx-tree-items-group (or its id or numeric path).
     */
    ensureVisible(item) {
        const that = this;

        item = that.getItem(item);

        if (item === undefined || item.hidden) {
            return;
        }

        let animation = false;

        if (item.level > 1 && !that._isBranchExpanded(item)) {
            super.expandItem(item.parentItem, undefined, false);
            animation = that.hasAnimation;

            if (animation) {
                that._ensureVisibleOnTransitionend = item;
            }
        }

        if (!animation) {
            that._ensureVisible(item);
        }
    }

    /**
     * Expands all items.
     *
     * @param {Boolean} animation Optional If set to false, disables expand animation even if animation is enabled for the element.
     */
    expandAll(animation) {
        const that = this,
            animationType = that.animation,
            restoreAnimation = animation === false && that.hasAnimation;
        let level = 1,
            treeItemsGroups = (that.enableShadowDOM ? that.shadowRoot : that).querySelectorAll('jqx-tree-items-group[level="1"]');

        if (restoreAnimation) {
            that.animation = 'none';
        }

        while (treeItemsGroups.length > 0) {
            for (let i = 0; i < treeItemsGroups.length; i++) {
                const currentTreeItemsGroup = treeItemsGroups[i];

                if (currentTreeItemsGroup.expanded) {
                    continue;
                }

                that._menuItemsGroupSelectionHandler(currentTreeItemsGroup, { target: currentTreeItemsGroup, type: 'expand' });
            }

            level++;
            treeItemsGroups = (that.enableShadowDOM ? that.shadowRoot : that).querySelectorAll('jqx-tree-items-group[level="' + level + '"]');
        }

        if (restoreAnimation) {
            that.animation = animationType;
        }
    }

    /**
     * Expands an item.
     *
     * @param {HTMLElement/String} item jqx-tree-item/jqx-tree-items-group (or its id or numeric path).
     * @param {Boolean} animation Optional If set to false, disables expand animation even if animation is enabled for the element.
     */
    expandItem(item, animation) {
        const that = this;

        item = that.getItem(item);

        if (item === undefined || item instanceof JQX.TreeItemsGroup === false ||
            that._isContainerOpened(item.container.level, item.container)) {
            return;
        }

        const restoreAnimation = animation === false && that.hasAnimation,
            animationType = that.animation;

        if (restoreAnimation) {
            that.animation = 'none';
        }

        that._discardKeyboardHover();

        that._menuItemsGroupSelectionHandler(item, { target: item, type: 'expand' }, arguments[2]);

        if (restoreAnimation) {
            that.animation = animationType;
        }
    }

    /**
     * Filters the Tree.
     *
     * @param {String} filterQuery Filter query.
     */
    filter(filterQuery) {
        const that = this;

        if (that.filterable) {
            that._applyFilter(filterQuery);
            that.$.filterInput.value = filterQuery;
        }
    }

    /**
     * Gets the Tree's state.
     */
    getState() {
        return JSON.parse(JSON.stringify(this._state));
    }

    /**
     * Inserts an item at the given position.
     * 
     * @param {HTMLElement/Object} item A jqx-tree-item/jqx-tree-items-group (or an Object to create an item from) to add to the Tree.
     * @param {String} path Optional The path to insert the item at.
     */
    insert(item, path) {
        const that = this;
        let element;

        function createTreeItem(item) {
            const subItems = item[that.itemsMember] || [],
                tagName = item.tagName === 'jqx-tree-items-group' || subItems.length > 0 ? 'jqx-tree-items-group' : 'jqx-tree-item',
                element = document.createElement(tagName);

            if (item.disabled) {
                element.disabled = true;
            }

            if (item[that.displayMember]) {
                element.label = item[that.displayMember];
            }

            if (item.separator) {
                element.separator = true;
            }

            if (item[that.valueMember]) {
                element.value = item[that.valueMember];
            }

            if (tagName === 'jqx-tree-items-group') {
                if (item.expanded) {
                    element.expanded = true;
                }

                for (let i = 0; i < subItems.length; i++) {
                    element.appendChild(createTreeItem(subItems[i]));
                }
            }
            else if (item.shortcut) {
                element.shortcut = item.shortcut;
            }

            return element;
        }

        if (item instanceof JQX.TreeItem || item instanceof JQX.TreeItemsGroup) {
            if (that.contains(item)) {
                return;
            }

            element = item;
        }
        else if (typeof item === 'object' && item.constructor === Object) {
            element = createTreeItem(item);
        }
        else {
            return;
        }

        if (path === undefined) {
            that.addTo(element);
            return;
        }

        if (typeof path === 'number') {
            path = path.toString();
        }
        else if (path instanceof JQX.TreeItem || path instanceof JQX.TreeItemsGroup) {
            if (!that.contains(path)) {
                return;
            }

            path = path.path;
        }
        else if (typeof path !== 'string') {
            return;
        }

        const pathParts = path.split('.');
        let parent, sibling;

        if (pathParts.length === 1) {
            sibling = that._menuItems[pathParts[0]];

            if (!sibling) {
                that.addTo(element);
            }
            else {
                that.addBefore(element, sibling);
            }
        }
        else {
            sibling = that._menuItems[path];
            parent = that._menuItems[pathParts.slice(0, pathParts.length - 1).join('.')];

            if (sibling) {
                that.addBefore(element, sibling);
            }
            else if (parent && parent instanceof JQX.TreeItemsGroup) {
                that.addTo(element, parent);
            }
        }
    }

    /**
     * Loads the Tree's state.
     *
     * @param {Object} state Optional An object returned by one of the methods getState or saveState.
     */
    loadState(state) {
        const that = this,
            oldSelectedIndexes = that.selectedIndexes.slice(0),
            selectedIndexes = [];

        if (!state) {
            if (!that.id) {
                that.warn(that.localize('noId'));
                return;
            }

            state = window.localStorage.getItem('jqxTree' + that.id);
        }

        if (typeof state === 'string') {
            state = JSON.parse(state);
        }

        if (state.filter && !that.filterable) {
            state.filter = '';
        }

        let filteringChanged = state.filter !== that._state.filter,
            sortingChanged = state.sorted !== that.sorted;

        if (sortingChanged) {
            that.sorted = state.sorted;
            that._updateState('sorted', that.sorted);

            if (state.sorted) {
                that._applyGrouping(that.$.mainContainer);
            }
            else {
                that._unsortItems(that.$.mainContainer);
            }

            if (state.filter || filteringChanged) {
                that._applyFilter(state.filter);
                that.$.filterInput.value = state.filter;
            }
        }
        else if (filteringChanged) {
            that._applyFilter(state.filter);
            that.$.filterInput.value = state.filter;
        }

        that._menuItemsGroupsToExpand = [];

        for (let i = 0; i < state.expanded.length; i++) {
            const originallyExpandedItem = that.getItem(state.expanded[i]);

            if (originallyExpandedItem) {
                that._menuItemsGroupsToExpand.push(originallyExpandedItem);
            }
        }

        that._expandItemsByDefault(true);

        for (let i = 0; i < state.selected.length; i++) {
            const originallySelectedItem = that.getItem(state.selected[i]);

            if (originallySelectedItem) {
                selectedIndexes.push(originallySelectedItem.path);
            }
        }

        that.selectedIndexes = selectedIndexes;
        that._applySelection(false, oldSelectedIndexes);
    }

    /**
     * Moves an item down relative to its siblings.
     *
     * @param {HTMLElement/String} item The jqx-tree-item/jqx-tree-items-group (or its id or numeric path) to remove.
     */
    moveDown(item) {
        const that = this;

        item = that.getItem(item);

        const nextSibling = item.nextElementSibling;

        if (item === undefined || !nextSibling || that.sorted) {
            return;
        }

        that._moveTreeItem(item, nextSibling, 2, [that]);

        if (that.filterable && that._state.filter) {
            that._applyFilter(that._state.filter);
        }
    }

    /**
     * Moves an item up relative to its siblings.
     *
     * @param {HTMLElement/String} item The jqx-tree-item/jqx-tree-items-group (or its id or numeric path) to remove.
     */
    moveUp(item) {
        const that = this;

        item = that.getItem(item);

        const previousSibling = item.previousElementSibling;

        if (item === undefined || !previousSibling || that.sorted) {
            return;
        }

        that._moveTreeItem(item, previousSibling, 0, [that]);

        if (that.filterable && that._state.filter) {
            that._applyFilter(that._state.filter);
        }
    }

    /**
     * Refreshes the layout of the Tree
     */
    refresh() {
        this._checkOverflow();
    }

    /**
     * Removes an item.
     *
     * @param {HTMLElement/String} item The jqx-tree-item/jqx-tree-items-group (or its id or numeric path) to remove.
     */
    removeItem(item) {
        const that = this;

        item = that.getItem(item);

        if (item === undefined) {
            return;
        }

        if (item instanceof JQX.TreeItemsGroup) {
            const container = item.container;

            if (that._isContainerOpened(container.level, container)) {
                that._closeSubContainersTreeMode(container.level, container);
            }
        }

        const restoreSorting = that.sorted && that.autoSort;

        if (restoreSorting) {
            that._unsortItems(that.$.mainContainer);
        }

        item.parentElement.removeChild(item);
        that._menuItems = {};
        that._refreshItemPaths(that.$.mainContainer, true, undefined, that.sorted && !that.autoSort);

        if (restoreSorting) {
            that._applyGrouping(that.$.mainContainer);
        }

        const filterQuery = that._state.filter,
            oldSelectedIndexes = that.selectedIndexes.slice(0);

        if (filterQuery) {
            that._applyFilter(filterQuery);
        }

        that._checkOverflow();

        that.selectedIndexes = [];
        that._applySelection(true, oldSelectedIndexes);
    }

    /**
     * Saves the Tree's state.
     */
    saveState() {
        const that = this;

        if (!that.id) {
            that.warn(that.localize('noId'));
        }
        else {
            window.localStorage.setItem('jqxTree' + that.id, JSON.stringify(that._state));
        }

        return JSON.parse(JSON.stringify(that._state));
    }

    /**
     * Selects an item.
     *
     * @param {HTMLElement/String} item jqx-tree-item/jqx-tree-items-group (or its id or numeric path).
     */
    select(item) {
        const that = this;

        item = that.getItem(item);

        if (item === undefined || item.selected || item.templateApplied) {
            return;
        }

        that._handleSelection(item, { type: 'programmatic' });
    }

    /**
     * Unselects an item.
     *
     * @param {HTMLElement/String} item jqx-tree-item/jqx-tree-items-group (or its id or numeric path).
     */
    unselect(item) {
        const that = this;

        item = that.getItem(item);

        if (item === undefined || !item.selected || item.templateApplied) {
            return;
        }

        that._handleSelection(item, { type: 'programmatic' });
    }

    /**
     * Updates an item.
     *
     * @param {HTMLElement/String} item jqx-tree-item/jqx-tree-items-group (or its id or numeric path).
     * @param {Object} newItem An object with updated properties.
     */
    updateItem(item, newItem) {
        const that = this;

        item = that.getItem(item);

        if (item === undefined || newItem === undefined) {
            return;
        }

        const treeItem = item instanceof JQX.TreeItem;

        for (let prop in newItem) {
            if (newItem.hasOwnProperty(prop)) {
                if (treeItem) {
                    if (['disabled', 'label', 'level', 'selected', 'separator', 'shortcut', 'value'].indexOf(prop) === -1) {
                        continue;
                    }
                }
                else if (['disabled', 'expanded', 'label', 'level', 'selected', 'separator', 'value'].indexOf(prop) === -1) {
                    continue;
                }

                item[prop] = newItem[prop];
            }
        }
    }

    /**
     * Called when a property is changed.
     */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        switch (propertyName) {
            case 'allowDrag':
            case 'allowDrop':
            case 'autoLoadState':
            case 'autoSort':
            case 'editable':
            case 'filterInputPlaceholder':
            case 'loadingIndicatorPlaceholder':
            case 'selectionDisplayMode':
            case 'showLines':
            case 'showRootLines':
            case 'toggleElementPosition':
            case 'toggleMode':
                break;
            case 'autoHideToggleElement':
                if (newValue) {
                    that.$mainContainer.addClass('hidden-arrows');
                }
                else {
                    that.$mainContainer.removeClass('hidden-arrows');
                }

                break;
            case 'autoSaveState':
                if (!newValue) {
                    return;
                }

                if (!that.id) {
                    that.warn(that.localize('noId'));
                    that.autoSaveState = false;
                    return;
                }

                window.localStorage.setItem('jqxTree' + that.id, JSON.stringify(that._state));
                break;
            case 'dataSource': {
                const oldSelectedIndexes = that.selectedIndexes.slice(0);

                that.selectedIndexes = [];
                that._menuItems = {};
                that._processDataSource();
                that._checkOverflow();
                that._expandItemsByDefault();
                that._applySelection(true, oldSelectedIndexes);

                const filterQuery = that._state.filter;

                if (filterQuery) {
                    that._applyFilter(filterQuery);
                }

                break;
            }
            case 'disabled':
                that._setFocusable();
                that.$.scrollButtonNear.disabled = newValue;
                that.$.scrollButtonFar.disabled = newValue;

                if (!newValue) {
                    that._updateScrollButtonVisibility();
                }

                break;
            case 'displayLoadingIndicator':
                if (newValue) {
                    that._discardKeyboardHover(true);
                    that.$loadingIndicatorContainer.removeClass('jqx-hidden');
                }
                else {
                    that.$loadingIndicatorContainer.addClass('jqx-hidden');
                }

                break;
            case 'filterable':
                if (newValue === false) {
                    that._applyFilter('');
                    that.$.filterInput.value = '';
                }

                that._checkOverflow();
                break;
            case 'filterMode':
                if (that.filterable && that._state.filter) {
                    that._applyFilter(that._state.filter);
                }

                break;
            case 'hasThreeStates':
                if (that.selectionMode !== 'checkBox') {
                    return;
                }

                if (newValue) {
                    that._applySelection(false);
                }
                else {
                    const indeterminateItems = (that.enableShadowDOM ? that.shadowRoot : that).querySelectorAll('[indeterminate]');

                    for (let i = 0; i < indeterminateItems.length; i++) {
                        indeterminateItems[i].removeAttribute('indeterminate');
                    }
                }

                break;
            case 'loadingIndicatorPosition':
                if (newValue === 'center') {
                    that.$loadingIndicatorPlaceHolder.addClass('jqx-hidden');
                }
                else {
                    that.$loadingIndicatorPlaceHolder.removeClass('jqx-hidden');
                }

                break;
            case 'overflow':
                if (that.scrollMode === 'scrollbar') {
                    if (newValue === 'scroll') {
                        that.$.scrollViewer.verticalScrollBarVisibility = 'visible';
                    }
                    else {
                        that.$.scrollViewer.verticalScrollBarVisibility = 'auto';
                    }

                    return;
                }

                that.$.scrollViewer.scrollTop = 0;

                if (newValue === 'hidden') {
                    that.$scrollViewer.removeClass('scroll-buttons-shown');
                    that.$scrollButtonNear.addClass('jqx-hidden');
                    that.$scrollButtonFar.addClass('jqx-hidden');
                }
                else {
                    that.$.scrollButtonNear.disabled = that.disabled;
                    that.$.scrollButtonFar.disabled = that.disabled;

                    if (newValue === 'auto') {
                        that.$scrollButtonNear.addClass('jqx-hidden');
                        that.$scrollButtonFar.addClass('jqx-hidden');
                        that._checkOverflow();
                    }
                    else {
                        that.$scrollViewer.addClass('scroll-buttons-shown');
                        that.$scrollViewer.removeClass('one-button-shown');
                        that.$scrollButtonNear.removeClass('jqx-hidden');
                        that.$scrollButtonFar.removeClass('jqx-hidden');
                        that._updateScrollButtonVisibility();
                    }
                }

                that.$.scrollViewer.refresh();
                break;
            case 'rightToLeft': {
                let oldPadding, newPadding;

                if (newValue) {
                    oldPadding = 'paddingLeft';
                    newPadding = 'paddingRight';
                }
                else {
                    oldPadding = 'paddingRight';
                    newPadding = 'paddingLeft';
                }

                for (let path in that._menuItems) {
                    if (that._menuItems.hasOwnProperty(path)) {
                        const item = that._menuItems[path],
                            labelContainer = item.firstElementChild;

                        labelContainer.style[oldPadding] = '';
                        that._setIndentation(labelContainer, item.level, newPadding);
                    }
                }

                break;
            }
            case 'scrollMode':
                if (that.overflow === 'hidden') {
                    return;
                }

                that.$.scrollViewer.scrollTop = 0;

                if (newValue === 'scrollButtons') {
                    if (that.overflow === 'scroll') {
                        that.$scrollViewer.addClass('scroll-buttons-shown');
                        that.$scrollButtonNear.removeClass('jqx-hidden');
                        that.$scrollButtonFar.removeClass('jqx-hidden');
                    }

                    that.$.scrollViewer.verticalScrollBarVisibility = 'auto';
                    that._checkOverflow();
                    return;
                }

                that.$scrollViewer.removeClass('scroll-buttons-shown');
                that.$scrollViewer.removeClass('one-button-shown');
                that.$scrollButtonNear.addClass('jqx-hidden');
                that.$scrollButtonFar.addClass('jqx-hidden');

                if (that.overflow === 'auto') {
                    that.$.scrollViewer.verticalScrollBarVisibility = 'auto';
                }
                else {
                    that.$.scrollViewer.verticalScrollBarVisibility = 'visible';
                }


                break;
            case 'selectedIndexes':
                that._applySelection(false, oldValue);
                break;
            case 'selectionMode':
                if (that._menuItems['0'] === undefined) {
                    return;
                }

                if ((oldValue === 'one' && newValue !== 'none' && newValue !== 'checkBox' && newValue !== 'radioButton') ||
                    (oldValue.indexOf('oneOrMany') !== -1 && newValue.indexOf('oneOrMany') !== -1) ||
                    (oldValue === 'none' && (newValue.indexOf('zero') !== -1 || newValue === 'checkBox')) ||
                    (newValue === 'zeroOrMany' && oldValue !== 'checkBox') ||
                    (oldValue === 'radioButton' && newValue.indexOf('Many') !== -1) ||
                    (!that.hasThreeStates && (newValue === 'checkBox' ||
                        oldValue === 'checkBox' && newValue === 'zeroOrMany'))) {

                    if (newValue === 'one' || newValue === 'oneOrManyExtended') {
                        that._lastSelectedItem = that._menuItems[that.selectedIndexes[that.selectedIndexes.length - 1]];
                    }
                    else {
                        that._lastSelectedItem = undefined;
                    }

                    return;
                }

                if (that.hasThreeStates && oldValue === 'checkBox') {
                    const indeterminateItems = (that.enableShadowDOM ? that.shadowRoot : that).querySelectorAll('[indeterminate]');

                    for (let i = 0; i < indeterminateItems.length; i++) {
                        indeterminateItems[i].removeAttribute('indeterminate');
                    }
                }

                that._applySelection(false);
                break;
            case 'sort': {
                if (!that.sorted) {
                    return;
                }

                that._refreshSorting();
                break;
            }
            case 'sortDirection':
                if (that.sorted && !that.sort) {
                    that._unsortItems(that.$.mainContainer);
                    that._applyGrouping(that.$.mainContainer);
                }

                break;
            case 'sorted': {
                if (!newValue && !that.autoSort) {
                    that._refreshItemPathsAndSelection();
                    that._updateState('sorted', false);
                    return;
                }

                if (newValue) {
                    that._applyGrouping(that.$.mainContainer);
                }
                else {
                    that._unsortItems(that.$.mainContainer);
                }

                const filterQuery = that._state.filter;

                if (filterQuery) {
                    that._applyFilter(filterQuery);
                }

                that._updateState('sorted', newValue);
                that._checkOverflow();
                break;
            }
            case 'unfocusable':
                that._setFocusable();
                break;
        }
    }

    /**
     * Adds drag feedback.
     */
    _addDragFeedback() {
        const that = this,
            feedback = document.createElement('div');

        feedback.className = 'jqx-tree-item-feedback';
        feedback.setAttribute('parent-tree-id', that.id);

        if (that.theme) {
            feedback.classList.add(that.theme);
        }

        if (that.dragFeedbackFormatFunction) {
            feedback.innerHTML = that.dragFeedbackFormatFunction(that._dragDetails.Items);
        }
        else if (that._dragDetails.Items.length === 1) {
            feedback.innerHTML = that._dragDetails.Item.label;
        }
        else {
            feedback.classList.add('multiple');
            feedback.innerHTML = '&#xf0c5;';
        }

        document.body.appendChild(feedback);
        return feedback;
    }

    /**
     * Applies filter.
     */
    _applyFilter(filterQuery) {
        const that = this;

        function hide(filteredItem, item) {
            if (filteredItem) {
                if (item.hidden) {
                    item.$.removeClass('jqx-hidden');
                }

                item.hidden = false;
            }
            else {
                if (!item.hidden) {
                    item.$.addClass('jqx-hidden');
                }

                item.hidden = true;
            }
        }

        function filter(item, childItems) {
            let shownChildren = false,
                numberOfShownChildren = 0,
                lastShownChild;

            childItems = Array.from(childItems);

            // filter children
            for (let i = 0; i < childItems.length; i++) {
                const currentChild = childItems[i];

                if (currentChild instanceof JQX.TreeItem) {
                    hide(that._findItem(currentChild, filterQuery), currentChild);
                }
                else {
                    filter(currentChild, currentChild.itemContainer.children);
                }

                if (!currentChild.hidden) {
                    numberOfShownChildren++;
                    lastShownChild = currentChild;
                }

                shownChildren = shownChildren || !currentChild.hidden;
            }

            // filter the item itself
            if (item !== that.$.mainContainer) {
                const filteredItem = that._findItem(item, filterQuery);

                hide(shownChildren || filteredItem, item);

                if (shownChildren && filteredItem === null) {
                    item.$.addClass('filtered-child');
                }
                else {
                    item.$.removeClass('filtered-child');
                }

                if (!shownChildren && childItems.length > 0) {
                    item.hiddenChildren = true;
                    item.$.addClass('hidden-children');
                    that.collapseItem(item, undefined, false);
                }
                else {
                    item.hiddenChildren = false;
                    item.$.removeClass('hidden-children');
                }
            }

            if (filterQuery !== '' && numberOfShownChildren > 0) {
                lastShownChild.$.addClass('last-filtered-child');
            }
        }

        if (filterQuery === '' && !that.hasAttribute('filter-applied')) {
            return;
        }

        const lastFilteredChildren = Array.from(that.getElementsByClassName('last-filtered-child'));

        for (let i = 0; i < lastFilteredChildren.length; i++) {
            lastFilteredChildren[i].$.removeClass('last-filtered-child');
        }

        filter(that.$.mainContainer, that.$.mainContainer.children);

        if (filterQuery !== '') {
            that.setAttribute('filter-applied', '');
        }
        else {
            that.removeAttribute('filter-applied');
        }

        that._updateState('filter', filterQuery);
        that._checkOverflow();
    }

    /**
     * Applies hierarchical checkbox selection.
     */
    _applyHierarchicalSelection(item, validatedSelection) {
        const that = this,
            branch = item !== that.$.mainContainer,
            children = branch ? item.itemContainer.children : item.children;
        let selectedChildren = 0, indeterminateChildren = 0;

        for (let i = 0; i < children.length; i++) {
            const currentChild = children[i];

            if (item.selected) {
                currentChild.set('selected', true);
            }

            if (currentChild instanceof JQX.TreeItemsGroup) {
                that._applyHierarchicalSelection(currentChild, validatedSelection);
            }
            else if (currentChild.selected) {
                validatedSelection.push(currentChild.path);
            }

            if (branch) {
                if (currentChild.selected) {
                    selectedChildren++;
                }
                else if (currentChild.hasAttribute('indeterminate')) {
                    indeterminateChildren++;
                }
            }
        }

        if (!branch) {
            return;
        }

        that._setThreeStateCheckbox(item, selectedChildren, indeterminateChildren);

        if (item.selected) {
            validatedSelection.push(item.path);
        }
    }

    /**
     * Applies radio button selection.
     */
    _applyRadioButtonSelection(item, initiallySelected, validatedSelection) {
        const that = this,
            children = item !== that.$.mainContainer ? item.itemContainer.children : item.children,
            selectedChildren = [];
        let selectedSibling;

        for (let i = 0; i < children.length; i++) {
            const currentChild = children[i];

            if (currentChild instanceof JQX.TreeItemsGroup) {
                that._applyRadioButtonSelection(currentChild, initiallySelected, validatedSelection);
            }

            currentChild.set('selected', false);

            if (initiallySelected.indexOf(currentChild.path) !== -1) {
                selectedChildren.push(currentChild);
            }
        }

        if (selectedChildren.length === 0) {
            selectedSibling = children[0];
        }
        else {
            selectedSibling = selectedChildren[selectedChildren.length - 1];
        }

        selectedSibling.set('selected', true);
        validatedSelection.push(selectedSibling.path);
    }

    /**
     * Applies selection.
     */
    _applySelection(combine, oldSelectedIndexes) {
        const that = this;
        let selected = that.selectedIndexes.slice(0);

        if (oldSelectedIndexes === undefined) {
            oldSelectedIndexes = selected.slice(0);
        }

        if (that._menuItems['0'] === undefined) {
            // no items in Tree
            that.selectedIndexes = [];
            that._lastSelectedItem = undefined;

            if (that.isCompleted && JSON.stringify(oldSelectedIndexes) !== JSON.stringify([])) {
                that.$.fireEvent('change', {
                    'selectedIndexes': that.selectedIndexes,
                    'oldSelectedIndexes': oldSelectedIndexes
                });
            }

            return;
        }

        const selectionMode = that.selectionMode,
            itemsWithSelectedAttr = Array.from((that.enableShadowDOM ? that.shadowRoot : that).querySelectorAll('jqx-tree-item[selected], jqx-tree-items-group[selected]'));

        for (let i = selected.length - 1; i >= 0; i--) {
            const currentMatchingItem = that._menuItems[selected[i]];

            if (currentMatchingItem === undefined) {
                selected.splice(i, 1);
            }
        }

        if (combine) {
            for (let i = 0; i < itemsWithSelectedAttr.length; i++) {
                if (selected.indexOf(itemsWithSelectedAttr[i].path) === -1) {
                    selected.push(itemsWithSelectedAttr[i].path);
                }
            }
        }
        else {
            for (let i = 0; i < itemsWithSelectedAttr.length; i++) {
                itemsWithSelectedAttr[i].set('selected', false);
            }

            itemsWithSelectedAttr.length = 0;
        }

        that._sortPathCollection(selected);

        switch (selectionMode) {
            case 'none':
                selected.length = 0;

                for (let i = 0; i < itemsWithSelectedAttr.length; i++) {
                    itemsWithSelectedAttr[i].set('selected', false);
                }

                break;
            case 'one':
            case 'zeroOrOne':
                if (selectionMode !== 'zeroOrOne' && selected.length === 0) {
                    selected.push('0');
                }

                for (let i = 0; i < selected.length; i++) {
                    const currentMatchingItem = that._menuItems[selected[i]];

                    if (i === selected.length - 1) {
                        currentMatchingItem.set('selected', true);
                        selected = [selected[i]];
                        break;
                    }

                    if (itemsWithSelectedAttr.indexOf(currentMatchingItem) !== -1) {
                        currentMatchingItem.set('selected', false);
                    }
                }

                break;
            case 'oneOrMany':
            case 'oneOrManyExtended':
                if (selected.length === 0) {
                    selected.push('0');
                }

                for (let i = 0; i < selected.length; i++) {
                    that._menuItems[selected[i]].set('selected', true);
                }

                break;
            case 'zeroOrMany':
            case 'checkBox':
                for (let i = 0; i < selected.length; i++) {
                    that._menuItems[selected[i]].set('selected', true);
                }

                if (selectionMode === 'checkBox' && that.hasThreeStates) {
                    const validatedSelection = [];

                    that._applyHierarchicalSelection(that.$.mainContainer, validatedSelection);
                    that._sortPathCollection(validatedSelection);
                    selected = validatedSelection;
                }

                break;
            case 'radioButton': {
                const validatedSelection = [];

                that._applyRadioButtonSelection(that.$.mainContainer, selected, validatedSelection);
                that._sortPathCollection(validatedSelection);
                selected = validatedSelection;
                break;
            }
        }

        that.selectedIndexes = selected;
        that._updateState('selected');

        if (selectionMode === 'one' || selectionMode === 'oneOrManyExtended') {
            that._lastSelectedItem = that._menuItems[selected[selected.length - 1]];
        }
        else {
            that._lastSelectedItem = undefined;
        }

        if (that.isCompleted && arguments[2] !== false &&
            JSON.stringify(oldSelectedIndexes) !== JSON.stringify(selected)) {
            that.$.fireEvent('change', {
                'selectedIndexes': that.selectedIndexes,
                'oldSelectedIndexes': oldSelectedIndexes
            });
        }
    }

    /**
     * Automatically loads stored state.
     */
    _autoLoadState(state) {
        const that = this,
            selectedIndexes = [];

        for (let i = 0; i < that._menuItemsGroupsToExpand.length; i++) {
            that._menuItemsGroupsToExpand[i].set('expanded', false);
        }

        that._menuItemsGroupsToExpand = [];

        for (let i = 0; i < state.expanded.length; i++) {
            const originallyExpandedItem = that.getItem(state.expanded[i]);

            if (originallyExpandedItem) {
                that._menuItemsGroupsToExpand.push(originallyExpandedItem);
            }
        }

        if (that.filterable && state.filter) {
            that._applyFilter(state.filter);
            that.$.filterInput.value = state.filter;
        }

        for (let i = 0; i < state.selected.length; i++) {
            const originallySelectedItem = that.getItem(state.selected[i]);

            if (originallySelectedItem) {
                selectedIndexes.push(originallySelectedItem.path);
            }
        }

        that.selectedIndexes = selectedIndexes;
    }

    /**
     * blur handler.
     */
    _blurHandler() {
        this._discardKeyboardHover(true);
    }

    /**
     * Checks if an item can be hovered.
     */
    _canItemBeHovered(item) {
        const level = item.level;

        return item.disabled === false &&
            item.templateApplied !== true &&
            item.hidden !== true &&
            (level === 1 ||
                level > 1 &&
                this._isContainerOpened(level, item.parentElement.container) &&
                item.getBoundingClientRect().height > 0);
    }

    /**
     * Checks if an item can be selected.
     */
    _canItemBeSelected(item) {
        return item.disabled === false && item.templateApplied !== true;
    }

    /**
     * Checks if items overflow and shows/hides scroll buttons.
     */
    _checkOverflow() {
        const that = this,
            scrollViewer = that.$.scrollViewer,
            overflow = that.overflow;

        if (that.scrollMode === 'scrollbar' || overflow === 'hidden') {
            scrollViewer.refresh();
            return;
        }

        const oldScrollTop = scrollViewer.scrollTop;

        if (overflow === 'auto') {
            scrollViewer.$.removeClass('scroll-buttons-shown');
            scrollViewer.$.removeClass('one-button-shown');
            that.$scrollButtonNear.addClass('jqx-hidden');
            that.$scrollButtonFar.addClass('jqx-hidden');
        }

        const overflowing = Math.round(scrollViewer.$.scrollViewerContentContainer.offsetHeight) >
            Math.round(scrollViewer.$.scrollViewerContainer.offsetHeight),
            showNear = Math.round(scrollViewer.scrollTop) > 0,
            showFar = Math.round(scrollViewer.$.scrollViewerContainer.offsetHeight + scrollViewer.scrollTop) <
                Math.round(scrollViewer.$.scrollViewerContentContainer.offsetHeight);

        if (overflowing) {
            if (overflow === 'auto') {
                scrollViewer.$.addClass('scroll-buttons-shown');

                if (showNear) {
                    that.$scrollButtonNear.removeClass('jqx-hidden');
                }

                if (showFar) {
                    that.$scrollButtonFar.removeClass('jqx-hidden');
                }

                if ((showNear && showFar) === false) {
                    scrollViewer.$.addClass('one-button-shown');
                }

                if (!that.disabled) {
                    that.$.scrollButtonNear.disabled = false;
                    that.$.scrollButtonFar.disabled = false;
                }

                scrollViewer.scrollTop = oldScrollTop;
            }
            else {
                that.$scrollButtonNear.removeClass('jqx-hidden');
                that.$scrollButtonFar.removeClass('jqx-hidden');

                if (that.disabled) {
                    that.$.scrollButtonNear.disabled = true;
                    that.$.scrollButtonFar.disabled = true;
                }
                else {
                    that.$.scrollButtonNear.disabled = !showNear;
                    that.$.scrollButtonFar.disabled = !showFar;
                }
            }
        }
        else if (overflow === 'scroll') {
            that.$.scrollButtonNear.disabled = true;
            that.$.scrollButtonFar.disabled = true;
        }

        scrollViewer.refresh();
    }

    /**
     * Applies initial settings to the Tree element.
     */
    _createElement() {
        const that = this,
            scrollViewerStyle = window.getComputedStyle(that.$.scrollViewer);

        that.$.scrollViewer.onVerticalChange = that._verticalScrollbarHandler;

        Object.defineProperty(that, 'dataSource', {
            get: function () {
                if (that.context === that) {
                    return that.properties.dataSource.value;
                }
                else {
                    return that._getDataSource();
                }
            },
            set(value) {
                that.updateProperty(that, that._properties.dataSource, value);
            }
        });

        if (!that.id && (that.autoLoadState || that.autoSaveState)) {
            that.warn(that.localize('noId'));
            that.autoLoadState = false;
            that.autoSaveState = false;
        }

        that.mode = 'tree';
        that._element = 'tree';
        that._isMobile = JQX.Utilities.Core.isMobile;
        that._edgeMacFF = false;
        that._autoScrollCoefficient = JQX.Utilities.Core.Browser.Firefox ? 4 : JQX.Utilities.Core.Browser.Edge ? 8 : 2;
        that._scrollViewerPadding = (parseFloat(scrollViewerStyle.paddingTop) + parseFloat(scrollViewerStyle.paddingBottom)) || 0;
        that._state = { expanded: [], filter: '', selected: [] };
        that._dblclickObject = { numberOfClicks: 0 };

        if (that.autoHideToggleElement) {
            that.$mainContainer.addClass('hidden-arrows');
        }

        if (that.disabled) {
            that.$.scrollButtonNear.disabled = true;
            that.$.scrollButtonFar.disabled = true;
        }

        if (that.scrollMode === 'scrollbar' && that.overflow === 'scroll') {
            that.$.scrollViewer.verticalScrollBarVisibility = 'visible';
        }

        if (that.dataSource === null && that.$.mainContainer.firstElementChild instanceof HTMLUListElement) {
            that._processUList();
        }

        const items = that.getElementsByTagName('jqx-tree-item');

        const itemsReady = function () {
            let previousState;

            if (that.autoLoadState) {
                previousState = window.localStorage.getItem('jqxTree' + that.id);

                if (previousState) {
                    previousState = JSON.parse(previousState);
                    that.sorted = previousState.sorted;
                }
            }

            that._setFocusable();

            that._menuItems = {};

            if (that.dataSource === null) {
                that._processHTML(that.$.mainContainer, 1);
            }
            else {
                // Task (3)
                that._processDataSource();
            }

            if (that.scrollMode === 'scrollButtons' && that.overflow === 'scroll') {
                that.$scrollViewer.addClass('scroll-buttons-shown');
                that.$scrollButtonNear.removeClass('jqx-hidden');
                that.$scrollButtonFar.removeClass('jqx-hidden');
                that._updateScrollButtonVisibility();
            }

            that._checkOverflow();

            if (previousState) {
                that._autoLoadState(previousState);
            }

            that._expandItemsByDefault();
            that._applySelection(true);

            that._updateState('sorted', that.sorted);

            if (that.displayLoadingIndicator) {
                that.$loadingIndicatorContainer.removeClass('jqx-hidden');
            }

            if (that.loadingIndicatorPosition !== 'center') {
                that.$loadingIndicatorPlaceHolder.removeClass('jqx-hidden');
            }

            if (that.__onCompleted) {
                that._onCompleted = that.__onCompleted;
                that.__onCompleted = null;
                that._onCompleted();
            }
        }

        if (items.length === 0) {
            itemsReady();
        }
        else {
            if (that._onCompleted) {
                that.__onCompleted = that._onCompleted;
                that._onCompleted = null;
            }
            that._ensureItemsReady(items, itemsReady);
        }
    }

    /**
     * dblclick handler.
     */
    _dblclickHandler(pressedItem, arrow, event) {
        const that = this;

        if (that.toggleMode !== 'dblclick' || pressedItem instanceof JQX.TreeItem || arrow) {
            return;
        }

        that._menuItemsGroupSelectionHandler(pressedItem, event);
    }

    /**
     * Removes "focused" class added by keyboard navigation.
     */
    _discardKeyboardHover(overrideCheck, mouseoutMouseover) {
        const that = this;

        if (mouseoutMouseover || !that._hoveredViaKeyboard) {
            return;
        }

        if (!overrideCheck &&
            that._hoveredViaKeyboard instanceof JQX.MenuItemsGroup &&
            that._isContainerOpened(that._hoveredViaKeyboard.level + 1, that._hoveredViaKeyboard.container)) {
            return;
        }

        that._hoveredViaKeyboard.removeAttribute('focus');
        that._hoveredViaKeyboard = undefined;
    }

    /**
     * Document up handler.
     */
    _documentUpHandler(event) {
        const that = this,
            downItem = that._downItem,
            upTarget = that.enableShadowDOM ? event.originalEvent.composedPath()[0] : event.originalEvent.target;

        delete that._downItem;

        if (that._editedItem && !that._editInputDown &&
            (!that._isMobile && upTarget !== that.$.editInput ||
                that._isMobile && (document.elementFromPoint(event.clientX, event.clientY) !== that.$.editInput))) {

            that._endEditing();
            return;
        }

        delete that._editInputDown;

        if (downItem) {
            const pressedItem = upTarget.closest('jqx-tree-item') || upTarget.closest('jqx-tree-items-group');

            if (pressedItem && pressedItem.selected && pressedItem === downItem &&
                (!that._dragDetails || !that._dragDetails.FeedbackShown) &&
                !(pressedItem instanceof JQX.TreeItemsGroup && (upTarget.closest('.jqx-tree-items-group-arrow') ||
                    upTarget === pressedItem.container || upTarget === pressedItem.container.firstElementChild))) {

                that._handleSelection(pressedItem, event);
            }
        }

        const dragDetails = that._dragDetails;

        if (!dragDetails) {
            return;
        }

        const targetTree = JQX.Tree.hoveredTree,
            targetItem = JQX.Tree.hoveredItem;

        delete that._dragDetails;
        delete JQX.Tree.treeItemDragged;
        delete JQX.Tree.hoveredTree;
        delete JQX.Tree.hoveredItem;
        that.$.scrollViewer._scrollView.disableSwipeScroll = false;

        if (!dragDetails.FeedbackShown) {
            return;
        }

        const dropTarget = targetTree || document.elementFromPoint(event.clientX, event.clientY);
        let position;

        document.body.classList.remove('jqx-dragging');
        document.body.removeChild(dragDetails.Feedback);

        if (targetTree) {
            clearInterval(targetTree._dragInterval);
        }

        const draggedItem = dragDetails.Item,
            draggedItems = dragDetails.Items,
            validDraggedItems = dragDetails.ValidItems;

        if (!dropTarget) {
            return;
        }

        if (!targetItem || draggedItem.contains(targetItem)) {
            // drops item somewhere in the DOM
            that.$.fireEvent('dragEnd', {
                'item': draggedItem,
                'items': draggedItems,
                'target': dropTarget,
                'data': dragDetails,
                'previousContainer': that,
                'container': targetTree || dropTarget,
                'originalEvent': event
            });
            return;
        }

        if (!(targetTree && targetTree.allowDrop && !targetTree.disabled)) {
            return;
        }

        const affectedTrees = [targetTree];
        let dropDetailsPosition;

        targetItem.classList.remove('drop-target');

        if (targetItem.classList.contains('top')) {
            targetItem.classList.remove('top');
            dropDetailsPosition = 'top';
            position = 0;
        }
        else if (targetItem.classList.contains('bottom')) {
            targetItem.classList.remove('bottom');
            dropDetailsPosition = 'bottom';
            position = 2;
        }
        else {
            dropDetailsPosition = 'inside';
            position = 1;
        }

        dragDetails.DropDetails = { item: targetItem, position: dropDetailsPosition };

        if (targetTree !== that) {
            affectedTrees.push(that);
        }
        else if (dragDetails.ValidateOnDrop) {
            // drop inside the same tree
            for (let i = 0; i < validDraggedItems.length; i++) {
                if (validDraggedItems[i].contains(targetItem)) {
                    return;
                }
            }
        }

        const dragEndEvent = that.$.fireEvent('dragEnd', {
            'item': draggedItem,
            'items': draggedItems,
            'target': targetItem,
            'data': dragDetails,
            'previousContainer': that,
            'container': targetTree,
            'originalEvent': event
        });

        if (dragEndEvent.defaultPrevented) {
            return;
        }

        if (targetTree.sorted && targetTree.autoSort) {
            targetTree._unsortItems(targetTree.$.mainContainer);
        }

        for (let i = 0; i < validDraggedItems.length; i++) {
            that._moveTreeItem(validDraggedItems[i], targetItem, position, affectedTrees);
        }

        if (targetTree.sorted && targetTree.autoSort) {
            targetTree._applyGrouping(targetTree.$.mainContainer);
        }

        if (targetTree !== that && targetTree._state.filter) {
            targetTree._applyFilter(targetTree._state.filter);
        }
    }

    /**
     * editInput blur handler.
     */
    _editInputBlurHandler() {
        this._endEditing();
    }

    /**
     * Ends editing operation.
     */
    _endEditing(discardChanges) {
        const that = this,
            editedItem = that._editedItem;

        if (!editedItem) {
            return;
        }

        delete that._editedItem;
        that.$editInput.addClass('jqx-hidden');
        that.focus();

        if (discardChanges) {
            return;
        }

        const newValue = that.$.editInput.value,
            restoreSorting = that.sorted && that.autoSort,
            filterQuery = that._state.filter;

        if (newValue === editedItem.label) {
            return;
        }

        editedItem.set('label', newValue);
        editedItem.firstElementChild.firstElementChild.firstElementChild.innerHTML = newValue;

        if (restoreSorting) {
            that._unsortItems(that.$.mainContainer);
            that._applyGrouping(that.$.mainContainer);
        }

        if (filterQuery) {
            that._applyFilter(filterQuery);
        }
    }

    /**
     * Makes sure an item is visible by scrolling to it.
     */
    _ensureVisible(item) {
        const that = this;

        that._ensureVisibleTreeMode(item, item.getBoundingClientRect(), that.$.scrollViewer,
            that.$.scrollViewer.getBoundingClientRect(), that._scrollViewerPadding);

        //Used in GanttChart to ensure the TaskBar inside the Timeline is also visible
        if (that._ensureVisibleCallback) {
            that._ensureVisibleCallback(item);
        }
    }

    /**
     * filterInput keydown handler.
     */
    _filterInputKeydownHandler(event) {
        if (event.key !== 'PageDown') {
            if (event.key === 'PageUp') {
                event.preventDefault();
                event.stopPropagation();
            }

            return;
        }

        const that = this;
        let itemToHighlight;

        event.preventDefault();
        event.stopPropagation();

        if (that.selectedIndexes.length > 0) {
            const oldSelectedIndexes = that.selectedIndexes.slice(0);

            itemToHighlight = that._lastSelectedItem || that._menuItems[that.selectedIndexes[that.selectedIndexes.length - 1]];

            if (that.selectionMode !== 'checkBox' && that.selectionMode !== 'radioButton') {
                that.selectedIndexes = [itemToHighlight.path];
                that._applySelection(false, oldSelectedIndexes);
            }

            that.focus();
        }
        else {
            itemToHighlight = that._getFirstEnabledChild(that.$.mainContainer);
            that.focus();

            if (itemToHighlight) {
                that._hoverViaKeyboard(itemToHighlight);
            }
        }

        that._ensureVisible(itemToHighlight);
    }

    /**
     * focus handler.
     */
    _focusHandler() {
        const that = this;

        if (that.selectedIndexes.length > 0 && !that._hoveredViaKeyboard) {
            if (that._lastSelectedItem) {
                that._hoverViaKeyboard(that._lastSelectedItem, false, undefined, false);
            }
            else {
                that._hoverViaKeyboard(that._menuItems[that.selectedIndexes[that.selectedIndexes.length - 1]], false, undefined, false);
            }
        }
    }

    /**
     * Gets a JSON representation of the current Tree state.
     */
    _getDataSource() {
        const that = this,
            dataSource = [];

        function recursion(children, itemsArray) {
            for (let i = 0; i < children.length; i++) {
                const currentChild = children[i],
                    dataSourceItem = { label: currentChild.label };

                if (currentChild.disabled) {
                    dataSourceItem.disabled = true;
                }

                if (currentChild.selected) {
                    dataSourceItem.selected = true;
                }

                if (currentChild.separator) {
                    dataSourceItem.separator = true;
                }

                if (currentChild.value !== null) {
                    dataSourceItem.value = currentChild.value;
                }

                if (currentChild instanceof JQX.TreeItem) {
                    if (currentChild.shortcut) {
                        dataSourceItem.shortcut = currentChild.shortcut;
                    }
                }
                else {
                    if (currentChild.expanded) {
                        dataSourceItem.expanded = true;
                    }

                    dataSourceItem.items = [];
                    recursion(currentChild.itemContainer.children, dataSourceItem.items);
                }

                itemsArray.push(dataSourceItem);
            }
        }

        recursion(that.$.mainContainer.children, dataSource);

        return dataSource;
    }

    /**
     * Handles hierarchical checkbox selection.
     */
    _handleHierarchicalSelection(item, selectedIndexes) {
        function checkUncheckChildren(item, check) {
            const children = item.itemContainer.children;

            for (let i = 0; i < children.length; i++) {
                const currentChild = children[i];

                currentChild.set('selected', check);
                currentChild.removeAttribute('indeterminate');

                if (currentChild instanceof JQX.TreeItemsGroup) {
                    checkUncheckChildren(currentChild, check);
                }
            }
        }

        const that = this;
        let currentItem = item;

        if (item.selected) {
            item.set('selected', false);
        }
        else {
            item.set('selected', true);
            item.removeAttribute('indeterminate');
        }

        while (currentItem.parentItem) {
            const parent = currentItem.parentItem,
                children = parent.itemContainer.children;
            let selectedChildren = 0, indeterminateChildren = 0;

            for (let i = 0; i < children.length; i++) {
                if (children[i].selected) {
                    selectedChildren++;
                }
                else if (children[i].hasAttribute('indeterminate')) {
                    indeterminateChildren++;
                }
            }

            that._setThreeStateCheckbox(parent, selectedChildren, indeterminateChildren);

            currentItem = parent;
        }

        if (item instanceof JQX.TreeItemsGroup) {
            checkUncheckChildren(item, item.selected);
        }

        selectedIndexes.length = 0;

        const selectedItems = Array.from((that.enableShadowDOM ? that.shadowRoot : that).querySelectorAll('[selected]'));

        for (let i = 0; i < selectedItems.length; i++) {
            selectedIndexes.push(selectedItems[i].path);
        }

        that._sortPathCollection(selectedIndexes);
    }

    /**
     * Handles item selection.
     */
    _handleSelection(item, event) {
        const that = this,
            selectionMode = that.selectionMode;

        if (selectionMode === 'none' ||
            (event.type !== 'programmatic' && !that._canItemBeSelected(item))) {
            return;
        }

        const selected = item.selected;

        if (selected && event.type === 'down') {
            return;
        }

        const oldSelectedIndexes = that.selectedIndexes.slice(0);
        let selectedIndexes = oldSelectedIndexes.slice(0);

        switch (selectionMode) {
            case 'one':
                if (selected) {
                    return;
                }

                that._menuItems[selectedIndexes[0]].set('selected', false);
                that.selectedIndexes = [item.path];
                item.set('selected', true);
                that._lastSelectedItem = item;
                break;
            case 'zeroOrOne':
                if (selected) {
                    that.selectedIndexes = [];
                    item.set('selected', false);
                }
                else {
                    if (selectedIndexes[0] !== undefined) {
                        that._menuItems[selectedIndexes[0]].set('selected', false);
                    }

                    that.selectedIndexes = [item.path];
                    item.set('selected', true);
                }

                break;
            case 'oneOrMany':
            case 'zeroOrMany':
                if (selected) {
                    if (selectedIndexes.length === 1 && selectionMode !== 'zeroOrMany') {
                        return;
                    }

                    selectedIndexes.splice(selectedIndexes.indexOf(item.path), 1);
                    item.set('selected', false);
                }
                else {
                    selectedIndexes.push(item.path);
                    that._sortPathCollection(selectedIndexes);
                    item.set('selected', true);
                }

                that.selectedIndexes = selectedIndexes;
                break;
            case 'oneOrManyExtended': {
                const ctrlKey = event.ctrlKey,
                    shiftKey = event.shiftKey;

                if (!ctrlKey && !shiftKey ||
                    shiftKey && item === that._lastSelectedItem) {
                    for (let i = 0; i < selectedIndexes.length; i++) {
                        that._menuItems[selectedIndexes[i]].set('selected', false);
                    }

                    selectedIndexes = [item.path];
                    item.set('selected', true);
                    that._lastSelectedItem = item;
                }
                else if (ctrlKey) {
                    if (item.selected && selectedIndexes.length > 1) {
                        selectedIndexes.splice(selectedIndexes.indexOf(item.path), 1);
                        item.set('selected', false);
                    }
                    else if (!item.selected) {
                        selectedIndexes.push(item.path);
                        that._sortPathCollection(selectedIndexes);
                        item.set('selected', true);
                        that._lastSelectedItem = item;
                    }
                }
                else if (shiftKey) {
                    for (let i = 0; i < selectedIndexes.length; i++) {
                        that._menuItems[selectedIndexes[i]].set('selected', false);
                    }

                    selectedIndexes = that._selectItemRange(that._lastSelectedItem, item);
                }

                that.selectedIndexes = selectedIndexes;
                break;
            }
            case 'checkBox':
                if (that.hasThreeStates) {
                    that._handleHierarchicalSelection(item, selectedIndexes);
                }
                else {
                    if (selected) {
                        selectedIndexes.splice(selectedIndexes.indexOf(item.path), 1);
                        item.set('selected', false);
                    }
                    else {
                        selectedIndexes.push(item.path);
                        that._sortPathCollection(selectedIndexes);
                        item.set('selected', true);
                    }
                }

                that.selectedIndexes = selectedIndexes;
                break;
            case 'radioButton': {
                if (item.selected) {
                    return;
                }

                let selectedSibling;

                for (let i = 0; i < item.parentElement.children.length; i++) {
                    const currentSibling = item.parentElement.children[i];

                    if (currentSibling.selected) {
                        selectedSibling = currentSibling;
                        break;
                    }
                }

                const selectedSiblingIndex = selectedIndexes.indexOf(selectedSibling.path);

                selectedSibling.set('selected', false);
                item.set('selected', true);
                selectedIndexes.splice(selectedSiblingIndex, 1);
                selectedIndexes.push(item.path);
                that._sortPathCollection(selectedIndexes);
                that.selectedIndexes = selectedIndexes;
                break;
            }
        }

        that._discardKeyboardHover(true);
        that._hoverViaKeyboard(item, false, undefined, !that._treeAnimationInProgress);
        that._updateState('selected');

        if (JSON.stringify(oldSelectedIndexes) !== JSON.stringify(that.selectedIndexes)) {
            //Will prevent 'change' firing on ready() of the ownerElement
            if (that.ownerElement && !that.ownerElement.isCompleted) {
                return;
            }

            that.$.fireEvent('change', {
                'item': item,
                'selectedIndexes': that.selectedIndexes,
                'oldSelectedIndexes': oldSelectedIndexes
            });
        }
    }

    /**
     * Highlights an item via the keyboard.
     */
    _hoverViaKeyboard(item, selectOnHover, event, ensureVisible) {
        if (!item) {
            return;
        }

        const that = this;

        item.setAttribute('focus', '');
        that._hoveredViaKeyboard = item;

        if (ensureVisible !== false) {
            that._ensureVisible(item);
        }

        if (selectOnHover) {
            that._handleSelection(item, event);
        }

        //NOTE: Used in GanttChart in order to handle Task Tree item focus state
        if (that._hoverViaKeyboardCallback) {
            that._hoverViaKeyboardCallback(item);
        }
    }

    /**
     * Keydown event handler.
     */
    _keydownHandler(event) {
        const that = this,
            key = event.key;

        if (that._editedItem) {
            if (key === 'Enter') {
                that._endEditing();
            }
            else if (key === 'Escape') {
                that._endEditing(true);
            }

            return;
        }

        if (document.activeElement !== that ||
            ['ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'End', 'Enter', 'F2', 'Home', 'PageDown', 'PageUp', ' '].indexOf(key) === -1 ||
            that.disabled || that.displayLoadingIndicator) {
            return;
        }

        event.preventDefault();

        const treeItems = Array.from(that.$.mainContainer.querySelectorAll('jqx-tree-item, jqx-tree-items-group')),
            selectOnHover = that.selectionMode === 'one' || that.selectionMode === 'oneOrManyExtended' && !event.ctrlKey,
            highlightedItem = that.$.mainContainer.querySelector('[focus]');

        function moveDown(startIndex) {
            for (let i = startIndex; i < treeItems.length; i++) {
                const currentItem = treeItems[i];

                if (that._canItemBeHovered(currentItem)) {
                    if (highlightedItem) {
                        if (highlightedItem === currentItem) {
                            break;
                        }

                        highlightedItem.removeAttribute('focus');
                    }

                    that._hoverViaKeyboard(currentItem, selectOnHover, event);
                    break;
                }
            }
        }

        function moveUp(startIndex) {
            for (let i = startIndex; i >= 0; i--) {
                const currentItem = treeItems[i];

                if (that._canItemBeHovered(currentItem)) {
                    if (highlightedItem) {
                        if (highlightedItem === currentItem) {
                            break;
                        }

                        highlightedItem.removeAttribute('focus');
                    }

                    that._hoverViaKeyboard(currentItem, selectOnHover, event);
                    break;
                }
            }
        }

        function navigateToParentItem() {
            if (highlightedItem.level > 1) {
                highlightedItem.removeAttribute('focus');
                that._hoverViaKeyboard(highlightedItem.parentItem, selectOnHover, event);
            }
        }

        let startIndex;

        switch (key) {
            case 'ArrowDown':
                if (highlightedItem) {
                    startIndex = treeItems.indexOf(highlightedItem) + 1;
                }
                else {
                    startIndex = 0;
                }

                moveDown(startIndex);
                break;
            case 'ArrowLeft':
                if (!highlightedItem) {
                    return;
                }

                if (highlightedItem instanceof JQX.TreeItem) {
                    navigateToParentItem();
                }
                else {
                    if (that._isContainerOpened(highlightedItem.level + 1, highlightedItem.container)) {
                        that._closeSubContainersTreeMode(highlightedItem.level + 1, highlightedItem.container, true, true);
                        return;
                    }

                    navigateToParentItem();
                }
                break;
            case 'ArrowRight':
                if (!highlightedItem || highlightedItem instanceof JQX.TreeItem) {
                    return;
                }

                if (that._isContainerOpened(highlightedItem.level + 1, highlightedItem.container)) {
                    highlightedItem.removeAttribute('focus');
                    that._hoverViaKeyboard(that._getFirstEnabledChild(highlightedItem.itemContainer), selectOnHover, event);
                }
                else {
                    that._menuItemsGroupSelectionHandler(highlightedItem, { target: highlightedItem, type: 'keydown' });
                }

                break;
            case 'ArrowUp':
                if (highlightedItem) {
                    startIndex = treeItems.indexOf(highlightedItem) - 1;
                }
                else {
                    startIndex = treeItems.length - 1;
                }

                moveUp(startIndex);
                break;
            case 'End':
                moveUp(treeItems.length - 1);
                break;
            case 'Enter':
                if (highlightedItem && highlightedItem instanceof JQX.TreeItemsGroup) {
                    that._menuItemsGroupSelectionHandler(highlightedItem, { target: highlightedItem, type: 'keydown' });
                }

                break;
            case 'F2':
                if (that.editable) {
                    that._startEditing(highlightedItem);
                }

                break;
            case 'Home':
                moveDown(0);
                break;
            case 'PageDown':
                that._pageDownHandler(treeItems, highlightedItem, selectOnHover, event);
                break;
            case 'PageUp':
                that._pageUpHandler(treeItems, highlightedItem, selectOnHover, event);
                break;
            case ' ':
                if (highlightedItem) {
                    that._handleSelection(highlightedItem, event);
                }

                break;
        }
    }

    /**
     * mainContainer swipeleft/swiperight handler.
     */
    _mainContainerSwipeHandler(event) {
        if (JQX.Tree.treeItemDragged) {
            event.stopPropagation();
        }
    }

    /**
     * jqx-menu-items-group selection handler.
     */
    _menuItemsGroupSelectionHandler(closestItemsGroup, event, fireEvent) {
        const that = this,
            toggleMode = that.toggleMode,
            arrow = event.originalEvent ? event.originalEvent.target.classList.contains('jqx-tree-items-group-arrow') : false,
            container = closestItemsGroup.container;

        if (that._waitAnimation && that._treeAnimationInProgress === container) {
            return;
        }

        if (event.type === 'down' && !arrow && (toggleMode !== 'dblclick' || that._dblclickObject.numberOfClicks === 1)) {
            that._handleSelection(closestItemsGroup, event);
        }

        if (event.type === 'down' && !arrow &&
            (toggleMode === 'dblclick' && that._dblclickObject.numberOfClicks !== 2 ||
                toggleMode === 'click' && that._dblclickObject.numberOfClicks > 1 ||
                toggleMode === 'arrow') ||
            closestItemsGroup.hiddenChildren) {
            return;
        }

        const level = container.level;
        let animation = that.hasAnimation;

        if (event.type === 'keydown') {
            that._discardKeyboardHover();
        }

        if (that._treeAnimationInProgress) {
            container.removeEventListener('transitionend', that._transitionendHandlerExpand);
            container.removeEventListener('transitionend', that._transitionendHandlerCollapse);
        }

        if (that._isContainerOpened(level, container)) {
            that._closeSubContainersTreeMode(level, container, true, fireEvent !== false);
        }
        else {
            const expandingEvent = that.$.fireEvent('expanding', {
                'item': closestItemsGroup,
                'label': closestItemsGroup.label,
                'path': closestItemsGroup.path,
                'value': closestItemsGroup.value,
                'children': closestItemsGroup.itemContainer.children
            });

            if (expandingEvent.defaultPrevented) {
                return;
            }

            if (animation) {
                if (event.type !== 'expand') {
                    that._ensureVisibleOnTransitionend = closestItemsGroup;
                }

                that._expandSection(container);
            }

            container.$.removeClass('jqx-visibility-hidden');

            if (event.type === 'keydown') {
                closestItemsGroup.setAttribute('focus', '');
                that._hoveredViaKeyboard = closestItemsGroup;
            }

            closestItemsGroup.$.addClass('jqx-tree-items-group-opened');
            closestItemsGroup.$.addClass('jqx-tree-items-group-expanded');

            that._addOpenedContainer(level, container);

            if (event.type === undefined) {
                that._hoverViaKeyboard(that._getFirstEnabledChild(closestItemsGroup.itemContainer));
            }

            if (fireEvent !== false) {
                const eventDetail = {
                    'item': closestItemsGroup,
                    'label': closestItemsGroup.label,
                    'path': closestItemsGroup.path,
                    'value': closestItemsGroup.value,
                    'children': closestItemsGroup.itemContainer.children
                };

                if (that.toggleCallback) {
                    eventDetail.type = 'expand';
                    that.toggleCallback(eventDetail);
                }
                else {
                    that.$.fireEvent('expand', eventDetail);
                }
            }
        }

        if (!animation) {
            that._checkOverflow();

            if (event.type !== 'expand') {
                that._ensureVisible(closestItemsGroup);
            }
        }
    }

    /**
     * mouseenter handler.
     */
    _mouseenterHandler() {
        const that = this;

        if (that.autoHideToggleElement) {
            that.$mainContainer.removeClass('hidden-arrows');
        }

        if (JQX.Tree.treeItemDragged && that.allowDrop && !that.disabled) {
            JQX.Tree.hoveredTree = that;
        }
    }

    /**
     * mouseleave handler.
     */
    _mouseleaveHandler() {
        const that = this;

        if (that.autoHideToggleElement) {
            that.$mainContainer.addClass('hidden-arrows');
        }

        if (JQX.Tree.treeItemDragged) {
            if (JQX.Tree.hoveredTree) {
                clearInterval(JQX.Tree.hoveredTree._dragInterval);
                delete JQX.Tree.hoveredTree;
            }

            const hoveredItem = JQX.Tree.hoveredItem;

            if (hoveredItem) {
                hoveredItem.classList.remove('drop-target');
                hoveredItem.classList.remove('top');
                hoveredItem.classList.remove('bottom');
                delete JQX.Tree.hoveredItem;
            }
        }
    }

    /**
     * Move handler.
     */
    _moveHandler(event) {
        const that = this,
            dragDetails = that._dragDetails;

        if (!dragDetails) {
            return;
        }

        if (!dragDetails.FeedbackShown) {
            if (Math.abs(dragDetails.StartPosition.left - event.pageX) > 5 ||
                Math.abs(dragDetails.StartPosition.top - event.pageY) > 5) {

                const dragStartEvent = that.$.fireEvent('dragStart', {
                    'item': dragDetails.Item,
                    'items': dragDetails.Items,
                    'data': dragDetails,
                    'container': that,
                    'previousContainer': that,
                    'originalEvent': dragDetails.OriginalEvent
                });

                if (dragStartEvent.defaultPrevented) {
                    delete that._dragDetails;
                    delete JQX.Tree.treeItemDragged;
                    delete JQX.Tree.hoveredTree;
                    delete JQX.Tree.hoveredItem;
                    that.$.scrollViewer._scrollView.disableSwipeScroll = false;
                    return;
                }

                document.body.classList.add('jqx-dragging');
                dragDetails.Feedback = that._addDragFeedback();
                dragDetails.FeedbackShown = true;
            }
            else {
                return;
            }
        }

        const dragOffset = that.dragOffset;
        let hoveredTree, target, hoveredItem;

        that.$.fireEvent('dragging', {
            'item': dragDetails.Item,
            'items': dragDetails.Items,
            'data': dragDetails,
            'originalEvent': event
        });

        dragDetails.Feedback.style.left = (event.pageX + dragOffset[0]) + 'px';
        dragDetails.Feedback.style.top = (event.pageY + dragOffset[1]) + 'px';

        if (that._isMobile) {
            const oldHoveredItem = JQX.Tree.hoveredItem;

            if (oldHoveredItem) {
                oldHoveredItem.classList.remove('drop-target');
                oldHoveredItem.classList.remove('top');
                oldHoveredItem.classList.remove('bottom');
                delete JQX.Tree.hoveredItem;
            }

            const realTarget = document.elementFromPoint(event.clientX, event.clientY);

            if (JQX.Tree.hoveredTree) {
                clearInterval(JQX.Tree.hoveredTree._dragInterval);
                delete JQX.Tree.hoveredTree;
            }

            if (realTarget) {
                hoveredTree = realTarget.closest('jqx-tree');

                if (hoveredTree && hoveredTree.allowDrop) {
                    JQX.Tree.hoveredTree = hoveredTree;
                    target = realTarget.closest('jqx-tree-item') || realTarget.closest('jqx-tree-items-group');

                    if (target) {
                        hoveredItem = target;
                    }
                    else {
                        target = realTarget;
                    }
                }
            }
        }

        hoveredTree = JQX.Tree.hoveredTree;

        if (!hoveredTree) {
            return;
        }

        const filterInputHeight = hoveredTree.filterable ? hoveredTree.$.filterInput.offsetHeight + 10 : 0;

        clearInterval(hoveredTree._dragInterval);
        hoveredTree._dragInterval = setInterval(function () {
            const rect = hoveredTree.getBoundingClientRect();

            if (hoveredTree.$.scrollViewer.scrollHeight > 0 &&
                rect.left <= event.clientX && rect.left + rect.width >= event.clientX) {
                if (event.clientY >= rect.top + filterInputHeight && event.clientY <= rect.top + 20 + filterInputHeight) {
                    hoveredTree.$.scrollViewer.scrollTop -= that._autoScrollCoefficient;

                    if (hoveredTree.scrollMode === 'scrollButtons') {
                        hoveredTree._updateScrollButtonVisibility();
                    }
                }
                else if (event.clientY >= rect.top + rect.height - 20 && event.clientY <= rect.top + rect.height) {
                    hoveredTree.$.scrollViewer.scrollTop += that._autoScrollCoefficient;

                    if (hoveredTree.scrollMode === 'scrollButtons') {
                        hoveredTree._updateScrollButtonVisibility();
                    }
                }
                else {
                    clearInterval(hoveredTree._dragInterval);
                }
            }
            else {
                clearInterval(hoveredTree._dragInterval);
            }
        }, 1);

        if (!that._isMobile) {
            target = event.originalEvent.target;

            if (target && target.enableShadowDOM) {
                target = event.originalEvent.composedPath()[0];
            }

            if (target && target.closest) {
                hoveredItem = target.closest('jqx-tree-item') || target.closest('jqx-tree-items-group');
            }
        }

        if (hoveredItem) {
            if (JQX.Tree.hoveredItem && hoveredItem !== JQX.Tree.hoveredItem) {
                JQX.Tree.hoveredItem.classList.remove('drop-target');
                JQX.Tree.hoveredItem.classList.remove('top');
                JQX.Tree.hoveredItem.classList.remove('bottom');
            }

            JQX.Tree.hoveredItem = hoveredItem;

            if (dragDetails.Item.contains(hoveredItem)) {
                return;
            }

            const hoveredItemRect = hoveredItem.getBoundingClientRect();

            if (hoveredItem instanceof JQX.TreeItem) {
                if (event.clientY - hoveredItemRect.top <= hoveredItemRect.height / 2) {
                    hoveredItem.classList.remove('bottom');
                    hoveredItem.classList.add('top');
                }
                else {
                    hoveredItem.classList.remove('top');
                    hoveredItem.classList.add('bottom');
                }
            }
            else {
                if (event.clientY - hoveredItemRect.top <= 10) {
                    hoveredItem.classList.remove('bottom');
                    hoveredItem.classList.add('top');
                }
                else if (!hoveredItem.expanded && hoveredItemRect.bottom - event.clientY <= 10) {
                    hoveredItem.classList.remove('top');
                    hoveredItem.classList.add('bottom');
                }
                else {
                    hoveredItem.classList.remove('top');
                    hoveredItem.classList.remove('bottom');
                }
            }

            hoveredItem.classList.add('drop-target');
        }
        else {
            if (JQX.Tree.hoveredItem) {
                JQX.Tree.hoveredItem.classList.remove('drop-target');
                JQX.Tree.hoveredItem.classList.remove('top');
                JQX.Tree.hoveredItem.classList.remove('bottom');
            }

            if (target === hoveredTree.$.scrollViewer.$.scrollViewerContainer) {
                if (hoveredTree._menuItems['0']) {
                    let lastVisibleItem = hoveredTree.$.mainContainer.lastElementChild,
                        i = hoveredTree.$.mainContainer.childElementCount - 1;

                    while (lastVisibleItem.hidden) {
                        i--;
                        lastVisibleItem = hoveredTree.$.mainContainer.children[i];

                        if (!lastVisibleItem) {
                            break;
                        }
                    }

                    if (lastVisibleItem) {
                        JQX.Tree.hoveredItem = lastVisibleItem;
                        JQX.Tree.hoveredItem.classList.add('bottom');
                    }
                    else {
                        JQX.Tree.hoveredItem = hoveredTree.$.container;
                    }

                    JQX.Tree.hoveredItem.classList.add('drop-target');
                }
                else {
                    JQX.Tree.hoveredItem = hoveredTree.$.container;
                    JQX.Tree.hoveredItem.classList.add('drop-target');
                }
            }
            else {
                delete JQX.Tree.hoveredItem;
            }
        }
    }

    /**
     * Moves the sub-items of a jqx-tree-items-group.
     */
    _moveSubItems(children, targetTree, padding) {
        const that = this;

        for (let i = 0; i < children.length; i++) {
            const currentChild = children[i];

            currentChild.menu = targetTree;
            currentChild.set('level', currentChild.parentItem.level + 1);
            currentChild.firstElementChild.style.paddingLeft = '';
            currentChild.firstElementChild.style.paddingRight = '';
            that._setIndentation(currentChild.firstElementChild, currentChild.level, padding);
            // restore filtered state
            currentChild.hidden = false;
            currentChild.$.removeClass('jqx-hidden');
            currentChild.$.removeClass('filtered-child');
            currentChild.$.removeClass('last-filtered-child');

            if (currentChild instanceof JQX.TreeItemsGroup) {
                currentChild.$.removeClass('hidden-children');
                currentChild.container.level = currentChild.level + 1;
                that._moveSubItems(currentChild.itemContainer.children, targetTree, padding);

                if (targetTree !== that && currentChild.expanded) {
                    targetTree._menuItemsGroupsToExpand.push(currentChild);
                    that._updateState('expanded', currentChild.id, false);
                }
            }
        }
    }

    /**
     * Moves a jqx-tree-item.
     */
    _moveTreeItem(draggedItem, targetItem, position, affectedTrees) {
        const that = this,
            oldLevel = draggedItem.level;

        if (position === 0) {
            if (targetItem.previousElementSibling === draggedItem) {
                return;
            }

            targetItem.parentElement.insertBefore(draggedItem, targetItem);
            draggedItem.set('level', targetItem.level);
        }
        else if (position === 2) {
            if (targetItem.nextElementSibling === draggedItem) {
                return;
            }

            targetItem.parentElement.insertBefore(draggedItem, targetItem.nextElementSibling || null);
            draggedItem.set('level', targetItem.level);
        }
        else if (targetItem === affectedTrees[0].$.container) {
            affectedTrees[0].$.mainContainer.appendChild(draggedItem);
            draggedItem.set('level', 1);
        }
        else {
            if (targetItem.itemContainer.lastElementChild === draggedItem) {
                return;
            }

            targetItem.itemContainer.appendChild(draggedItem);
            draggedItem.set('level', targetItem.level + 1);
        }

        const padding = affectedTrees[0].rightToLeft ? 'paddingRight' : 'paddingLeft';

        draggedItem.menu = affectedTrees[0];
        draggedItem.parentItem = draggedItem.parentElement.menuItemsGroup;
        draggedItem.firstElementChild.style.paddingLeft = '';
        draggedItem.firstElementChild.style.paddingRight = '';
        that._setIndentation(draggedItem.firstElementChild, draggedItem.level, padding);
        // restore filtered state
        draggedItem.hidden = false;
        draggedItem.$.removeClass('jqx-hidden');
        draggedItem.$.removeClass('filtered-child');
        draggedItem.$.removeClass('last-filtered-child');

        if (draggedItem instanceof JQX.TreeItemsGroup) {
            draggedItem.$.removeClass('hidden-children');
            draggedItem.container.level = draggedItem.level + 1;
            that._moveSubItems(draggedItem.itemContainer.children, affectedTrees[0], padding);

            if (draggedItem.expanded) {
                const index = that._openedContainers[oldLevel + 1].indexOf(draggedItem.container);

                if (index !== -1) {
                    that._openedContainers[oldLevel + 1].splice(index, 1);
                }

                affectedTrees[0]._menuItemsGroupsToExpand.push(draggedItem);

                if (affectedTrees.length === 2) {
                    that._updateState('expanded', draggedItem.id, false);
                }
            }
        }

        for (let i = 0; i < affectedTrees.length; i++) {
            const tree = affectedTrees[i],
                oldContext = tree.context,
                oldSelectedIndexes = tree.selectedIndexes.slice(0);

            tree.context = tree;
            tree._menuItems = {};
            tree._refreshItemPaths(tree.$.mainContainer, true, undefined, tree.sorted && !tree.autoSort);
            tree.selectedIndexes = [];
            tree._applySelection(true, oldSelectedIndexes, false);
            tree._checkOverflow();
            tree.context = oldContext;
        }

        affectedTrees[0]._expandItemsByDefault();
    }

    /**
     * An empty handler used to override unnecessarily inherited Menu handlers.
     */
    _overriddenMenuHandler() { }

    /**
     * Handles PgDn navigation.
     */
    _pageDownHandler(treeItems, highlightedItem, selectOnHover, event) {
        const that = this,
            scrollViewer = that.$.scrollViewer;

        function getLastItemInView() {
            for (let i = treeItems.length - 1; i >= 0; i--) {
                const currentItem = treeItems[i];

                if (that._canItemBeHovered(currentItem) &&
                    that._getOffsetTop(currentItem) + currentItem.firstElementChild.offsetHeight <=
                    scrollViewer.scrollTop + scrollViewer.$.container.offsetHeight) {
                    return currentItem;
                }
            }
        }

        if (!highlightedItem) {
            return;
        }

        let lastItemInView = getLastItemInView();

        if (!lastItemInView) {
            return;
        }

        if (highlightedItem !== lastItemInView) {
            highlightedItem.removeAttribute('focus');
            that._hoverViaKeyboard(lastItemInView, selectOnHover, event);
        }
        else if (scrollViewer.scrollTop + scrollViewer.$.container.offsetHeight !==
            scrollViewer.$.scrollViewerContentContainer.offsetHeight) {

            that.$.scrollViewer.scrollTop += scrollViewer.$.container.offsetHeight;

            if (that.scrollMode === 'scrollButtons') {
                that._updateScrollButtonVisibility();
            }

            lastItemInView = getLastItemInView();
            highlightedItem.removeAttribute('focus');
            that._hoverViaKeyboard(lastItemInView, selectOnHover, event);
        }
    }

    /**
     * Handles PgUp navigation.
     */
    _pageUpHandler(treeItems, highlightedItem, selectOnHover, event) {
        const that = this,
            scrollViewer = that.$.scrollViewer;

        function getFirstItemInView() {
            for (let i = 0; i < treeItems.length; i++) {
                const currentItem = treeItems[i];

                if (that._canItemBeHovered(currentItem) &&
                    that._getOffsetTop(currentItem) >= scrollViewer.scrollTop) {
                    return currentItem;
                }
            }
        }

        if (!highlightedItem) {
            return;
        }

        let firstItemInView = getFirstItemInView();

        if (!firstItemInView) {
            return;
        }

        if (highlightedItem !== firstItemInView) {
            highlightedItem.removeAttribute('focus');
            that._hoverViaKeyboard(firstItemInView, selectOnHover, event);
        }
        else if (scrollViewer.scrollTop !== 0) {
            that.$.scrollViewer.scrollTop -= scrollViewer.$.container.offsetHeight;

            if (that.scrollMode === 'scrollButtons') {
                that._updateScrollButtonVisibility();
            }

            firstItemInView = getFirstItemInView();
            highlightedItem.removeAttribute('focus');
            that._hoverViaKeyboard(firstItemInView, selectOnHover, event);
        }
        else if (that.filterable) {
            that.$.filterInput.focus();
        }
    }

    /**
     * Refreshes item paths and selection.
     */
    _refreshItemPathsAndSelection() {
        const that = this,
            oldSelectedIndexes = that.selectedIndexes.slice(0);

        that._menuItems = {
        };
        that._refreshItemPaths(that.$.mainContainer, true);
        that.selectedIndexes = [];
        that._applySelection(true, oldSelectedIndexes);
    }

    /**
     * Refreshes sorting.
     */
    _refreshSorting() {
        const that = this;

        that._unsortItems(that.$.mainContainer);
        that._applyGrouping(that.$.mainContainer);

        const filterQuery = that._state.filter;

        if (filterQuery) {
            that._applyFilter(filterQuery);
        }

        that._checkOverflow();
    }

    /**
     * Scrolls using scroll buttons.
     */
    _scroll(scrollCoefficient) {
        const that = this;

        that.$.scrollViewer.scrollTop = that.$.scrollViewer.scrollTop + scrollCoefficient * 10;
        that._updateScrollButtonVisibility();
        that.focus();
    }

    /**
     * Far scroll button click handler.
     */
    _scrollButtonFarClickHandler() {
        const that = this;

        if (that.$.scrollButtonFar.disabled) {
            return;
        }

        that._scroll(1);
    }

    /**
     * Near scroll button click handler.
     */
    _scrollButtonNearClickHandler() {
        const that = this;

        if (that.$.scrollButtonNear.disabled) {
            return;
        }

        that._scroll(-1);
    }

    /**
     * scrollViewer down handler.
     */
    _scrollViewerDownHandler(event) {
        const that = this;

        if (event.target !== that.$.scrollViewer || that.disabled || that.displayLoadingIndicator || (!that._isMobile && event.which !== 1)) {
            return;
        }

        function continueSelection() {
            const pressedItem = target.closest('jqx-tree-item') || target.closest('jqx-tree-items-group');

            if (!(pressedItem && that._canItemBeSelected(pressedItem))) {
                return;
            }

            const arrow = target.closest('.jqx-tree-items-group-arrow');
            let selectionHandler;

            if (pressedItem instanceof JQX.TreeItem) {
                selectionHandler = '_handleSelection';
            }
            else {
                if (target === pressedItem.container || target === pressedItem.container.firstElementChild) {
                    return;
                }

                selectionHandler = '_menuItemsGroupSelectionHandler';
            }

            clearTimeout(that._dblclickTimeout);

            if (pressedItem !== that._dblclickObject.target) {
                that._dblclickObject.numberOfClicks = 0;
            }

            that._dblclickObject.target = pressedItem;
            that._dblclickObject.numberOfClicks++;

            that._dblclickTimeout = setTimeout(function () {
                that._dblclickObject.numberOfClicks = 0;
            }, 300);

            if (that._dblclickObject.numberOfClicks === 2) {
                if (!that.editable) {
                    that._dblclickHandler(pressedItem, arrow, event);
                    that._dblclickObject.numberOfClicks = 0;
                }
                else {
                    that._startEditing(pressedItem);
                    return;
                }
            }

            if (pressedItem.selected) {
                that._downItem = pressedItem;
            }

            that[selectionHandler](pressedItem, event);
            that._discardKeyboardHover(true);
            that._hoverViaKeyboard(pressedItem, false, undefined, false);

            if (!arrow) {
                that._startDragging(pressedItem, event);
            }
        }

        const target = event.originalEvent.target;

        if (target === that.$.editInput) {
            that._editInputDown = true;
            return;
        }

        if (that._isMobile) {
            const current = that.$.scrollViewer.scrollTop;

            setTimeout(function () {
                if (that.$.scrollViewer.scrollTop !== current) {
                    return;
                }
                else {
                    const oldContext = that.context;

                    that.context = that;
                    continueSelection();
                    that.context = oldContext;
                }
            }, 250);
        }
        else {
            continueSelection();
        }
    }

    /**
     * scrollViewer wheel handler.
     */
    _scrollViewerWheelHandler() {
        const that = this;

        if (that.scrollMode === 'scrollButtons' && that.overflow !== 'hidden') {
            that._updateScrollButtonVisibility();
        }
    }

    /**
     * Selects a range of items.
     */
    _selectItemRange(from, to) {
        const that = this,
            treeItems = Array.from(that.$.mainContainer.querySelectorAll('jqx-tree-item, jqx-tree-items-group')),
            indexOfFrom = treeItems.indexOf(from),
            indexOfTo = treeItems.indexOf(to),
            selectedIndexes = [];

        for (let i = Math.min(indexOfFrom, indexOfTo); i <= Math.max(indexOfFrom, indexOfTo); i++) {
            const currentItem = treeItems[i];

            if (that._canItemBeHovered(currentItem)) {
                selectedIndexes.push(currentItem.path);
                currentItem.set('selected', true);
            }
        }

        return selectedIndexes;
    }

    /**
     * Sets whether the element can be focused.
     */
    _setFocusable() {
        super._setFocusable();

        const that = this;

        if (that.disabled || that.unfocusable) {
            that.$.filterInput.tabIndex = -1;
            return;
        }

        that.$.filterInput.removeAttribute('tabindex');
    }

    /**
     * Sets item indentation.
     */
    _setIndentation(labelContainer, level, padding) {
        labelContainer.style[padding] = (level * 20 - 10) + 'px';
    }

    /**
     * Sets checked, unchecked, or indeterminate state to a checkbox.
     */
    _setThreeStateCheckbox(item, selectedChildren, indeterminateChildren) {
        if (selectedChildren === item.itemContainer.childElementCount) {
            item.removeAttribute('indeterminate');
            item.set('selected', true);
        }
        else if (selectedChildren === 0 && indeterminateChildren === 0) {
            item.removeAttribute('indeterminate');
            item.set('selected', false);
        }
        else {
            item.setAttribute('indeterminate', '');
            item.set('selected', false);
        }
    }

    /**
     * Sorts items.
     */
    _sortItems(item) {
        const that = this;

        if (!that.sorted) {
            return;
        }

        let parent;

        if (item instanceof JQX.TreeItemsGroup) {
            parent = item.container.firstElementChild;
        }
        else if (item === that.$.mainContainer) {
            parent = item;
        }

        let children = Array.from(parent.children);

        if (that.sort) {
            // custom sorting
            const customSortingResult = that.sort(children, item);

            if (Array.isArray(customSortingResult)) {
                children = customSortingResult;
            }
        }
        else if (that.sortDirection === 'asc') {
            children.sort(function (a, b) {
                return (a.label).localeCompare(b.label);
            });
        }
        else {
            children.sort(function (a, b) {
                return (b.label).localeCompare(a.label);
            });
        }

        // sort items in DOM
        for (let i = children.length - 1; i >= 0; i--) {
            parent.insertBefore(children[i], parent.firstElementChild);
        }
    }

    /**
     * Sorts a collection of item paths.
     */
    _sortPathCollection(collection) {
        collection.sort(function (a, b) {
            const aSplit = a.split('.'),
                bSplit = b.split('.'),
                maxLength = Math.max(aSplit.length, bSplit.length);

            for (let i = 0; i < maxLength; i++) {
                const aCurrent = parseFloat(aSplit[i]),
                    bCurrent = parseFloat(bSplit[i]);

                if (isNaN(aCurrent)) {
                    return -1;
                }

                if (isNaN(bCurrent)) {
                    return 1;
                }

                if (aCurrent < bCurrent) {
                    return -1;
                }

                if (aCurrent > bCurrent) {
                    return 1;
                }
            }
        });
    }

    /**
     * starts dragging operation
     */
    _startDragging(pressedItem, event) {
        const that = this,
            selectionMode = that.selectionMode;

        if (!that.allowDrag || that._editedItem || selectionMode === 'none') {
            return;
        }

        const items = [],
            validItems = [];
        let validateOnDrop;

        if (['one', 'zeroOrOne', 'checkBox', 'radioButton'].indexOf(selectionMode) !== -1) {
            validateOnDrop = false;
            items.push(pressedItem);
            validItems.push(pressedItem);
        }
        else {
            // selectionModes 'oneOrManyExtended', 'zeroOrMany', 'oneOrMany'
            validateOnDrop = true;

            for (let i = 0; i < that.selectedIndexes.length; i++) {
                items.push(that._menuItems[that.selectedIndexes[i]]);
                validItems.push(items[i]);
            }

            for (let i = 0; i < items.length; i++) {
                const item = items[i];

                if (validItems.indexOf(item) === -1) {
                    continue;
                }

                for (let j = validItems.length - 1; j >= 0; j--) {
                    const nextItem = validItems[j];

                    if (nextItem === item) {
                        break;
                    }

                    if (item.contains(nextItem)) {
                        validItems.splice(j, 1);
                    }
                }
            }
        }

        that._dragDetails = {
            StartPosition: {
                left: event.pageX, top: event.pageY
            },
            Items: items,
            ValidItems: validItems,
            Item: pressedItem,
            FeedbackShown: false,
            ValidateOnDrop: validateOnDrop,
            OriginalEvent: event,
            StartTime: new Date(),
            Dragging: true
        };

        JQX.Tree.treeItemDragged = true;
        that.$.scrollViewer._scrollView.disableSwipeScroll = true;

        if (that.allowDrop) {
            JQX.Tree.hoveredTree = that;
            JQX.Tree.hoveredItem = pressedItem;
        }
    }

    /**
     * Starts editing operation.
     */
    _startEditing(item) {
        const that = this,
            editInput = that.$.editInput;
        let getOffset, padding;

        if (!that._canItemBeSelected(item)) {
            return;
        }

        const labelContainer = item.firstElementChild,
            labelElement = labelContainer.firstElementChild;

        if (!that.rightToLeft) {
            getOffset = function () {
                return labelElement.offsetLeft + parseFloat(window.getComputedStyle(labelContainer).borderLeftWidth);
            };
            padding = 'paddingLeft';
        }
        else {
            getOffset = function () {
                return labelContainer.offsetWidth - labelElement.offsetLeft - labelElement.offsetWidth;
            };
            padding = 'paddingRight';
        }

        if (item instanceof JQX.TreeItemsGroup) {
            editInput.style[padding] = getOffset() + (that.showLines ? parseFloat(window.getComputedStyle(labelElement.firstElementChild).paddingLeft) : 0) - 1 + 'px';
            editInput.style.height = labelContainer.offsetHeight + 'px';
        }
        else {
            editInput.style[padding] = item.offsetWidth + parseInt(labelContainer.style[padding], 10) - labelContainer.offsetWidth + parseFloat(window.getComputedStyle(labelElement.firstElementChild).paddingLeft) - 2 + 'px';
            editInput.style.height = item.offsetHeight + 'px';
        }

        editInput.style.top = that._getOffsetTop(item) + 'px';
        that.$editInput.removeClass('jqx-hidden');
        editInput.value = item.label;
        that._editedItem = item;

        setTimeout(function () {
            editInput.focus();
        }, 0)
    }

    /**
     * styleChanged event handler.
     */
    _styleChangedHandler(event) {
        if (event.detail.styleProperties && event.detail.styleProperties['font-size']) {
            this._checkOverflow();
        }
    }

    /**
     * Updates scroll button visibility.
     */
    _updateScrollButtonVisibility() {
        const that = this,
            overflow = that.overflow;

        if (that.scrollMode === 'scrollbar' || overflow === 'hidden') {
            return;
        }

        let showNear = true,
            showFar = true;

        if (Math.round(that.$.scrollViewer.scrollTop) === 0) {
            showNear = false;
        }

        if (Math.round(that.$.scrollViewer.$.scrollViewerContainer.offsetHeight + that.$.scrollViewer.scrollTop) >=
            Math.round(that.$.scrollViewer.$.scrollViewerContentContainer.offsetHeight)) {
            showFar = false;
        }

        if (overflow === 'auto') {
            if (showNear && showFar) {
                that.$scrollButtonNear.removeClass('jqx-hidden');
                that.$scrollButtonFar.removeClass('jqx-hidden');
                that.$scrollViewer.removeClass('one-button-shown');
                that.$.scrollViewer.refresh();
                return;
            }

            if (showNear) {
                that.$scrollButtonNear.removeClass('jqx-hidden');
            }
            else {
                that.$scrollButtonNear.addClass('jqx-hidden');
            }

            if (showFar) {
                that.$scrollButtonFar.removeClass('jqx-hidden');
            }
            else {
                that.$scrollButtonFar.addClass('jqx-hidden');
            }

            that.$scrollViewer.addClass('one-button-shown');
            that.$.scrollViewer.refresh();
        }
        else if (overflow === 'scroll' && !that.disabled) {
            that.$.scrollButtonNear.disabled = !showNear;
            that.$.scrollButtonFar.disabled = !showFar;
        }
    }

    /**
     * Updates stored state.
     */
    _updateState(field, value, add) {
        const that = this;

        switch (field) {
            case 'expanded': {
                const index = that._state.expanded.indexOf(value);

                if (add && index === -1) {
                    that._state.expanded.push(value);
                }
                else if (!add && index !== -1) {
                    that._state.expanded.splice(index, 1);
                }
                else {
                    return;
                }

                break;
            }
            case 'filter':
                that._state.filter = value !== undefined ? value : that.$.filterInput.value;
                break;
            case 'selected':
                that._state.selected = [];

                for (let i = 0; i < that.selectedIndexes.length; i++) {
                    const currentSelectedItem = that._menuItems[that.selectedIndexes[i]];

                    that._state.selected.push(currentSelectedItem.id);
                }
                break;
            case 'sorted':
                that._state.sorted = value;
                break;
        }

        if (that.autoSaveState) {
            window.localStorage.setItem('jqxTree' + that.id, JSON.stringify(that._state));
        }
    }

    /**
     * Vertical Scroll Bar handler
     */
    _verticalScrollbarHandler() {
        const scrollViewer = this,
            verticalScrollBar = scrollViewer.$.verticalScrollBar,
            value = verticalScrollBar.value;

        if (scrollViewer.disabled) {
            return;
        }

        if (verticalScrollBar.max === value) {
            if (!scrollViewer._bottomReached) {
                scrollViewer.$.fireEvent('scrollBottomReached');
                delete scrollViewer._topReached;
                scrollViewer._bottomReached = true;
            }

            return;
        }

        if (verticalScrollBar.min === value) {
            if (!scrollViewer._topReached) {
                scrollViewer.$.fireEvent('scrollTopReached');
                delete scrollViewer._bottomReached;
                scrollViewer._topReached = true;
            }
            return;
        }

        delete scrollViewer._topReached;
        delete scrollViewer._bottomReached;
    }
});

/**
* jqxWindow custom element.
*/
JQX('jqx-window', class Window extends JQX.ContentElement {

    /**
    * Element's properties
    */
    static get properties() {
        return {
            'collapsed': {
                value: false,
                type: 'boolean'
            },
            'closeOnMaskClick': {
                value: false,
                type: 'boolean'
            },
            'disableSnap': {
                value: false,
                type: 'boolean'
            },
            'footerPosition': {
                value: 'bottom',
                allowedValues: ['bottom', 'none'],
                type: 'string'
            },
            'footerTemplate': {
                value: null,
                type: 'any'
            },
            'headerButtons': {
                value: ['close', 'maximize', 'minimize'],
                //Default built-in buttons: ['close', 'collapse', 'pin' 'maximize', 'minimize']
                type: 'array'
            },
            'headerPosition': {
                value: 'top',
                allowedValues: ['top', 'bottom', 'left', 'right', 'none'],
                type: 'string'
            },
            'headerTemplate': {
                value: null,
                type: 'any'
            },
            'label': {
                value: '',
                type: 'string'
            },
            'liveResize': {
                value: false,
                type: 'boolean'
            },
            'maximized': {
                value: false,
                type: 'boolean'
            },
            'modal': {
                value: false,
                type: 'boolean'
            },
            'minimized': {
                value: false,
                type: 'boolean'
            },
            'opened': {
                value: false,
                type: 'boolean'
            },
            'pinned': {
                value: false,
                type: 'boolean'
            },
            'resizeIndicator': {
                value: false,
                type: 'boolean'
            },
            'resizeMode': {
                allowedValues: ['none', 'horizontal', 'vertical', 'both', 'top', 'bottom', 'left', 'right'],
                value: 'none',
                type: 'string'
            },
            'windowParent': {
                value: null,
                type: 'any'
            }
        }
    }

    /**
    * Element's event listeners.
    */
    static get listeners() {
        return {
            'document.dragstart': '_dragStartHandler',
            'document.focusin': '_documentFocusInEventHandler',
            'document.move': '_documentMoveHandler',
            'document.up': '_documentUpHandler',
            'document.wheel': '_mouseWheelHandler',
            'document.selectstart': '_documentSelectStartHandler',
            'down': '_downHandler',
            'focus': '_focusHandler',
            'blur': '_focusHandler',
            'move': '_moveHandler',
            'keydown': '_keyDownHandler',
            'keyup': '_keyUpHandler',
            'stylechanged': '_styleChangedHandler'
        }
    }

    /**
    * Element's HTML template.
    */
    template() {
        return `<div id="container">
                    <div id="headerSection" class="jqx-header-section">
                        <div id="header" class="jqx-header">[[label]]</div>
                        <div id="buttonsContainer" class="jqx-buttons-container">
                            <jqx-button id="pinButton" class="jqx-pin-button" animation="[[animation]]" theme="[[theme]]"></jqx-button>
                            <jqx-button id="collapseButton" class="jqx-collapse-button" animation="[[animation]]" theme="[[theme]]"></jqx-button>
                            <jqx-button id="minimizeButton" class="jqx-minimize-button" animation="[[animation]]" theme="[[theme]]"></jqx-button>
                            <jqx-button id="maximizeButton" class="jqx-maximize-button" animation="[[animation]]" theme="[[theme]]"></jqx-button>
                            <jqx-button id="closeButton" class="jqx-close-button" animation="[[animation]]" theme="[[theme]]"></jqx-button>
                        </div>
                    </div>
                    <div class="jqx-content" inner-h-t-m-l="[[innerHTML]]"><content></content></div>
                    <div id="footer" class="jqx-footer"></div>
                </div>`;
    }

    /**
    * Updates the element when a property is changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
    * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        switch (propertyName) {
            case 'collapsed':
                newValue ? that.collapse(true) : that.expand(true);
                break;
            case 'disabled':
            case 'unfocusable':
                that._setFocusable();
                break;
            case 'headerTemplate':
            case 'footerTemplate':
                that._applyLayoutTemplate(that.$[propertyName.split(/[T]/)[0]], newValue);
                break;
            case 'headerButtons':
                that._setHeaderButtons();
                break;
            case 'headerPosition':
                that.style.width = '';
                that.style.height = '';
                break;
            case 'label':
                that.$.header.innerHTML = that.label;
                break;
            case 'maximized':
                newValue ? that.maximize(true) : that.restore(propertyName);
                break;
            case 'modal':
                that._setModal();
                break;
            case 'minimized':
                newValue ? that.minimize(true) : that.restore(propertyName);
                break;
            case 'opened':
                newValue ? that.open(true) : that.close(true);
                break;
            case 'resizeMode':
                //Reset the resizing indicator
                that.$.container.className = 'jqx-container';
                break;
            case 'windowParent':
                that._setElementParent(newValue);
                break;
            default:
                super.propertyChangedHandler(propertyName, oldValue, newValue);
                break;
        }
    }

    /**
    * Disables the styleObserver
    */
    get hasStyleObserver() {
        return false;
    }

    /**
    * Element's ready method.
    */
    ready() {
        super.ready();

        const that = this,
            animationType = that.animation;

        if (!that.opened) {
            that.animation = 'none';
        }

        that.$.addClass('jqx-window');
        that._createElement();
        that._windowParent = { initialParent: that.parentElement };
        that._setElementParent(that.windowParent); //Remove if added to attached method
        that._setHeaderButtons();

        if (that.headerTemplate) {
            that._applyLayoutTemplate(that.$.header, that.headerTemplate);
        }

        if (that.footerTemplate) {
            that._applyLayoutTemplate(that.$.footer, that.footerTemplate);
        }

        that.opened ? that.open() : that.close();

        if (that.maximized) {
            that.maximize(true);
        }

        if (that.minimized) {
            that.minimize(true);
        }

        if (that.collapsed) {
            that.collapse(true);
        }

        that.pinned ? that.pin() : that.unpin();
        that._setFocusable();

        that.animation = animationType;
    }

    /**
     * 
     */
    _styleChangedHandler() {
        const that = this;

        if (!that.maximized) {
            return;
        }

        //that._windowParent.element.
    }

    /**
    * Checks for missing modules.
    */
    static get requires() {
        return {
            'JQX.Button': 'jqxbutton.js'
        }
    }

    /**
    * Sets tab index 
    */
    _setFocusable() {
        const that = this;

        if (!that.disabled && !that.unfocusable) {
            let index = that.tabIndex > 0 ? that.tabIndex : 0;

            that.setAttribute('tabindex', index);
        }
        else {
            that.removeAttribute('tabindex');
        }
    }

    /**
    * Appends an HTML element content section of the Window.
    */
    appendChild(node) {
        const that = this;

        if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!node) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'appendChild', node: 'node' }));
            return
        }

        that.$.content.appendChild(node);
    }

    /**
     * Collapses the window
     */
    collapse(propertyChange) {
        const that = this;

        if (!propertyChange && that.collapsed) {
            return;
        }

        that.collapsed = true;
        that.$.fireEvent('collapse');

        if (that.headerPosition === 'left' || that.headerPosition === 'right') {
            that.style.width = '';
        }
        else {
            that.style.height = '';
        }
    }

    /**
     * Closes the window
     */
    close(propertyChange) {
        const that = this;

        if (!propertyChange && that.$.hasClass('jqx-visibility-hidden')) {
            return;
        }

        if (that.isCompleted) {
            const isOpeningEventPrevented = that.$.fireEvent('closing').defaultPrevented;

            if (isOpeningEventPrevented) {
                return;
            }

            that.$.addClass('jqx-visibility-hidden');
            that.opened = false;
            that.$.fireEvent('close');
        }
        else {
            that.$.addClass('jqx-visibility-hidden');
            that.opened = false;
        }

        that._setModal();
        that.removeAttribute('ontop');
    }

    /**
     * Element's Attached method
     */
    attached() {
        super.attached();

        const that = this;

        //MoveHandler not working, if enabled. Reason: Appending twice to the same parent.
        //that._setElementParent(that.windowParent);

        if (that._windowParent.parent !== document.body &&
            that._windowParent.parent.querySelectorAll('jqx-window, jqx-dialog-window, jqx-progress-window, jqx-wait-window, ' +
                'jqx-alert-window, jqx-prompt-window, jqx-multiline-prompt-window')) {
            that._windowParent.parent.style.position = 'relative';
        }

        if (that.opened && that._modal) {
            that.parentElement.insertBefore(that._modal, that);
        }
    }

    /**
     * Sets the window to the top level so the user can interact with it
     */
    bringToFront() {
        const that = this;

        if (!that.parentElement) {
            return;
        }

        const parentWindow = that.parentElement.closest('.jqx-window');

        if (parentWindow) {
            parentWindow.bringToFront();
            return;
        }

        const windows = document.body.getElementsByClassName('jqx-window');

        for (let w = 0; w < windows.length; w++) {
            windows[w].removeAttribute('ontop');
        }

        if (windows.length === 1 && windows[0] === that) {
            return;
        }

        that.setAttribute('ontop', '');
    }

    /**
     * Clears the content of the Window
     */
    clear() {
        const that = this;

        if (!that.isCompleted || that.nodeName !== 'JQX-WINDOW') {
            return;
        }

        that.$.content.innerHTML = '';
    }

    /**
     * Element's Detached method
     */
    detached() {
        super.detached();

        const that = this;

        if (!that._windowParent.parent.querySelectorAll('jqx-window, jqx-dialog-window, jqx-progress-window, jqx-wait-window, ' +
            'jqx-alert-window, jqx-prompt-window, jqx-multiline-prompt-window')) {
            that._windowParent.parent.style.position = '';
        }

        if (that._modal && that._modal.parentElement) {
            that._modal.parentElement.removeChild(that._modal);
        }

        if (that._resizeDummy && that._resizeDummy.parentElement) {
            that._handleWindowResizeDummy();
        }

        that._refreshMinimizedWindowsPosition();
    }

    /**
     * Expands the window
     */
    expand(propertyChange) {
        const that = this;

        if (!propertyChange && !that.collapsed) {
            return;
        }

        that.collapsed = false;
        that.$.fireEvent('expand');

        if (that.maximized) {
            if (that.headerPosition === 'left' || that.headerPosition === 'right') {
                //In Safari and EDGE there is a bug. If scrollHeight < clientHeight, scrollHeight is not correct
                that.style.width = (Math.max(that._windowParent.scrollElement.scrollWidth, that._windowParent.element.clientWidth) - that._windowParent.borderWidth) + 'px';
            }
            else {
                that.style.height = (Math.max(that._windowParent.scrollElement.scrollHeight, that._windowParent.element.clientHeight) - that._windowParent.borderWidth) + 'px';
            }
        }
        else {
            if (that.headerPosition === 'left' || that.headerPosition === 'right') {
                that.style.width = that.className.indexOf('jqx-window-snapped-') < 0 && that._dragDetails ? that._dragDetails.width + 'px' : '';
            }
            else {
                that.style.height = that.className.indexOf('jqx-window-snapped-') < 0 && that._dragDetails ? that._dragDetails.height + 'px' : '';
            }
        }
    }

    /**
     * Maximizes the window
     */
    maximize(propertyChange) {
        const that = this;

        //Fixes the issue where maximizing a window that overflows the viewport ( scrollbars are rendered ) with animation causes inproper height/width calculation if the scrollbars get hidden
        function transitionHandler() {
            if (!that.maximized || !that.hasAnimation) {
                return;
            }

            const scrollHeight = that._windowParent.scrollElement.scrollHeight,
                clientHeight = that._windowParent.element.clientHeight,
                totalParentHeight = Math.max(scrollHeight, clientHeight);

            if (that.headerPosition === 'top' || that.headerPosition === 'bottom') {
                if (!that.collapsed) {
                    that.style.height = scrollHeight > clientHeight ? (totalParentHeight - that._windowParent.borderWidth) + 'px' : '100%';
                }
            }
            else {
                that.style.height = scrollHeight > clientHeight ? (totalParentHeight - that._windowParent.borderWidth) + 'px' : '100%';
            }

            that.removeEventListener('transitionend', transitionHandler);
        }

        if (!propertyChange && that.maximized) {
            return;
        }

        if (that.minimized) {
            that._restoreFromMinimization(propertyChange);
        }

        //Save the current size and position before maximizing
        that._setDragDetails();

        //Remove resizing indicator classes if added
        if (that.resizeMode !== 'none') {
            that.$.container.className = 'jqx-container';
        }

        if (that._snapDummy && that.$.hasClass('jqx-window-snapped-' + that._snapDummy._position)) {
            that.classList.remove('jqx-window-snapped-' + that._snapDummy._position);
        }

        that.maximized = true;
        that.$.fireEvent('maximize');

        that.style.left = that.style.top = '0px';
        that.style.maxWidth = that.style.maxHeight = 'none';

        //NOTE: Resize event must be added in order to always fit the parent. That will hammer the performance. That's why it's not added!
        //In Safari and EDGE there is a bug. If scrollHeight < clientHeight, scrollHeight is not correct
        const scrollHeight = that._windowParent.scrollElement.scrollHeight,
            scrollWidth = that._windowParent.scrollElement.scrollWidth,
            clientHeight = that._windowParent.element.clientHeight,
            clientWidth = that._windowParent.element.clientWidth,
            totalParentHeight = Math.max(scrollHeight, clientHeight),
            totalParentWidth = Math.max(scrollWidth, clientWidth);

        if (that.headerPosition === 'top' || that.headerPosition === 'bottom') {
            that.style.width = scrollWidth > clientWidth ? (totalParentWidth - that._windowParent.borderWidth) + 'px' : '100%';

            if (!that.collapsed) {
                that.style.height = scrollHeight > clientHeight ? (totalParentHeight - that._windowParent.borderWidth) + 'px' : '100%';
            }
        }
        else {
            if (!that.collapsed) {
                that.style.width = scrollWidth > clientWidth ? (totalParentWidth - that._windowParent.borderWidth) + 'px' : '100%';
            }

            that.style.height = scrollHeight > clientHeight ? (totalParentHeight - that._windowParent.borderWidth) + 'px' : '100%';
        }

        if (that.style.height !== '100%') {
            that.addEventListener('transitionend', transitionHandler);
        }
    }

    /**
     * Minimizes the window
     * @param {any} propertyChange
     */
    minimize(propertyChange) {
        const that = this;

        if (!propertyChange && that.minimized) {
            return;
        }

        if (that.maximized) {
            that.restore();
        }

        //Save the size and position of the element before minimizing
        that._setDragDetails();

        that.minimized = true;
        that.$.fireEvent('minimize');

        if (that._snapDummy && that.$.hasClass('jqx-window-snapped-' + that._snapDummy._position)) {
            that.$.removeClass('jqx-window-snapped-' + that._snapDummy._position);
            that.style.right = that.style.top = that.style.left = '';
        }

        const minimizedWindows = that._getAllMinimizedWindows(that._windowParent.element);

        if (minimizedWindows.length > 0) {
            const lastWindow = minimizedWindows[minimizedWindows.length - 1];

            that.style.left = (lastWindow.offsetLeft + lastWindow.offsetWidth + that._dragDetails.minWidth + 10 > that._windowParent.element.clientWidth ?
                lastWindow.offsetLeft : lastWindow.offsetLeft + lastWindow.offsetWidth + 5) + 'px';
            that.style.top = lastWindow.offsetTop + 'px';
        }
        else {
            that.style.left = '5px';

            //document.documentElement.scrollTop is always 0 in MS EDGE but not in IE11!
            that.style.top = (that._windowParent.element.clientHeight +
                that._windowParent.scrollElement.scrollTop - that.$.headerSection.offsetHeight - 5) + 'px';
        }

        that.style.width = '';
        that.style.height = that.$.headerSection.offsetHeight + 'px';
    }

    /**
     * Create Element
     */
    _createElement() {
    }

    /**
    * Removes an HTML element from the content section.
    */
    removeChild(node) {
        const that = this;

        if (!that.isCompleted) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!node) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'removeChild', node: 'node' }));
            return
        }

        that.$.content.removeChild(node);
    }

    /**
     * Unmaximizes the window
     */
    restore(propertyChange) {
        const that = this;

        if (propertyChange === 'maximized' || that.maximized) {
            that.maximized = false;
            that.style.width = that.style.height = that.style.top = that.style.left = '';
        }
        else if (propertyChange === 'minimized' || that.minimized) {
            that._restoreFromMinimization(propertyChange);
        }

        that.$.fireEvent('restore');

        that.style.maxWidth = that.style.maxHeight = '';

        if (that._dragDetails) {
            that.style.left = Math.max(0, Math.min(that._dragDetails.windowX, that._windowParent.element.clientWidth - that._dragDetails.width)) + 'px';
            that.style.top = Math.max(0, Math.min(that._dragDetails.windowY, that._windowParent.scrollElement.scrollHeight - that._dragDetails.height)) + 'px';

            if (that.collapsed) {
                if (that.headerPosition === 'top' || that.headerPosition === 'bottom') {
                    that.style.width = that._dragDetails.width + 'px';
                }
                else {
                    that.style.height = that._dragDetails.height + 'px';
                }

                return;
            }

            if (that._dragDetails.resized) {
                that.style.width = that._dragDetails.width + 'px';
                that.style.height = that._dragDetails.height + 'px';
            }
        }
    }

    /**
     * Opens the window
     */
    open(propertyChange) {
        const that = this;

        if (!propertyChange && !that.$.hasClass('jqx-visibility-hidden')) {
            return;
        }

        function focusAfterOpen() {
            that.focus();
            that.removeEventListener('transitionend', focusAfterOpen);

        }

        if (that.isCompleted) {
            const isOpeningEventPrevented = that.$.fireEvent('opening').defaultPrevented;

            if (isOpeningEventPrevented) {
                return;
            }

            that.$.removeClass('jqx-visibility-hidden');
            that.opened = true;
            that.$.fireEvent('open');
        }
        else {
            that.$.removeClass('jqx-visibility-hidden');
            that.opened = true;
        }

        that.bringToFront();
        that._setModal();
        that._handleActiveState();

        if (!that.hasAnimation) {
            focusAfterOpen();
        }
        else {
            that.addEventListener('transitionend', focusAfterOpen);
        }

    }

    /**
     * Pins the window
     */
    pin() {
        this.pinned = true;
    }

    /**
     * Unpin the window
     */
    unpin() {
        this.pinned = false;
    }

    /**
    * Apply the layout template for the header/footer
    */
    _applyLayoutTemplate(selector, template) {
        const that = this;

        if (!template) {
            selector.innerHTML = '';

            if (selector === that.$.header && that.label) {
                selector.innerHTML = that.label;
            }

            return;
        }

        if (!('content' in document.createElement('template'))) {
            that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() }));
            return;
        }

        if (!(template instanceof HTMLTemplateElement)) {
            template = document.getElementById(template);
        }

        if (template === null || !('content' in template)) {
            that.error(that.localize('invalidTemplate', {
                elementType: that.nodeName.toLowerCase(),
                property: selector === that.$.footer ? 'footerTemplate' : 'headerTemplate'
            }));
            return;
        }

        selector.innerHTML = '';
        selector.appendChild(document.importNode(template.content, true));
    }

    /**
    * Cancel the Drag operation
    * @param {any} event
    */
    _cancelDragging(event) {
        const that = this;

        if (that._dragDetails && that._dragDetails.started && that._dragDetails.type === 'drag') {
            if (!event) {
                const windowRect = that.getBoundingClientRect();

                event = { pageX: windowRect.left, pageY: windowRect.top };
            }

            that.$.fireEvent('dragEnd', { x: event.pageX, y: event.pageY });
            that.removeAttribute('dragged');
            that._dragDetails.started = false;
            delete that._mouseManipulation;
        }
    }

    /**
    * Document focusin event handler.
    * Called when an element is about to receive focus
    * @param {any} event
    */
    _documentFocusInEventHandler(event) {
        const that = this;

        if (!that._changingFocus) {
            return;
        }

        if (!that.contains(event.target)) {
            that.focus();
        }

        delete that._changingFocus;
    }

    /**
     * Element Down event handler
     * @param {any} event
     */
    _downHandler(event) {
        const that = this;
        let target = JQX.Utilities.Core.isMobile ? document.elementFromPoint(event.pageX - window.pageXOffset, event.pageY - window.pageYOffset) : event.originalEvent.target;

        event.stopPropagation();

        //Left mouse click is 1
        if (that.disabled || (!JQX.Utilities.Core.isMobile && event.which !== 1)) {
            return;
        }

        //AutoHideWindow in a JQX.TabsWindow
        if (that._tabsWindow) {
            that._tabsWindow._isAutoHideWindowClicked = true;
        }

        if (!that.hasAttribute('ontop')) {
            that.bringToFront();
        }

        if (target.closest && target.closest('.jqx-buttons-container') === that.$.buttonsContainer) {
            that._buttonPressed = target.closest('jqx-button');

            if (that._buttonPressed) {
                return;
            }
        }

        that._isWindowContentClicked = event.originalEvent.target.closest('.jqx-content') && event.originalEvent.target.closest('.jqx-window');

        const isInsideLayout = that.closest('jqx-docking-layout');

        if (that instanceof JQX.TabsWindow && isInsideLayout && isInsideLayout.disabled) {
            return;
        }

        that._handleActiveState();

        if (that instanceof JQX.TabsWindow && isInsideLayout) {
            if (that.$.hasClass('jqx-docking-layout-auto-hide-window')) {
                //Check if a resize zone is entered on touchstart
                if (JQX.Utilities.Core.isMobile) {
                    that._moveHandler(event);
                }

                if (that.resizeMode !== 'none' && that.$.container.className.indexOf('jqx-window-resizing') > -1) {
                    that._mouseManipulation = true;
                    that._setDragDetails('resize', event);
                }
            }

            return;
        }

        if (event.originalEvent.target.closest('.jqx-header-section') === that.$.headerSection) {
            if (that._dblClickDetails === undefined) {
                that._dblClickDetails = { clicks: 0 };
            }

            clearTimeout(that._dblClickDetails.timeOut);
            that._dblClickDetails.clicks++;

            that._dblClickDetails.timeOut = setTimeout(function () {
                if (that._dblClickDetails) {
                    that._dblClickDetails.clicks = 0;
                }
            }, 300);

            if (that._dblClickDetails.clicks === 2) {
                that._headerDblCickHandler(event);
                that._dblClickDetails.clicks = 0;
                return;
            }
        }

        if (that.maximized) {
            return;
        }

        //Check if a resize zone is entered on touchstart
        if (JQX.Utilities.Core.isMobile) {
            that._moveHandler(event);
        }

        if (!that.pinned && !that.minimized && that.$.container.className.indexOf('jqx-window-resizing') < 0) {
            target = target.closest('.jqx-header-section');

            if (target && target === that.$.headerSection) {
                that._mouseManipulation = true;
                that._setDragDetails('drag', event);
            }
        }

        if (that.resizeMode !== 'none' && that.$.container.className.indexOf('jqx-window-resizing') > -1) {
            that._mouseManipulation = true;
            that._setDragDetails('resize', event);
        }
    }

    /**
     * Document Move Event Handler
     * @param {any} event - event details
     */
    _documentMoveHandler(event) {
        const that = this;

        if (!that._dragDetails || !that._dragDetails.started || that.minimized || !that._mouseManipulation ||
            (Math.abs(event.pageX - that._dragDetails.x) <= 5 && Math.abs(event.pageY - that._dragDetails.y) <= 5)) {
            return;
        }

        if (!that.hasAttribute('dragged') && !that.hasAttribute('resized')) {
            that.$.fireEvent(that._dragDetails.type + 'Start', { left: event.pageX, top: event.pageY, width: that.offsetWidth, height: that.offsetHeight });
        }

        event.stopPropagation();

        if (that._dragDetails.type === 'drag' && !that.pinned) {
            that.setAttribute('dragged', '');

            if (that._snapDummy && that.$.hasClass('jqx-window-snapped-' + that._snapDummy._position)) {
                that.$.removeClass('jqx-window-snapped-' + that._snapDummy._position);
                that.style.right = that.style.top = that.style.left = '';

                if (!that.collapsed) {
                    that.style.height = that._dragDetails.height + 'px';
                    that.style.width = that._dragDetails.width + 'px';
                }
            }

            that._drag(event, 'both');

            //document.documentElement.scrollTop is always 0 in MS EDGE but not in IE11!
            that._dragDetails.x = Math.max(that._windowParent.offsetLeft + that._dragDetails.offsetX - that._windowParent.scrollElement.scrollLeft,
                Math.min((that._windowParent.offsetLeft + that._windowParent.element.offsetWidth) - (that._windowParent.element.offsetWidth -
                    that.offsetLeft) + that._dragDetails.offsetX, event.pageX));

            that._dragDetails.y = Math.max(that._windowParent.offsetTop + that._dragDetails.offsetY - that._windowParent.scrollElement.scrollTop,
                Math.min((that._windowParent.offsetTop + that._windowParent.element.offsetHeight) - (that._windowParent.element.offsetHeight -
                    that.offsetTop) + that._dragDetails.offsetY, event.pageY));

            //Window snapping logic
            if (event.pageX >= that._windowParent.offsetLeft + that._windowParent.scrollElement.scrollWidth - 1) {
                that._handleSnapping('right');
            }
            else if (event.pageY <= that._windowParent.offsetTop) {
                that._handleSnapping('top');
            }
            else if (event.pageX <= that._windowParent.offsetLeft) {
                that._handleSnapping('left');
            }
            else {
                that._handleSnapping();
            }
        }
        else {
            that._dragDetails.resized = true;
            that._resize(that._dragDetails.side, event);

            //document.documentElement.scrollTop is always 0 in MS EDGE but not in IE11!
            that._dragDetails.x = Math.max(that._windowParent.offsetLeft + that._dragDetails.left,
                Math.min(that._windowParent.offsetLeft + that._dragDetails.left + (that._dragDetails.side.toLowerCase().indexOf('left') > -1 ? 0 : that._dragDetails.newWidth), event.pageX));

            that._dragDetails.y = Math.max(that._windowParent.offsetTop + that._dragDetails.top,
                Math.min(that._windowParent.offsetTop + that._dragDetails.top + (that._dragDetails.side.toLowerCase().indexOf('top') > -1 ? 0 : that._dragDetails.newHeight), event.pageY));
        }
    }

    /**
    * Document Down event handler
    * @param {any} event - event details
    */
    _documentUpHandler(event) {
        const that = this,
            target = event.originalEvent.target;

        if (that.disabled) {
            that.removeAttribute('active');
            delete that._buttonPressed;
            delete that._isWindowContentClicked;
            return;
        }

        if (that._dragDetails && that._dragDetails.started) {
            if (that.hasAttribute('resized')) {
                that.$.fireEvent(that._dragDetails.type + 'End', { x: event.pageX, y: event.pageY, width: that._dragDetails.newWidth, height: that._dragDetails.newHeight });
                that.removeAttribute('resized');
                that._handleWindowResizeDummy();
                that.$.container.className = 'jqx-container';
            }

            //The only way to stop the transitions when liveResize is false
            setTimeout(function () {
                that.$.removeClass('no-transition');
            }, 20);

            if (that.hasAttribute('dragged')) {
                that.$.fireEvent(that._dragDetails.type + 'End', { x: event.pageX, y: event.pageY });
                that.removeAttribute('dragged');
            }

            that._dragDetails.started = false;
            delete that._mouseManipulation;
        }

        if (that._snapDummy && !that._snapDummy.classList.contains('jqx-visibility-hidden')) {
            switch (that._snapDummy._position) {
                case 'left':
                case 'top':
                    that.style.left = that.style.top = '0';
                    that.style.right = 'auto';

                    break;
                case 'right':
                    that.style.left = 'auto';
                    that.style.top = that.style.right = '0';
                    break;
            }

            that.style.width = that._snapDummy._position === 'top' ? '100%' : '50%';
            that.style.height = '100%';
            that.$.addClass('jqx-window-snapped-' + that._snapDummy._position);
            that._handleSnapping();
        }

        if (that._modal && event.originalEvent.target === that._modal && !that._isWindowContentClicked) {
            that.closeOnMaskClick ? that.close() : that.focus();
        }

        if (that._isWindowButton(event.originalEvent.target)) {
            that.focus();
        }

        delete that._isWindowContentClicked;
        delete that._buttonPressed;

        if (!that.hasAttribute('active') || document.activeElement === that) {
            return;
        }

        if (!target.closest) {
            return;
        }

        let closestWindow = target.closest('.jqx-window');

        while (closestWindow) {
            if (closestWindow === that) {
                break;
            }

            closestWindow = closestWindow.parentElement.closest('.jqx-window');
        }

        if (closestWindow !== that) {
            that.removeAttribute('active');
        }
    }

    /**
     * Document select start handler.
     */
    _documentSelectStartHandler(event) {
        const that = this;

        if (that._dragDetails && that._dragDetails.started) {
            event.preventDefault();
        }
    }

    /**
     * Repositions the window ( Dragging  operation ) 
     */
    _drag(event, direction) {
        const that = this;

        if (!event || that.pinned || that.maximized) {
            return;
        }

        let distanceX, distanceY;

        if (!that._dragDetails || !that._dragDetails.started) {
            that._setDragDetails('drag', event);
        }

        //Disables animatied movement
        that.$.addClass('no-transition');

        if (typeof (event) === 'object') {
            distanceX = event.pageX - that._dragDetails.x;
            distanceY = event.pageY - that._dragDetails.y;
        }
        else {
            distanceX = distanceY = event;
        }

        //Safari, EDGE have a different with the height of the viewport depending on the elemnets on the page
        const totalParentHeight = Math.max(that._windowParent.element.clientHeight, that._windowParent.scrollElement.scrollHeight),
            totalParentWidth = Math.max(that._windowParent.element.clientWidth, that._windowParent.scrollElement.scrollWidth);

        switch (direction) {
            case 'horizontal':
                that._dragDetails.windowX = Math.max(0, Math.min(that._dragDetails.windowX + distanceX, totalParentWidth - that.offsetWidth));
                that.style.left = that._dragDetails.windowX + 'px';
                break;
            case 'vertical':
                that._dragDetails.windowY = Math.max(0, Math.min(that._dragDetails.windowY + distanceY, totalParentHeight - that.offsetHeight));
                that.style.top = that._dragDetails.windowY + 'px';
                break;
            case 'both':
                that._dragDetails.windowX = Math.max(0, Math.min(that._dragDetails.windowX + distanceX, totalParentWidth - that.offsetWidth));
                that._dragDetails.windowY = Math.max(0, Math.min(that._dragDetails.windowY + distanceY, totalParentHeight - that.offsetHeight));
                that.style.left = that._dragDetails.windowX + 'px';
                that.style.top = that._dragDetails.windowY + 'px';
                break;
        }

        that._dragDetails.top = that.offsetTop;
        that._dragDetails.left = that.offsetLeft;
    }

    /**
     * DragStarted Event Handler
     * @param {any} event
     */
    _dragStartHandler(event) {
        const that = this;

        if (that._dragDetails && that._dragDetails.started) {
            event.preventDefault();
        }
    }

    /**
     * Element's focus/blue event handler
     * @param {any} event
     */
    _focusHandler(event) {
        const that = this;

        if (event.type === 'focus') {
            that.setAttribute('focus', '');
            that.bringToFront();
        }
        else if (!that._buttonPressed) {
            that.removeAttribute('focus');

            if (that._dragDetails && that._dragDetails.started) {
                that._handleWindowResizeDummy();
            }
        }
    }

    /**
    * Retrieves all curently minimized windows in an array.
    * @param {any} container
    */
    _getAllMinimizedWindows(container) {
        const that = this;
        let minimizedWindows = [];

        if (!container) {
            container = that._windowParent.element;
        }

        const windowElements = container.getElementsByTagName('jqx-window');

        for (let i = 0; i < windowElements.length; i++) {
            if (windowElements[i] !== that && windowElements[i].hasAttribute('minimized')) {
                minimizedWindows.push(windowElements[i]);
            }
        }

        minimizedWindows.sort(function (a, b) {
            let aRect = a.getBoundingClientRect(),
                bRect = b.getBoundingClientRect();

            return aRect.right - bRect.right;
        });

        return minimizedWindows;
    }

    /**
    * Handles the snapping of the window to the viewport. Adds a dummy that will determine the snapping behavior.
    * @param {any} position
    */
    _handleSnapping(position) {
        const that = this;

        function transitionEndHandler() {
            if (that._snapDummy.classList.contains('jqx-visibility-hidden') && that._snapDummy.parentElement) {
                that._snapDummy.parentElement.removeChild(that._snapDummy);
            }
        }

        if (!position) {
            if (that._snapDummy && that._snapDummy.parentElement) {
                that._snapDummy.classList.add('jqx-visibility-hidden');
            }

            return;
        }

        if (that.disableSnap || that.collapsed) {
            return;
        }

        if (!that._snapDummy) {
            that._snapDummy = document.createElement('div');

            that._snapDummy.addEventListener('transitionend', transitionEndHandler);
        }

        that._snapDummy.className = 'jqx-window-snap-' + position + '-feedback';
        that._snapDummy._position = position;

        if (!that._snapDummy.parentElement) {
            that._windowParent.element.appendChild(that._snapDummy);
        }
    }

    /**
     * Window header double click handler.
     */
    _headerDblCickHandler(event) {
        const that = this,
            target = event.originalEvent.target;

        if ((target !== that.$.headerSection && target !== that.$.header) || (that.$.maximizeButton && that.$.maximizeButton.offsetHeight === 0)) {
            return;
        }

        that.maximized ? that.restore() : that.maximize();
    }

    /**
    * Element Up event handler
    * @param {any} event - event details
    */
    _isWindowButton(target) {
        const that = this;

        if (!target.closest || target.closest('.jqx-buttons-container') !== that.$.buttonsContainer) {
            return;
        }

        const customButtonRegex = /jqx-(\w+[-]*\w*)-button/ig;

        target = target.closest('jqx-button');

        if (!target || target !== that._buttonPressed) {
            return;
        }

        switch (target) {
            case that.$.closeButton:
                that.close();
                return true;
            case that.$.collapseButton:
                that.collapsed ? that.expand() : that.collapse();
                return true;
            case that.$.maximizeButton:
                that.maximized ? that.restore() : that.maximize();
                return true;
            case that.$.minimizeButton:
                that.minimized ? that.restore() : that.minimize();
                return true;
            case that.$.pinButton:
                that.pinned ? that.unpin() : that.pin();
                return true;
            default:
                //Custom Header Button
                if (!(customButtonRegex.test(target.className))) {
                    return;
                }

                that.$.fireEvent(JQX.Utilities.Core.toCamelCase(target.className.match(customButtonRegex).toString().replace('jqx-', '').replace('-button', '')), { button: target });
                return true;
        }
    }

    /**
     * Key Down event handler
     * @param {any} event - event details
     */
    _keyDownHandler(event) {
        const that = this;

        delete that._changingFocus;

        if (that.disabled || ((that.hasAttribute('dragged') || that.hasAttribute('resized')) && that._mouseManipulation)) {
            return;
        }

        event.stopPropagation();

        //Distance hardcoded to 10px
        const distance = event.key === 'ArrowDown' || event.key === 'ArrowRight' ? 10 : -10;

        switch (event.key) {
            case 'ArrowUp':
            case 'ArrowDown':
            case 'ArrowLeft':
            case 'ArrowRight': {
                if (that.minimized || document.activeElement !== that) {
                    return;
                }

                let direction = event.key.indexOf('Right') > -1 || event.key.indexOf('Left') > -1;

                event.preventDefault();

                if (!direction && event.altKey) {
                    event.key === 'ArrowUp' ? that.maximize() : that.restore();
                    return;
                }

                if (that.maximized) {
                    return;
                }

                //that.style.transition = '';
                that.$.addClass('no-transition');

                if (event.ctrlKey && that.resizeMode !== 'none' && !that.collapsed) {
                    if (['horizontal', 'vertical', 'both'].indexOf(that.resizeMode) === -1) {
                        direction = that.resizeMode;
                    }
                    else {
                        direction = direction ? 'right' : 'bottom';
                    }

                    if (that.hasAttribute('dragged')) {
                        that._cancelDragging(event);
                    }

                    if (!that.hasAttribute('resized')) {
                        that.$.fireEvent('resizeStart', { 'position': { x: event.pageX, y: event.pageY } });
                    }

                    that._resize(direction, distance);
                    return;
                }

                if (!that.pinned) {
                    if (!that.hasAttribute('dragged')) {
                        that.setAttribute('dragged', '');
                        that.$.fireEvent('dragStart', { 'position': { left: event.pageX, top: event.pageY } });
                    }

                    that._drag(distance, direction ? 'horizontal' : 'vertical');
                }

                //that.style.transition = '';
                that.$.removeClass('no-transition');
                break;
            }
            case 'Escape':
                if (that.headerButtons.indexOf('close') > -1 && document.activeElement === that) {
                    that.close();
                }

                break;
            case 'p':
                if (event.altKey && that.headerButtons.indexOf('pin') > -1) {
                    that.pinned ? that.unpin() : that.pin();
                }

                break;
            case 'c':
                if (event.altKey && that.headerButtons.indexOf('collapse') > -1) {
                    that.collapsed ? that.expand() : that.collapse();
                }

                break;

            case 'm':
                if (event.altKey && that.headerButtons.indexOf('minimize') > -1) {
                    that.minimized ? that.restore() : that.minimize();
                }

                break;
            case 'Tab':
                if (that.opened && that.modal) {
                    that._changingFocus = true;
                }

                break;
            case 'Enter':
            case ' ':
                {
                    const target = event.target.closest && event.target.closest('jqx-button');

                    if (!target) {
                        return;
                    }

                    that._isWindowButton(that._buttonPressed = target);
                    delete that._buttonPressed;
                    break;
                }

        }
    }

    /**
     * KeyUp Event Handler
     */
    _keyUpHandler(event) {
        const that = this;

        if (!event.key) {
            return;
        }

        if (event.key === 'Control' && that._dragDetails && that.hasAttribute('resized') && !that._mouseManipulation) {
            if (!that._dragDetails.started) {
                return;
            }

            if (that._dragDetails.type !== 'drag') {
                that.removeAttribute('resized');
                that.$.fireEvent('resizeEnd', { x: event.pageX, y: event.pageY, width: that._dragDetails.newWidth, height: that._dragDetails.newHeight });
                that._handleWindowResizeDummy();
            }

            that._dragDetails.started = false;
        }

        if (event.key.indexOf('Arrow') > -1 && that.hasAttribute('dragged') && !that._mouseManipulation) {
            that._cancelDragging(event);
        }
    }

    /**
     * Document Mouse Wheel event
     */
    _mouseWheelHandler(event) {
        const that = this;

        if (that.disabled || !(that._dragDetails && that._dragDetails.started)) {
            return;
        }

        //document.documentElement.scrollTop is always 0 in MS EDGE but not in IE11!
        if (event.deltaY < 0 && that._windowParent.scrollElement.scrollTop + event.deltaY <= 0) {
            that.style.top = Math.max(0, that._dragDetails.windowY) + 'px';
            return;
        }

        if (event.deltaY > 0 && (that._dragDetails.windowY + that.offsetHeight + event.deltaY >= that._windowParent.scrollElement.scrollHeight ||
            that._windowParent.scrollElement.scrollTop + that._windowParent.element.clientHeight === that._windowParent.scrollElement.scrollHeight)) {
            return;
        }

        if (that._dragDetails.type === 'drag') {
            that._dragDetails.windowY += event.deltaY;
            that.style.top = that._dragDetails.windowY + 'px';
        }
        else {
            that._dragDetails.height += event.deltaY;
            that.style.height = that._dragDetails.height + 'px';
        }
    }

    /**
     * Element's Mouse Move handler'
     */
    _moveHandler(event) {
        const that = this;

        if (that.disabled || that.collapsed || that.maximized || that.minimized) {
            return;
        }

        //iOS Safari fix for dragging (prevents window scrolling)
        if (JQX.Utilities.Core.isMobile && !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform) && that.hasAttribute('dragged')) {
            event.originalEvent.preventDefault();
        }

        if (that._mouseManipulation) {
            return;
        }

        if (that.$.container.className.indexOf('jqx-window-resizing') > -1) {
            that.$.container.className = 'jqx-container';
        }

        //Set resizing cursor
        if (that.resizeMode !== 'none') {
            const windowCoordinates = that.getBoundingClientRect(),
                isNearTop = event.clientY < windowCoordinates.top + 10 ? true : false,
                isNearBottom = event.clientY > windowCoordinates.bottom - 10 ? true : false,
                isNearRight = event.clientX > windowCoordinates.right - 10 ? true : false,
                isNearLeft = event.clientX < windowCoordinates.left + 10 ? true : false;

            switch (that.resizeMode) {
                case 'none':
                    break;
                case 'both':
                    if (that.resizeIndicator) {
                        if (isNearBottom && isNearRight) {
                            that.$.container.classList.add('jqx-window-resizing-bottom-right');
                        }

                        return;
                    }

                    if (isNearLeft || isNearRight) {
                        if (isNearTop) {
                            isNearLeft ? that.$.container.classList.add('jqx-window-resizing-top-left') : that.$.container.classList.add('jqx-window-resizing-top-right');
                            return;
                        }
                        else if (isNearBottom) {
                            isNearLeft ? that.$.container.classList.add('jqx-window-resizing-bottom-left') : that.$.container.classList.add('jqx-window-resizing-bottom-right');
                            return;
                        }

                        isNearLeft ? that.$.container.classList.add('jqx-window-resizing-left') : that.$.container.classList.add('jqx-window-resizing-right');
                        return;
                    }

                    if (isNearTop || isNearBottom) {
                        if (isNearRight) {
                            isNearTop ? that.$.container.classList.add('jqx-window-resizing-top-right') : that.$.container.classList.add('jqx-window-resizing-bottom-right');
                            return;
                        }
                        else if (isNearLeft) {
                            isNearTop ? that.$.container.classList.add('jqx-window-resizing-top-left') : that.$.container.classList.add('jqx-window-resizing-bottom-left');
                            return;
                        }

                        isNearTop ? that.$.container.classList.add('jqx-window-resizing-top') : that.$.container.classList.add('jqx-window-resizing-bottom');
                    }

                    break;
                case 'horizontal':
                    if (that.resizeIndicator) {
                        if (isNearBottom && isNearRight) {
                            that.$.container.classList.add('jqx-window-resizing-right');
                        }

                        return;
                    }

                    if (isNearLeft) {
                        that.$.container.classList.add('jqx-window-resizing-left');
                        return;
                    }

                    if (isNearRight) {
                        that.$.container.classList.add('jqx-window-resizing-right');
                    }

                    break;
                case 'vertical':
                    if (that.resizeIndicator) {
                        if (isNearBottom && isNearRight) {
                            that.$.container.classList.add('jqx-window-resizing-bottom');
                        }

                        return;
                    }

                    if (isNearTop) {
                        that.$.container.classList.add('jqx-window-resizing-top');
                        return;
                    }

                    if (isNearBottom) {
                        that.$.container.classList.add('jqx-window-resizing-bottom');
                    }

                    break;
                case 'top':
                    if (isNearTop) {
                        if (that.resizeIndicator && !isNearLeft) {
                            return;
                        }

                        that.$.container.classList.add('jqx-window-resizing-top');
                    }

                    break;
                case 'bottom':
                    if (isNearBottom) {
                        if (that.resizeIndicator && !isNearRight) {
                            return;
                        }

                        that.$.container.classList.add('jqx-window-resizing-bottom');
                    }

                    break;
                case 'left':
                    if (isNearLeft) {
                        if (that.resizeIndicator && !isNearTop) {
                            return;
                        }

                        that.$.container.classList.add('jqx-window-resizing-left');
                    }

                    break;
                case 'right':
                    if (isNearRight) {
                        if (that.resizeIndicator && !isNearBottom) {
                            return;
                        }

                        that.$.container.classList.add('jqx-window-resizing-right');
                    }

                    break;
            }
        }
    }

    /**
     * Handles the active state of the Window
     */
    _handleActiveState() {
        const that = this;

        //Remove the active state of all windows on page
        const allWindowsOnPage = document.getElementsByClassName('jqx-window');

        for (let w = 0; w < allWindowsOnPage.length; w++) {
            if (!allWindowsOnPage[w].contains(that) && !that.contains(allWindowsOnPage[w])) {
                allWindowsOnPage[w].removeAttribute('active');
            }
        }

        that.setAttribute('active', '');
    }

    /**
     * Creates a resize dummy that's used during resizing ( if liveResize is off ).
     */
    _handleWindowResizeDummy() {
        const that = this;

        if (!that._resizeDummy) {
            that._resizeDummy = document.createElement('div');
            that._resizeDummy.classList.add('jqx-window-resize-feedback');
        }

        if (!that.hasAttribute('resized')) {
            if (that._resizeDummy.parentElement) {
                that._resizeDummy.parentElement.removeChild(that._resizeDummy);
            }

            if (!that.liveResize && that._dragDetails.type === 'resize' && that._dragDetails.started) {
                that.style.top = that._dragDetails.top + 'px';
                that.style.left = that._dragDetails.left + 'px';
                that.style.width = that._dragDetails.newWidth + 'px';
                that.style.height = that._dragDetails.newHeight + 'px';
            }

            return;
        }

        if (that._resizeDummy.parentElement) {
            return;
        }

        that._resizeDummy.style.width = that.offsetWidth + 'px';
        that._resizeDummy.style.height = that.offsetHeight + 'px';
        that._resizeDummy.style.top = that.offsetTop + 'px';
        that._resizeDummy.style.left = that.offsetLeft + 'px';

        that._windowParent.element.appendChild(that._resizeDummy);
    }

    /**
    * 
    * @param {any} side - the side from which the dragging occurs
    * @param {any} event - mouse pointer event
    */
    _resize(side, event) {
        const that = this;
        let size;

        if (!that._dragDetails || (that._dragDetails && that._dragDetails.type === 'drag')) {
            that._setDragDetails('resize');
        }

        if (!that._dragDetails) {
            return;
        }

        that._dragDetails.started = true;

        if (!that.hasAttribute('resized')) {
            that.setAttribute('resized', '');

            //Disables animatied movement
            //that.style.transition = 'none';

            if (that.hasAnimation) {
                that.$.addClass('no-transition');
            }
        }

        if (!that.liveResize) {
            that._handleWindowResizeDummy();
        }

        const width = that._snapDummy && that.$.hasClass('jqx-window-snapped-' + that._snapDummy._position) ? 'snapWindowWidth' : 'width';

        //document.documentElement.scrollTop is always 0 in MS EDGE but not in IE11!
        switch (side) {
            case 'left': {
                size = typeof (event) === 'object' ? event.pageX - that._dragDetails.x : event;

                if (size > 0) {
                    size = Math.min(size, that._dragDetails[width] - that._dragDetails.minWidth);
                }
                else {
                    size = Math.min(that._dragDetails.maxWidth ? that._dragDetails.maxWidth - that._dragDetails[width] : that._dragDetails.left, Math.abs(size)) * -1;
                }

                that._dragDetails[width] = Math.min(that._dragDetails[width] + that._dragDetails.left - that._windowParent.scrollElement.scrollLeft, that._dragDetails[width] - size);
                that._dragDetails.windowX = Math.max(that._windowParent.scrollElement.scrollLeft, that._dragDetails.windowX + size);

                if (typeof (event) !== 'object') {
                    that._dragDetails[width] = Math.max(that._dragDetails[width], that._dragDetails.minWidth);
                }

                if (that._dragDetails[width] >= that._dragDetails.minWidth) {
                    that._dragDetails.left = that._dragDetails.windowX;
                    that._dragDetails.newWidth = that._dragDetails[width];
                }

                break;
            }
            case 'right': {
                const borderWidth = that._windowParent.element.clientWidth !== that._windowParent.element.offsetWidth ? that._windowParent.borderWidth : 0,
                    width = that._snapDummy && that.$.hasClass('jqx-window-snapped-' + that._snapDummy._position) ? 'snapWindowWidth' : 'width';

                size = typeof (event) === 'object' ? event.pageX - that._dragDetails.x : event;

                if (size > 0 && that._dragDetails.maxWidth) {
                    size = Math.min(that._dragDetails.maxWidth - that._dragDetails[width], size);
                }

                that._dragDetails[width] = Math.min(that._windowParent.element.clientWidth + that._windowParent.scrollElement.scrollLeft - that._dragDetails.left -
                    borderWidth, Math.max(0, that._dragDetails[width] + size));

                if (typeof (event) !== 'object') {
                    that._dragDetails[width] = Math.max(that._dragDetails[width], that._dragDetails.minWidth);
                }

                that._dragDetails.left = that.offsetLeft;
                that._dragDetails.newWidth = Math.max(that._dragDetails.minWidth, that._dragDetails[width]);
                break;
            }
            case 'top':
                if (that._snapDummy && that.$.hasClass('jqx-window-snapped-' + that._snapDummy._position)) {
                    that._dragDetails.height = that._dragDetails.snapWindowHeight;
                }

                size = typeof (event) === 'object' ? event.pageY - that._dragDetails.y : event;

                if (size > 0) {
                    size = Math.min(size, that._dragDetails.height - that._dragDetails.minHeight);
                }
                else {
                    size = Math.min(that._dragDetails.maxHeight ? that._dragDetails.maxHeight - that._dragDetails.height : that._dragDetails.top, Math.abs(size)) * -1;
                }

                that._dragDetails.snapWindowHeight = that._dragDetails.height =
                    Math.min(that._dragDetails.height + that._dragDetails.top - that._windowParent.scrollElement.scrollTop, that._dragDetails.height - size);

                that._dragDetails.windowY = Math.max(that._windowParent.scrollElement.scrollTop, that._dragDetails.windowY + size);

                if (typeof (event) !== 'object') {
                    that._dragDetails.snapWindowHeight = that._dragDetails.height = Math.max(that._dragDetails.height, that._dragDetails.minHeight);
                }

                if (that._dragDetails.height >= that._dragDetails.minHeight) {
                    that._dragDetails.top = that._dragDetails.windowY;
                    that._dragDetails.newHeight = that._dragDetails.height;
                }

                that._dragDetails.newWidth = Math.max(that._dragDetails[width], that._dragDetails.newWidth);
                break;
            case 'bottom':
                if (that._snapDummy && that.$.hasClass('jqx-window-snapped-' + that._snapDummy._position)) {
                    that._dragDetails.height = that._dragDetails.snapWindowHeight;
                }

                size = typeof (event) === 'object' ? event.pageY - that._dragDetails.y : event;

                if (size > 0 && that._dragDetails.maxHeight) {
                    size = Math.min(that._dragDetails.maxHeight - that._dragDetails.height, size);
                }

                that._dragDetails.snapWindowHeight = that._dragDetails.height =
                    Math.min(that._windowParent.element.clientHeight + that._windowParent.scrollElement.scrollTop - that._dragDetails.top -
                        that._windowParent.borderWidth, Math.max(0, that._dragDetails.height + size));

                if (typeof (event) !== 'object') {
                    that._dragDetails.snapWindowHeight = that._dragDetails.height = Math.max(that._dragDetails.height, that._dragDetails.minHeight);
                }

                that._dragDetails.newHeight = Math.max(that._dragDetails.minHeight, that._dragDetails.height);
                that._dragDetails.newWidth = Math.max(that._dragDetails[width], that._dragDetails.newWidth);
                break;
            case 'bottomLeftCorner':
                that._resize('bottom', event);
                that._resize('left', event);
                break;
            case 'bottomRightCorner':
                that._resize('bottom', event);
                that._resize('right', event);
                break;
            case 'topLeftCorner':
                that._resize('top', event);
                that._resize('left', event);
                break;
            case 'topRightCorner':
                that._resize('top', event);
                that._resize('right', event);
                break;
        }

        const resizeTarget = that.liveResize ? that : that._resizeDummy;

        that._dragDetails.newHeight = Math.max(that._dragDetails.snapWindowHeight, that._dragDetails.newHeight);

        resizeTarget.style.top = that._dragDetails.top + 'px';
        resizeTarget.style.left = that._dragDetails.left + 'px';
        resizeTarget.style.width = that._dragDetails.newWidth + 'px';
        resizeTarget.style.height = that._dragDetails.newHeight + 'px';
    }

    /**
     * Restore the window from minimization
     */
    _restoreFromMinimization() {
        const that = this;

        that.minimized = false;
        that.style.width = that.style.height = that.style.top = that.style.left = '';

        //Re-arrange the rest of the minimized windows
        that._refreshMinimizedWindowsPosition();
    }

    /**
     * Recalculates the position of the minimized windows on the page
     */
    _refreshMinimizedWindowsPosition() {
        const that = this;

        const minimizedWindows = that._getAllMinimizedWindows();

        if (minimizedWindows.length === 0) {
            return;
        }

        //Some offset from the edge of the window
        minimizedWindows[0].style.left = '5px';

        let lastWindow;

        //Using style.left instead of offsetLeft to ignore the transiton of the animation if enabled
        for (let i = 1; i < minimizedWindows.length; i++) {
            if (parseFloat(minimizedWindows[i - 1].style.left) + minimizedWindows[i - 1].offsetWidth + minimizedWindows[i].offsetWidth + 10 <
                that._windowParent.element.clientWidth) {

                minimizedWindows[i].style.left = (parseFloat(minimizedWindows[i - 1].style.left) + minimizedWindows[i - 1].offsetWidth + 5) + 'px';
                minimizedWindows[i].style.top = minimizedWindows[i - 1].offsetTop + 'px';
                lastWindow = minimizedWindows[i];
            }
            else {
                minimizedWindows[i].style.left = parseFloat(lastWindow.style.left) + 'px';
                minimizedWindows[i].style.top = lastWindow.offsetTop + 'px';
            }
        }
    }

    /**
     * Set the visibility of the Header Buttons
     */
    _setHeaderButtons() {
        const that = this,
            buttons = that.headerButtons,
            currentButtons = that.$.buttonsContainer.children,
            isAlreadyCreated = function (name) {
                const button = that.$.buttonsContainer.getElementsByClassName('jqx-' + (name + '').split(/(?=[A-Z])/).join('-').toLowerCase() + '-button')[0];

                if (button) {
                    button.$.removeClass('jqx-hidden');
                }

                return button;
            };

        for (let b = 0; b < currentButtons.length; b++) {
            currentButtons[b].$.addClass('jqx-hidden');
        }

        //Create a new custom header button
        if (buttons.length > 0) {

            for (let i = 0; i < buttons.length; i++) {
                let button = isAlreadyCreated(buttons[i]);

                if (!button) {
                    button = document.createElement('jqx-button');
                    button.$.addClass('jqx-' + (buttons[i] + '').split(/(?=[A-Z])/).join('-').toLowerCase() + '-button');
                    button.theme = that.theme;
                }

                that.$.buttonsContainer.insertBefore(button, that.$.buttonsContainer.firstElementChild);
            }
        }
    }

    /**
     * Creates the Drag details for window dragging and resizing
     * @param {any} type - type of event
     * @param {any} event - event details (optional)
     */
    _setDragDetails(type, event) {
        const that = this;

        if (!that._dragDetails) {
            that._dragDetails = {};
        }

        if (that._dragDetails.minWidth === undefined || that._dragDetails.minHeight === undefined ||
            that._dragDetails.maxWidth === undefined || that._dragDetails.maxHeight === undefined) {
            const computedStyle = getComputedStyle(that);

            that._dragDetails.minWidth = parseFloat(computedStyle.getPropertyValue('min-width')) || 0;
            that._dragDetails.minHeight = parseFloat(computedStyle.getPropertyValue('min-height')) || 0;
            that._dragDetails.maxWidth = parseFloat(computedStyle.getPropertyValue('max-width')) || 0;
            that._dragDetails.maxHeight = parseFloat(computedStyle.getPropertyValue('max-height')) || 0;
        }

        that._dragDetails.windowX = that.offsetLeft;
        that._dragDetails.windowY = that.offsetTop;

        const elementStyle = that.getBoundingClientRect();

        if (!that._snapDummy || !that.$.hasClass('jqx-window-snapped-' + that._snapDummy._position)) {

            // Left/Top of the direct parent of the element.
            const parentStyle = that.parentElement === document.body ?
                document.documentElement.getBoundingClientRect() : that.parentElement.getBoundingClientRect(),
                scrollX = window.scrollX || window.pageXOffset,
                scrollY = window.scrollY || window.pageYOffset;

            that._windowParent.offsetLeft = parentStyle.left + scrollX;
            that._windowParent.offsetTop = parentStyle.top + scrollY;

            if (event && typeof event === 'object') {
                that._dragDetails.offsetX = event.clientX - elementStyle.left;
                that._dragDetails.offsetY = event.clientY - elementStyle.top;
            }

            if (!that.collapsed) {
                that._dragDetails.width = that.offsetWidth;
                that._dragDetails.height = that.offsetHeight;

                if (that.style.width || that.style.height) {
                    that._dragDetails.resized = true;
                }
            }
        }
        else if (that.headerPosition === 'right' && that.collapsed) {
            that._dragDetails.offsetX = elementStyle.left + that.offsetWidth - event.clientX;
        }

        if (type === 'minimize' || !type) {
            return;
        }

        that._dragDetails.type = type;
        that._dragDetails.started = true;
        that._dragDetails.snapWindowWidth = that.offsetWidth;
        that._dragDetails.snapWindowHeight = that.offsetHeight;

        if (event && typeof (event) === 'object') {
            that._dragDetails.x = event.pageX;
            that._dragDetails.y = event.pageY;
        }
        else {
            that._dragDetails.x = that.offsetLeft;
            that._dragDetails.y = that.offsetTop;
        }

        if (type === 'resize') {
            if (that.resizeMode === 'none') {
                delete that._dragDetails;
                return;
            }

            that._dragDetails.top = that.offsetTop;
            that._dragDetails.left = that.offsetLeft;
            that._dragDetails.newWidth = that._dragDetails.width;
            that._dragDetails.newHeight = that._dragDetails.height;

            if (that.$container.hasClass('jqx-window-resizing-right')) {
                that._dragDetails.side = 'right';
            }
            else if (that.$container.hasClass('jqx-window-resizing-left')) {
                that._dragDetails.side = 'left';
            }
            else if (that.$container.hasClass('jqx-window-resizing-top')) {
                that._dragDetails.side = 'top';
            }
            else if (that.$container.hasClass('jqx-window-resizing-bottom')) {
                that._dragDetails.side = 'bottom';
            }
            else if (that.$container.hasClass('jqx-window-resizing-top-left')) {
                that._dragDetails.side = 'topLeftCorner';
            }
            else if (that.$container.hasClass('jqx-window-resizing-bottom-left')) {
                that._dragDetails.side = 'bottomLeftCorner';
            }
            else if (that.$container.hasClass('jqx-window-resizing-top-right')) {
                that._dragDetails.side = 'topRightCorner';
            }
            else if (that.$container.hasClass('jqx-window-resizing-bottom-right')) {
                that._dragDetails.side = 'bottomRightCorner';
            }
        }
    }

    /**
     * Set the window parent.
     */
    _setElementParent(id) {
        const that = this;

        that._windowParent.element = undefined;

        if (that._windowParent.parent &&
            !that._windowParent.parent.querySelectorAll('jqx-window, jqx-dialog-window, jqx-progress-window, jqx-wait-window, ' +
                'jqx-alert-window, jqx-prompt-window, jqx-multiline-prompt-window')) {
            that._windowParent.parent.style.position = '';
        }

        if (id instanceof HTMLElement) {
            that._windowParent.element = id;
        }
        else if (typeof (id) === 'string') {
            that._windowParent.element = id === 'body' ? document.body : document.getElementById(id);
        }

        if (!that._windowParent.element) {
            that._windowParent.element = that._windowParent.initialParent.parentElement ? that._windowParent.initialParent : document.body;
        }

        if (that.parentElement !== that._windowParent.element) {
            that._windowParent.element.appendChild(that);
        }

        if (that._windowParent.element === document.body) {
            that._windowParent.element = document.documentElement;
            that._windowParent.scrollElement = document.scrollingElement;
            //Neccessary because EDGE and Safari have a bug

            that._windowParent.parent = document.body;
            that._windowParent.borderWidth = 0;
        }
        else {

            //Specific case for jqxWindow nesting
            if (that._windowParent.element instanceof JQX.Window) {
                that._windowParent.element = that._windowParent.element.$.content;
            }

            const computedStyle = getComputedStyle(that.parentElement),
                windowParentPosition = computedStyle.getPropertyValue('position');

            that._windowParent.borderWidth = 2 * parseInt(computedStyle.getPropertyValue('border-width') || 0);
            that._windowParent.parent = that.parentElement;
            that._windowParent.scrollElement = that._windowParent.element;

            if (windowParentPosition !== 'relative') {
                that.parentElement.style.position = 'relative';
            }
        }

        that._setModal();

        if (that.style.left && that.offsetLeft > that._windowParent.scrollElement.scrollWidth) {
            that.style.left = that._windowParent.scrollElement.scrollWidth - that.offsetWidth + 'px';
        }

        if (that.style.top && that.offsetTop > that._windowParent.scrollElement.scrollHeight) {
            that.style.top = that._windowParent.scrollElement.scrollHeight - that.offsetHeight + 'px';
        }
    }

    /**
     * Enable/Disable modal mode
     */
    _setModal() {
        const that = this;

        delete that._changingFocus;

        if (!that._windowParent.element) {
            return;
        }

        if (!that.modal) {
            if (that._modal && that._modal.parentElement) {
                that._modal.parentElement.removeChild(that._modal);
                delete that._modal;
            }

            return;
        }

        if (!that._modal) {
            that._modal = document.createElement('div');
            that._modal.classList.add('jqx-modal');
        }

        if (that._windowParent.parent !== document.body) {
            that._modal.setAttribute('nested-modal', '');
        }
        else {
            that._modal.removeAttribute('nested-modal');
        }

        that._modal._window = that;


        if (that.opened && !that._modal.parentElement) {
            const zIndex = parseInt(getComputedStyle(that).getPropertyValue('z-index'));

            if (!isNaN(zIndex)) {
                that._modal.style.zIndex = zIndex - 1;
            }

            that.parentElement.insertBefore(that._modal, that);
        }
        else if (that._modal.parentElement) {
            that._modal.parentElement.removeChild(that._modal);
        }
    }
});

/**
* jqxDialogWindow
*/
JQX('jqx-dialog-window', class DialogWindow extends JQX.Window {

    /**
    * Element's properties
    */
    static get properties() {
        return {
            'cancelLabel': {
                value: 'Cancel',
                type: 'string'
            },
            'confirmLabel': {
                value: 'Ok',
                type: 'string'
            },
            'disableSnap': {
                value: true,
                readOnly: true,
                type: 'boolean'
            },
            'headerButtons': {
                value: ['close'],
                type: 'array'
            },
            'modal': {
                value: true,
                readOnly: true,
                type: 'boolean',
                defaultReflectToAttribute: true
            }
        }
    }

    /**
    * Element's event listeners.
    */
    static get listeners() {
        return {
            'footer.click': '_footerClickHandler'
        }
    }

    /**
   * Element's HTML template.
   */
    template() {
        return `<div id="container">
                    <div id="headerSection" class="jqx-header-section">
                        <div id="header" class="jqx-header">[[label]]</div>
                        <div id="buttonsContainer" class="jqx-buttons-container">
                            <jqx-button id="pinButton" class="jqx-pin-button" animation="[[animation]]" theme="[[theme]]"></jqx-button>
                            <jqx-button id="collapseButton" class="jqx-collapse-button" animation="[[animation]]" theme="[[theme]]"></jqx-button>
                            <jqx-button id="minimizeButton" class="jqx-minimize-button" animation="[[animation]]" theme="[[theme]]"></jqx-button>
                            <jqx-button id="maximizeButton" class="jqx-maximize-button" animation="[[animation]]" theme="[[theme]]"></jqx-button>
                            <jqx-button id="closeButton" class="jqx-close-button" animation="[[animation]]" theme="[[theme]]"></jqx-button>
                        </div>
                    </div>
                    <div class="jqx-content">
                        <content></content>
                    </div>
                    <div id="footer" class="jqx-footer">
                        <jqx-button id="confirmButton" class="jqx-confirm-button" animation="[[animation]]" theme="[[theme]]">[[confirmLabel]]</jqx-button>
                        <jqx-button id="cancelButton" class="jqx-cancel-button" animation="[[animation]]" theme="[[theme]]">[[cancelLabel]]</jqx-button>
                    </div>
                </div>`;
    }

    /**
     * Footer Click Event Handler
     * @param {any} event
     */
    _footerClickHandler(event) {
        const that = this,
            target = event.target;

        if (target.closest('.jqx-confirm-button')) {
            that.$.fireEvent('confirm');
        }
        else if (target.closest('.jqx-cancel-button')) {
            that.$.fireEvent('cancel');
        }
    }

    /**
     * Key Down event handler
     * @param {any} event - event details
     */
    _keyDownHandler(event) {
        const that = this;

        delete that._changingFocus;

        if (that.disabled || ((that.hasAttribute('dragged') || that.hasAttribute('resized')) && that._mouseManipulation)) {
            return;
        }

        event.stopPropagation();

        //Distance hardcoded to 10px
        const distance = event.key === 'ArrowDown' || event.key === 'ArrowRight' ? 10 : -10;

        switch (event.key) {
            case 'ArrowUp':
            case 'ArrowDown':
            case 'ArrowLeft':
            case 'ArrowRight': {
                if (that.minimized || document.activeElement !== that) {
                    return;
                }

                const direction = event.key.indexOf('Right') > -1 || event.key.indexOf('Left') > -1;

                event.preventDefault();

                if (!direction && event.altKey) {
                    event.key === 'ArrowUp' ? that.maximize() : that.restore();
                    return;
                }

                that.$.addClass('no-transition');

                if (that.maximized) {
                    return;
                }

                if (event.ctrlKey && that.resizeMode !== 'none') {
                    if (that.hasAttribute('dragged')) {
                        that._cancelDragging(event);
                    }

                    if (!that.hasAttribute('resized')) {
                        that.$.fireEvent('resizeStart', { 'position': { x: event.pageX, y: event.pageY } });
                    }

                    that._resize(direction ? 'right' : 'bottom', distance);
                    return;
                }

                if (!that.pinned) {
                    if (!that.hasAttribute('dragged')) {
                        that.setAttribute('dragged', '');
                        that.$.fireEvent('dragStart', { 'position': { left: event.pageX, top: event.pageY } });
                    }

                    that._drag(distance, direction ? 'horizontal' : 'vertical');
                }

                //that.style.transition = '';
                that.$.removeClass('no-transition');
                break;
            }
            case 'Escape':
                if (that.headerButtons.indexOf('close') > -1 && document.activeElement === that) {
                    that.close();
                }
                break;
            case 'Tab':
                if (that.opened && that.modal) {
                    that._changingFocus = true;
                }

                break;
            case 'Enter':
            case ' ':
                {
                    const target = event.target.closest && event.target.closest('jqx-button');

                    if (!target) {
                        return;
                    }

                    that._isWindowButton(that._buttonPressed = target);
                    delete that._buttonPressed;
                    break;
                }
        }
    }
});

JQX('jqx-alert-window', class AlertWindow extends JQX.DialogWindow {
    /**
    * Element's properties
    */
    static get properties() {
        return {
            'headerButtons': {
                value: [],
                type: 'array'
            }
        }
    }
});

JQX('jqx-prompt-window', class PromptWindow extends JQX.DialogWindow {

    /**
    * Element's properties
    */
    static get properties() {
        return {
            'autoComplete': {
                allowedValues: ['none', 'manual', 'auto', 'inline'],
                type: 'string',
                value: 'manual'
            },
            'confirmLabel': {
                value: 'Ok',
                type: 'string'
            },
            'cancelLabel': {
                value: 'Cancel',
                type: 'string'
            },
            'disableSnap': {
                value: true,
                readOnly: true,
                type: 'boolean'
            },
            'displayMode': {
                value: 'default',
                allowedValues: ['default', 'escaped'],
                type: 'string'
            },
            'headerButtons': {
                value: ['close'],
                type: 'array'
            },
            'form': {
                value: '',
                type: 'string'
            },
            'hint': {
                value: null,
                type: 'any?'
            },
            'maxLength': {
                value: null,
                type: 'number?'
            },
            'minLength': {
                value: 2,
                type: 'number'
            },
            'messages': {
                extend: true,
                value: {
                    'en': {
                        'missingReference': '{{elementType}}: Missing reference to {{files}}.'
                    }
                },
                type: 'object'
            },
            'modal': {
                value: true,
                readOnly: true,
                type: 'boolean',
                defaultReflectToAttribute: true
            },
            'name': {
                value: '',
                type: 'string'
            },
            'placeholder': {
                value: '',
                type: 'string'
            },
            'promptLabel': {
                value: '',
                type: 'string?'
            },
            'required': {
                value: false,
                type: 'boolean'
            },
            'requiredMessage': {
                value: '',
                type: 'string'
            },
            'selectAllOnFocus': {
                value: false,
                type: 'boolean'
            },
            'value': {
                value: '',
                type: 'string'
            }
        }
    }

    /**
   * Element's HTML template.
   */
    template() {
        return `<div id="container">
                    <div id="headerSection" class="jqx-header-section">
                        <div id="header" class="jqx-header">[[label]]</div>
                        <div id="buttonsContainer" class="jqx-buttons-container">
                            <jqx-button id="closeButton" class="jqx-close-button" animation="[[animation]]" theme="[[theme]]"></jqx-button>
                        </div>
                    </div>
                    <div class="jqx-content">
                        <content></content>
                        <jqx-text-box id="textBox"
                            animation="[[animation]]"
                            auto-complete="[[autoComplete]]"
                            max-length="[[maxLength]]"
                            value="{{value}}"
                            form="[[form]]"
                            label="[[promptLabel]]"
                            hint="[[hint]]"
                            display-mode="[[displayMode]]"
                            max-length="[[maxLength]]"
                            placeholder="[[placeholder]]"
                            required="[[required]]"
                            required-message="[[requiredMessage]]"
                            select-all-on-focus="[[selectAllOnFocus]]"
                            theme="[[theme]]">
                        </jqx-text-box>
                    </div>
                    <div id="footer" class="jqx-footer">
                        <jqx-button id="confirmButton" class="jqx-confirm-button flat" animation="[[animation]]" theme="[[theme]]">[[confirmLabel]]</jqx-button>
                        <jqx-button id="cancelButton" class="jqx-cancel-button flat" animation="[[animation]]" theme="[[theme]]">[[cancelLabel]]</jqx-button>
                    </div>
                </div>`;
    }

    /**
* Element's event listeners.
*/
    static get listeners() {
        return {
            'footer.click': '_footerClickHandler'
        }
    }

    /**
    * Checks for missing modules.
    */
    static get requires() {
        return {
            'JQX.TextBox': 'jqxtextbox.js'
        }
    }

    /**
     * Footer Click Event Handler
     * @param {any} event
     */
    _footerClickHandler(event) {
        const that = this,
            target = event.target;

        if (target.closest('.jqx-confirm-button')) {
            that.$.fireEvent('confirm', { value: that.$.textBox.value });
        }
        else if (target.closest('.jqx-cancel-button')) {
            that.$.fireEvent('cancel', { value: that.$.textBox.value });
        }
    }

    /**
     * Key Down event handler
     * @param {any} event - event details
     */
    _keyDownHandler(event) {
        const that = this;

        delete that._changingFocus;

        function endDrag() {
            if (that._dragDetails) {
                that._dragDetails.started = false;
            }

            that.$.removeClass('no-transition');
        }

        if (that.disabled || (that._dragDetails && that._dragDetails.started)) {
            return;
        }

        event.stopPropagation();

        //Distance hardcoded to 10px
        const distance = event.key === 'ArrowDown' || event.key === 'ArrowRight' ? 10 : -10;

        //that.style.transition = '';
        that.$.removeClass('no-transition');

        switch (event.key) {
            case 'ArrowUp':
            case 'ArrowDown':
                if (document.activeElement !== that) {
                    return;
                }

                event.preventDefault();

                if (event.altKey) {
                    event.key === 'ArrowUp' ? that.maximize() : that.restore();
                    endDrag();
                    return;
                }

                that.$.addClass('no-transition');

                if (event.ctrlKey) {
                    that._resize('bottom', distance);
                    endDrag();
                    return;
                }

                that._drag(distance, 'vertical');
                break;
            case 'ArrowLeft':
            case 'ArrowRight':
                if (document.activeElement !== that) {
                    return;
                }

                event.preventDefault();
                that.$.addClass('no-transition');

                if (event.ctrlKey) {
                    that._resize('right', distance);
                    endDrag();
                    return;
                }

                that._drag(distance, 'horizontal');
                that.$.removeClass('no-transition');
                break;
            case 'Escape':
                if (that.headerButtons.indexOf('close') > -1 && document.activeElement === that)
                    that.close();
                break;
            case 'Tab':
                if (that.opened && that.modal) {
                    that._changingFocus = true;
                }

                break;
            case 'Enter':
            case ' ':
                {
                    const target = event.target.closest && event.target.closest('jqx-button');

                    if (!target) {
                        return;
                    }

                    that._isWindowButton(that._buttonPressed = target);
                    delete that._buttonPressed;
                    break;
                }
        }

        endDrag();
    }
});

JQX('jqx-multiline-prompt-window', class MultiLinePromptWindow extends JQX.PromptWindow {

    /**
    * Element's properties
    */
    static get properties() {
        return {
            'autoCapitalize': {
                value: 'none',
                allowedValues: ['none', 'words', 'characters'],
                type: 'string'
            },
            'autoExpand': {
                value: false,
                type: 'boolean'
            },
            'headerButtons': {
                value: ['close'],
                type: 'array'
            },
            'horizontalScrollBarVisibility': {
                type: 'string',
                value: 'auto',
                allowedValues: ['auto', 'disabled', 'hidden', 'visible']
            },
            'modal': {
                value: true,
                readOnly: true,
                type: 'boolean',
                defaultReflectToAttribute: true
            },
            'selectionDirection': {
                value: 'none',
                allowedValues: ['forward', 'backward', 'none'],
                type: 'string'
            },
            'selectionEnd': {
                value: 0,
                reflectToAttribute: false,
                type: 'number'
            },
            'selectionStart': {
                value: 0,
                reflectToAttribute: false,
                type: 'number'
            },
            'spellCheck': {
                value: false,
                type: 'boolean'
            },
            'verticalScrollBarVisibility': {
                type: 'string',
                value: 'auto',
                allowedValues: ['auto', 'disabled', 'hidden', 'visible']
            },
            'wrap': {
                value: 'soft',
                allowedValues: ['hard', 'soft', 'off'],
                type: 'string'
            }
        }
    }

    /**
   * Element's HTML template.
   */
    template() {
        return `<div id="container">
                    <div id="headerSection" class="jqx-header-section">
                        <div id="header" class="jqx-header">[[label]]</div>
                        <div id="buttonsContainer" class="jqx-buttons-container">
                            <jqx-button id="closeButton" class="jqx-close-button" animation="[[animation]]" theme="[[theme]]"></jqx-button>
                        </div>
                    </div>
                    <div class="jqx-content">
                        <content></content>
                       <jqx-multiline-text-box id="textBox"
                            animation="[[animation]]"
                            horizontal-scroll-bar-visibility= "[[horizontalScrollBarVisibility]]"
                            vertical-scroll-bar-visibility= "[[verticalScrollBarVisibility]]"
                            auto-capitalize="[[autoCapitalize]]"
                            auto-expand = "[[autoExpand]]"
                            selection-direction= "[[selectionDirection]]"
                            selection-end= "[[selectionEnd]]"
                            selection-start="[[selectionStart]]"
                            spell-check= "[[spellCheck]]"
                            wrap="[[wrap]]"
                            max-length="[[maxLength]]"
                            value="{{value}}"
                            form="[[form]]"
                            label="[[promptLabel]]"
                            hint="[[hint]]"
                            display-mode="[[displayMode]]"
                            max-length="[[maxLength]]"
                            placeholder="[[placeholder]]"
                            required="[[required]]"
                            required-message="[[requiredMessage]]"
                            select-all-on-focus="[[selectAllOnFocus]]"
                            theme="[[theme]]">
                       </jqx-multiline-text-box>
                    </div>
                    <div id="footer" class="jqx-footer">
                        <jqx-button id="confirmButton" class="jqx-confirm-button flat" animation="[[animation]]" theme="[[theme]]">[[confirmLabel]]</jqx-button>
                        <jqx-button id="cancelButton" class="jqx-cancel-button flat" animation="[[animation]]" theme="[[theme]]">[[cancelLabel]]</jqx-button>
                    </div>
                </div>`;
    }

    /**
   * Element's event listeners.
   */
    static get listeners() {
        return {
            'footer.click': '_footerClickHandler'
        }
    }

    /**
    * Checks for missing modules.
    */
    static get requires() {
        return {
            'JQX.MultilineTextBox': 'jqxmultilinetextbox.js'
        }
    }

    /**
    * Footer Click Event Handler
    * @param {any} event
    */
    _footerClickHandler(event) {
        const that = this,
            target = event.target;

        if (target.closest('.jqx-confirm-button')) {
            that.$.fireEvent('confirm', { value: that.$.textBox.value });
        }
        else if (target.closest('.jqx-cancel-button')) {
            that.$.fireEvent('cancel', { value: that.$.textBox.value });
        }
    }
});

JQX('jqx-progress-window', class ProgressWindow extends JQX.Window {

    /**
    * Element's properties
    */
    static get properties() {
        return {
            'completeLabel': {
                value: 'Continue',
                type: 'string'
            },
            'disableSnap': {
                value: true,
                readOnly: true,
                type: 'boolean'
            },
            'headerButtons': {
                value: ['close'],
                type: 'array'
            },
            'indeterminate': {
                value: false,
                type: 'boolean'
            },
            'inverted': {
                value: false,
                type: 'boolean'
            },
            'formatFunction': {
                value: null,
                type: 'function'
            },
            'max': {
                value: 100,
                type: 'number'
            },
            'modal': {
                value: true,
                readOnly: true,
                type: 'boolean',
                defaultReflectToAttribute: true
            },
            'min': {
                value: 0,
                type: 'number'
            },
            'showProgressValue': {
                value: false,
                type: 'boolean'
            },
            'value': {
                value: 0,
                type: 'number?'
            }
        }
    }

    /**
   * Element's HTML template.
   */
    template() {
        return `<div id="container">
                    <div id="headerSection" class="jqx-header-section">
                        <div id="header" class="jqx-header">[[label]]</div>
                        <div id="buttonsContainer" class="jqx-buttons-container">
                            <jqx-button id="closeButton" class="jqx-close-button" animation="[[animation]]" theme="[[theme]]"></jqx-button>
                        </div>
                    </div>
                    <div class="jqx-content" inner-h-t-m-l="[[innerHTML]]">
                        <content></content>
                    </div>
                    <div id="footer" class="jqx-footer">
                        <jqx-progress-bar id="progressBar"
                            animation="[[animation]]"
                            min="[[min]]"
                            max="[[max]]"
                            indeterminate="[[inditerminate]]"
                            inverted="[[inverted]]"
                            format-function="[[formatFunction]]"
                            show-progress-value="[[showProgressValue]]"
                            theme="[[theme]]"
                            value="{{value}}">
                        </jqx-progress-bar>
                        <jqx-button id="completeButton" class="jqx-complete-button jqx-visibility-hidden" animation="[[animation]]" theme="[[theme]]">[[completeLabel]]</jqx-button>
                    </div>
                </div>`;
    }

    /** Checks for missing modules.
        */
    static get requires() {
        return {
            'JQX.ProgressBar': 'jqxprogressbar.js'
        }
    }

    /**
    * Updates the element when a property is changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
    * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        switch (propertyName) {
            case 'value':
                that._handleCompletion();
                break;
            default:
                super.propertyChangedHandler(propertyName, oldValue, newValue);
                break;
        }
    }

    /**
     * Create Element method
     */
    _createElement() {
        const that = this;

        that._handleCompletion();
    }

    /**
     * Show the complete button when value === max
     */
    _handleCompletion() {
        const that = this;

        if (that.$.completeButton) {
            if (that.value >= that.max) {
                that.$completeButton.removeClass('jqx-visibility-hidden');
                that.$progressBar.addClass('jqx-visibility-hidden');
            }
            else {
                that.$completeButton.addClass('jqx-visibility-hidden');
                that.$progressBar.removeClass('jqx-visibility-hidden');
            }
        }
    }

    /**
     * Key Down event handler
     * @param {any} event - event details
     */
    _keyDownHandler(event) {
        const that = this;

        delete that._changingFocus;

        function endDrag() {
            if (that._dragDetails) {
                that._dragDetails.started = false;
            }

            that.$.removeClass('no-transition');
        }

        if (that.disabled || (that._dragDetails && that._dragDetails.started)) {
            return;
        }

        event.stopPropagation();

        //Distance hardcoded to 10px
        const distance = event.key === 'ArrowDown' || event.key === 'ArrowRight' ? 10 : -10;

        //that.style.transition = '';
        that.$.removeClass('no-transition');

        switch (event.key) {
            case 'ArrowUp':
            case 'ArrowDown':
                if (document.activeElement !== that) {
                    return;
                }

                event.preventDefault();
                if (event.altKey) {
                    event.key === 'ArrowUp' ? that.maximize() : that.restore();
                    endDrag()
                    return;
                }

                that.$.addClass('no-transition');

                if (event.ctrlKey) {
                    that._resize('bottom', distance);
                    endDrag()
                    return;
                }

                that._drag(distance, 'vertical');
                that.$.removeClass('no-transition');
                break;
            case 'ArrowLeft':
            case 'ArrowRight':
                if (document.activeElement !== that) {
                    return;
                }

                event.preventDefault();

                that.$.addClass('no-transition');

                if (event.ctrlKey) {
                    that._resize('right', distance);
                    endDrag()
                    return;
                }

                that._drag(distance, 'horizontal');
                that.$.removeClass('no-transition');
                break;
            case 'Escape':
                if (that.headerButtons.indexOf('close') > -1 && document.activeElement === that) {
                    that.close();
                }

                break;
            case 'Tab':
                if (that.opened && that.modal) {
                    that._changingFocus = true;
                }

                break;
            case 'Enter':
            case ' ':
                {
                    const target = event.target.closest && event.target.closest('jqx-button');

                    if (!target) {
                        return;
                    }

                    that._isWindowButton(that._buttonPressed = target);
                    delete that._buttonPressed;
                    break;
                }
        }

        endDrag()
    }
});

JQX('jqx-tabs-window', class TabsWindow extends JQX.Window {

    /**
    * Element's properties
    */
    static get properties() {
        return {
            'disableSnap': {
                value: true,
                readOnly: true,
                type: 'boolean'
            },
            //Property used by DockingLayouts only
            'dropPosition': {
                //allowedValues: ['all', 'top', 'left', 'right', 'bottom', 'center', 'header', 'none'],
                value: ['all'],
                type: 'array'
            },
            'addNewTab': {
                value: false,
                type: 'boolean'
            },
            'allowToggle': {
                value: false,
                type: 'boolean'
            },
            'autoHide': {
                value: false,
                type: 'boolean'
            },
            'autoHideWindow': {
                value: null,
                type: 'any'
            },
            'dataSource': {
                value: null,
                type: 'array?',
                reflectToAttribute: false
            },
            'tabCloseButtonMode': {
                value: 'default',
                allowedValues: ['default', 'selected'],
                type: 'string'
            },
            'tabCloseButtons': {
                value: false,
                type: 'boolean'
            },
            'messages': {
                value: {
                    'en': {
                        'ambiguousIndexes': 'jqx-tabs: Initially set jqx-tab-item indexes are ambiguous and are ignored in favour of the HTML structure.',
                        'detailsObjectRequired': 'jqx-tabs: The method "insert" requires a details Object to be passed as a second argument.',
                        'invalidIndex': 'jqx-tabs: "{{method}}" method accepts an index of type number.',
                        'referenceNodeNotChild': 'jqx-tabs: Passed {{argument}} is not part of this jqx-tabs element.',
                        'tabItemRequired': 'jqx-tabs: The method "{{method}}" requires a "jqx-tab-item" element to be passed as an argument.'
                    }
                },
                type: 'object',
                extend: true
            },
            'tabOverflow': {
                value: 'auto',
                allowedValues: ['auto', 'hidden', 'scroll'],
                type: 'string'
            },
            'tabReorder': {
                value: false,
                type: 'boolean'
            },
            'tabResize': {
                value: false,
                type: 'boolean'
            },
            'tabScrollButtonsPosition': {
                value: 'both',
                allowedValues: ['near', 'far', 'both'],
                type: 'string'
            },
            'selectedIndex': {
                value: null,
                type: 'number?'
            },
            'selectionMode': {
                value: 'click',
                allowedValues: ['click', 'dblclick', 'mouseenter', 'none'],
                type: 'string'
            },
            'collapsed': {
                value: false,
                type: 'boolean'
            },
            'collapsible': {
                value: false,
                type: 'boolean'
            },
            'locked': {
                value: false,
                type: 'boolean'
            },
            'max': {
                value: '',
                type: 'any'
            },
            'min': {
                value: '',
                type: 'any'
            },
            'size': {
                value: '',
                type: 'any'
            },
            'tabLayout': {
                value: 'scroll',
                allowedValues: ['scroll', 'dropdown', 'wrap', 'shrink'],
                type: 'string',
                defaultReflectToAttribute: true
            },
            'tabPosition': {
                value: 'top',
                allowedValues: ['top', 'bottom', 'left', 'right', 'hidden'],
                type: 'string'
            },
            'tabTextOrientation': {
                value: 'horizontal',
                allowedValues: ['horizontal', 'vertical'],
                type: 'string'
            },
            //Property used by DockingLayouts only
            'layout': {
                value: null,
                type: 'any'
            }
        }
    }

    /**
    * Element's event listeners.
    */
    static get listeners() {
        return {
            'tabsElement.blur': '_tabsFocusHandler',
            'tabsElement.change': '_tabsChangeHandler',
            'tabsElement.focus': '_tabsFocusHandler',
            'autoHideWindow.close': '_autoHideWindowCloseHandler',
            'autoHideWindow.open': '_autoHideWindowOpenHandler'
        }
    }

    /**
   * Element's HTML template.
   */
    template() {
        return `<div id="container">
                    <div id="headerSection" class="jqx-header-section">
                        <div id="header" class="jqx-header">[[label]]</div>
                        <div id="buttonsContainer" class="jqx-buttons-container">
                            <jqx-button id="minimizeButton" class="jqx-minimize-button" animation="[[animation]]" theme="[[theme]]"></jqx-button>
                            <jqx-button id="maximizeButton" class="jqx-maximize-button" animation="[[animation]]" theme="[[theme]]"></jqx-button>
                            <jqx-button id="closeButton" class="jqx-close-button" animation="[[animation]]" theme="[[theme]]"></jqx-button>
                        </div>
                    </div>
                    <div id="contentSection" class="jqx-content">
                       <jqx-tabs id="tabsElement"
                            animation="[[animation]]"
                            add-new-tab="[[addNewTab]]"
                            allow-toggle="[[allowToggle]]"
                            close-button-mode="[[tabCloseButtonMode]]"
                            close-buttons="[[tabCloseButtons]]"
                            disabled="[[disabled]]"
                            overflow="[[tabOverflow]]"
                            reorder="[[tabReorder]]"
                            resize="[[tabResize]]"
                            scroll-buttons-position="[[tabScrollButtonsPosition]]"
                            selected-index="{{selectedIndex}}"
                            selection-mode="[[selectionMode]]"
                            tab-layout="[[tabLayout]]"
                            tab-position="[[tabPosition]]"
                            tab-text-orientation="[[tabTextOrientation]]"
                            theme="[[theme]]">
                            <content></content>
                        </jqx-tabs>
                    </div>
                    <div id="footer" class="jqx-footer jqx-hidden"></div>
                </div>`;
    }

    /**
    * Checks for missing modules.
    */
    static get requires() {
        return {
            'JQX.Tabs': 'jqxtabs.js'
        }
    }

    /**
     * Appens a Tab item to the Window
     * @param {any} node
     */
    appendChild(node) {
        const that = this;

        if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!node) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'appendChild', node: 'node' }));
            return
        }

        if (!(node instanceof JQX.TabItem)) {
            that.error(that.localize('tabItemRequired', { method: 'removeChild' }));
        }

        that.$.tabsElement.appendChild(node);
    }

    /**
     * Insert Tab items into the Window
     * @param {any} index
     * @param {any} details
     */
    insert(index, details) {
        this.$.tabsElement.insert(index, details);
    }

    /**
     * Insert a Tab item before another item inside the Window
     * @param {any} node
     */
    insertBefore(node, referenceNode) {
        this.$.tabsElement.insertBefore(node, referenceNode);
    }

    /**
     * Removes a Tab item from the Window
     */
    remove(index) {
        this.$.tabsElement.remove(index);
    }

    /**
     * Removes a Tab item from the Window
     * @param {any} node
     */
    removeChild(node) {
        const that = this;

        if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!node) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'removeChild', node: 'node' }));
            return
        }

        if (!(node instanceof JQX.TabItem)) {
            that.error(that.localize('tabItemRequired', { method: 'removeChild' }));
        }

        if (!that.contains(node)) {
            that.error(that.localize('referenceNodeNotChild', { argument: 'node' }));
        }

        that.$.tabsElement.removeChild(node);
    }

    /**
     * Selects a Tab item inside the Window
     * @param {any} index
     */
    select(index) {
        this.$.tabsElement.select(index);
    }

    /**
     * Update Tab Item element method
     * @param {any} index
     * @param {any} label
     * @param {any} content
     */
    update(index, label, content) {
        this.$.tabsElement.update(index, label, content);
    }

    /**
     * Returns all tab items 
     */
    get items() {
        const that = this;

        if (!that.isCompleted || !that.$.tabsElement) {
            return;
        }

        return this.$.tabsElement._tabs;
    }

    /**
     * Returns all tab labels
     */
    get itemLabels() {
        const that = this;

        if (!that.$) {
            return;
        }

        return this.$.tabsElement._tabLabelContainers;
    }

    /**
    * Returns a list of all sibling TabsWindow components IF the element is docked inside a DockingLaoyut
    */
    get siblings() {
        const that = this;
        let siblings = [];

        if (!that.isCompleted) {
            return siblings;
        }

        const closestSplitter = that.closest('jqx-splitter');

        if (!closestSplitter || !closestSplitter.closest('jqx-docking-layout')) {
            return siblings;
        }

        const items = closestSplitter._items;

        if (!items || !items.length) {
            return siblings;
        }

        for (let s = 0; s < items.length; s++) {
            const item = items[s];

            if (item !== that.closest('jqx-splitter-item')) {
                const siblingItem = item.querySelector('jqx-tabs-window');

                if (siblingItem.closest('jqx-splitter') === closestSplitter) {
                    siblings.push(item.querySelector('jqx-tabs-window'));
                }
            }
        }

        return siblings;
    }

    /**
     * Updates the element when a property is changed.
     * @param {string} propertyName The name of the property.
     * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
     * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
     */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        const that = this;

        if (propertyName !== 'collapsed') {
            super.propertyChangedHandler(propertyName, oldValue, newValue);
        }

        switch (propertyName) {
            case 'theme':
                if (oldValue !== '') {
                    that.$.closeButton.classList.remove(oldValue);
                    that.$.collapseButton.classList.remove(oldValue);
                    that.$.maximizeButton.classList.remove(oldValue);
                    that.$.pinButton.classList.remove(oldValue);
                }

                that._applyTheme(newValue);
                break;
            case 'autoHideWindow':
                that._handleAutoHideWindow();
                break;
            case 'autoHide':
                if (!newValue) {
                    //Delete the additionaly added cached property
                    if (that.$.tabsElement.selectedIndex !== null) {
                        that.$.tabsElement._tabs[that.$.tabsElement.selectedIndex]._autoHideWindowSize = undefined;
                    }

                    if (that._autoHideWindow) {
                        that._autoHideWindow.close();
                    }
                }

                break;
            case 'dataSource':
                that.$.tabsElement.dataSource = newValue;
                break;
            case 'layout':
                that._handleLayoutProperty();
                break;
            case 'collapsible':
            case 'collapsed':
            case 'locked':
            case 'max':
            case 'min':
            case 'size': {
                const isInsideLayout = that.closest('jqx-docking-layout'),
                    splitterItemParent = that.closest('jqx-splitter-item');

                if (!isInsideLayout) {
                    if (propertyName === 'collapsed') {
                        super.propertyChangedHandler(propertyName, oldValue, newValue);
                    }

                    return;
                }

                if (splitterItemParent) {
                    splitterItemParent[propertyName] = newValue;
                }

                break;
            }
        }
    }

    /**
     * Apply theme to internal custom elements
     */
    _applyTheme(theme) {
        const that = this;

        if (theme !== '') {
            const headerButtons = that.$.buttonsContainer.children;

            for (let i = 0; i < headerButtons.length; i++) {
                headerButtons[i].classList.add(theme);
            }
        }
    }

    /**
     * AutoHideContainer Close event handler
     */
    _autoHideWindowCloseHandler() {
        const that = this;

        if (that.allowToggle && that.$.tabsElement.selectedIndex !== null) {
            that.$.tabsElement.select(that.$.tabsElement.selectedIndex);
        }

        if (that._autoHideWindow) {
            that._moveContent(that._autoHideWindow.items[0], that._autoHideWindow._tab);
        }
    }

    /**
     * AutoHideContainer Open event handler
     * @param {any} event
     */
    _autoHideWindowOpenHandler() {
        const that = this;

        if (that.$.tabsElement.selectedIndex) {
            that._handleAutoHide(that.$.tabsElement.selectedIndex);
        }
    }

    /**
    * Create method called on ready stage
    **/
    _createElement() {
        const that = this;

        if (!that.$.tabsElement.$.tabHeaderControls.innerHTML) {
            that.$.tabsElement.$tabHeaderControls.addClass('jqx-hidden');
        }

        that.$.tabsElement.dataSource = that.dataSource;

        that._applyTheme(that.theme);
        that._handleAutoHideWindow();

        if (that.autoHide) {
            that._handleAutoHide(that.$.tabsElement.selectedIndex);
        }

        //Two-way binding possible issue. The Tabs element has selectedIndex but TabsWindow element has null
        //This leads to setting the attribute 'selectedIndex' of the Tabs element to null even tho 
        //It's actual value is not null
        if (!that.allowToggle && !that.selectedIndex && that.$.tabsElement.selectedIndex !== null) {
            that.selectedIndex = that.$.tabsElement.selectedIndex;
            that.$.tabsElement.setAttribute('selected-index', that.selectedIndex);
        }

        that._handleLayoutProperty();

        const isInsideLayout = that.closest('jqx-docking-layout'),
            splitterItemParent = that.closest('jqx-splitter-item');

        if (isInsideLayout && splitterItemParent) {
            splitterItemParent.collapsible = that.collapsible;
            splitterItemParent.collapsed = that.collapsed;
            splitterItemParent.min = that.min;
            splitterItemParent.max = that.max;
            splitterItemParent.size = that.size;
            splitterItemParent.locked = that.locked;
        }
    }

    /**
     * Hnadle layout property
     */
    _handleLayoutProperty() {
        const that = this,
            ownerLayout = that.closest('jqx-docking-layout');

        if (!JQX.DockingLayout) {
            return;
        }

        if (ownerLayout) {
            that.layout = ownerLayout;
            return;
        }

        if (that.layout instanceof JQX.DockingLayout) {
            return;
        }

        if (typeof that.layout === 'string') {
            that.layout = document.getElementById(that.layout);
        }
    }

    /**
    * Window header double click handler.
    */
    _headerDblCickHandler(event) {
        const that = this,
            target = event.originalEvent.target;

        //NOTE: DoubleCLick + ctrlKey is used in DockingLayout
        if (event.ctrlKey || (target !== that.$.headerSection && target !== that.$.header) ||
            (that.$.maximizeButton && that.$.maximizeButton.offsetHeight === 0)) {
            return;
        }

        that.maximized ? that.restore() : that.maximize();
    }

    /**
    * Document Down event handler
    * @param {any} event - event details
    */
    _documentUpHandler(event) {
        const that = this,
            target = event.originalEvent.target.closest ? event.originalEvent.target.closest('.jqx-window') : event.originalEvent.target,
            isClickInside = target === that || target === that._autoHideWindow || that._isAutoHideWindowClicked,
            isInsideLayout = that.closest('jqx-docking-layout');

        if (isInsideLayout && isInsideLayout.disabled) {
            delete that._isWindowContentClicked;
            return;
        }

        super._documentUpHandler(event);

        delete that._isAutoHideWindowClicked;

        if (!that.autoHide || !that._autoHideWindow) {
            return;
        }

        if (!isClickInside || !that._autoHideWindow.opened) {
            that.selectedIndex = null;

            if (that._autoHideWindow.parentElement && that._autoHideWindow.parentElement.closest('.jqx-window') === that) {
                that._autoHideWindow.close();
            }
        }
    }

    /**
     * Handles the positioning and content of the auto hide container
     */
    _handleAutoHide(index) {
        const that = this;

        if (!that.autoHide || index === null) {
            return;
        }

        if (!that._autoHideWindow) {
            that._handleAutoHideWindow(true);
        }

        if (!that._autoHideWindow) {
            return;
        }

        if (that._autoHideWindow._tabsWindow && that._autoHideWindow._tabsWindow !== that) {
            that._autoHideWindow._tabsWindow.selectedIndex = null;
        }

        const targetTab = that.$.tabsElement._tabs[index];

        if (that._autoHideWindow._tab !== targetTab) {
            that._moveContent(that._autoHideWindow.items[0], that._autoHideWindow._tab);
        }

        that._autoHideWindow.label = targetTab.label;
        that._autoHideWindow.draggable = targetTab.draggable;
        that._autoHideWindow.floatable = targetTab.floatable;
        that._autoHideWindow._tab = targetTab;
        that._moveContent(that._autoHideWindow._tab, that._autoHideWindow.items[0]);
        that._autoHideWindow.bringToFront();
        that._setAutoHideWindowSize(index);
        that._autoHideWindow.open();
        that._autoHideWindow._tabsWindow = that;
    }

    /**
     * Sets the cursor on element move event
     * @param {any} event
     */
    _moveHandler(event) {
        const that = this,
            isInsideLayout = that.closest('jqx-docking-layout');

        if (isInsideLayout) {
            const layoutItems = isInsideLayout.items;

            if (layoutItems.indexOf(that) > -1) {
                return;
            }
        }

        //iOS Safari fix for dragging (prevents window scrolling)
        if (JQX.Utilities.Core.isMobile && !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform) &&
            that.layout instanceof JQX.DockingLayout && that.layout.hasAttribute('dragged')) {
            event.originalEvent.preventDefault();
        }

        super._moveHandler(event);
    }

    /**
     * Calculates the width/height/top/left of the autoHideWindow
     * @param {any} selectedIndex - the selectedIndex of the tabs inside the TabsWindow
     */
    _setAutoHideWindowSize(selectedIndex) {
        const that = this;

        if (!that._autoHideWindow) {
            return;
        }

        that._autoHideWindow.$.addClass('no-transition');
        that._autoHideWindow.style.maxWidth = that._autoHideWindow.style.maxHeight = '';

        const targetTab = that.$.tabsElement._tabs[selectedIndex],
            autoHideWindowParent = that._autoHideWindow.closest('jqx-docking-layout') || that._autoHideWindow.parentElement,
            windowParentRect = autoHideWindowParent.getBoundingClientRect(),
            tabsRect = that.$.tabsElement.getBoundingClientRect();

        if (!targetTab) {
            return;
        }

        if (that.tabPosition === 'top' || that.tabPosition === 'bottom') {
            that._autoHideWindow.resizeMode = that.tabPosition === 'top' ? 'bottom' : 'top';
            that._autoHideWindow.style.width = that.$.tabsElement.offsetWidth + 'px';

            let height = targetTab._autoHideWindowSize ? parseFloat(targetTab._autoHideWindowSize) || '' : '';

            if (JQX.DockingLayout && autoHideWindowParent instanceof JQX.DockingLayout) {
                if (height) {
                    height = Math.min(autoHideWindowParent.$.itemsContainer.offsetHeight, height) + 'px';
                }

                that._autoHideWindow.style.maxHeight = autoHideWindowParent.$.itemsContainer.offsetHeight + 'px';
            }

            that._autoHideWindow.style.height = height;
            that._autoHideWindow.style.left = (tabsRect.left - windowParentRect.left) + 'px';

            if (that._autoHideWindow) {
                if (that.tabPosition === 'top') {
                    that._autoHideWindow.style.top = (tabsRect.top + -windowParentRect.top + tabsRect.height) + 'px';
                }
                else {
                    that._autoHideWindow.style.top = (tabsRect.top - windowParentRect.top - that._autoHideWindow.offsetHeight) + 'px';
                }
            }
        }
        else {
            that._autoHideWindow.resizeMode = that.tabPosition === 'left' ? 'right' : 'left';
            that._autoHideWindow.style.height = that.$.tabsElement.offsetHeight + 'px';

            let width = targetTab._autoHideWindowSize ? parseFloat(targetTab._autoHideWindowSize) || '' : '';

            if (autoHideWindowParent instanceof JQX.DockingLayout) {
                if (width) {
                    width = Math.min(autoHideWindowParent.$.itemsContainer.offsetWidth, width) + 'px';
                }

                that._autoHideWindow.style.maxWidth = autoHideWindowParent.$.itemsContainer.offsetWidth + 'px';
            }

            that._autoHideWindow.style.width = width;
            that._autoHideWindow.style.top = (tabsRect.top - windowParentRect.top) + 'px';

            if (that.tabPosition === 'left') {
                that._autoHideWindow.style.left = (tabsRect.left - windowParentRect.left + that.$.tabsElement.offsetWidth) + 'px';
            }
            else {
                that._autoHideWindow.style.left = (tabsRect.left - windowParentRect.left - that._autoHideWindow.offsetWidth) + 'px';
            }
        }

        //Causing the maxWidth/maxHeight to be recalculated
        if (that._autoHideWindow._dragDetails) {
            that._autoHideWindow._dragDetails.maxWidth = undefined;
        }

        //Make sure the new dimensions are set
        that._autoHideWindow._setDragDetails('resize');

        that._autoHideWindow.$.removeClass('no-transition');
    }

    /**
     * Handles the autoHideWindow instance when 'autoHide' property is enabled
     */
    _handleAutoHideWindow(createWindow) {
        const that = this;

        if (that.autoHideWindow) {
            if (that._autoHideWindow) {
                that._autoHideWindow.parentElement.removeChild(that._autoHideWindow);
            }

            if (typeof (that.autoHideWindow) === 'string') {
                that._autoHideWindow = document.getElementById(that.autoHideWindow);
                return;
            }
            else if (that.autoHideWindow instanceof JQX.Window) {
                that._autoHideWindow = that.autoHideWindow;
                return;
            }
        }

        if (!createWindow || that._autoHideWindow || (that.$.contentSection.children.length === 2 && that.$.contentSection.children[1] instanceof JQX.Window)) {
            return;
        }

        //Create the autoHideWindow
        const autoHideWindow = document.createElement('jqx-window');

        autoHideWindow.$ = JQX.Utilities.Extend(autoHideWindow);
        autoHideWindow.disableSnap = autoHideWindow.pinned = true;
        autoHideWindow.headerButtons = ['close'];

        that.$.contentSection.appendChild(autoHideWindow);

        that._autoHideWindow = autoHideWindow;
    }

    /**
     * Moves the content from one element to another. Used for the autoHideWindow
     * @param {any} from - Source element
     * @param {any} to - target element
     */
    _moveContent(from, to) {
        if (!from || !to) {
            return;
        }

        const contentNodes = [].slice.call(from.$.content.childNodes);

        for (let i = 0; i < contentNodes.length; i++) {
            to.appendChild(contentNodes[i]);
        }
    }

    /**
     * jqxtabs element change event handler
     * @param {any} event
     */
    _tabsChangeHandler(event) {
        const that = this;

        if (event.target !== that.$.tabsElement || !that.autoHide) {
            return;
        }

        if (!that._autoHideWindow) {
            that._handleAutoHideWindow(true);
        }


        if (event.detail.oldIndex !== null && that._autoHideWindow.opened) {
            const previousTabItem = that.$.tabsElement._tabs[event.detail.oldIndex];

            previousTabItem._autoHideWindowSize =
                that._autoHideWindow.style[that.$.tabsElement.tabPosition === 'right' || that.$.tabsElement.tabPosition === 'left' ? 'width' : 'height'];

        }

        if (!that.autoHide || event.detail.index === null || event.detail.index === undefined) {
            that._autoHideWindow.close();
            return;
        }

        that._handleAutoHide(event.detail.index);
    }

    /**
     * Tabs element focus/blur event handler
     */
    _tabsFocusHandler(event) {
        const that = this;

        if (event.type === 'focus') {
            that.bringToFront();
            that.setAttribute('focus', '');
        }
        else {
            that.removeAttribute('focus');
        }
    }
});

JQX('jqx-wait-window', class WaitWindow extends JQX.ProgressWindow {

    /**
    * Element's properties
    */
    static get properties() {
        return {
            'headerButtons': {
                value: [],
                type: 'array'
            },
            'disableSnap': {
                value: true,
                readOnly: true,
                type: 'boolean'
            },
            'modal': {
                value: true,
                readOnly: true,
                type: 'boolean',
                defaultReflectToAttribute: true
            },
            'pinned': {
                value: true,
                type: 'boolean',
                readOnly: true
            }
        }
    }

    /**
   * Element's HTML template.
   */
    template() {
        return `<div id="container">
                    <div id="headerSection" class="jqx-header-section">
                        <div id="header" class="jqx-header">[[label]]</div>
                        <div id="buttonsContainer" class="jqx-buttons-container">
                            <jqx-button id="closeButton" class="jqx-close-button" animation="[[animation]]" theme="[[theme]]"></jqx-button>
                        </div>
                    </div>
                    <div class="jqx-content">
                        <content></content>
                        <jqx-progress-bar id="progressBar" animation="[[animation]]" indeterminate theme="[[theme]]"></jqx-progress-bar>
                    </div>
                    <div id="footer" class="jqx-footer"></div>
                </div>`;
    }

    /**
     * Key Down event handler
     * @param {any} event - event details
     */
    _keyDownHandler(event) {
        const that = this;

        delete that._changingFocus;

        function endDrag() {
            if (that._dragDetails) {
                that._dragDetails.started = false;
            }

            that.$.removeClass('no-transition');
        }

        if (that.disabled || (that._dragDetails && that._dragDetails.started)) {
            return;
        }

        event.stopPropagation();

        //Distance hardcoded to 10px
        const distance = event.key === 'ArrowDown' || event.key === 'ArrowRight' ? 10 : -10;

        //that.style.transition = '';
        that.$.removeClass('no-transition');

        switch (event.key) {
            case 'ArrowUp':
            case 'ArrowDown':
                if (document.activeElement !== that) {
                    return;
                }

                event.preventDefault();

                if (event.altKey) {
                    event.key === 'ArrowUp' ? that.maximize() : that.restore();
                    endDrag()
                    return;
                }

                that.$.addClass('no-transition');

                if (event.ctrlKey) {
                    that._resize('bottom', distance);
                    endDrag()
                    return;
                }

                that._drag(distance, 'vertical');
                break;
            case 'ArrowLeft':
            case 'ArrowRight':
                if (document.activeElement !== that) {
                    return;
                }

                event.preventDefault();
                that.$.addClass('no-transition');

                if (event.ctrlKey) {
                    that._resize('right', distance);
                    endDrag()
                    return;
                }

                that._drag(distance, 'horizontal');
                break;
            case 'Tab':
                if (that.opened && that.modal) {
                    that._changingFocus = true;
                }

                break;
            case 'Enter':
            case ' ':
                {
                    const target = event.target.closest && event.target.closest('jqx-button');

                    if (!target) {
                        return;
                    }

                    that._isWindowButton(that._buttonPressed = target);
                    delete that._buttonPressed;
                    break;
                }
        }

        endDrag()
    }
});