(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define('vireoHelpers', factory) :
  (global = global || self, global.vireoHelpers = factory());
}(this, function () { 'use strict';

  var VireoCreateCoreModule = (function() {
    var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
    return (
  function(VireoCreateCoreModule) {
    VireoCreateCoreModule = VireoCreateCoreModule || {};

  // Copyright 2010 The Emscripten Authors.  All rights reserved.
  // Emscripten is available under two separate licenses, the MIT license and the
  // University of Illinois/NCSA Open Source License.  Both these licenses can be
  // found in the LICENSE file.

  // The Module object: Our interface to the outside world. We import
  // and export values on it. There are various ways Module can be used:
  // 1. Not defined. We create it here
  // 2. A function parameter, function(Module) { ..generated code.. }
  // 3. pre-run appended it, var Module = {}; ..generated code..
  // 4. External script tag defines var Module.
  // We need to check if Module already exists (e.g. case 3 above).
  // Substitution will be replaced with actual code on later stage of the build,
  // this way Closure Compiler will not mangle it (e.g. case 4. above).
  // Note that if you want to run closure, and also to use Module
  // after the generated code, you will need to define   var Module = {};
  // before the code. Then that object will be used in the code, and you
  // can continue to use Module afterwards as well.
  var Module = typeof VireoCreateCoreModule !== 'undefined' ? VireoCreateCoreModule : {};

  // --pre-jses are emitted after the Module integration code, so that they can
  // refer to Module (if they choose; they can also define Module)
  /* global Module */
  Module.vireoprejs = function () {
      // intentionally left blank
  };
  // Emscripten code starts here



  // Sometimes an existing Module object exists with properties
  // meant to overwrite the default module functionality. Here
  // we collect those properties and reapply _after_ we configure
  // the current environment's defaults to avoid having to be so
  // defensive during initialization.
  var moduleOverrides = {};
  var key;
  for (key in Module) {
    if (Module.hasOwnProperty(key)) {
      moduleOverrides[key] = Module[key];
    }
  }

  Module['arguments'] = [];
  Module['thisProgram'] = './this.program';
  Module['quit'] = function(status, toThrow) {
    throw toThrow;
  };
  Module['preRun'] = [];
  Module['postRun'] = [];

  // Determine the runtime environment we are in. You can customize this by
  // setting the ENVIRONMENT setting at compile time (see settings.js).

  var ENVIRONMENT_IS_WEB = false;
  var ENVIRONMENT_IS_WORKER = false;
  var ENVIRONMENT_IS_NODE = false;
  var ENVIRONMENT_IS_SHELL = false;
  ENVIRONMENT_IS_WEB = typeof window === 'object';
  ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
  ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
  ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

  if (Module['ENVIRONMENT']) {
    throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)');
  }


  // Three configurations we can be running in:
  // 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)
  // 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)
  // 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)




  // `/` should be present at the end if `scriptDirectory` is not empty
  var scriptDirectory = '';
  function locateFile(path) {
    if (Module['locateFile']) {
      return Module['locateFile'](path, scriptDirectory);
    } else {
      return scriptDirectory + path;
    }
  }

  if (ENVIRONMENT_IS_NODE) {
    scriptDirectory = __dirname + '/';

    // Expose functionality in the same simple way that the shells work
    // Note that we pollute the global namespace here, otherwise we break in node
    var nodeFS;
    var nodePath;

    Module['read'] = function shell_read(filename, binary) {
      var ret;
        if (!nodeFS) nodeFS = require('fs');
        if (!nodePath) nodePath = require('path');
        filename = nodePath['normalize'](filename);
        ret = nodeFS['readFileSync'](filename);
      return binary ? ret : ret.toString();
    };

    Module['readBinary'] = function readBinary(filename) {
      var ret = Module['read'](filename, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      assert(ret.buffer);
      return ret;
    };

    if (process['argv'].length > 1) {
      Module['thisProgram'] = process['argv'][1].replace(/\\/g, '/');
    }

    Module['arguments'] = process['argv'].slice(2);

    // MODULARIZE will export the module in the proper place outside, we don't need to export here

    process['on']('uncaughtException', function(ex) {
      // suppress ExitStatus exceptions from showing an error
      if (!(ex instanceof ExitStatus)) {
        throw ex;
      }
    });
    // Currently node will swallow unhandled rejections, but this behavior is
    // deprecated, and in the future it will exit with error status.
    process['on']('unhandledRejection', abort);

    Module['quit'] = function(status) {
      process['exit'](status);
    };

    Module['inspect'] = function () { return '[Emscripten Module object]'; };
  } else
  if (ENVIRONMENT_IS_SHELL) {


    if (typeof read != 'undefined') {
      Module['read'] = function shell_read(f) {
        return read(f);
      };
    }

    Module['readBinary'] = function readBinary(f) {
      var data;
      if (typeof readbuffer === 'function') {
        return new Uint8Array(readbuffer(f));
      }
      data = read(f, 'binary');
      assert(typeof data === 'object');
      return data;
    };

    if (typeof scriptArgs != 'undefined') {
      Module['arguments'] = scriptArgs;
    } else if (typeof arguments != 'undefined') {
      Module['arguments'] = arguments;
    }

    if (typeof quit === 'function') {
      Module['quit'] = function(status) {
        quit(status);
      };
    }
  } else
  if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
    if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
      scriptDirectory = self.location.href;
    } else if (document.currentScript) { // web
      scriptDirectory = document.currentScript.src;
    }
    // When MODULARIZE (and not _INSTANCE), this JS may be executed later, after document.currentScript
    // is gone, so we saved it, and we use it here instead of any other info.
    if (_scriptDir) {
      scriptDirectory = _scriptDir;
    }
    // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
    // otherwise, slice off the final part of the url to find the script directory.
    // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
    // and scriptDirectory will correctly be replaced with an empty string.
    if (scriptDirectory.indexOf('blob:') !== 0) {
      scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/')+1);
    } else {
      scriptDirectory = '';
    }


    Module['read'] = function shell_read(url) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.send(null);
        return xhr.responseText;
    };

    if (ENVIRONMENT_IS_WORKER) {
      Module['readBinary'] = function readBinary(url) {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', url, false);
          xhr.responseType = 'arraybuffer';
          xhr.send(null);
          return new Uint8Array(xhr.response);
      };
    }

    Module['readAsync'] = function readAsync(url, onload, onerror) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, true);
      xhr.responseType = 'arraybuffer';
      xhr.onload = function xhr_onload() {
        if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
          onload(xhr.response);
          return;
        }
        onerror();
      };
      xhr.onerror = onerror;
      xhr.send(null);
    };

    Module['setWindowTitle'] = function(title) { document.title = title; };
  } else
  {
    throw new Error('environment detection error');
  }

  // Set up the out() and err() hooks, which are how we can print to stdout or
  // stderr, respectively.
  // If the user provided Module.print or printErr, use that. Otherwise,
  // console.log is checked first, as 'print' on the web will open a print dialogue
  // printErr is preferable to console.warn (works better in shells)
  // bind(console) is necessary to fix IE/Edge closed dev tools panel behavior.
  var out = Module['print'] || (typeof console !== 'undefined' ? console.log.bind(console) : (typeof print !== 'undefined' ? print : null));
  var err = Module['printErr'] || (typeof printErr !== 'undefined' ? printErr : ((typeof console !== 'undefined' && console.warn.bind(console)) || out));

  // Merge back in the overrides
  for (key in moduleOverrides) {
    if (moduleOverrides.hasOwnProperty(key)) {
      Module[key] = moduleOverrides[key];
    }
  }
  // Free the object hierarchy contained in the overrides, this lets the GC
  // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
  moduleOverrides = undefined;

  // perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
  assert(typeof Module['memoryInitializerPrefixURL'] === 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');
  assert(typeof Module['pthreadMainPrefixURL'] === 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');
  assert(typeof Module['cdInitializerPrefixURL'] === 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');
  assert(typeof Module['filePackagePrefixURL'] === 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');

  // stack management, and other functionality that is provided by the compiled code,
  // should not be used before it is ready
  stackSave = stackRestore = stackAlloc = function() {
    abort('cannot use the stack before compiled code is ready to run, and has provided stack access');
  };

  function dynamicAlloc(size) {
    assert(DYNAMICTOP_PTR);
    var ret = HEAP32[DYNAMICTOP_PTR>>2];
    var end = (ret + size + 15) & -16;
    if (end <= _emscripten_get_heap_size()) {
      HEAP32[DYNAMICTOP_PTR>>2] = end;
    } else {
      var success = _emscripten_resize_heap(end);
      if (!success) return 0;
    }
    return ret;
  }

  function getNativeTypeSize(type) {
    switch (type) {
      case 'i1': case 'i8': return 1;
      case 'i16': return 2;
      case 'i32': return 4;
      case 'i64': return 8;
      case 'float': return 4;
      case 'double': return 8;
      default: {
        if (type[type.length-1] === '*') {
          return 4; // A pointer
        } else if (type[0] === 'i') {
          var bits = parseInt(type.substr(1));
          assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
          return bits / 8;
        } else {
          return 0;
        }
      }
    }
  }

  function warnOnce(text) {
    if (!warnOnce.shown) warnOnce.shown = {};
    if (!warnOnce.shown[text]) {
      warnOnce.shown[text] = 1;
      err(text);
    }
  }

  var asm2wasmImports = { // special asm2wasm imports
      "f64-rem": function(x, y) {
          return x % y;
      },
      "debugger": function() {
          debugger;
      }
      ,
      "f64-to-int": function(x) {
          return x | 0;
      },
      "i32s-div": function(x, y) {
          return ((x | 0) / (y | 0)) | 0;
      },
      "i32u-div": function(x, y) {
          return ((x >>> 0) / (y >>> 0)) >>> 0;
      },
      "i32s-rem": function(x, y) {
          return ((x | 0) % (y | 0)) | 0;
      },
      "i32u-rem": function(x, y) {
          return ((x >>> 0) % (y >>> 0)) >>> 0;
      }
  };

  var tempRet0 = 0;

  var setTempRet0 = function(value) {
    tempRet0 = value;
  };

  var getTempRet0 = function() {
    return tempRet0;
  };




  // === Preamble library stuff ===

  // Documentation for the public APIs defined in this file must be updated in:
  //    site/source/docs/api_reference/preamble.js.rst
  // A prebuilt local version of the documentation is available at:
  //    site/build/text/docs/api_reference/preamble.js.txt
  // You can also build docs locally as HTML or other formats in site/
  // An online HTML version (which may be of a different version of Emscripten)
  //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html


  if (typeof WebAssembly !== 'object') {
    abort('No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.');
  }


  /** @type {function(number, string, boolean=)} */
  function getValue(ptr, type, noSafe) {
    type = type || 'i8';
    if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
      switch(type) {
        case 'i1': return HEAP8[((ptr)>>0)];
        case 'i8': return HEAP8[((ptr)>>0)];
        case 'i16': return HEAP16[((ptr)>>1)];
        case 'i32': return HEAP32[((ptr)>>2)];
        case 'i64': return HEAP32[((ptr)>>2)];
        case 'float': return HEAPF32[((ptr)>>2)];
        case 'double': return HEAPF64[((ptr)>>3)];
        default: abort('invalid type for getValue: ' + type);
      }
    return null;
  }




  // Wasm globals

  var wasmMemory;

  // Potentially used for direct table calls.
  var wasmTable;


  //========================================
  // Runtime essentials
  //========================================

  // whether we are quitting the application. no code should run after this.
  // set in exit() and abort()
  var ABORT = false;

  /** @type {function(*, string=)} */
  function assert(condition, text) {
    if (!condition) {
      abort('Assertion failed: ' + text);
    }
  }

  /** @type {function(number, number, string, boolean=)} */
  function setValue(ptr, value, type, noSafe) {
    type = type || 'i8';
    if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
      switch(type) {
        case 'i1': HEAP8[((ptr)>>0)]=value; break;
        case 'i8': HEAP8[((ptr)>>0)]=value; break;
        case 'i16': HEAP16[((ptr)>>1)]=value; break;
        case 'i32': HEAP32[((ptr)>>2)]=value; break;
        case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
        case 'float': HEAPF32[((ptr)>>2)]=value; break;
        case 'double': HEAPF64[((ptr)>>3)]=value; break;
        default: abort('invalid type for setValue: ' + type);
      }
  }

  var ALLOC_NORMAL = 0; // Tries to use _malloc()
  var ALLOC_NONE = 3; // Do not allocate

  // allocate(): This is for internal use. You can use it yourself as well, but the interface
  //             is a little tricky (see docs right below). The reason is that it is optimized
  //             for multiple syntaxes to save space in generated code. So you should
  //             normally not use allocate(), and instead allocate memory using _malloc(),
  //             initialize it with setValue(), and so forth.
  // @slab: An array of data, or a number. If a number, then the size of the block to allocate,
  //        in *bytes* (note that this is sometimes confusing: the next parameter does not
  //        affect this!)
  // @types: Either an array of types, one for each byte (or 0 if no type at that position),
  //         or a single type which is used for the entire block. This only matters if there
  //         is initial data - if @slab is a number, then this does not matter at all and is
  //         ignored.
  // @allocator: How to allocate memory, see ALLOC_*
  /** @type {function((TypedArray|Array<number>|number), string, number, number=)} */
  function allocate(slab, types, allocator, ptr) {
    var zeroinit, size;
    if (typeof slab === 'number') {
      zeroinit = true;
      size = slab;
    } else {
      zeroinit = false;
      size = slab.length;
    }

    var singleType = typeof types === 'string' ? types : null;

    var ret;
    if (allocator == ALLOC_NONE) {
      ret = ptr;
    } else {
      ret = [_malloc,
      stackAlloc,
      dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));
    }

    if (zeroinit) {
      var stop;
      ptr = ret;
      assert((ret & 3) == 0);
      stop = ret + (size & ~3);
      for (; ptr < stop; ptr += 4) {
        HEAP32[((ptr)>>2)]=0;
      }
      stop = ret + size;
      while (ptr < stop) {
        HEAP8[((ptr++)>>0)]=0;
      }
      return ret;
    }

    if (singleType === 'i8') {
      if (slab.subarray || slab.slice) {
        HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);
      } else {
        HEAPU8.set(new Uint8Array(slab), ret);
      }
      return ret;
    }

    var i = 0, type, typeSize, previousType;
    while (i < size) {
      var curr = slab[i];

      type = singleType || types[i];
      if (type === 0) {
        i++;
        continue;
      }
      assert(type, 'Must know what type to store in allocate!');

      if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

      setValue(ret+i, curr, type);

      // no need to look up size unless type changes, so cache it
      if (previousType !== type) {
        typeSize = getNativeTypeSize(type);
        previousType = type;
      }
      i += typeSize;
    }

    return ret;
  }

  // Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready
  function getMemory(size) {
    if (!runtimeInitialized) return dynamicAlloc(size);
    return _malloc(size);
  }


  // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
  // a copy of that string as a Javascript String object.

  var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;

  /**
   * @param {number} idx
   * @param {number=} maxBytesToRead
   * @return {string}
   */
  function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
    // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
    // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
    while (u8Array[endPtr] && !(endPtr >= endIdx)) ++endPtr;

    if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
      return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
    } else {
      var str = '';
      // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
      while (idx < endPtr) {
        // For UTF8 byte structure, see:
        // http://en.wikipedia.org/wiki/UTF-8#Description
        // https://www.ietf.org/rfc/rfc2279.txt
        // https://tools.ietf.org/html/rfc3629
        var u0 = u8Array[idx++];
        if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
        var u1 = u8Array[idx++] & 63;
        if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
        var u2 = u8Array[idx++] & 63;
        if ((u0 & 0xF0) == 0xE0) {
          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
        } else {
          if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!');
          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (u8Array[idx++] & 63);
        }

        if (u0 < 0x10000) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 0x10000;
          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
        }
      }
    }
    return str;
  }

  // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
  // copy of that string as a Javascript String object.
  // maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
  //                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
  //                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
  //                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
  //                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
  //                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
  //                 throw JS JIT optimizations off, so it is worth to consider consistently using one
  //                 style or the other.
  /**
   * @param {number} ptr
   * @param {number=} maxBytesToRead
   * @return {string}
   */
  function UTF8ToString(ptr, maxBytesToRead) {
    return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
  }

  // Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
  // encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
  // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
  // Parameters:
  //   str: the Javascript string to copy.
  //   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.
  //   outIdx: The starting offset in the array to begin the copying.
  //   maxBytesToWrite: The maximum number of bytes this function can write to the array.
  //                    This count should include the null terminator,
  //                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
  //                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
  // Returns the number of bytes written, EXCLUDING the null terminator.

  function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
    if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
      return 0;

    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
    for (var i = 0; i < str.length; ++i) {
      // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
      // See http://unicode.org/faq/utf_bom.html#utf16-3
      // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
      var u = str.charCodeAt(i); // possibly a lead surrogate
      if (u >= 0xD800 && u <= 0xDFFF) {
        var u1 = str.charCodeAt(++i);
        u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
      }
      if (u <= 0x7F) {
        if (outIdx >= endIdx) break;
        outU8Array[outIdx++] = u;
      } else if (u <= 0x7FF) {
        if (outIdx + 1 >= endIdx) break;
        outU8Array[outIdx++] = 0xC0 | (u >> 6);
        outU8Array[outIdx++] = 0x80 | (u & 63);
      } else if (u <= 0xFFFF) {
        if (outIdx + 2 >= endIdx) break;
        outU8Array[outIdx++] = 0xE0 | (u >> 12);
        outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
        outU8Array[outIdx++] = 0x80 | (u & 63);
      } else {
        if (outIdx + 3 >= endIdx) break;
        if (u >= 0x200000) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).');
        outU8Array[outIdx++] = 0xF0 | (u >> 18);
        outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
        outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
        outU8Array[outIdx++] = 0x80 | (u & 63);
      }
    }
    // Null-terminate the pointer to the buffer.
    outU8Array[outIdx] = 0;
    return outIdx - startIdx;
  }

  // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
  // null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
  // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
  // Returns the number of bytes written, EXCLUDING the null terminator.

  function stringToUTF8(str, outPtr, maxBytesToWrite) {
    assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
    return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
  }

  // Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
  function lengthBytesUTF8(str) {
    var len = 0;
    for (var i = 0; i < str.length; ++i) {
      // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
      // See http://unicode.org/faq/utf_bom.html#utf16-3
      var u = str.charCodeAt(i); // possibly a lead surrogate
      if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
      if (u <= 0x7F) ++len;
      else if (u <= 0x7FF) len += 2;
      else if (u <= 0xFFFF) len += 3;
      else len += 4;
    }
    return len;
  }


  // Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
  // a copy of that string as a Javascript String object.

  var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;

  function writeAsciiToMemory(str, buffer, dontAddNull) {
    for (var i = 0; i < str.length; ++i) {
      assert(str.charCodeAt(i) === str.charCodeAt(i)&0xff);
      HEAP8[((buffer++)>>0)]=str.charCodeAt(i);
    }
    // Null-terminate the pointer to the HEAP.
    if (!dontAddNull) HEAP8[((buffer)>>0)]=0;
  }





  function demangle(func) {
    warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');
    return func;
  }

  function demangleAll(text) {
    var regex =
      /__Z[\w\d_]+/g;
    return text.replace(regex,
      function(x) {
        var y = demangle(x);
        return x === y ? x : (y + ' [' + x + ']');
      });
  }

  function jsStackTrace() {
    var err = new Error();
    if (!err.stack) {
      // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
      // so try that as a special-case.
      try {
        throw new Error(0);
      } catch(e) {
        err = e;
      }
      if (!err.stack) {
        return '(no stack trace available)';
      }
    }
    return err.stack.toString();
  }

  function stackTrace() {
    var js = jsStackTrace();
    if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
    return demangleAll(js);
  }
  var WASM_PAGE_SIZE = 65536;

  function alignUp(x, multiple) {
    if (x % multiple > 0) {
      x += multiple - (x % multiple);
    }
    return x;
  }

  var /** @type {ArrayBuffer} */
    buffer,
  /** @type {Int8Array} */
    HEAP8,
  /** @type {Uint8Array} */
    HEAPU8,
  /** @type {Int16Array} */
    HEAP16,
  /** @type {Uint16Array} */
    HEAPU16,
  /** @type {Int32Array} */
    HEAP32,
  /** @type {Uint32Array} */
    HEAPU32,
  /** @type {Float32Array} */
    HEAPF32,
  /** @type {Float64Array} */
    HEAPF64;

  function updateGlobalBufferViews() {
    Module['HEAP8'] = HEAP8 = new Int8Array(buffer);
    Module['HEAP16'] = HEAP16 = new Int16Array(buffer);
    Module['HEAP32'] = HEAP32 = new Int32Array(buffer);
    Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);
    Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);
    Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);
    Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);
    Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);
  }


  var STACK_BASE = 64304,
      STACK_MAX = 5307184,
      DYNAMIC_BASE = 5307184,
      DYNAMICTOP_PTR = 64048;

  assert(STACK_BASE % 16 === 0, 'stack must start aligned');
  assert(DYNAMIC_BASE % 16 === 0, 'heap must start aligned');



  var TOTAL_STACK = 5242880;
  if (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime');

  var INITIAL_TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;
  if (INITIAL_TOTAL_MEMORY < TOTAL_STACK) err('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');

  // Initialize the runtime's memory
  // check for full engine support (use string 'subarray' to avoid closure compiler confusion)
  assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined,
         'JS engine does not provide full typed array support');







  // Use a provided buffer, if there is one, or else allocate a new one
  if (Module['buffer']) {
    buffer = Module['buffer'];
    assert(buffer.byteLength === INITIAL_TOTAL_MEMORY, 'provided buffer should be ' + INITIAL_TOTAL_MEMORY + ' bytes, but it is ' + buffer.byteLength);
  } else {
    // Use a WebAssembly memory where available
    if (typeof WebAssembly === 'object' && typeof WebAssembly.Memory === 'function') {
      assert(INITIAL_TOTAL_MEMORY % WASM_PAGE_SIZE === 0);
      wasmMemory = new WebAssembly.Memory({ 'initial': INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE });
      buffer = wasmMemory.buffer;
    } else
    {
      buffer = new ArrayBuffer(INITIAL_TOTAL_MEMORY);
    }
    assert(buffer.byteLength === INITIAL_TOTAL_MEMORY);
  }
  updateGlobalBufferViews();


  HEAP32[DYNAMICTOP_PTR>>2] = DYNAMIC_BASE;


  // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
  function writeStackCookie() {
    assert((STACK_MAX & 3) == 0);
    HEAPU32[(STACK_MAX >> 2)-1] = 0x02135467;
    HEAPU32[(STACK_MAX >> 2)-2] = 0x89BACDFE;
  }

  function checkStackCookie() {
    if (HEAPU32[(STACK_MAX >> 2)-1] != 0x02135467 || HEAPU32[(STACK_MAX >> 2)-2] != 0x89BACDFE) {
      abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x' + HEAPU32[(STACK_MAX >> 2)-2].toString(16) + ' ' + HEAPU32[(STACK_MAX >> 2)-1].toString(16));
    }
    // Also test the global address 0 for integrity.
    if (HEAP32[0] !== 0x63736d65 /* 'emsc' */) throw 'Runtime error: The application has corrupted its heap memory area (address zero)!';
  }

  function abortStackOverflow(allocSize) {
    abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - stackSave() + allocSize) + ' bytes available!');
  }


    HEAP32[0] = 0x63736d65; /* 'emsc' */



  // Endianness check (note: assumes compiler arch was little-endian)
  HEAP16[1] = 0x6373;
  if (HEAPU8[2] !== 0x73 || HEAPU8[3] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';

  function callRuntimeCallbacks(callbacks) {
    while(callbacks.length > 0) {
      var callback = callbacks.shift();
      if (typeof callback == 'function') {
        callback();
        continue;
      }
      var func = callback.func;
      if (typeof func === 'number') {
        if (callback.arg === undefined) {
          Module['dynCall_v'](func);
        } else {
          Module['dynCall_vi'](func, callback.arg);
        }
      } else {
        func(callback.arg === undefined ? null : callback.arg);
      }
    }
  }

  var __ATPRERUN__  = []; // functions called before the runtime is initialized
  var __ATINIT__    = []; // functions called during startup
  var __ATMAIN__    = []; // functions called when main() is to be run
  var __ATPOSTRUN__ = []; // functions called after the main() is called

  var runtimeInitialized = false;
  var runtimeExited = false;


  function preRun() {
    // compatibility - merge in anything from Module['preRun'] at this time
    if (Module['preRun']) {
      if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
      while (Module['preRun'].length) {
        addOnPreRun(Module['preRun'].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }

  function ensureInitRuntime() {
    checkStackCookie();
    if (runtimeInitialized) return;
    runtimeInitialized = true;
    
    callRuntimeCallbacks(__ATINIT__);
  }

  function preMain() {
    checkStackCookie();
    
    callRuntimeCallbacks(__ATMAIN__);
  }

  function exitRuntime() {
    checkStackCookie();
    runtimeExited = true;
  }

  function postRun() {
    checkStackCookie();
    // compatibility - merge in anything from Module['postRun'] at this time
    if (Module['postRun']) {
      if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
      while (Module['postRun'].length) {
        addOnPostRun(Module['postRun'].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }

  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }

  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }


  assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
  assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
  assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
  assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');

  var Math_abs = Math.abs;
  var Math_cos = Math.cos;
  var Math_sin = Math.sin;
  var Math_ceil = Math.ceil;
  var Math_floor = Math.floor;
  var Math_min = Math.min;
  var Math_trunc = Math.trunc;



  // A counter of dependencies for calling run(). If we need to
  // do asynchronous work before running, increment this and
  // decrement it. Incrementing must happen in a place like
  // Module.preRun (used by emcc to add file preloading).
  // Note that you can add dependencies in preRun, even though
  // it happens right before run - run will be postponed until
  // the dependencies are met.
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled
  var runDependencyTracking = {};

  function addRunDependency(id) {
    runDependencies++;
    if (Module['monitorRunDependencies']) {
      Module['monitorRunDependencies'](runDependencies);
    }
    if (id) {
      assert(!runDependencyTracking[id]);
      runDependencyTracking[id] = 1;
      if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {
        // Check for missing dependencies every few seconds
        runDependencyWatcher = setInterval(function() {
          if (ABORT) {
            clearInterval(runDependencyWatcher);
            runDependencyWatcher = null;
            return;
          }
          var shown = false;
          for (var dep in runDependencyTracking) {
            if (!shown) {
              shown = true;
              err('still waiting on run dependencies:');
            }
            err('dependency: ' + dep);
          }
          if (shown) {
            err('(end of list)');
          }
        }, 10000);
      }
    } else {
      err('warning: run dependency added without ID');
    }
  }

  function removeRunDependency(id) {
    runDependencies--;
    if (Module['monitorRunDependencies']) {
      Module['monitorRunDependencies'](runDependencies);
    }
    if (id) {
      assert(runDependencyTracking[id]);
      delete runDependencyTracking[id];
    } else {
      err('warning: run dependency removed without ID');
    }
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback(); // can add another dependenciesFulfilled
      }
    }
  }

  Module["preloadedImages"] = {}; // maps url to image data
  Module["preloadedAudios"] = {}; // maps url to audio data



  var /* show errors on likely calls to FS when it was not included */ FS = {
    error: function() {
      abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1');
    },
    init: function() { FS.error(); },
    createDataFile: function() { FS.error(); },
    createPreloadedFile: function() { FS.error(); },
    createLazyFile: function() { FS.error(); },
    open: function() { FS.error(); },
    mkdev: function() { FS.error(); },
    registerDevice: function() { FS.error(); },
    analyzePath: function() { FS.error(); },
    loadFilesFromDB: function() { FS.error(); },

    ErrnoError: function ErrnoError() { FS.error(); },
  };
  Module['FS_createDataFile'] = FS.createDataFile;
  Module['FS_createPreloadedFile'] = FS.createPreloadedFile;



  // Copyright 2017 The Emscripten Authors.  All rights reserved.
  // Emscripten is available under two separate licenses, the MIT license and the
  // University of Illinois/NCSA Open Source License.  Both these licenses can be
  // found in the LICENSE file.

  // Prefix of data URIs emitted by SINGLE_FILE and related options.
  var dataURIPrefix = 'data:application/octet-stream;base64,';

  // Indicates whether filename is a base64 data URI.
  function isDataURI(filename) {
    return String.prototype.startsWith ?
        filename.startsWith(dataURIPrefix) :
        filename.indexOf(dataURIPrefix) === 0;
  }




  var wasmBinaryFile = 'vireo.core.wasm';
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }

  function getBinary() {
    try {
      if (Module['wasmBinary']) {
        return new Uint8Array(Module['wasmBinary']);
      }
      if (Module['readBinary']) {
        return Module['readBinary'](wasmBinaryFile);
      } else {
        throw "both async and sync fetching of the wasm failed";
      }
    }
    catch (err) {
      abort(err);
    }
  }

  function getBinaryPromise() {
    // if we don't have the binary yet, and have the Fetch api, use that
    // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web
    if (!Module['wasmBinary'] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        if (!response['ok']) {
          throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
        }
        return response['arrayBuffer']();
      }).catch(function () {
        return getBinary();
      });
    }
    // Otherwise, getBinary should be able to get it synchronously
    return new Promise(function(resolve, reject) {
      resolve(getBinary());
    });
  }

  // Create the wasm instance.
  // Receives the wasm imports, returns the exports.
  function createWasm(env) {
    // prepare imports
    var info = {
      'env': env
      ,
      'global': {
        'NaN': NaN,
        'Infinity': Infinity
      },
      'global.Math': Math,
      'asm2wasm': asm2wasmImports
    };
    // Load the wasm module and create an instance of using native support in the JS engine.
    // handle a generated wasm instance, receiving its exports and
    // performing other necessary setup
    function receiveInstance(instance, module) {
      var exports = instance.exports;
      Module['asm'] = exports;
      removeRunDependency('wasm-instantiate');
    }
    addRunDependency('wasm-instantiate');

    // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
    // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
    // to any other async startup actions they are performing.
    if (Module['instantiateWasm']) {
      try {
        return Module['instantiateWasm'](info, receiveInstance);
      } catch(e) {
        err('Module.instantiateWasm callback failed with error: ' + e);
        return false;
      }
    }

    // Async compilation can be confusing when an error on the page overwrites Module
    // (for example, if the order of elements is wrong, and the one defining Module is
    // later), so we save Module and check it later.
    var trueModule = Module;
    function receiveInstantiatedSource(output) {
      // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.
      // receiveInstance() will swap in the exports (to Module.asm) so they can be called
      assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');
      trueModule = null;
        // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
        // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.
      receiveInstance(output['instance']);
    }
    function instantiateArrayBuffer(receiver) {
      getBinaryPromise().then(function(binary) {
        return WebAssembly.instantiate(binary, info);
      }).then(receiver, function(reason) {
        err('failed to asynchronously prepare wasm: ' + reason);
        abort(reason);
      });
    }
    // Prefer streaming instantiation if available.
    if (!Module['wasmBinary'] &&
        typeof WebAssembly.instantiateStreaming === 'function' &&
        !isDataURI(wasmBinaryFile) &&
        typeof fetch === 'function') {
      WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, { credentials: 'same-origin' }), info)
        .then(receiveInstantiatedSource, function(reason) {
          // We expect the most common failure cause to be a bad MIME type for the binary,
          // in which case falling back to ArrayBuffer instantiation should work.
          err('wasm streaming compile failed: ' + reason);
          err('falling back to ArrayBuffer instantiation');
          instantiateArrayBuffer(receiveInstantiatedSource);
        });
    } else {
      instantiateArrayBuffer(receiveInstantiatedSource);
    }
    return {}; // no exports yet; we'll fill them in later
  }

  // Provide an "asm.js function" for the application, called to "link" the asm.js module. We instantiate
  // the wasm module at that time, and it receives imports and provides exports and so forth, the app
  // doesn't need to care that it is wasm or asm.js.

  Module['asm'] = function(global, env, providedBuffer) {
    // memory was already allocated (so js could use the buffer)
    env['memory'] = wasmMemory
    ;
    // import table
    env['table'] = wasmTable = new WebAssembly.Table({
      'initial': 12552,
      'maximum': 12552,
      'element': 'anyfunc'
    });
    env['__memory_base'] = 1024; // tell the memory segments where to place themselves
    env['__table_base'] = 0; // table starts at 0 by default (even in dynamic linking, for the main module)

    var exports = createWasm(env);
    assert(exports, 'binaryen setup failed (no wasm support?)');
    return exports;
  };





  // STATICTOP = STATIC_BASE + 63280;
  /* global initializers */  __ATINIT__.push({ func: function() { globalCtors(); } });








  /* no memory initializer */
  var tempDoublePtr = 64288;
  assert(tempDoublePtr % 8 == 0);

  // {{PRE_LIBRARY}}


    
    var ENV={};function ___buildEnvironment(environ) {
        // WARNING: Arbitrary limit!
        var MAX_ENV_VALUES = 64;
        var TOTAL_ENV_SIZE = 1024;
    
        // Statically allocate memory for the environment.
        var poolPtr;
        var envPtr;
        if (!___buildEnvironment.called) {
          ___buildEnvironment.called = true;
          // Set default values. Use string keys for Closure Compiler compatibility.
          ENV['USER'] = ENV['LOGNAME'] = 'web_user';
          ENV['PATH'] = '/';
          ENV['PWD'] = '/';
          ENV['HOME'] = '/home/web_user';
          ENV['LANG'] = 'C.UTF-8';
          ENV['_'] = Module['thisProgram'];
          // Allocate memory.
          poolPtr = getMemory(TOTAL_ENV_SIZE);
          envPtr = getMemory(MAX_ENV_VALUES * 4);
          HEAP32[((envPtr)>>2)]=poolPtr;
          HEAP32[((environ)>>2)]=envPtr;
        } else {
          envPtr = HEAP32[((environ)>>2)];
          poolPtr = HEAP32[((envPtr)>>2)];
        }
    
        // Collect key=value lines.
        var strings = [];
        var totalSize = 0;
        for (var key in ENV) {
          if (typeof ENV[key] === 'string') {
            var line = key + '=' + ENV[key];
            strings.push(line);
            totalSize += line.length;
          }
        }
        if (totalSize > TOTAL_ENV_SIZE) {
          throw new Error('Environment size exceeded TOTAL_ENV_SIZE!');
        }
    
        // Make new.
        var ptrSize = 4;
        for (var i = 0; i < strings.length; i++) {
          var line = strings[i];
          writeAsciiToMemory(line, poolPtr);
          HEAP32[(((envPtr)+(i * ptrSize))>>2)]=poolPtr;
          poolPtr += line.length + 1;
        }
        HEAP32[(((envPtr)+(strings.length * ptrSize))>>2)]=0;
      }

    function ___cxa_pure_virtual() {
        ABORT = true;
        throw 'Pure virtual function called!';
      }

    function ___lock() {}

    
    var SYSCALLS={buffers:[null,[],[]],printChar:function (stream, curr) {
          var buffer = SYSCALLS.buffers[stream];
          assert(buffer);
          if (curr === 0 || curr === 10) {
            (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
            buffer.length = 0;
          } else {
            buffer.push(curr);
          }
        },varargs:0,get:function (varargs) {
          SYSCALLS.varargs += 4;
          var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
          return ret;
        },getStr:function () {
          var ret = UTF8ToString(SYSCALLS.get());
          return ret;
        },get64:function () {
          var low = SYSCALLS.get(), high = SYSCALLS.get();
          if (low >= 0) assert(high === 0);
          else assert(high === -1);
          return low;
        },getZero:function () {
          assert(SYSCALLS.get() === 0);
        }};function ___syscall140(which, varargs) {SYSCALLS.varargs = varargs;
    try {
     // llseek
        var stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get();
        // NOTE: offset_high is unused - Emscripten's off_t is 32-bit
        var offset = offset_low;
        FS.llseek(stream, offset, whence);
        HEAP32[((result)>>2)]=stream.position;
        if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
        return 0;
      } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
      return -e.errno;
    }
    }

    
    function flush_NO_FILESYSTEM() {
        // flush anything remaining in the buffers during shutdown
        var fflush = Module["_fflush"];
        if (fflush) fflush(0);
        var buffers = SYSCALLS.buffers;
        if (buffers[1].length) SYSCALLS.printChar(1, 10);
        if (buffers[2].length) SYSCALLS.printChar(2, 10);
      }function ___syscall146(which, varargs) {SYSCALLS.varargs = varargs;
    try {
     // writev
        // hack to support printf in FILESYSTEM=0
        var stream = SYSCALLS.get(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          for (var j = 0; j < len; j++) {
            SYSCALLS.printChar(stream, HEAPU8[ptr+j]);
          }
          ret += len;
        }
        return ret;
      } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
      return -e.errno;
    }
    }

    function ___syscall195(which, varargs) {SYSCALLS.varargs = varargs;
    try {
     // SYS_stat64
        var path = SYSCALLS.getStr(), buf = SYSCALLS.get();
        return SYSCALLS.doStat(FS.stat, path, buf);
      } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
      return -e.errno;
    }
    }

    function ___syscall197(which, varargs) {SYSCALLS.varargs = varargs;
    try {
     // SYS_fstat64
        var stream = SYSCALLS.getStreamFromFD(), buf = SYSCALLS.get();
        return SYSCALLS.doStat(FS.stat, stream.path, buf);
      } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
      return -e.errno;
    }
    }

    
    function ___setErrNo(value) {
        if (Module['___errno_location']) HEAP32[((Module['___errno_location']())>>2)]=value;
        else err('failed to set errno from JS');
        return value;
      }function ___syscall221(which, varargs) {SYSCALLS.varargs = varargs;
    try {
     // fcntl64
        return 0;
      } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
      return -e.errno;
    }
    }

    function ___syscall3(which, varargs) {SYSCALLS.varargs = varargs;
    try {
     // read
        var stream = SYSCALLS.getStreamFromFD(), buf = SYSCALLS.get(), count = SYSCALLS.get();
        return FS.read(stream, HEAP8,buf, count);
      } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
      return -e.errno;
    }
    }

    function ___syscall4(which, varargs) {SYSCALLS.varargs = varargs;
    try {
     // write
        // hack to support printf in FILESYSTEM=0
        var stream = SYSCALLS.get(), buf = SYSCALLS.get(), count = SYSCALLS.get();
        for (var i = 0; i < count; i++) {
          SYSCALLS.printChar(stream, HEAPU8[buf+i]);
        }
        return count;
      } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
      return -e.errno;
    }
    }

    function ___syscall54(which, varargs) {SYSCALLS.varargs = varargs;
    try {
     // ioctl
        return 0;
      } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
      return -e.errno;
    }
    }

    function ___syscall6(which, varargs) {SYSCALLS.varargs = varargs;
    try {
     // close
        var stream = SYSCALLS.getStreamFromFD();
        FS.close(stream);
        return 0;
      } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
      return -e.errno;
    }
    }

    function ___unlock() {}

    function _abort() {
        Module['abort']();
      }

    function _emscripten_get_heap_size() {
        return HEAP8.length;
      }

    function _emscripten_get_now() { abort(); }

    
    function emscripten_realloc_buffer(size) {
        var PAGE_MULTIPLE = 65536;
        size = alignUp(size, PAGE_MULTIPLE); // round up to wasm page size
        var oldSize = buffer.byteLength;
        // native wasm support
        try {
          var result = wasmMemory.grow((size - oldSize) / 65536); // .grow() takes a delta compared to the previous size
          if (result !== (-1 | 0)) {
            // success in native wasm memory growth, get the buffer from the memory
            return buffer = wasmMemory.buffer;
          } else {
            return null;
          }
        } catch(e) {
          console.error('emscripten_realloc_buffer: Attempted to grow from ' + oldSize  + ' bytes to ' + size + ' bytes, but got error: ' + e);
          return null;
        }
      }function _emscripten_resize_heap(requestedSize) {
        var oldSize = _emscripten_get_heap_size();
        assert(requestedSize > oldSize); // This function should only ever be called after the ceiling of the dynamic heap has already been bumped to exceed the current total size of the asm.js heap.
    
    
        var PAGE_MULTIPLE = 65536;
        var LIMIT = 2147483648 - PAGE_MULTIPLE; // We can do one page short of 2GB as theoretical maximum.
    
        if (requestedSize > LIMIT) {
          err('Cannot enlarge memory, asked to go up to ' + requestedSize + ' bytes, but the limit is ' + LIMIT + ' bytes!');
          return false;
        }
    
        var MIN_TOTAL_MEMORY = 16777216;
        var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY); // So the loop below will not be infinite, and minimum asm.js memory size is 16MB.
    
        while (newSize < requestedSize) { // Keep incrementing the heap size as long as it's less than what is requested.
          if (newSize <= 536870912) {
            newSize = alignUp(2 * newSize, PAGE_MULTIPLE); // Simple heuristic: double until 1GB...
          } else {
            // ..., but after that, add smaller increments towards 2GB, which we cannot reach
            newSize = Math.min(alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);
            if (newSize === oldSize) {
              warnOnce('Cannot ask for more memory since we reached the practical limit in browsers (which is just below 2GB), so the request would have failed. Requesting only ' + HEAP8.length);
            }
          }
        }
    
        var replacement = emscripten_realloc_buffer(newSize);
        if (!replacement || replacement.byteLength != newSize) {
          err('Failed to grow the heap from ' + oldSize + ' bytes to ' + newSize + ' bytes, not enough memory!');
          if (replacement) {
            err('Expected to get back a buffer of size ' + newSize + ' bytes, but instead got back a buffer of size ' + replacement.byteLength);
          }
          return false;
        }
    
        // everything worked
        updateGlobalBufferViews();
    
    
    
        return true;
      }

    function _exit(status) {
        // void _exit(int status);
        // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html
        exit(status);
      }

    function _gettimeofday(ptr) {
        var now = Date.now();
        HEAP32[((ptr)>>2)]=(now/1000)|0; // seconds
        HEAP32[(((ptr)+(4))>>2)]=((now % 1000)*1000)|0; // microseconds
        return 0;
      }

    
    var ___tm_timezone=(stringToUTF8("GMT", 64192, 4), 64192);function _gmtime_r(time, tmPtr) {
        var date = new Date(HEAP32[((time)>>2)]*1000);
        HEAP32[((tmPtr)>>2)]=date.getUTCSeconds();
        HEAP32[(((tmPtr)+(4))>>2)]=date.getUTCMinutes();
        HEAP32[(((tmPtr)+(8))>>2)]=date.getUTCHours();
        HEAP32[(((tmPtr)+(12))>>2)]=date.getUTCDate();
        HEAP32[(((tmPtr)+(16))>>2)]=date.getUTCMonth();
        HEAP32[(((tmPtr)+(20))>>2)]=date.getUTCFullYear()-1900;
        HEAP32[(((tmPtr)+(24))>>2)]=date.getUTCDay();
        HEAP32[(((tmPtr)+(36))>>2)]=0;
        HEAP32[(((tmPtr)+(32))>>2)]=0;
        var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
        var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24))|0;
        HEAP32[(((tmPtr)+(28))>>2)]=yday;
        HEAP32[(((tmPtr)+(40))>>2)]=___tm_timezone;
    
        return tmPtr;
      }

    function _jsExecutionContextFPSync() {
                Module.coreHelpers.jsExecutionContextFPSync.apply(undefined, arguments);
            }

    function _jsHttpClientAddHeader() {
                Module.httpClient.jsHttpClientAddHeader.apply(undefined, arguments);
            }

    function _jsHttpClientClose() {
                Module.httpClient.jsHttpClientClose.apply(undefined, arguments);
            }

    function _jsHttpClientConfigCORS() {
                Module.httpClient.jsHttpClientConfigCORS.apply(undefined, arguments);
            }

    function _jsHttpClientGetHeader() {
                Module.httpClient.jsHttpClientGetHeader.apply(undefined, arguments);
            }

    function _jsHttpClientHeaderExists() {
                Module.httpClient.jsHttpClientHeaderExists.apply(undefined, arguments);
            }

    function _jsHttpClientListHeaders() {
                Module.httpClient.jsHttpClientListHeaders.apply(undefined, arguments);
            }

    function _jsHttpClientMethod() {
                Module.httpClient.jsHttpClientMethod.apply(undefined, arguments);
            }

    function _jsHttpClientOpen() {
                Module.httpClient.jsHttpClientOpen.apply(undefined, arguments);
            }

    function _jsHttpClientRemoveHeader() {
                Module.httpClient.jsHttpClientRemoveHeader.apply(undefined, arguments);
            }

    function _jsIsNotAJavaScriptRefnum() {
                Module.javaScriptInvoke.jsIsNotAJavaScriptRefnum.apply(undefined, arguments);
            }

    function _jsJavaScriptInvoke() {
                Module.javaScriptInvoke.jsJavaScriptInvoke.apply(undefined, arguments);
            }

    function _jsPropertyNodeRead() {
                Module.propertyNode.jsPropertyNodeRead.apply(undefined, arguments);
            }

    function _jsPropertyNodeWrite() {
                Module.propertyNode.jsPropertyNodeWrite.apply(undefined, arguments);
            }

    function _jsRegisterForControlEvent() {
                Module.eventHelpers.jsRegisterForControlEvent.apply(undefined, arguments);
            }

    function _jsSystemLogging_WriteMessageUTF8() {
                Module.coreHelpers.jsSystemLogging_WriteMessageUTF8.apply(undefined, arguments);
            }

    function _jsUnRegisterForControlEvent() {
                Module.eventHelpers.jsUnRegisterForControlEvent.apply(undefined, arguments);
            }

    var _llvm_cos_f32=Math_cos;

    var _llvm_cos_f64=Math_cos;

    function _llvm_log10_f32(x) {
        return Math.log(x) / Math.LN10; // TODO: Math.log10, when browser support is there
      }

    function _llvm_log10_f64(a0
    /*``*/) {
    return _llvm_log10_f32(a0);
    }

    function _llvm_log2_f32(x) {
        return Math.log(x) / Math.LN2; // TODO: Math.log2, when browser support is there
      }

    function _llvm_log2_f64(a0
    /*``*/) {
    return _llvm_log2_f32(a0);
    }

     

     

    
    
      

    var _llvm_sin_f32=Math_sin;

    var _llvm_sin_f64=Math_sin;

    function _llvm_trap() {
        abort('trap!');
      }

    var _llvm_trunc_f32=Math_trunc;

    var _llvm_trunc_f64=Math_trunc;

    
    function _tzset() {
        // TODO: Use (malleable) environment variables instead of system settings.
        if (_tzset.called) return;
        _tzset.called = true;
    
        // timezone is specified as seconds west of UTC ("The external variable
        // `timezone` shall be set to the difference, in seconds, between
        // Coordinated Universal Time (UTC) and local standard time."), the same
        // as returned by getTimezoneOffset().
        // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html
        HEAP32[((__get_timezone())>>2)]=(new Date()).getTimezoneOffset() * 60;
    
        var winter = new Date(2000, 0, 1);
        var summer = new Date(2000, 6, 1);
        HEAP32[((__get_daylight())>>2)]=Number(winter.getTimezoneOffset() != summer.getTimezoneOffset());
    
        function extractZone(date) {
          var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
          return match ? match[1] : "GMT";
        }      var winterName = extractZone(winter);
        var summerName = extractZone(summer);
        var winterNamePtr = allocate(intArrayFromString(winterName), 'i8', ALLOC_NORMAL);
        var summerNamePtr = allocate(intArrayFromString(summerName), 'i8', ALLOC_NORMAL);
        if (summer.getTimezoneOffset() < winter.getTimezoneOffset()) {
          // Northern hemisphere
          HEAP32[((__get_tzname())>>2)]=winterNamePtr;
          HEAP32[(((__get_tzname())+(4))>>2)]=summerNamePtr;
        } else {
          HEAP32[((__get_tzname())>>2)]=summerNamePtr;
          HEAP32[(((__get_tzname())+(4))>>2)]=winterNamePtr;
        }
      }function _localtime_r(time, tmPtr) {
        _tzset();
        var date = new Date(HEAP32[((time)>>2)]*1000);
        HEAP32[((tmPtr)>>2)]=date.getSeconds();
        HEAP32[(((tmPtr)+(4))>>2)]=date.getMinutes();
        HEAP32[(((tmPtr)+(8))>>2)]=date.getHours();
        HEAP32[(((tmPtr)+(12))>>2)]=date.getDate();
        HEAP32[(((tmPtr)+(16))>>2)]=date.getMonth();
        HEAP32[(((tmPtr)+(20))>>2)]=date.getFullYear()-1900;
        HEAP32[(((tmPtr)+(24))>>2)]=date.getDay();
    
        var start = new Date(date.getFullYear(), 0, 1);
        var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;
        HEAP32[(((tmPtr)+(28))>>2)]=yday;
        HEAP32[(((tmPtr)+(36))>>2)]=-(date.getTimezoneOffset() * 60);
    
        // Attention: DST is in December in South, and some regions don't have DST at all.
        var summerOffset = new Date(2000, 6, 1).getTimezoneOffset();
        var winterOffset = start.getTimezoneOffset();
        var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset))|0;
        HEAP32[(((tmPtr)+(32))>>2)]=dst;
    
        var zonePtr = HEAP32[(((__get_tzname())+(dst ? 4 : 0))>>2)];
        HEAP32[(((tmPtr)+(40))>>2)]=zonePtr;
    
        return tmPtr;
      }

    
    function _emscripten_memcpy_big(dest, src, num) {
        HEAPU8.set(HEAPU8.subarray(src, src+num), dest);
      }
    
     

     

     

     
  if (ENVIRONMENT_IS_NODE) {
      _emscripten_get_now = function _emscripten_get_now_actual() {
        var t = process['hrtime']();
        return t[0] * 1e3 + t[1] / 1e6;
      };
    } else if (typeof dateNow !== 'undefined') {
      _emscripten_get_now = dateNow;
    } else if (typeof performance === 'object' && performance && typeof performance['now'] === 'function') {
      _emscripten_get_now = function() { return performance['now'](); };
    } else {
      _emscripten_get_now = Date.now;
    }
  // Copyright 2017 The Emscripten Authors.  All rights reserved.
  // Emscripten is available under two separate licenses, the MIT license and the
  // University of Illinois/NCSA Open Source License.  Both these licenses can be
  // found in the LICENSE file.

  /** @type {function(string, boolean=, number=)} */
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull) u8array.length = numBytesWritten;
    return u8array;
  }


  // ASM_LIBRARY EXTERN PRIMITIVES: Math_max,Math_floor,Math_ceil,Int8Array,Int32Array


  function nullFunc_ii(x) { err("Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x); }

  function nullFunc_iii(x) { err("Invalid function pointer called with signature 'iii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x); }

  function nullFunc_iiii(x) { err("Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x); }

  function nullFunc_iiiii(x) { err("Invalid function pointer called with signature 'iiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x); }

  function nullFunc_iiiiii(x) { err("Invalid function pointer called with signature 'iiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x); }

  function nullFunc_iiiiiii(x) { err("Invalid function pointer called with signature 'iiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x); }

  function nullFunc_v(x) { err("Invalid function pointer called with signature 'v'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x); }

  function nullFunc_vi(x) { err("Invalid function pointer called with signature 'vi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x); }

  function nullFunc_vii(x) { err("Invalid function pointer called with signature 'vii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x); }

  function nullFunc_viiii(x) { err("Invalid function pointer called with signature 'viiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x); }

  function nullFunc_viiiii(x) { err("Invalid function pointer called with signature 'viiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x); }

  function nullFunc_viiiiii(x) { err("Invalid function pointer called with signature 'viiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x); }

  var asmGlobalArg = {};

  var asmLibraryArg = {
    "abort": abort,
    "setTempRet0": setTempRet0,
    "getTempRet0": getTempRet0,
    "abortStackOverflow": abortStackOverflow,
    "nullFunc_ii": nullFunc_ii,
    "nullFunc_iii": nullFunc_iii,
    "nullFunc_iiii": nullFunc_iiii,
    "nullFunc_iiiii": nullFunc_iiiii,
    "nullFunc_iiiiii": nullFunc_iiiiii,
    "nullFunc_iiiiiii": nullFunc_iiiiiii,
    "nullFunc_v": nullFunc_v,
    "nullFunc_vi": nullFunc_vi,
    "nullFunc_vii": nullFunc_vii,
    "nullFunc_viiii": nullFunc_viiii,
    "nullFunc_viiiii": nullFunc_viiiii,
    "nullFunc_viiiiii": nullFunc_viiiiii,
    "___buildEnvironment": ___buildEnvironment,
    "___cxa_pure_virtual": ___cxa_pure_virtual,
    "___lock": ___lock,
    "___setErrNo": ___setErrNo,
    "___syscall140": ___syscall140,
    "___syscall146": ___syscall146,
    "___syscall195": ___syscall195,
    "___syscall197": ___syscall197,
    "___syscall221": ___syscall221,
    "___syscall3": ___syscall3,
    "___syscall4": ___syscall4,
    "___syscall54": ___syscall54,
    "___syscall6": ___syscall6,
    "___unlock": ___unlock,
    "_abort": _abort,
    "_emscripten_get_heap_size": _emscripten_get_heap_size,
    "_emscripten_get_now": _emscripten_get_now,
    "_emscripten_memcpy_big": _emscripten_memcpy_big,
    "_emscripten_resize_heap": _emscripten_resize_heap,
    "_exit": _exit,
    "_gettimeofday": _gettimeofday,
    "_gmtime_r": _gmtime_r,
    "_jsExecutionContextFPSync": _jsExecutionContextFPSync,
    "_jsHttpClientAddHeader": _jsHttpClientAddHeader,
    "_jsHttpClientClose": _jsHttpClientClose,
    "_jsHttpClientConfigCORS": _jsHttpClientConfigCORS,
    "_jsHttpClientGetHeader": _jsHttpClientGetHeader,
    "_jsHttpClientHeaderExists": _jsHttpClientHeaderExists,
    "_jsHttpClientListHeaders": _jsHttpClientListHeaders,
    "_jsHttpClientMethod": _jsHttpClientMethod,
    "_jsHttpClientOpen": _jsHttpClientOpen,
    "_jsHttpClientRemoveHeader": _jsHttpClientRemoveHeader,
    "_jsIsNotAJavaScriptRefnum": _jsIsNotAJavaScriptRefnum,
    "_jsJavaScriptInvoke": _jsJavaScriptInvoke,
    "_jsPropertyNodeRead": _jsPropertyNodeRead,
    "_jsPropertyNodeWrite": _jsPropertyNodeWrite,
    "_jsRegisterForControlEvent": _jsRegisterForControlEvent,
    "_jsSystemLogging_WriteMessageUTF8": _jsSystemLogging_WriteMessageUTF8,
    "_jsUnRegisterForControlEvent": _jsUnRegisterForControlEvent,
    "_llvm_cos_f32": _llvm_cos_f32,
    "_llvm_cos_f64": _llvm_cos_f64,
    "_llvm_log10_f32": _llvm_log10_f32,
    "_llvm_log10_f64": _llvm_log10_f64,
    "_llvm_log2_f32": _llvm_log2_f32,
    "_llvm_log2_f64": _llvm_log2_f64,
    "_llvm_sin_f32": _llvm_sin_f32,
    "_llvm_sin_f64": _llvm_sin_f64,
    "_llvm_trap": _llvm_trap,
    "_llvm_trunc_f32": _llvm_trunc_f32,
    "_llvm_trunc_f64": _llvm_trunc_f64,
    "_localtime_r": _localtime_r,
    "_tzset": _tzset,
    "emscripten_realloc_buffer": emscripten_realloc_buffer,
    "flush_NO_FILESYSTEM": flush_NO_FILESYSTEM,
    "tempDoublePtr": tempDoublePtr,
    "DYNAMICTOP_PTR": DYNAMICTOP_PTR
  };
  // EMSCRIPTEN_START_ASM
  var asm =Module["asm"]// EMSCRIPTEN_END_ASM
  (asmGlobalArg, asmLibraryArg, buffer);

  var real__Data_GetArrayBegin = asm["_Data_GetArrayBegin"]; asm["_Data_GetArrayBegin"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_GetArrayBegin.apply(null, arguments);
  };

  var real__Data_GetArrayDimensions = asm["_Data_GetArrayDimensions"]; asm["_Data_GetArrayDimensions"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_GetArrayDimensions.apply(null, arguments);
  };

  var real__Data_GetArrayLength = asm["_Data_GetArrayLength"]; asm["_Data_GetArrayLength"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_GetArrayLength.apply(null, arguments);
  };

  var real__Data_GetLength = asm["_Data_GetLength"]; asm["_Data_GetLength"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_GetLength.apply(null, arguments);
  };

  var real__Data_GetStringBegin = asm["_Data_GetStringBegin"]; asm["_Data_GetStringBegin"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_GetStringBegin.apply(null, arguments);
  };

  var real__Data_GetStringLength = asm["_Data_GetStringLength"]; asm["_Data_GetStringLength"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_GetStringLength.apply(null, arguments);
  };

  var real__Data_Length = asm["_Data_Length"]; asm["_Data_Length"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_Length.apply(null, arguments);
  };

  var real__Data_RawBlockSize = asm["_Data_RawBlockSize"]; asm["_Data_RawBlockSize"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_RawBlockSize.apply(null, arguments);
  };

  var real__Data_RawPointerFromOffset = asm["_Data_RawPointerFromOffset"]; asm["_Data_RawPointerFromOffset"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_RawPointerFromOffset.apply(null, arguments);
  };

  var real__Data_Read1Byte = asm["_Data_Read1Byte"]; asm["_Data_Read1Byte"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_Read1Byte.apply(null, arguments);
  };

  var real__Data_Read2Bytes = asm["_Data_Read2Bytes"]; asm["_Data_Read2Bytes"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_Read2Bytes.apply(null, arguments);
  };

  var real__Data_Read4Bytes = asm["_Data_Read4Bytes"]; asm["_Data_Read4Bytes"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_Read4Bytes.apply(null, arguments);
  };

  var real__Data_Read8Bytes = asm["_Data_Read8Bytes"]; asm["_Data_Read8Bytes"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_Read8Bytes.apply(null, arguments);
  };

  var real__Data_ReadBytes = asm["_Data_ReadBytes"]; asm["_Data_ReadBytes"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_ReadBytes.apply(null, arguments);
  };

  var real__Data_ReadPointer = asm["_Data_ReadPointer"]; asm["_Data_ReadPointer"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_ReadPointer.apply(null, arguments);
  };

  var real__Data_Resize1D = asm["_Data_Resize1D"]; asm["_Data_Resize1D"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_Resize1D.apply(null, arguments);
  };

  var real__Data_ResizeDimensions = asm["_Data_ResizeDimensions"]; asm["_Data_ResizeDimensions"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_ResizeDimensions.apply(null, arguments);
  };

  var real__Data_Type = asm["_Data_Type"]; asm["_Data_Type"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_Type.apply(null, arguments);
  };

  var real__Data_Write1Byte = asm["_Data_Write1Byte"]; asm["_Data_Write1Byte"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_Write1Byte.apply(null, arguments);
  };

  var real__Data_Write2Bytes = asm["_Data_Write2Bytes"]; asm["_Data_Write2Bytes"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_Write2Bytes.apply(null, arguments);
  };

  var real__Data_Write4Bytes = asm["_Data_Write4Bytes"]; asm["_Data_Write4Bytes"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_Write4Bytes.apply(null, arguments);
  };

  var real__Data_Write8Bytes = asm["_Data_Write8Bytes"]; asm["_Data_Write8Bytes"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_Write8Bytes.apply(null, arguments);
  };

  var real__Data_WriteBytes = asm["_Data_WriteBytes"]; asm["_Data_WriteBytes"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_WriteBytes.apply(null, arguments);
  };

  var real__Data_WritePointer = asm["_Data_WritePointer"]; asm["_Data_WritePointer"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Data_WritePointer.apply(null, arguments);
  };

  var real__EggShell_AllocateData = asm["_EggShell_AllocateData"]; asm["_EggShell_AllocateData"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__EggShell_AllocateData.apply(null, arguments);
  };

  var real__EggShell_Create = asm["_EggShell_Create"]; asm["_EggShell_Create"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__EggShell_Create.apply(null, arguments);
  };

  var real__EggShell_DeallocateData = asm["_EggShell_DeallocateData"]; asm["_EggShell_DeallocateData"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__EggShell_DeallocateData.apply(null, arguments);
  };

  var real__EggShell_Delete = asm["_EggShell_Delete"]; asm["_EggShell_Delete"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__EggShell_Delete.apply(null, arguments);
  };

  var real__EggShell_DeleteVariantAttribute = asm["_EggShell_DeleteVariantAttribute"]; asm["_EggShell_DeleteVariantAttribute"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__EggShell_DeleteVariantAttribute.apply(null, arguments);
  };

  var real__EggShell_ExecuteSlices = asm["_EggShell_ExecuteSlices"]; asm["_EggShell_ExecuteSlices"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__EggShell_ExecuteSlices.apply(null, arguments);
  };

  var real__EggShell_FindSubValue = asm["_EggShell_FindSubValue"]; asm["_EggShell_FindSubValue"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__EggShell_FindSubValue.apply(null, arguments);
  };

  var real__EggShell_FindValue = asm["_EggShell_FindValue"]; asm["_EggShell_FindValue"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__EggShell_FindValue.apply(null, arguments);
  };

  var real__EggShell_GetTypeList = asm["_EggShell_GetTypeList"]; asm["_EggShell_GetTypeList"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__EggShell_GetTypeList.apply(null, arguments);
  };

  var real__EggShell_GetVariantAttribute = asm["_EggShell_GetVariantAttribute"]; asm["_EggShell_GetVariantAttribute"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__EggShell_GetVariantAttribute.apply(null, arguments);
  };

  var real__EggShell_PeekMemory = asm["_EggShell_PeekMemory"]; asm["_EggShell_PeekMemory"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__EggShell_PeekMemory.apply(null, arguments);
  };

  var real__EggShell_PokeMemory = asm["_EggShell_PokeMemory"]; asm["_EggShell_PokeMemory"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__EggShell_PokeMemory.apply(null, arguments);
  };

  var real__EggShell_REPL = asm["_EggShell_REPL"]; asm["_EggShell_REPL"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__EggShell_REPL.apply(null, arguments);
  };

  var real__EggShell_ReadDouble = asm["_EggShell_ReadDouble"]; asm["_EggShell_ReadDouble"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__EggShell_ReadDouble.apply(null, arguments);
  };

  var real__EggShell_ReadValueString = asm["_EggShell_ReadValueString"]; asm["_EggShell_ReadValueString"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__EggShell_ReadValueString.apply(null, arguments);
  };

  var real__EggShell_ReinitializeToDefault = asm["_EggShell_ReinitializeToDefault"]; asm["_EggShell_ReinitializeToDefault"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__EggShell_ReinitializeToDefault.apply(null, arguments);
  };

  var real__EggShell_ResizeArray = asm["_EggShell_ResizeArray"]; asm["_EggShell_ResizeArray"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__EggShell_ResizeArray.apply(null, arguments);
  };

  var real__EggShell_SetVariantAttribute = asm["_EggShell_SetVariantAttribute"]; asm["_EggShell_SetVariantAttribute"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__EggShell_SetVariantAttribute.apply(null, arguments);
  };

  var real__EggShell_WriteDouble = asm["_EggShell_WriteDouble"]; asm["_EggShell_WriteDouble"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__EggShell_WriteDouble.apply(null, arguments);
  };

  var real__EggShell_WriteValueString = asm["_EggShell_WriteValueString"]; asm["_EggShell_WriteValueString"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__EggShell_WriteValueString.apply(null, arguments);
  };

  var real__JavaScriptInvoke_GetParameterDataRef = asm["_JavaScriptInvoke_GetParameterDataRef"]; asm["_JavaScriptInvoke_GetParameterDataRef"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__JavaScriptInvoke_GetParameterDataRef.apply(null, arguments);
  };

  var real__JavaScriptInvoke_GetParameterTypeRef = asm["_JavaScriptInvoke_GetParameterTypeRef"]; asm["_JavaScriptInvoke_GetParameterTypeRef"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__JavaScriptInvoke_GetParameterTypeRef.apply(null, arguments);
  };

  var real__OccurEvent = asm["_OccurEvent"]; asm["_OccurEvent"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__OccurEvent.apply(null, arguments);
  };

  var real__Occurrence_Set = asm["_Occurrence_Set"]; asm["_Occurrence_Set"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Occurrence_Set.apply(null, arguments);
  };

  var real__TypeManager_Define = asm["_TypeManager_Define"]; asm["_TypeManager_Define"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeManager_Define.apply(null, arguments);
  };

  var real__TypeManager_FindType = asm["_TypeManager_FindType"]; asm["_TypeManager_FindType"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeManager_FindType.apply(null, arguments);
  };

  var real__TypeRef_Alignment = asm["_TypeRef_Alignment"]; asm["_TypeRef_Alignment"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_Alignment.apply(null, arguments);
  };

  var real__TypeRef_BitEncoding = asm["_TypeRef_BitEncoding"]; asm["_TypeRef_BitEncoding"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_BitEncoding.apply(null, arguments);
  };

  var real__TypeRef_ElementName = asm["_TypeRef_ElementName"]; asm["_TypeRef_ElementName"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_ElementName.apply(null, arguments);
  };

  var real__TypeRef_ElementOffset = asm["_TypeRef_ElementOffset"]; asm["_TypeRef_ElementOffset"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_ElementOffset.apply(null, arguments);
  };

  var real__TypeRef_ElementUsageType = asm["_TypeRef_ElementUsageType"]; asm["_TypeRef_ElementUsageType"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_ElementUsageType.apply(null, arguments);
  };

  var real__TypeRef_GetSubElementByIndex = asm["_TypeRef_GetSubElementByIndex"]; asm["_TypeRef_GetSubElementByIndex"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_GetSubElementByIndex.apply(null, arguments);
  };

  var real__TypeRef_HasCustomDefault = asm["_TypeRef_HasCustomDefault"]; asm["_TypeRef_HasCustomDefault"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_HasCustomDefault.apply(null, arguments);
  };

  var real__TypeRef_IsAnalogWaveform = asm["_TypeRef_IsAnalogWaveform"]; asm["_TypeRef_IsAnalogWaveform"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_IsAnalogWaveform.apply(null, arguments);
  };

  var real__TypeRef_IsArray = asm["_TypeRef_IsArray"]; asm["_TypeRef_IsArray"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_IsArray.apply(null, arguments);
  };

  var real__TypeRef_IsBoolean = asm["_TypeRef_IsBoolean"]; asm["_TypeRef_IsBoolean"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_IsBoolean.apply(null, arguments);
  };

  var real__TypeRef_IsCluster = asm["_TypeRef_IsCluster"]; asm["_TypeRef_IsCluster"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_IsCluster.apply(null, arguments);
  };

  var real__TypeRef_IsComplex = asm["_TypeRef_IsComplex"]; asm["_TypeRef_IsComplex"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_IsComplex.apply(null, arguments);
  };

  var real__TypeRef_IsEnum = asm["_TypeRef_IsEnum"]; asm["_TypeRef_IsEnum"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_IsEnum.apply(null, arguments);
  };

  var real__TypeRef_IsFlat = asm["_TypeRef_IsFlat"]; asm["_TypeRef_IsFlat"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_IsFlat.apply(null, arguments);
  };

  var real__TypeRef_IsFloat = asm["_TypeRef_IsFloat"]; asm["_TypeRef_IsFloat"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_IsFloat.apply(null, arguments);
  };

  var real__TypeRef_IsInteger = asm["_TypeRef_IsInteger"]; asm["_TypeRef_IsInteger"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_IsInteger.apply(null, arguments);
  };

  var real__TypeRef_IsJavaScriptDynamicRefNum = asm["_TypeRef_IsJavaScriptDynamicRefNum"]; asm["_TypeRef_IsJavaScriptDynamicRefNum"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_IsJavaScriptDynamicRefNum.apply(null, arguments);
  };

  var real__TypeRef_IsJavaScriptStaticRefNum = asm["_TypeRef_IsJavaScriptStaticRefNum"]; asm["_TypeRef_IsJavaScriptStaticRefNum"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_IsJavaScriptStaticRefNum.apply(null, arguments);
  };

  var real__TypeRef_IsPath = asm["_TypeRef_IsPath"]; asm["_TypeRef_IsPath"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_IsPath.apply(null, arguments);
  };

  var real__TypeRef_IsSigned = asm["_TypeRef_IsSigned"]; asm["_TypeRef_IsSigned"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_IsSigned.apply(null, arguments);
  };

  var real__TypeRef_IsString = asm["_TypeRef_IsString"]; asm["_TypeRef_IsString"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_IsString.apply(null, arguments);
  };

  var real__TypeRef_IsTimestamp = asm["_TypeRef_IsTimestamp"]; asm["_TypeRef_IsTimestamp"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_IsTimestamp.apply(null, arguments);
  };

  var real__TypeRef_IsValid = asm["_TypeRef_IsValid"]; asm["_TypeRef_IsValid"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_IsValid.apply(null, arguments);
  };

  var real__TypeRef_Name = asm["_TypeRef_Name"]; asm["_TypeRef_Name"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_Name.apply(null, arguments);
  };

  var real__TypeRef_Next = asm["_TypeRef_Next"]; asm["_TypeRef_Next"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_Next.apply(null, arguments);
  };

  var real__TypeRef_PointerType = asm["_TypeRef_PointerType"]; asm["_TypeRef_PointerType"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_PointerType.apply(null, arguments);
  };

  var real__TypeRef_Rank = asm["_TypeRef_Rank"]; asm["_TypeRef_Rank"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_Rank.apply(null, arguments);
  };

  var real__TypeRef_SubElementCount = asm["_TypeRef_SubElementCount"]; asm["_TypeRef_SubElementCount"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_SubElementCount.apply(null, arguments);
  };

  var real__TypeRef_TopAQSize = asm["_TypeRef_TopAQSize"]; asm["_TypeRef_TopAQSize"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__TypeRef_TopAQSize.apply(null, arguments);
  };

  var real__Vireo_MaxExecWakeUpTime = asm["_Vireo_MaxExecWakeUpTime"]; asm["_Vireo_MaxExecWakeUpTime"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__Vireo_MaxExecWakeUpTime.apply(null, arguments);
  };

  var real___get_daylight = asm["__get_daylight"]; asm["__get_daylight"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real___get_daylight.apply(null, arguments);
  };

  var real___get_timezone = asm["__get_timezone"]; asm["__get_timezone"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real___get_timezone.apply(null, arguments);
  };

  var real___get_tzname = asm["__get_tzname"]; asm["__get_tzname"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real___get_tzname.apply(null, arguments);
  };

  var real__free = asm["_free"]; asm["_free"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__free.apply(null, arguments);
  };

  var real__llvm_maxnum_f32 = asm["_llvm_maxnum_f32"]; asm["_llvm_maxnum_f32"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__llvm_maxnum_f32.apply(null, arguments);
  };

  var real__llvm_maxnum_f64 = asm["_llvm_maxnum_f64"]; asm["_llvm_maxnum_f64"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__llvm_maxnum_f64.apply(null, arguments);
  };

  var real__llvm_rint_f64 = asm["_llvm_rint_f64"]; asm["_llvm_rint_f64"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__llvm_rint_f64.apply(null, arguments);
  };

  var real__malloc = asm["_malloc"]; asm["_malloc"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__malloc.apply(null, arguments);
  };

  var real__memmove = asm["_memmove"]; asm["_memmove"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__memmove.apply(null, arguments);
  };

  var real__sbrk = asm["_sbrk"]; asm["_sbrk"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real__sbrk.apply(null, arguments);
  };

  var real_establishStackSpace = asm["establishStackSpace"]; asm["establishStackSpace"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real_establishStackSpace.apply(null, arguments);
  };

  var real_globalCtors = asm["globalCtors"]; asm["globalCtors"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real_globalCtors.apply(null, arguments);
  };

  var real_stackAlloc = asm["stackAlloc"]; asm["stackAlloc"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real_stackAlloc.apply(null, arguments);
  };

  var real_stackRestore = asm["stackRestore"]; asm["stackRestore"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real_stackRestore.apply(null, arguments);
  };

  var real_stackSave = asm["stackSave"]; asm["stackSave"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return real_stackSave.apply(null, arguments);
  };
  Module["asm"] = asm;
  var _Data_GetArrayBegin = Module["_Data_GetArrayBegin"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_GetArrayBegin"].apply(null, arguments) };
  var _Data_GetArrayDimensions = Module["_Data_GetArrayDimensions"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_GetArrayDimensions"].apply(null, arguments) };
  var _Data_GetArrayLength = Module["_Data_GetArrayLength"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_GetArrayLength"].apply(null, arguments) };
  var _Data_GetLength = Module["_Data_GetLength"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_GetLength"].apply(null, arguments) };
  var _Data_GetStringBegin = Module["_Data_GetStringBegin"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_GetStringBegin"].apply(null, arguments) };
  var _Data_GetStringLength = Module["_Data_GetStringLength"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_GetStringLength"].apply(null, arguments) };
  var _Data_Length = Module["_Data_Length"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_Length"].apply(null, arguments) };
  var _Data_RawBlockSize = Module["_Data_RawBlockSize"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_RawBlockSize"].apply(null, arguments) };
  var _Data_RawPointerFromOffset = Module["_Data_RawPointerFromOffset"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_RawPointerFromOffset"].apply(null, arguments) };
  var _Data_Read1Byte = Module["_Data_Read1Byte"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_Read1Byte"].apply(null, arguments) };
  var _Data_Read2Bytes = Module["_Data_Read2Bytes"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_Read2Bytes"].apply(null, arguments) };
  var _Data_Read4Bytes = Module["_Data_Read4Bytes"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_Read4Bytes"].apply(null, arguments) };
  var _Data_Read8Bytes = Module["_Data_Read8Bytes"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_Read8Bytes"].apply(null, arguments) };
  var _Data_ReadBytes = Module["_Data_ReadBytes"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_ReadBytes"].apply(null, arguments) };
  var _Data_ReadPointer = Module["_Data_ReadPointer"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_ReadPointer"].apply(null, arguments) };
  var _Data_Resize1D = Module["_Data_Resize1D"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_Resize1D"].apply(null, arguments) };
  var _Data_ResizeDimensions = Module["_Data_ResizeDimensions"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_ResizeDimensions"].apply(null, arguments) };
  var _Data_Type = Module["_Data_Type"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_Type"].apply(null, arguments) };
  var _Data_Write1Byte = Module["_Data_Write1Byte"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_Write1Byte"].apply(null, arguments) };
  var _Data_Write2Bytes = Module["_Data_Write2Bytes"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_Write2Bytes"].apply(null, arguments) };
  var _Data_Write4Bytes = Module["_Data_Write4Bytes"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_Write4Bytes"].apply(null, arguments) };
  var _Data_Write8Bytes = Module["_Data_Write8Bytes"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_Write8Bytes"].apply(null, arguments) };
  var _Data_WriteBytes = Module["_Data_WriteBytes"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_WriteBytes"].apply(null, arguments) };
  var _Data_WritePointer = Module["_Data_WritePointer"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Data_WritePointer"].apply(null, arguments) };
  var _EggShell_AllocateData = Module["_EggShell_AllocateData"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_EggShell_AllocateData"].apply(null, arguments) };
  var _EggShell_Create = Module["_EggShell_Create"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_EggShell_Create"].apply(null, arguments) };
  var _EggShell_DeallocateData = Module["_EggShell_DeallocateData"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_EggShell_DeallocateData"].apply(null, arguments) };
  var _EggShell_Delete = Module["_EggShell_Delete"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_EggShell_Delete"].apply(null, arguments) };
  var _EggShell_DeleteVariantAttribute = Module["_EggShell_DeleteVariantAttribute"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_EggShell_DeleteVariantAttribute"].apply(null, arguments) };
  var _EggShell_ExecuteSlices = Module["_EggShell_ExecuteSlices"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_EggShell_ExecuteSlices"].apply(null, arguments) };
  var _EggShell_FindSubValue = Module["_EggShell_FindSubValue"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_EggShell_FindSubValue"].apply(null, arguments) };
  var _EggShell_FindValue = Module["_EggShell_FindValue"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_EggShell_FindValue"].apply(null, arguments) };
  var _EggShell_GetTypeList = Module["_EggShell_GetTypeList"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_EggShell_GetTypeList"].apply(null, arguments) };
  var _EggShell_GetVariantAttribute = Module["_EggShell_GetVariantAttribute"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_EggShell_GetVariantAttribute"].apply(null, arguments) };
  var _EggShell_PeekMemory = Module["_EggShell_PeekMemory"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_EggShell_PeekMemory"].apply(null, arguments) };
  var _EggShell_PokeMemory = Module["_EggShell_PokeMemory"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_EggShell_PokeMemory"].apply(null, arguments) };
  var _EggShell_REPL = Module["_EggShell_REPL"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_EggShell_REPL"].apply(null, arguments) };
  var _EggShell_ReadDouble = Module["_EggShell_ReadDouble"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_EggShell_ReadDouble"].apply(null, arguments) };
  var _EggShell_ReadValueString = Module["_EggShell_ReadValueString"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_EggShell_ReadValueString"].apply(null, arguments) };
  var _EggShell_ReinitializeToDefault = Module["_EggShell_ReinitializeToDefault"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_EggShell_ReinitializeToDefault"].apply(null, arguments) };
  var _EggShell_ResizeArray = Module["_EggShell_ResizeArray"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_EggShell_ResizeArray"].apply(null, arguments) };
  var _EggShell_SetVariantAttribute = Module["_EggShell_SetVariantAttribute"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_EggShell_SetVariantAttribute"].apply(null, arguments) };
  var _EggShell_WriteDouble = Module["_EggShell_WriteDouble"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_EggShell_WriteDouble"].apply(null, arguments) };
  var _EggShell_WriteValueString = Module["_EggShell_WriteValueString"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_EggShell_WriteValueString"].apply(null, arguments) };
  var _JavaScriptInvoke_GetParameterDataRef = Module["_JavaScriptInvoke_GetParameterDataRef"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_JavaScriptInvoke_GetParameterDataRef"].apply(null, arguments) };
  var _JavaScriptInvoke_GetParameterTypeRef = Module["_JavaScriptInvoke_GetParameterTypeRef"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_JavaScriptInvoke_GetParameterTypeRef"].apply(null, arguments) };
  var _OccurEvent = Module["_OccurEvent"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_OccurEvent"].apply(null, arguments) };
  var _Occurrence_Set = Module["_Occurrence_Set"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Occurrence_Set"].apply(null, arguments) };
  var _TypeManager_Define = Module["_TypeManager_Define"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeManager_Define"].apply(null, arguments) };
  var _TypeManager_FindType = Module["_TypeManager_FindType"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeManager_FindType"].apply(null, arguments) };
  var _TypeRef_Alignment = Module["_TypeRef_Alignment"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_Alignment"].apply(null, arguments) };
  var _TypeRef_BitEncoding = Module["_TypeRef_BitEncoding"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_BitEncoding"].apply(null, arguments) };
  var _TypeRef_ElementName = Module["_TypeRef_ElementName"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_ElementName"].apply(null, arguments) };
  var _TypeRef_ElementOffset = Module["_TypeRef_ElementOffset"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_ElementOffset"].apply(null, arguments) };
  var _TypeRef_ElementUsageType = Module["_TypeRef_ElementUsageType"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_ElementUsageType"].apply(null, arguments) };
  var _TypeRef_GetSubElementByIndex = Module["_TypeRef_GetSubElementByIndex"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_GetSubElementByIndex"].apply(null, arguments) };
  var _TypeRef_HasCustomDefault = Module["_TypeRef_HasCustomDefault"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_HasCustomDefault"].apply(null, arguments) };
  var _TypeRef_IsAnalogWaveform = Module["_TypeRef_IsAnalogWaveform"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_IsAnalogWaveform"].apply(null, arguments) };
  var _TypeRef_IsArray = Module["_TypeRef_IsArray"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_IsArray"].apply(null, arguments) };
  var _TypeRef_IsBoolean = Module["_TypeRef_IsBoolean"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_IsBoolean"].apply(null, arguments) };
  var _TypeRef_IsCluster = Module["_TypeRef_IsCluster"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_IsCluster"].apply(null, arguments) };
  var _TypeRef_IsComplex = Module["_TypeRef_IsComplex"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_IsComplex"].apply(null, arguments) };
  var _TypeRef_IsEnum = Module["_TypeRef_IsEnum"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_IsEnum"].apply(null, arguments) };
  var _TypeRef_IsFlat = Module["_TypeRef_IsFlat"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_IsFlat"].apply(null, arguments) };
  var _TypeRef_IsFloat = Module["_TypeRef_IsFloat"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_IsFloat"].apply(null, arguments) };
  var _TypeRef_IsInteger = Module["_TypeRef_IsInteger"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_IsInteger"].apply(null, arguments) };
  var _TypeRef_IsJavaScriptDynamicRefNum = Module["_TypeRef_IsJavaScriptDynamicRefNum"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_IsJavaScriptDynamicRefNum"].apply(null, arguments) };
  var _TypeRef_IsJavaScriptStaticRefNum = Module["_TypeRef_IsJavaScriptStaticRefNum"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_IsJavaScriptStaticRefNum"].apply(null, arguments) };
  var _TypeRef_IsPath = Module["_TypeRef_IsPath"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_IsPath"].apply(null, arguments) };
  var _TypeRef_IsSigned = Module["_TypeRef_IsSigned"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_IsSigned"].apply(null, arguments) };
  var _TypeRef_IsString = Module["_TypeRef_IsString"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_IsString"].apply(null, arguments) };
  var _TypeRef_IsTimestamp = Module["_TypeRef_IsTimestamp"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_IsTimestamp"].apply(null, arguments) };
  var _TypeRef_IsValid = Module["_TypeRef_IsValid"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_IsValid"].apply(null, arguments) };
  var _TypeRef_Name = Module["_TypeRef_Name"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_Name"].apply(null, arguments) };
  var _TypeRef_Next = Module["_TypeRef_Next"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_Next"].apply(null, arguments) };
  var _TypeRef_PointerType = Module["_TypeRef_PointerType"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_PointerType"].apply(null, arguments) };
  var _TypeRef_Rank = Module["_TypeRef_Rank"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_Rank"].apply(null, arguments) };
  var _TypeRef_SubElementCount = Module["_TypeRef_SubElementCount"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_SubElementCount"].apply(null, arguments) };
  var _TypeRef_TopAQSize = Module["_TypeRef_TopAQSize"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_TypeRef_TopAQSize"].apply(null, arguments) };
  var _Vireo_MaxExecWakeUpTime = Module["_Vireo_MaxExecWakeUpTime"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_Vireo_MaxExecWakeUpTime"].apply(null, arguments) };
  var __get_daylight = Module["__get_daylight"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["__get_daylight"].apply(null, arguments) };
  var __get_timezone = Module["__get_timezone"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["__get_timezone"].apply(null, arguments) };
  var __get_tzname = Module["__get_tzname"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["__get_tzname"].apply(null, arguments) };
  var _emscripten_replace_memory = Module["_emscripten_replace_memory"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_emscripten_replace_memory"].apply(null, arguments) };
  var _free = Module["_free"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_free"].apply(null, arguments) };
  var _llvm_maxnum_f32 = Module["_llvm_maxnum_f32"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_llvm_maxnum_f32"].apply(null, arguments) };
  var _llvm_maxnum_f64 = Module["_llvm_maxnum_f64"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_llvm_maxnum_f64"].apply(null, arguments) };
  var _llvm_rint_f64 = Module["_llvm_rint_f64"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_llvm_rint_f64"].apply(null, arguments) };
  var _malloc = Module["_malloc"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_malloc"].apply(null, arguments) };
  var _memcpy = Module["_memcpy"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_memcpy"].apply(null, arguments) };
  var _memmove = Module["_memmove"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_memmove"].apply(null, arguments) };
  var _memset = Module["_memset"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_memset"].apply(null, arguments) };
  var _sbrk = Module["_sbrk"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["_sbrk"].apply(null, arguments) };
  var establishStackSpace = Module["establishStackSpace"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["establishStackSpace"].apply(null, arguments) };
  var globalCtors = Module["globalCtors"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["globalCtors"].apply(null, arguments) };
  var stackAlloc = Module["stackAlloc"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["stackAlloc"].apply(null, arguments) };
  var stackRestore = Module["stackRestore"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["stackRestore"].apply(null, arguments) };
  var stackSave = Module["stackSave"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["stackSave"].apply(null, arguments) };
  var dynCall_ii = Module["dynCall_ii"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["dynCall_ii"].apply(null, arguments) };
  var dynCall_iii = Module["dynCall_iii"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["dynCall_iii"].apply(null, arguments) };
  var dynCall_iiii = Module["dynCall_iiii"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["dynCall_iiii"].apply(null, arguments) };
  var dynCall_iiiii = Module["dynCall_iiiii"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["dynCall_iiiii"].apply(null, arguments) };
  var dynCall_iiiiii = Module["dynCall_iiiiii"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["dynCall_iiiiii"].apply(null, arguments) };
  var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["dynCall_iiiiiii"].apply(null, arguments) };
  var dynCall_v = Module["dynCall_v"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["dynCall_v"].apply(null, arguments) };
  var dynCall_vi = Module["dynCall_vi"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["dynCall_vi"].apply(null, arguments) };
  var dynCall_vii = Module["dynCall_vii"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["dynCall_vii"].apply(null, arguments) };
  var dynCall_viiii = Module["dynCall_viiii"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["dynCall_viiii"].apply(null, arguments) };
  var dynCall_viiiii = Module["dynCall_viiiii"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["dynCall_viiiii"].apply(null, arguments) };
  var dynCall_viiiiii = Module["dynCall_viiiiii"] = function() {
    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
    return Module["asm"]["dynCall_viiiiii"].apply(null, arguments) };



  // === Auto-generated postamble setup entry stuff ===

  Module['asm'] = asm;

  if (!Module["intArrayFromString"]) Module["intArrayFromString"] = function() { abort("'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["intArrayToString"]) Module["intArrayToString"] = function() { abort("'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["ccall"]) Module["ccall"] = function() { abort("'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["cwrap"]) Module["cwrap"] = function() { abort("'cwrap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  Module["setValue"] = setValue;
  Module["getValue"] = getValue;
  if (!Module["allocate"]) Module["allocate"] = function() { abort("'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["getMemory"]) Module["getMemory"] = function() { abort("'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"); };
  if (!Module["AsciiToString"]) Module["AsciiToString"] = function() { abort("'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["stringToAscii"]) Module["stringToAscii"] = function() { abort("'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["UTF8ArrayToString"]) Module["UTF8ArrayToString"] = function() { abort("'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["UTF8ToString"]) Module["UTF8ToString"] = function() { abort("'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["stringToUTF8Array"]) Module["stringToUTF8Array"] = function() { abort("'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  Module["stringToUTF8"] = stringToUTF8;
  Module["lengthBytesUTF8"] = lengthBytesUTF8;
  if (!Module["UTF16ToString"]) Module["UTF16ToString"] = function() { abort("'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["stringToUTF16"]) Module["stringToUTF16"] = function() { abort("'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["lengthBytesUTF16"]) Module["lengthBytesUTF16"] = function() { abort("'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["UTF32ToString"]) Module["UTF32ToString"] = function() { abort("'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["stringToUTF32"]) Module["stringToUTF32"] = function() { abort("'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["lengthBytesUTF32"]) Module["lengthBytesUTF32"] = function() { abort("'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["allocateUTF8"]) Module["allocateUTF8"] = function() { abort("'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["stackTrace"]) Module["stackTrace"] = function() { abort("'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["addOnPreRun"]) Module["addOnPreRun"] = function() { abort("'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["addOnInit"]) Module["addOnInit"] = function() { abort("'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["addOnPreMain"]) Module["addOnPreMain"] = function() { abort("'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["addOnExit"]) Module["addOnExit"] = function() { abort("'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["addOnPostRun"]) Module["addOnPostRun"] = function() { abort("'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["writeStringToMemory"]) Module["writeStringToMemory"] = function() { abort("'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["writeArrayToMemory"]) Module["writeArrayToMemory"] = function() { abort("'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["writeAsciiToMemory"]) Module["writeAsciiToMemory"] = function() { abort("'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["addRunDependency"]) Module["addRunDependency"] = function() { abort("'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"); };
  if (!Module["removeRunDependency"]) Module["removeRunDependency"] = function() { abort("'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"); };
  if (!Module["ENV"]) Module["ENV"] = function() { abort("'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["FS"]) Module["FS"] = function() { abort("'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["FS_createFolder"]) Module["FS_createFolder"] = function() { abort("'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"); };
  if (!Module["FS_createPath"]) Module["FS_createPath"] = function() { abort("'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"); };
  if (!Module["FS_createDataFile"]) Module["FS_createDataFile"] = function() { abort("'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"); };
  if (!Module["FS_createPreloadedFile"]) Module["FS_createPreloadedFile"] = function() { abort("'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"); };
  if (!Module["FS_createLazyFile"]) Module["FS_createLazyFile"] = function() { abort("'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"); };
  if (!Module["FS_createLink"]) Module["FS_createLink"] = function() { abort("'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"); };
  if (!Module["FS_createDevice"]) Module["FS_createDevice"] = function() { abort("'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"); };
  if (!Module["FS_unlink"]) Module["FS_unlink"] = function() { abort("'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"); };
  if (!Module["GL"]) Module["GL"] = function() { abort("'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["dynamicAlloc"]) Module["dynamicAlloc"] = function() { abort("'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["warnOnce"]) Module["warnOnce"] = function() { abort("'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["loadDynamicLibrary"]) Module["loadDynamicLibrary"] = function() { abort("'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["loadWebAssemblyModule"]) Module["loadWebAssemblyModule"] = function() { abort("'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["getLEB"]) Module["getLEB"] = function() { abort("'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["getFunctionTables"]) Module["getFunctionTables"] = function() { abort("'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["alignFunctionTables"]) Module["alignFunctionTables"] = function() { abort("'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["registerFunctions"]) Module["registerFunctions"] = function() { abort("'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["addFunction"]) Module["addFunction"] = function() { abort("'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["removeFunction"]) Module["removeFunction"] = function() { abort("'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["getFuncWrapper"]) Module["getFuncWrapper"] = function() { abort("'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["prettyPrint"]) Module["prettyPrint"] = function() { abort("'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["makeBigInt"]) Module["makeBigInt"] = function() { abort("'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["dynCall"]) Module["dynCall"] = function() { abort("'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["getCompilerSetting"]) Module["getCompilerSetting"] = function() { abort("'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  Module["stackSave"] = stackSave;
  Module["stackRestore"] = stackRestore;
  Module["stackAlloc"] = stackAlloc;
  if (!Module["establishStackSpace"]) Module["establishStackSpace"] = function() { abort("'establishStackSpace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["print"]) Module["print"] = function() { abort("'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["printErr"]) Module["printErr"] = function() { abort("'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["getTempRet0"]) Module["getTempRet0"] = function() { abort("'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["setTempRet0"]) Module["setTempRet0"] = function() { abort("'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["Pointer_stringify"]) Module["Pointer_stringify"] = function() { abort("'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["writeStackCookie"]) Module["writeStackCookie"] = function() { abort("'writeStackCookie' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["checkStackCookie"]) Module["checkStackCookie"] = function() { abort("'checkStackCookie' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };
  if (!Module["abortStackOverflow"]) Module["abortStackOverflow"] = function() { abort("'abortStackOverflow' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); };if (!Module["ALLOC_NORMAL"]) Object.defineProperty(Module, "ALLOC_NORMAL", { get: function() { abort("'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); } });
  if (!Module["ALLOC_STACK"]) Object.defineProperty(Module, "ALLOC_STACK", { get: function() { abort("'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); } });
  if (!Module["ALLOC_DYNAMIC"]) Object.defineProperty(Module, "ALLOC_DYNAMIC", { get: function() { abort("'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); } });
  if (!Module["ALLOC_NONE"]) Object.defineProperty(Module, "ALLOC_NONE", { get: function() { abort("'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"); } });



  // Modularize mode returns a function, which can be called to
  // create instances. The instances provide a then() method,
  // must like a Promise, that receives a callback. The callback
  // is called when the module is ready to run, with the module
  // as a parameter. (Like a Promise, it also returns the module
  // so you can use the output of .then(..)).
  Module['then'] = function(func) {
    // We may already be ready to run code at this time. if
    // so, just queue a call to the callback.
    if (Module['calledRun']) {
      func(Module);
    } else {
      // we are not ready to call then() yet. we must call it
      // at the same time we would call onRuntimeInitialized.
      var old = Module['onRuntimeInitialized'];
      Module['onRuntimeInitialized'] = function() {
        if (old) old();
        func(Module);
      };
    }
    return Module;
  };

  /**
   * @constructor
   * @extends {Error}
   * @this {ExitStatus}
   */
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = "Program terminated with exit(" + status + ")";
    this.status = status;
  }ExitStatus.prototype = new Error();
  ExitStatus.prototype.constructor = ExitStatus;

  dependenciesFulfilled = function runCaller() {
    // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
    if (!Module['calledRun']) run();
    if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
  };





  /** @type {function(Array=)} */
  function run(args) {
    args = args || Module['arguments'];

    if (runDependencies > 0) {
      return;
    }

    writeStackCookie();

    preRun();

    if (runDependencies > 0) return; // a preRun added a dependency, run will be called later
    if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame

    function doRun() {
      if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening
      Module['calledRun'] = true;

      if (ABORT) return;

      ensureInitRuntime();

      preMain();

      if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

      assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');

      postRun();
    }

    if (Module['setStatus']) {
      Module['setStatus']('Running...');
      setTimeout(function() {
        setTimeout(function() {
          Module['setStatus']('');
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
    checkStackCookie();
  }
  Module['run'] = run;

  function checkUnflushedContent() {
    // Compiler settings do not allow exiting the runtime, so flushing
    // the streams is not possible. but in ASSERTIONS mode we check
    // if there was something to flush, and if so tell the user they
    // should request that the runtime be exitable.
    // Normally we would not even include flush() at all, but in ASSERTIONS
    // builds we do so just for this check, and here we see if there is any
    // content to flush, that is, we check if there would have been
    // something a non-ASSERTIONS build would have not seen.
    // How we flush the streams depends on whether we are in FILESYSTEM=0
    // mode (which has its own special function for this; otherwise, all
    // the code is inside libc)
    var print = out;
    var printErr = err;
    var has = false;
    out = err = function(x) {
      has = true;
    };
    try { // it doesn't matter if it fails
      var flush = flush_NO_FILESYSTEM;
      if (flush) flush(0);
    } catch(e) {}
    out = print;
    err = printErr;
    if (has) {
      warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');
      warnOnce('(this may also be due to not including full filesystem support - try building with -s FORCE_FILESYSTEM=1)');
    }
  }

  function exit(status, implicit) {
    checkUnflushedContent();

    // if this is just main exit-ing implicitly, and the status is 0, then we
    // don't need to do anything here and can just leave. if the status is
    // non-zero, though, then we need to report it.
    // (we may have warned about this earlier, if a situation justifies doing so)
    if (implicit && Module['noExitRuntime'] && status === 0) {
      return;
    }

    if (Module['noExitRuntime']) {
      // if exit() was called, we may warn the user if the runtime isn't actually being shut down
      if (!implicit) {
        err('exit(' + status + ') called, but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)');
      }
    } else {

      ABORT = true;

      exitRuntime();

      if (Module['onExit']) Module['onExit'](status);
    }

    Module['quit'](status, new ExitStatus(status));
  }

  var abortDecorators = [];

  function abort(what) {
    if (Module['onAbort']) {
      Module['onAbort'](what);
    }

    if (what !== undefined) {
      out(what);
      err(what);
      what = JSON.stringify(what);
    } else {
      what = '';
    }

    ABORT = true;

    var extra = '';
    var output = 'abort(' + what + ') at ' + stackTrace() + extra;
    if (abortDecorators) {
      abortDecorators.forEach(function(decorator) {
        output = decorator(output, what);
      });
    }
    throw output;
  }
  Module['abort'] = abort;

  if (Module['preInit']) {
    if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
    while (Module['preInit'].length > 0) {
      Module['preInit'].pop()();
    }
  }


    Module["noExitRuntime"] = true;

  run();





  // {{MODULE_ADDITIONS}}




  // Emscripten code ends here
  Module.vireopostjs = function () {
      // intentionally left blank
  };



    return VireoCreateCoreModule
  }
  );
  })();

  var assignCoreHelpers;
  (function () {
      // Static Private Variables (all vireo instances)
      // None

      // Vireo Core Mixin Function
      assignCoreHelpers = function (Module, publicAPI) {
          Module.coreHelpers = {};
          publicAPI.coreHelpers = {};

          // Private Instance Variables (per vireo instance)
          var fpSync = function (/* fpIdStr*/) {
              // Dummy noop function user can replace by using eggShell.setFPSyncFunction
          };

          var CODES = {
              NO_ERROR: 0
          };

          // Exported functions
          Module.coreHelpers.jsExecutionContextFPSync = function (fpStringPointer) {
              var fpString = Module.eggShell.dataReadString(fpStringPointer);
              fpSync(fpString);
          };

          Module.coreHelpers.jsSystemLogging_WriteMessageUTF8 = function (
              messageTypeRef, messageDataRef,
              severityTypeRef, severityDataRef) {
              var messageValueRef = Module.eggShell.createValueRef(messageTypeRef, messageDataRef);
              var severityValueRef = Module.eggShell.createValueRef(severityTypeRef, severityDataRef);
              var message = Module.eggShell.readString(messageValueRef);
              var severity = Module.eggShell.readDouble(severityValueRef);
              switch (severity) {
              case 0:
                  console.error(message);
                  break;
              case 1:
                  console.warn(message);
                  break;
              case 2:
                  console.info(message);
                  break;
              default:
                  console.log(message);
                  break;
              }
          };

          publicAPI.coreHelpers.setFPSyncFunction = function (fn) {
              if (typeof fn !== 'function') {
                  throw new Error('FPSync must be a callable function');
              }

              fpSync = fn;
          };

          // Returns the length of a C string (excluding null terminator)
          Module.coreHelpers.findCStringLength = function (u8Array, startIndex) {
              var i,
                  end = u8Array.length;

              for (i = startIndex; i < end; i += 1) {
                  if (u8Array[i] === 0) {
                      return i - startIndex;
                  }
              }
              return -1;
          };

          // WARNING: DO NOT USE UNLESS STACK SAVED FIRST
          Module.coreHelpers.writeJSStringToStack = function (str) {
              /* eslint-disable no-bitwise */
              // See https://github.com/kripken/emscripten/blob/6dc4ac5f9e4d8484e273e4dcc554f809738cedd6/src/preamble.js#L155
              // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
              var strMaxStackLength = (str.length << 2) + 1;
              var strStackPointer = Module.stackAlloc(strMaxStackLength);
              Module.stringToUTF8(str, strStackPointer, strMaxStackLength);
              return strStackPointer;
          };

          // WARNING: CALLER IS RESPONSIBLE TO FREE THE RETURNED POINTER
          Module.coreHelpers.writeJSStringToHeap = function (str) {
              /* eslint-disable no-bitwise */
              // See https://github.com/kripken/emscripten/blob/6dc4ac5f9e4d8484e273e4dcc554f809738cedd6/src/preamble.js#L155
              // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
              var strMaxHeapLength = (str.length << 2) + 1;
              var strHeapPointer = Module._malloc(strMaxHeapLength);
              Module.stringToUTF8(str, strHeapPointer, strMaxHeapLength);
              return strHeapPointer;
          };

          // Takes Vireo Strings (non-safe UTF-8 encoded byte buffers with known length) and returns JS strings (non-safe UTF-16 encoded character arrays)
          // Any bytes that are not part of a valid UTF-8 byte sequence are replaced with the Unicode Replacement Character
          // In addition, code points represented as overlong UTF-8 byte sequences have the byte sequence replaced with an equal number of Unicode Replacement Characters
          // This code does not validate for UTF-8 safety, only for UTF-8 byte sequence structure.
          // As such, the following UTF-8 safety checks are not performed: forbidding unicode reserved blocks, forbidding internal use blocks, forbidding the surrogate code point range in UTF-8 byte sequences, etc.
          Module.coreHelpers.sizedUtf8ArrayToJSString = function (u8Array, startIndex, length) {
              /* eslint-disable no-continue, no-plusplus, no-bitwise */
              /* eslint complexity: ["error", 40]*/
              var REPLACEMENT_CODEPOINT = '\uFFFD';
              var REPLACEMENT_CODEPOINT_LENGTH_2 = '\uFFFD\uFFFD';
              var REPLACEMENT_CODEPOINT_LENGTH_3 = '\uFFFD\uFFFD\uFFFD';
              var REPLACEMENT_CODEPOINT_LENGTH_4 = '\uFFFD\uFFFD\uFFFD\uFFFD';
              var u0, u1, u2, u3;
              var idx = startIndex;
              var endIndex = startIndex + length;
              endIndex = endIndex > u8Array.length ? u8Array.length : endIndex;
              var str = '';
              if (length <= 0) {
                  return str;
              }
              while (true) {
                  // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
                  // This algorithm was adapted from the emscripten source: https://github.com/kripken/emscripten/blob/6dc4ac5f9e4d8484e273e4dcc554f809738cedd6/src/preamble.js#L543

                  // Algorithm based on the following UTF-8 byte structure:
                  // [1 byte] 0xxx xxxx
                  // [2 byte] 110x xxxx   10xx xxxx
                  // [3 byte] 1110 xxxx   10xx xxxx   10xx xxxx
                  // [4 byte] 1111 0xxx   10xx xxxx   10xx xxxx   10xx xxxx
                  // Note: The [4 byte] sequence can numerically encode a 21-bit number representing values up to U+1FFFFF however the last valid Unicode code point is U+10FFFF
                  // Note: Numerically a character must be represented with the minimum number of bytes in a UTF-8 byte sequence as possible. For example NULL (U+0000) can be represented as
                  // [1 byte] with 7-bits of zero, [2 bytes] with 11 bits of zero, [3 bytes] with 16 bits of zero, or [4 bytes] with 21 bits of zero.
                  // Using a longer byte sequence than necessary is referred to as overlong encoding and is an invalid UTF-8 byte sequence.

                  // Continue as long as there are bytes to process
                  if (idx >= endIndex) {
                      return str;
                  }

                  // [1 byte] sequences take the value as is and continue
                  u0 = u8Array[idx++];
                  if (!(u0 & 0x80)) {
                      str += String.fromCharCode(u0);
                      continue;
                  }

                  // Look ahead to validate the UTF-8 structure for [2 byte] to [4 byte] representations
                  // For invalid UTF-8 byte structures replace the current byte and continue
                  // Note: at this point idx refers to the first byte after u0
                  if ((u0 & 0xE0) === 0xC0) {
                      if (idx >= endIndex || (u8Array[idx] & 0xC0) !== 0x80) {
                          str += REPLACEMENT_CODEPOINT;
                          continue;
                      }
                  } else if ((u0 & 0xF0) === 0xE0) {
                      if (idx + 1 >= endIndex || (u8Array[idx] & 0xC0) !== 0x80 || (u8Array[idx + 1] & 0xC0) !== 0x80) {
                          str += REPLACEMENT_CODEPOINT;
                          continue;
                      }
                  } else if ((u0 & 0xF8) === 0xF0) {
                      if (idx + 2 >= endIndex || (u8Array[idx] & 0xC0) !== 0x80 || (u8Array[idx + 1] & 0xC0) !== 0x80 || (u8Array[idx + 2] & 0xC0) !== 0x80) {
                          str += REPLACEMENT_CODEPOINT;
                          continue;
                      }
                  } else {
                      // u0 byte says multi-byte utf-8 encoding but is invalid so replace this byte and move on
                      str += REPLACEMENT_CODEPOINT;
                      continue;
                  }

                  // At this point UTF-8 byte sequence following byte u0 is valid

                  // [2 byte] sequences are always below the UTF-16 surrogate pair range so take the value and continue
                  // Note: The first code point in a [2 byte] sequence is U+0080, so any code point less than that is overlong and is replaced
                  u1 = u8Array[idx++] & 63;
                  if ((u0 & 0xE0) === 0xC0) {
                      u0 = ((u0 & 31) << 6) | u1;
                      if (u0 < 0x80) {
                          str += REPLACEMENT_CODEPOINT_LENGTH_2;
                          continue;
                      }
                      str += String.fromCharCode(u0);
                      continue;
                  }

                  // [3 byte] and [4 byte] sequences may require UTF-16 surrogate pair so create point but do not append to the string until checking
                  // Note: The first code point in a [3 byte] sequence is U+0800, so any code point less than that is overlong and is replaced
                  // Note: The first code point in a [4 byte] sequence is U+10000, so any code point less than that is overlong and is replaced
                  u2 = u8Array[idx++] & 63;
                  if ((u0 & 0xF0) === 0xE0) {
                      u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
                      if (u0 < 0x800) {
                          str += REPLACEMENT_CODEPOINT_LENGTH_3;
                          continue;
                      }
                  } else {
                      u3 = u8Array[idx++] & 63;
                      u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;
                      if (u0 < 0x10000) {
                          str += REPLACEMENT_CODEPOINT_LENGTH_4;
                          continue;
                      }
                  }

                  // Codepoints in the range U+10000 to U+10FFFF must be encoded as a UTF-16 surrogate pair
                  // A surrogate pair is a high surrogate UTF-16 character with range 0xD800-0xDBFF and a low surrogate UTF-16 character with range 0xDC00-0xDFFF
                  // The algorithm for encoding a codepoint as a UTF-16 surrogate pair is available here: https://en.wikipedia.org/wiki/UTF-16#U.2B10000_to_U.2B10FFFF
                  // Note: Code points less than U+10000 are saved as a single UTF-16 character
                  // Note: Code points >= U+10000 and <= 0x10FFFF are saved as two UTF-16 characters using the surrogate pair algorithm
                  // Note: Code points greater than U+10FFFF are outside the Unicode range and replaced with the Unicode Replacement Character
                  if (u0 < 0x10000) {
                      str += String.fromCharCode(u0);
                  } else if (u0 <= 0x10FFFF) {
                      var ch = u0 - 0x10000;
                      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
                  } else {
                      str += REPLACEMENT_CODEPOINT_LENGTH_4;
                  }
              }
          };

          // Source adapted from https://github.com/kripken/emscripten/blob/bd050e64bb0d9952df1344b8ea9356252328ad83/src/preamble.js#L488
          // Copies the given Javascript String object 'str' to the given byte array at address 'startIndex' encoded in UTF8 form.
          // Use the function lengthBytesUTF8 to compute the exact number of bytes that this function will write.
          // Parameters:
          //   str: the Javascript string to copy.
          //   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.
          //   startIndex: The starting offset in the array to begin the copying.
          //   maxBytesToWrite: The maximum number of bytes this function can write to the array. maxBytesToWrite=0 does not write any bytes to the output.
          // Returns the number of bytes written.
          Module.coreHelpers.jsStringToSizedUTF8Array = function (str, outU8Array, startIndex, maxBytesToWrite) {
              /* eslint-disable no-plusplus, id-length */
              // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
              if (!(maxBytesToWrite > 0)) {
                  return 0;
              }
              var outIdx = startIndex;
              var endIdx = outIdx + maxBytesToWrite;
              for (var i = 0; i < str.length; ++i) {
                  // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
                  // See http://unicode.org/faq/utf_bom.html#utf16-3
                  // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
                  var u = str.charCodeAt(i); // possibly a lead surrogate
                  if (u >= 0xD800 && u <= 0xDFFF) {
                      u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
                  }
                  if (u <= 0x7F) {
                      if (outIdx >= endIdx) {
                          break;
                      }
                      outU8Array[outIdx++] = u;
                  } else if (u <= 0x7FF) {
                      if (outIdx + 1 >= endIdx) {
                          break;
                      }
                      outU8Array[outIdx++] = 0xC0 | (u >> 6);
                      outU8Array[outIdx++] = 0x80 | (u & 63);
                  } else if (u <= 0xFFFF) {
                      if (outIdx + 2 >= endIdx) {
                          break;
                      }
                      outU8Array[outIdx++] = 0xE0 | (u >> 12);
                      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
                      outU8Array[outIdx++] = 0x80 | (u & 63);
                  } else if (u <= 0x1FFFFF) {
                      if (outIdx + 3 >= endIdx) {
                          break;
                      }
                      outU8Array[outIdx++] = 0xF0 | (u >> 18);
                      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
                      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
                      outU8Array[outIdx++] = 0x80 | (u & 63);
                  } else if (u <= 0x3FFFFFF) {
                      if (outIdx + 4 >= endIdx) {
                          break;
                      }
                      outU8Array[outIdx++] = 0xF8 | (u >> 24);
                      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);
                      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
                      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
                      outU8Array[outIdx++] = 0x80 | (u & 63);
                  } else {
                      if (outIdx + 5 >= endIdx) {
                          break;
                      }
                      outU8Array[outIdx++] = 0xFC | (u >> 30);
                      outU8Array[outIdx++] = 0x80 | ((u >> 24) & 63);
                      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);
                      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
                      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
                      outU8Array[outIdx++] = 0x80 | (u & 63);
                  }
              }
              return outIdx - startIndex;
          };

          var writeNewError = function (errorValueRef, newError) {
              Module.eggShell.writeDouble(Module.eggShell.findSubValueRef(errorValueRef, 'status'), newError.status ? 1 : 0);
              Module.eggShell.writeDouble(Module.eggShell.findSubValueRef(errorValueRef, 'code'), newError.code);
              Module.eggShell.writeString(Module.eggShell.findSubValueRef(errorValueRef, 'source'), newError.source);
          };

          Module.coreHelpers.mergeErrors = function (errorValueRef, newError) {
              // Follows behavior of merge errors function: https://zone.ni.com/reference/en-XX/help/371361N-01/glang/merge_errors_function/
              if (errorValueRef === undefined) {
                  return;
              }

              var errorStatusValueRef = Module.eggShell.findSubValueRef(errorValueRef, 'status');
              var isExistingError = Module.eggShell.readDouble(errorStatusValueRef) !== 0;
              if (isExistingError) {
                  return;
              }

              var isNewError = newError.status;
              if (isNewError) {
                  writeNewError(errorValueRef, newError);
                  return;
              }

              var existingErrorCodeValueRef = Module.eggShell.findSubValueRef(errorValueRef, 'code');
              var existingErrorCode = Module.eggShell.readDouble(existingErrorCodeValueRef);
              var isExistingWarning = existingErrorCode !== CODES.NO_ERROR;
              var isNewWarning = newError.code !== CODES.NO_ERROR;
              if (isExistingWarning) {
                  return;
              }

              if (isNewWarning) {
                  writeNewError(errorValueRef, newError);
                  return;
              }

              // If no error or warning then pass through
              // Note: merge errors function ignores newErrorSource if no newError or newWarning so replicated here
              return;
          };

          Module.coreHelpers.formatMessageWithException = function (messageText, exception) {
              var additionalInfo;
              if (exception !== undefined && exception !== null) {
                  // Some browsers do not print the message in the stack so print both
                  if (typeof exception.message === 'string' && exception.message.length !== 0) {
                      additionalInfo = ', Additional information:\nMessage: ' + exception.message;
                      if (typeof exception.stack === 'string' && exception.stack.length !== 0) {
                          additionalInfo += '\nStack: ' + exception.stack;
                      }
                      return messageText + additionalInfo;
                  }
              }

              return messageText;
          };

          Module.coreHelpers.createSourceFromMessage = function (additionalInformation) {
              if (typeof additionalInformation === 'string' && additionalInformation.length !== 0) {
                  return `<APPEND>\n${additionalInformation}`;
              }

              return '';
          };
      };
  }());

  var assignCoreHelpers$1 = assignCoreHelpers;

  var assignTypeHelpers;
  (function () {
      assignTypeHelpers = function (Module) {
          Module.typeHelpers = {};

          // Private instance functions
          var validateVisitMethod = function (fn, fnName) {
              if (typeof fn !== 'function') {
                  throw new Error('Visitor must have a method named `' + fnName + '`. Found: ' + fn);
              }
          };

          var dispatchVisitBoolean = function (typeVisitor, valueRef, data) {
              var visitFn = typeVisitor.visitBoolean;
              validateVisitMethod(visitFn, 'visitBoolean');
              return visitFn.call(typeVisitor, valueRef, data);
          };

          var dispatchVisitEnum = function (typeVisitor, valueRef, data) {
              var sizeOfEnum = Module.typeHelpers.topAQSize(valueRef.typeRef);
              var visitFn = undefined;
              var fnName = '';
              switch (sizeOfEnum) {
              case 1:
                  visitFn = typeVisitor.visitEnum8;
                  fnName = 'visitEnum8';
                  break;
              case 2:
                  visitFn = typeVisitor.visitEnum16;
                  fnName = 'visitEnum16';
                  break;
              case 4:
                  visitFn = typeVisitor.visitEnum32;
                  fnName = 'visitEnum32';
                  break;
              default:
                  throw new Error('Unexpected size for Enum. Found: ' + sizeOfEnum);
              }

              validateVisitMethod(visitFn, fnName);
              return visitFn.call(typeVisitor, valueRef, data);
          };

          var dispatchVisitInteger = function (typeVisitor, valueRef, data) {
              var typeRef = valueRef.typeRef;
              var isSignedInteger = Module.typeHelpers.isSigned(typeRef);
              var sizeOfInteger = Module.typeHelpers.topAQSize(typeRef);
              var visitFn = undefined;
              var fnName = '';
              if (isSignedInteger === true) {
                  switch (sizeOfInteger) {
                  case 1:
                      visitFn = typeVisitor.visitInt8;
                      fnName = 'visitInt8';
                      break;
                  case 2:
                      visitFn = typeVisitor.visitInt16;
                      fnName = 'visitInt16';
                      break;
                  case 4:
                      visitFn = typeVisitor.visitInt32;
                      fnName = 'visitInt32';
                      break;
                  case 8:
                      visitFn = typeVisitor.visitInt64;
                      fnName = 'visitInt64';
                      break;
                  default:
                      throw new Error('Unexpected size for Integer. Found: ' + sizeOfInteger);
                  }
              } else {
                  switch (sizeOfInteger) {
                  case 1:
                      visitFn = typeVisitor.visitUInt8;
                      fnName = 'visitUInt8';
                      break;
                  case 2:
                      visitFn = typeVisitor.visitUInt16;
                      fnName = 'visitUInt16';
                      break;
                  case 4:
                      visitFn = typeVisitor.visitUInt32;
                      fnName = 'visitUInt32';
                      break;
                  case 8:
                      visitFn = typeVisitor.visitUInt64;
                      fnName = 'visitUInt64';
                      break;
                  default:
                      throw new Error('Unexpected size for Unsigned Integer. Found: ' + sizeOfInteger);
                  }
              }

              validateVisitMethod(visitFn, fnName);
              return visitFn.call(typeVisitor, valueRef, data);
          };

          var dispatchVisitFloat = function (typeVisitor, valueRef, data) {
              var typeRef = valueRef.typeRef;
              var sizeOfFloat = Module.typeHelpers.topAQSize(typeRef);
              var visitFn;
              var fnName = '';
              switch (sizeOfFloat) {
              case 4:
                  visitFn = typeVisitor.visitSingle;
                  fnName = 'visitSingle';
                  break;
              case 8:
                  visitFn = typeVisitor.visitDouble;
                  fnName = 'visitDouble';
                  break;
              default:
                  throw new Error('Unexpected size for a Float value. Found: ' + sizeOfFloat);
              }

              validateVisitMethod(visitFn, fnName);
              return visitFn.call(typeVisitor, valueRef, data);
          };

          var dispatchVisitString = function (typeVisitor, valueRef, data) {
              var visitFn = typeVisitor.visitString;
              validateVisitMethod(visitFn, 'visitString');
              return visitFn.call(typeVisitor, valueRef, data);
          };

          var dispatchVisitComplex = function (typeVisitor, valueRef, data) {
              var typeRef = valueRef.typeRef,
                  sizeOfComplex = Module.typeHelpers.topAQSize(typeRef),
                  visitFn,
                  fnName;
              switch (sizeOfComplex) {
              case 8:
                  visitFn = typeVisitor.visitComplexSingle;
                  fnName = 'visitComplexSingle';
                  break;
              case 16:
                  visitFn = typeVisitor.visitComplexDouble;
                  fnName = 'visitComplexDouble';
                  break;
              default:
                  throw new Error('Unexpected size for a Complex value. Found: ' + sizeOfComplex);
              }

              validateVisitMethod(visitFn, fnName);
              return visitFn.call(typeVisitor, valueRef, data);
          };

          var dispatchVisitAnalogWaveform = function (typeVisitor, valueRef, data) {
              var visitFn = typeVisitor.visitAnalogWaveform;
              validateVisitMethod(visitFn, 'visitAnalogWaveform');
              return visitFn.call(typeVisitor, valueRef, data);
          };

          var dispatchVisitTimestamp = function (typeVisitor, valueRef, data) {
              var visitFn = typeVisitor.visitTimestamp;
              validateVisitMethod(visitFn, 'visitTimestamp');
              return visitFn.call(typeVisitor, valueRef, data);
          };

          var dispatchVisitPath = function (typeVisitor, valueRef, data) {
              var visitFn = typeVisitor.visitPath;
              validateVisitMethod(visitFn, 'visitPath');
              return visitFn.call(typeVisitor, valueRef, data);
          };

          var dispatchVisitArray = function (typeVisitor, valueRef, data) {
              var visitFn = typeVisitor.visitArray;
              validateVisitMethod(visitFn, 'visitArray');
              return visitFn.call(typeVisitor, valueRef, data);
          };

          var dispatchVisitJSObjectRefnum = function (typeVisitor, valueRef, data) {
              var visitFn = typeVisitor.visitJSObjectRefnum;
              validateVisitMethod(visitFn, 'visitJSObjectRefnum');
              return visitFn.call(typeVisitor, valueRef, data);
          };

          var dispatchVisitCluster = function (typeVisitor, valueRef, data) {
              var visitFn = typeVisitor.visitCluster;
              validateVisitMethod(visitFn, 'visitCluster');
              return visitFn.call(typeVisitor, valueRef, data);
          };

          // Exported functions
          Module.typeHelpers.topAQSize = function (typeRef) {
              return Module._TypeRef_TopAQSize(typeRef);
          };

          Module.typeHelpers.typeName = function (typeRef) {
              var stringTypeRef = Module.typeHelpers.findType('String');
              var responseValueRef = Module.eggShell.allocateData(stringTypeRef);
              Module._TypeRef_Name(Module.eggShell.v_userShell, typeRef, responseValueRef.typeRef, responseValueRef.dataRef);
              var response = Module.eggShell.readString(responseValueRef);
              Module.eggShell.deallocateData(responseValueRef);
              return response;
          };

          Module.typeHelpers.findType = function (typeName) {
              var stack = Module.stackSave();

              var typeNamePointer = Module.coreHelpers.writeJSStringToStack(typeName);
              const typeRef = Module._TypeManager_FindType(Module.eggShell.v_userShell, typeNamePointer);
              Module.stackRestore(stack);
              return typeRef;
          };

          Module.typeHelpers.typeRank = function (typeRef) {
              return Module._TypeRef_Rank(typeRef);
          };

          Module.typeHelpers.elementName = function (typeRef) {
              var stringTypeRef = Module.typeHelpers.findType('String');
              var responseValueRef = Module.eggShell.allocateData(stringTypeRef);
              Module._TypeRef_ElementName(Module.eggShell.v_userShell, typeRef, responseValueRef.typeRef, responseValueRef.dataRef);
              var response = Module.eggShell.readString(responseValueRef);
              Module.eggShell.deallocateData(responseValueRef);
              return response;
          };

          Module.typeHelpers.subElementCount = function (typeRef) {
              return Module._TypeRef_SubElementCount(typeRef);
          };

          Module.typeHelpers.subElementByIndex = function (typeRef, index) {
              return Module._TypeRef_GetSubElementByIndex(typeRef, index);
          };

          Module.typeHelpers.isCluster = function (typeRef) {
              return Module._TypeRef_IsCluster(typeRef) !== 0;
          };

          Module.typeHelpers.isArray = function (typeRef) {
              return Module._TypeRef_IsArray(typeRef) !== 0;
          };

          Module.typeHelpers.isBoolean = function (typeRef) {
              return Module._TypeRef_IsBoolean(typeRef) !== 0;
          };

          Module.typeHelpers.isInteger = function (typeRef) {
              return Module._TypeRef_IsInteger(typeRef) !== 0;
          };

          Module.typeHelpers.isSigned = function (typeRef) {
              return Module._TypeRef_IsSigned(typeRef) !== 0;
          };

          Module.typeHelpers.isEnum = function (typeRef) {
              return Module._TypeRef_IsEnum(typeRef) !== 0;
          };

          Module.typeHelpers.isFloat = function (typeRef) {
              return Module._TypeRef_IsFloat(typeRef) !== 0;
          };

          Module.typeHelpers.isString = function (typeRef) {
              return Module._TypeRef_IsString(typeRef) !== 0;
          };

          Module.typeHelpers.isPath = function (typeRef) {
              return Module._TypeRef_IsPath(typeRef) !== 0;
          };

          Module.typeHelpers.isTimestamp = function (typeRef) {
              return Module._TypeRef_IsTimestamp(typeRef) !== 0;
          };

          Module.typeHelpers.isComplex = function (typeRef) {
              return Module._TypeRef_IsComplex(typeRef) !== 0;
          };

          Module.typeHelpers.isAnalogWaveform = function (typeRef) {
              return Module._TypeRef_IsAnalogWaveform(typeRef) !== 0;
          };

          Module.typeHelpers.isJSObjectRefnum = function (typeRef) {
              return Module._TypeRef_IsJavaScriptStaticRefNum(typeRef) !== 0 ||
                     Module._TypeRef_IsJavaScriptDynamicRefNum(typeRef) !== 0;
          };

          Module.typeHelpers.isJSObjectStaticRefnum = function (typeRef) {
              return Module._TypeRef_IsJavaScriptStaticRefNum(typeRef) !== 0;
          };

          Module.typeHelpers.isJSObjectDynamicRefnum = function (typeRef) {
              return Module._TypeRef_IsJavaScriptDynamicRefNum(typeRef) !== 0;
          };

          var typeHandlers = [
              {
                  // JSObjectRefnum is Integer, so it should be before Integer
                  typeChecker: Module.typeHelpers.isJSObjectRefnum,
                  dispatcher: dispatchVisitJSObjectRefnum
              },
              {
                  typeChecker: Module.typeHelpers.isBoolean,
                  dispatcher: dispatchVisitBoolean
              },
              {
                  // Enum is wrapping an integer, so it needs to be evaluated first.
                  typeChecker: Module.typeHelpers.isEnum,
                  dispatcher: dispatchVisitEnum
              },
              {
                  typeChecker: Module.typeHelpers.isInteger,
                  dispatcher: dispatchVisitInteger
              },
              {
                  typeChecker: Module.typeHelpers.isFloat,
                  dispatcher: dispatchVisitFloat
              },
              {
                  // String is an array of UTF-8 chars so it is evaluated before array.
                  typeChecker: Module.typeHelpers.isString,
                  dispatcher: dispatchVisitString
              },
              {
                  typeChecker: Module.typeHelpers.isComplex,
                  dispatcher: dispatchVisitComplex
              },
              {
                  typeChecker: Module.typeHelpers.isAnalogWaveform,
                  dispatcher: dispatchVisitAnalogWaveform
              },
              {
                  typeChecker: Module.typeHelpers.isTimestamp,
                  dispatcher: dispatchVisitTimestamp
              },
              {
                  typeChecker: Module.typeHelpers.isPath,
                  dispatcher: dispatchVisitPath
              },
              {
                  typeChecker: Module.typeHelpers.isArray,
                  dispatcher: dispatchVisitArray
              },
              {
                  // Cluster is evaluated last because Complex, AnalogWaveform, Path and Timestamps
                  // are internally also clusters.
                  typeChecker: Module.typeHelpers.isCluster,
                  dispatcher: dispatchVisitCluster
              }
          ];

          Module.typeHelpers.findTypeDispatcher = function (typeRef) {
              var i = 0,
                  typeHandler;

              for (i = 0; i < typeHandlers.length; i += 1) {
                  typeHandler = typeHandlers[i];
                  if (typeHandler.typeChecker(typeRef) === true) {
                      return typeHandler.dispatcher;
                  }
              }
              return undefined;
          };
      };
  }());
  var assignTypeHelpers$1 = assignTypeHelpers;

  const isCharacterAlphabetOrNonAscii = function (codePoint) {
      return ((codePoint >= 0x41 && codePoint <= 0x5A) || (codePoint >= 0x61 && codePoint <= 0x7A) || (codePoint > 0x7F));
  };

  const encodeIdentifier = function (str) {
      if (typeof str !== 'string' || str === '') {
          throw new Error('Identifier must be a non-empty string. Found: ' + str);
      }

      let encoded = '',
          codePoint = str.charCodeAt(0),
          ch = str.charAt(0);

      if (!isCharacterAlphabetOrNonAscii(codePoint)) {
          encoded += '%' + codePoint.toString(16).toUpperCase();
      } else {
          encoded += ch;
      }

      for (let i = 1; i < str.length; i += 1) {
          codePoint = str.charCodeAt(i);
          ch = str.charAt(i);

          // Do not encode if it is a number [0-9] or uppercase letter [A-Z] or lowercase [a-z] or any of these [*+_-$] or a non-ascii character.
          if ((codePoint >= 0x30 && codePoint <= 0x39) || (codePoint >= 0x41 && codePoint <= 0x5A) || (codePoint >= 0x61 && codePoint <= 0x7A) ||
              codePoint === 0x24 || codePoint === 0x2A || codePoint === 0x2B || codePoint === 0x2D || codePoint === 0x5F || codePoint > 0x7F) {
              encoded += ch;
          } else {
              encoded += '%' + codePoint.toString(16).toUpperCase();
          }
      }

      return encoded;
  };

  const decodeIdentifier = function (str) {
      if (typeof str !== 'string' || str === '') {
          throw new Error('Identifier must be a non-empty string. Found: ' + str);
      }

      return decodeURIComponent(str);
  };

  var staticHelpers = {
      encodeIdentifier,
      decodeIdentifier
  };

  var assignEggShell;
  (function () {
      // Static Private Variables (all vireo instances)
      // None

      // Vireo Core Mixin Function
      assignEggShell = function (Module, publicAPI) {
          Module.eggShell = {};
          publicAPI.eggShell = {};

          Module.eggShell.readJavaScriptRefNum = publicAPI.eggShell.readJavaScriptRefNum = function (valueRef) {
              return Module.javaScriptInvoke.readJavaScriptRefNum(valueRef);
          };

          Module.eggShell.writeJavaScriptRefNum = publicAPI.eggShell.writeJavaScriptRefNum = function (valueRef, data) {
              return Module.javaScriptInvoke.writeJavaScriptRefNum(valueRef, data);
          };

          // Private Instance Variables (per vireo instance)
          var POINTER_SIZE = 4;
          var DOUBLE_SIZE = 8;
          var LENGTH_SIZE = 4;

          // Keep in sync with EggShellResult in CEntryPoints.h
          var EGGSHELL_RESULT = {
              SUCCESS: 0,
              OBJECT_NOT_FOUND_AT_PATH: 1,
              UNEXPECTED_OBJECT_TYPE: 2,
              INVALID_RESULT_POINTER: 3,
              UNABLE_TO_CREATE_RETURN_BUFFER: 4,
              INVALID_TYPE_REF: 5,
              MISMATCHED_ARRAY_RANK: 6,
              UNABLE_TO_PARSE_DATA: 7,
              UNABLE_TO_ALLOCATE_DATA: 8,
              UNABLE_TO_DEALLOCATE_DATA: 9,
              INVALID_DATA_POINTER: 10
          };
          var eggShellResultEnum = {};
          eggShellResultEnum[EGGSHELL_RESULT.SUCCESS] = 'Success';
          eggShellResultEnum[EGGSHELL_RESULT.OBJECT_NOT_FOUND_AT_PATH] = 'ObjectNotFoundAtPath';
          eggShellResultEnum[EGGSHELL_RESULT.UNEXPECTED_OBJECT_TYPE] = 'UnexpectedObjectType';
          eggShellResultEnum[EGGSHELL_RESULT.INVALID_RESULT_POINTER] = 'InvalidResultPointer';
          eggShellResultEnum[EGGSHELL_RESULT.UNABLE_TO_CREATE_RETURN_BUFFER] = 'UnableToCreateReturnBuffer';
          eggShellResultEnum[EGGSHELL_RESULT.INVALID_TYPE_REF] = 'InvalidTypeRef';
          eggShellResultEnum[EGGSHELL_RESULT.MISMATCHED_ARRAY_RANK] = 'MismatchedArrayRank';
          eggShellResultEnum[EGGSHELL_RESULT.UNABLE_TO_PARSE_DATA] = 'UnableToParseData';
          eggShellResultEnum[EGGSHELL_RESULT.UNABLE_TO_ALLOCATE_DATA] = 'UnableToAllocateData';
          eggShellResultEnum[EGGSHELL_RESULT.UNABLE_TO_DEALLOCATE_DATA] = 'UnableToDeallocateData';
          eggShellResultEnum[EGGSHELL_RESULT.INVALID_DATA_POINTER] = 'InvalidDataPointer';

          // Keep in sync with NIError in DataTypes.h
          var niErrorEnum = {
              0: 'Success',
              1: 'InsufficientResources',
              2: 'ResourceNotFound',
              3: 'ArrayRankMismatch',
              4: 'CantDecode',
              5: 'CantEncode',
              6: 'LogicFailure',
              7: 'ValueTruncated'
          };

          // Create shell for vireo instance
          Module.eggShell.create = function (parentTypeManager) {
              return Module._EggShell_Create(parentTypeManager);
          };
          Module.eggShell.delete = function (typeManager) {
              Module._EggShell_Delete(typeManager);
          };
          Module.eggShell.v_root = Module.eggShell.create(0);
          Module.eggShell.v_userShell = Module.eggShell.create(Module.eggShell.v_root);

          // Exported functions
          publicAPI.eggShell.setPrintFunction = function (fn) {
              if (typeof fn !== 'function') {
                  throw new Error('Print must be a callable function');
              }

              Module.vireoPrint = fn;
          };

          publicAPI.eggShell.setPrintErrorFunction = function (fn) {
              if (typeof fn !== 'function') {
                  throw new Error('PrintError must be a callable function');
              }

              Module.vireoPrintErr = fn;
          };

          Module.eggShell.executeSlicesWakeUpCallback = function () {
              // By default do no action
          };

          publicAPI.eggShell.setExecuteSlicesWakeUpCallback = function (fn) {
              if (typeof fn !== 'function') {
                  throw new Error('Execute slices wake-up callback must be a callable function');
              }

              Module.eggShell.executeSlicesWakeUpCallback = fn;
          };

          publicAPI.eggShell.internal_module_do_not_use_or_you_will_be_fired = Module;

          // Exporting functions to both Module.eggShell and publicAPI.eggShell is not normal
          // This is unique to the eggShell API as it is consumed by other modules as well as users
          Module.eggShell.maxExecWakeUpTime = publicAPI.eggShell.maxExecWakeUpTime = function () {
              return Module._Vireo_MaxExecWakeUpTime();
          };

          Module.eggShell.reboot = publicAPI.eggShell.reboot = function () {
              // TODO abort all http requests
              // TODO reset internal jsli functions
              Module.eggShell.delete(Module.eggShell.v_userShell);
              Module.eggShell.delete(Module.eggShell.v_root);
              Module.eggShell.v_root = Module.eggShell.create(0);
              Module.eggShell.v_userShell = Module.eggShell.create(Module.eggShell.v_root);
          };

          Module.eggShell.createValueRef = function (typeRef, dataRef) {
              if (typeof typeRef !== 'number' || typeof dataRef !== 'number' ||
                  (typeRef <= 0 || dataRef <= 0)) {
                  return undefined;
              }
              return Object.freeze({
                  typeRef: typeRef,
                  dataRef: dataRef
              });
          };

          Module.eggShell.allocateData = function (typeRef) {
              var stack = Module.stackSave();

              var dataStackPointer = Module.stackAlloc(POINTER_SIZE);
              var eggShellResult = Module._EggShell_AllocateData(Module.eggShell.v_userShell, typeRef, dataStackPointer);
              if (eggShellResult !== EGGSHELL_RESULT.SUCCESS) {
                  throw new Error('A new ValueRef could not be allocated for the following reason: ' + eggShellResultEnum[eggShellResult] +
                      ' (error code: ' + eggShellResult + ')' +
                      ' (typeRef: ' + typeRef + ')');
              }

              var dataRef = Module.getValue(dataStackPointer, 'i32');
              var allocatedValueRef = Module.eggShell.createValueRef(typeRef, dataRef);

              Module.stackRestore(stack);
              return allocatedValueRef;
          };

          Module.eggShell.deallocateData = function (valueRef) {
              var eggShellResult = Module._EggShell_DeallocateData(Module.eggShell.v_userShell, valueRef.typeRef, valueRef.dataRef);
              if (eggShellResult !== EGGSHELL_RESULT.SUCCESS) {
                  throw new Error('A ValueRef could not be deallocated for the following reason: ' + eggShellResultEnum[eggShellResult] +
                      ' (error code: ' + eggShellResult + ')' +
                      ' (typeRef: ' + valueRef.typeRef + ')' +
                      ' (dataRef: ' + valueRef.dataRef + ')');
              }
          };

          Module.eggShell.reinitializeToDefault = publicAPI.eggShell.reinitializeToDefault = function (valueRef) {
              var eggShellResult = Module._EggShell_ReinitializeToDefault(Module.eggShell.v_userShell, valueRef.typeRef, valueRef.dataRef);
              if (eggShellResult !== EGGSHELL_RESULT.SUCCESS) {
                  throw new Error('The ValueRef could not be reinitialized to default for the following reason: ' + eggShellResultEnum[eggShellResult] +
                      ' (error code: ' + eggShellResult + ')' +
                      ' (typeRef: ' + valueRef.typeRef + ')');
              }
          };

          Module.eggShell.findValueRef = publicAPI.eggShell.findValueRef = function (vi, path) {
              var stack = Module.stackSave();

              var viStackPointer = Module.coreHelpers.writeJSStringToStack(vi);
              var pathStackPointer = Module.coreHelpers.writeJSStringToStack(path);
              var typeStackPointer = Module.stackAlloc(POINTER_SIZE);
              var dataStackPointer = Module.stackAlloc(POINTER_SIZE);

              var eggShellResult = Module._EggShell_FindValue(Module.eggShell.v_userShell, viStackPointer, pathStackPointer, typeStackPointer, dataStackPointer);
              if (eggShellResult !== EGGSHELL_RESULT.SUCCESS && eggShellResult !== EGGSHELL_RESULT.OBJECT_NOT_FOUND_AT_PATH) {
                  throw new Error('A ValueRef could not be made for the following reason: ' + eggShellResultEnum[eggShellResult] +
                      ' (error code: ' + eggShellResult + ')' +
                      ' (vi name: ' + vi + ')' +
                      ' (path: ' + path + ')');
              }

              var typeRef, dataRef, valueRef;
              if (eggShellResult === EGGSHELL_RESULT.SUCCESS) {
                  typeRef = Module.getValue(typeStackPointer, 'i32');
                  dataRef = Module.getValue(dataStackPointer, 'i32');
                  valueRef = Module.eggShell.createValueRef(typeRef, dataRef);
              } else {
                  valueRef = undefined;
              }

              Module.stackRestore(stack);
              return valueRef;
          };

          Module.eggShell.findSubValueRef = publicAPI.eggShell.findSubValueRef = function (valueRef, subPath) {
              var stack = Module.stackSave();

              var subPathStackPointer = Module.coreHelpers.writeJSStringToStack(subPath);
              var typeStackPointer = Module.stackAlloc(POINTER_SIZE);
              var dataStackPointer = Module.stackAlloc(POINTER_SIZE);

              var eggShellResult = Module._EggShell_FindSubValue(Module.eggShell.v_userShell, valueRef.typeRef, valueRef.dataRef, subPathStackPointer, typeStackPointer, dataStackPointer);
              if (eggShellResult !== EGGSHELL_RESULT.SUCCESS && eggShellResult !== EGGSHELL_RESULT.OBJECT_NOT_FOUND_AT_PATH) {
                  throw new Error('A ValueRef could not be made for the following reason: ' + eggShellResultEnum[eggShellResult] +
                      ' (error code: ' + eggShellResult + ')' +
                      ' (type name: ' + Module.typeHelpers.typeName(valueRef.typeRef) + ')' +
                      ' (subpath: ' + subPath + ')');
              }

              var typeRef, dataRef, subValueRef;
              if (eggShellResult === EGGSHELL_RESULT.SUCCESS) {
                  typeRef = Module.getValue(typeStackPointer, 'i32');
                  dataRef = Module.getValue(dataStackPointer, 'i32');
                  subValueRef = Module.eggShell.createValueRef(typeRef, dataRef);
              } else {
                  subValueRef = undefined;
              }

              Module.stackRestore(stack);
              return subValueRef;
          };

          Module.eggShell.readValueRefObject = publicAPI.eggShell.readValueRefObject = function (valueRef) {
              var typeRef = valueRef.typeRef;
              var valueRefs = {};

              if (Module.typeHelpers.isCluster(typeRef) === false) {
                  throw new Error('A ValueRefObject could not be made for the following reason: ' + eggShellResultEnum[EGGSHELL_RESULT.UNEXPECTED_OBJECT_TYPE] +
                      ' (error code: ' + EGGSHELL_RESULT.UNEXPECTED_OBJECT_TYPE + ')' +
                      ' (type name: ' + Module.typeHelpers.typeName(typeRef) + ')');
              }

              var fieldCount = Module.typeHelpers.subElementCount(typeRef);

              var fieldTypeRef, fieldNameEncoded, fieldName;
              for (var i = 0; i < fieldCount; i += 1) {
                  fieldTypeRef = Module.typeHelpers.subElementByIndex(typeRef, i);
                  fieldNameEncoded = Module.typeHelpers.elementName(fieldTypeRef);
                  fieldName = staticHelpers.decodeIdentifier(fieldNameEncoded);
                  valueRefs[fieldName] = Module.eggShell.findSubValueRef(valueRef, fieldNameEncoded);
              }

              return valueRefs;
          };

          Module.eggShell.reflectOnValueRef = publicAPI.eggShell.reflectOnValueRef = function (typeVisitor, valueRef, data) {
              if (typeof valueRef !== 'object' || valueRef === null) {
                  throw new Error('valueRef must be an object. Found: ' + valueRef);
              }

              if (typeof typeVisitor !== 'object' || typeVisitor === null) {
                  throw new Error('typeVisitor must be an object. Found: ' + typeVisitor);
              }

              var typeRef = valueRef.typeRef,
                  dispatchFunction = Module.typeHelpers.findTypeDispatcher(typeRef);

              if (dispatchFunction === undefined) {
                  throw new Error('Unexpected type. Is typeRef pointing to a valid type?. Type found: ' + typeRef === 0 ? 'invalid type' : Module.typeHelpers.typeName(typeRef));
              }

              return dispatchFunction(typeVisitor, valueRef, data);
          };

          Module.eggShell.readDouble = publicAPI.eggShell.readDouble = function (valueRef) {
              var stack = Module.stackSave();
              var resultPointer = Module.stackAlloc(DOUBLE_SIZE);

              // TODO mraj should we try to resolve the typeref name on error for more context?
              var eggShellResult = Module._EggShell_ReadDouble(Module.eggShell.v_userShell, valueRef.typeRef, valueRef.dataRef, resultPointer);
              if (eggShellResult !== EGGSHELL_RESULT.SUCCESS) {
                  throw new Error('Could not run readDouble for the following reason: ' + eggShellResultEnum[eggShellResult] +
                      ' (error code: ' + eggShellResult + ')' +
                      ' (typeRef: ' + valueRef.typeRef + ')' +
                      ' (dataRef: ' + valueRef.dataRef + ')');
              }
              var result = Module.getValue(resultPointer, 'double');

              Module.stackRestore(stack);
              return result;
          };

          Module.eggShell.writeDouble = publicAPI.eggShell.writeDouble = function (valueRef, value) {
              if (typeof value !== 'number') {
                  throw new Error('Expected value to write to be of type number, instead got: ' + value);
              }

              var eggShellResult = Module._EggShell_WriteDouble(Module.eggShell.v_userShell, valueRef.typeRef, valueRef.dataRef, value);
              if (eggShellResult !== EGGSHELL_RESULT.SUCCESS) {
                  throw new Error('Could not run writeDouble for the following reason: ' + eggShellResultEnum[eggShellResult] +
                      ' (error code: ' + eggShellResult + ')' +
                      ' (typeRef: ' + valueRef.typeRef + ')' +
                      ' (dataRef: ' + valueRef.dataRef + ')');
              }
          };

          Module.eggShell.readJSON = publicAPI.eggShell.readJSON = function (valueRef) {
              var stack = Module.stackSave(); // Stack save only needed for input parameter string or array

              var type = 'JSON';
              var typeStackPointer = Module.coreHelpers.writeJSStringToStack(type);

              var stringTypeRef = Module.typeHelpers.findType('String');
              var jsonResponseValueRef = Module.eggShell.allocateData(stringTypeRef);
              var eggShellError = Module._EggShell_ReadValueString(Module.eggShell.v_userShell, valueRef.typeRef, valueRef.dataRef, typeStackPointer, jsonResponseValueRef.typeRef, jsonResponseValueRef.dataRef);
              if (eggShellError !== 0) {
                  throw new Error('Performing readJSON failed for the following reason: ' + eggShellResultEnum[eggShellError] +
                      ' (error code: ' + eggShellError + ')' +
                      ' (typeRef: ' + valueRef.typeRef + ')' +
                      ' (dataRef: ' + valueRef.dataRef + ')');
              }

              var response = Module.eggShell.readString(jsonResponseValueRef);
              Module.eggShell.deallocateData(jsonResponseValueRef);
              Module.stackRestore(stack);
              return response;
          };

          Module.eggShell.writeJSON = publicAPI.eggShell.writeJSON = function (valueRef, value) {
              var stack = Module.stackSave();

              var type = 'JSON';
              var valueStackPointer = Module.coreHelpers.writeJSStringToHeap(value);
              var typeStackPointer = Module.coreHelpers.writeJSStringToStack(type);

              var eggShellError = Module._EggShell_WriteValueString(Module.eggShell.v_userShell, valueRef.typeRef, valueRef.dataRef, typeStackPointer, valueStackPointer);
              if (eggShellError !== 0) {
                  throw new Error('Performing writeJSON failed for the following reason: ' + eggShellResultEnum[eggShellError] +
                      ' (error code: ' + eggShellError + ')' +
                      ' (typeRef: ' + valueRef.typeRef + ')' +
                      ' (dataRef: ' + valueRef.dataRef + ')');
              }

              Module._free(valueStackPointer);
              Module.stackRestore(stack);
          };

          Module.eggShell.dataGetArrayBegin = function (dataRef) {
              return Module._Data_GetArrayBegin(dataRef);
          };

          Module.eggShell.dataGetArrayLength = function (dataRef) {
              return Module._Data_GetArrayLength(dataRef);
          };

          Module.eggShell.readString = publicAPI.eggShell.readString = function (valueRef) {
              if (Module.typeHelpers.isString(valueRef.typeRef) === false) {
                  throw new Error('Performing readString failed for the following reason: ' + eggShellResultEnum[EGGSHELL_RESULT.UNEXPECTED_OBJECT_TYPE] +
                      ' (error code: ' + EGGSHELL_RESULT.UNEXPECTED_OBJECT_TYPE + ')' +
                      ' (typeRef: ' + valueRef.typeRef + ')' +
                      ' (dataRef: ' + valueRef.dataRef + ')');
              }
              var arrayBegin = Module.eggShell.dataGetArrayBegin(valueRef.dataRef);
              var totalLength = Module.eggShell.dataGetArrayLength(valueRef.dataRef);
              var result = Module.coreHelpers.sizedUtf8ArrayToJSString(Module.HEAPU8, arrayBegin, totalLength);
              return result;
          };

          Module.eggShell.writeString = publicAPI.eggShell.writeString = function (valueRef, inputString) {
              if (Module.typeHelpers.isString(valueRef.typeRef) === false) {
                  throw new Error('Performing writeString failed for the following reason: ' + eggShellResultEnum[EGGSHELL_RESULT.UNEXPECTED_OBJECT_TYPE] +
                      ' (error code: ' + EGGSHELL_RESULT.UNEXPECTED_OBJECT_TYPE + ')' +
                      ' (typeRef: ' + valueRef.typeRef + ')' +
                      ' (dataRef: ' + valueRef.dataRef + ')');
              }

              if (typeof inputString !== 'string') {
                  throw new Error('Expected string input to be of type string, instead got: ' + inputString);
              }

              var strLength = Module.lengthBytesUTF8(inputString);
              Module.eggShell.resizeArray(valueRef, [strLength]);
              var typedArray = Module.eggShell.readTypedArray(valueRef);
              var bytesWritten = Module.coreHelpers.jsStringToSizedUTF8Array(inputString, typedArray, 0, strLength);
              if (bytesWritten !== strLength) {
                  throw new Error('Could not write JS string to memory');
              }
          };

          var findCompatibleTypedArrayConstructor = function (typeRef) {
              var subTypeRef, isSigned, size;
              // String will go down the Array code path a bit as is so check before array checks
              if (Module.typeHelpers.isString(typeRef)) {
                  return Uint8Array; // exposes UTF-8 encoded array to client
              } else if (Module.typeHelpers.isArray(typeRef)) {
                  subTypeRef = Module.typeHelpers.subElementByIndex(typeRef, 0);
                  if (Module.typeHelpers.isBoolean(subTypeRef)) {
                      return Uint8Array;
                  } else if (Module.typeHelpers.isInteger(subTypeRef)) { // Used for Enums and Integers
                      isSigned = Module.typeHelpers.isSigned(subTypeRef);
                      size = Module.typeHelpers.topAQSize(subTypeRef);
                      if (isSigned === true) {
                          switch (size) {
                          case 1:
                              return Int8Array;
                          case 2:
                              return Int16Array;
                          case 4:
                              return Int32Array;
                          default:
                              return undefined;
                          }
                      } else {
                          switch (size) {
                          case 1:
                              return Uint8Array;
                          case 2:
                              return Uint16Array;
                          case 4:
                              return Uint32Array;
                          default:
                              return undefined;
                          }
                      }
                  } else if (Module.typeHelpers.isFloat(subTypeRef)) {
                      size = Module.typeHelpers.topAQSize(subTypeRef);
                      switch (size) {
                      case 4:
                          return Float32Array;
                      case 8:
                          return Float64Array;
                      default:
                          return undefined;
                      }
                  }
              }
              return undefined;
          };

          Module.eggShell.isTypedArrayCompatible = publicAPI.eggShell.isTypedArrayCompatible = function (valueRef) {
              return findCompatibleTypedArrayConstructor(valueRef.typeRef) !== undefined;
          };

          Module.eggShell.getArrayDimensions = publicAPI.eggShell.getArrayDimensions = function (valueRef) {
              if (!Module.typeHelpers.isArray(valueRef.typeRef)) {
                  throw new Error('Performing getArrayDimensions failed for the following reason: ' + eggShellResultEnum[EGGSHELL_RESULT.UNEXPECTED_OBJECT_TYPE] +
                      ' (error code: ' + EGGSHELL_RESULT.UNEXPECTED_OBJECT_TYPE + ')' +
                      ' (typeRef: ' + valueRef.typeRef + ')' +
                      ' (dataRef: ' + valueRef.dataRef + ')');
              }

              var rank = Module.typeHelpers.typeRank(valueRef.typeRef);
              var stack = Module.stackSave();
              var dimensionsPointer = Module.stackAlloc(rank * LENGTH_SIZE);
              Module._Data_GetArrayDimensions(valueRef.dataRef, dimensionsPointer);
              var dimensions = [];
              var i;
              for (i = 0; i < rank; i += 1) {
                  dimensions.push(Module.getValue(dimensionsPointer + (i * LENGTH_SIZE), 'i32'));
              }
              Module.stackRestore(stack);

              return dimensions;
          };

          Module.eggShell.readTypedArray = publicAPI.eggShell.readTypedArray = function (valueRef) {
              var TypedArrayConstructor = findCompatibleTypedArrayConstructor(valueRef.typeRef);
              if (TypedArrayConstructor === undefined) {
                  throw new Error('Performing readTypedArray failed for the following reason: ' + eggShellResultEnum[EGGSHELL_RESULT.UNEXPECTED_OBJECT_TYPE] +
                      ' (error code: ' + EGGSHELL_RESULT.UNEXPECTED_OBJECT_TYPE + ')' +
                      ' (typeRef: ' + valueRef.typeRef + ')' +
                      ' (dataRef: ' + valueRef.dataRef + ')');
              }
              var arrayBegin = Module.eggShell.dataGetArrayBegin(valueRef.dataRef);
              var totalLength = Module.eggShell.dataGetArrayLength(valueRef.dataRef);
              var typedArray = new TypedArrayConstructor(Module.HEAP8.buffer, arrayBegin, totalLength);
              return typedArray;
          };

          Module.eggShell.isSupportedAndCompatibleArrayType = function (valueRef, typedArrayValue) {
              var TypedArrayConstructor = findCompatibleTypedArrayConstructor(valueRef.typeRef);
              return (TypedArrayConstructor !== undefined && typedArrayValue instanceof TypedArrayConstructor);
          };

          Module.eggShell.writeTypedArray = publicAPI.eggShell.writeTypedArray = function (valueRef, typedArrayValue) {
              var TypedArrayConstructor = findCompatibleTypedArrayConstructor(valueRef.typeRef);
              if (TypedArrayConstructor === undefined || !(typedArrayValue instanceof TypedArrayConstructor)) {
                  throw new Error('Performing writeTypedArray failed for the following reason: ' + eggShellResultEnum[EGGSHELL_RESULT.UNEXPECTED_OBJECT_TYPE] +
                      ' (error code: ' + EGGSHELL_RESULT.UNEXPECTED_OBJECT_TYPE + ')' +
                      ' (typeRef: ' + valueRef.typeRef + ')' +
                      ' (dataRef: ' + valueRef.dataRef + ')');
              }

              var arrayTotalLength = Module.eggShell.dataGetArrayLength(valueRef.dataRef);
              var totalLength = typedArrayValue.length;
              if (totalLength !== arrayTotalLength) {
                  throw new Error('TypedArray total length must be ' + arrayTotalLength + ' instead got ' + totalLength);
              }
              var arrayBegin = Module.eggShell.dataGetArrayBegin(valueRef.dataRef);
              var typedArray = new TypedArrayConstructor(Module.HEAP8.buffer, arrayBegin, totalLength);
              typedArray.set(typedArrayValue);
          };

          Module.eggShell.resizeArray = publicAPI.eggShell.resizeArray = function (valueRef, newDimensions) {
              if (!Array.isArray(newDimensions)) {
                  throw new Error('Expected newDimensions to be an array of dimension lengths, instead got: ' + newDimensions);
              }
              var stack = Module.stackSave();
              var newDimensionsLength = newDimensions.length;
              var dimensionsPointer = Module.stackAlloc(newDimensionsLength * LENGTH_SIZE);
              var i, currentDimension;
              for (i = 0; i < newDimensionsLength; i += 1) {
                  currentDimension = newDimensions[i];

                  if (typeof currentDimension !== 'number') {
                      throw new Error('Expected all dimensions of newDimensions to be numeric values for dimension length, instead got' + currentDimension);
                  }
                  Module.setValue(dimensionsPointer + (i * LENGTH_SIZE), currentDimension, 'i32');
              }
              var eggShellResult = Module._EggShell_ResizeArray(Module.eggShell.v_userShell, valueRef.typeRef, valueRef.dataRef, newDimensionsLength, dimensionsPointer);
              if (eggShellResult !== EGGSHELL_RESULT.SUCCESS) {
                  throw new Error('Resizing the array failed for the following reason: ' + eggShellResultEnum[eggShellResult] +
                  ' (error code: ' + eggShellResult + ')' +
                  ' (typeRef: ' + valueRef.typeRef + ')' +
                  ' (dataRef: ' + valueRef.dataRef + ')');
              }
              Module.stackRestore(stack);
          };

          Module.eggShell.getVariantAttribute = publicAPI.eggShell.getVariantAttribute = function (valueRef, attributeName) {
              var stack = Module.stackSave();

              var attributeNameStackPointer = Module.coreHelpers.writeJSStringToStack(attributeName);
              var typeStackPointer = Module.stackAlloc(POINTER_SIZE);
              var dataStackPointer = Module.stackAlloc(POINTER_SIZE);

              var eggShellResult = Module._EggShell_GetVariantAttribute(Module.eggShell.v_userShell, valueRef.typeRef, valueRef.dataRef, attributeNameStackPointer, typeStackPointer, dataStackPointer);
              if (eggShellResult !== EGGSHELL_RESULT.SUCCESS && eggShellResult !== EGGSHELL_RESULT.OBJECT_NOT_FOUND_AT_PATH) {
                  throw new Error('Could not get variant attribute for the following reason: ' + eggShellResultEnum[eggShellResult] +
                      ' (error code: ' + eggShellResult + ')' +
                      ' (type name: ' + Module.typeHelpers.typeName(valueRef.typeRef) + ')' +
                      ' (subpath: ' + attributeName + ')');
              }

              var typeRef, dataRef, resultValueRef;
              if (eggShellResult === EGGSHELL_RESULT.SUCCESS) {
                  typeRef = Module.getValue(typeStackPointer, 'i32');
                  dataRef = Module.getValue(dataStackPointer, 'i32');
                  resultValueRef = Module.eggShell.createValueRef(typeRef, dataRef);
              } else {
                  resultValueRef = undefined;
              }

              Module.stackRestore(stack);
              return resultValueRef;
          };

          // Note: Not exported as public api does not have ability to allocate arbitrary types
          // Instead call setVariantAttributeAs<Typename> for current allocatable types as variant attributes
          Module.eggShell.setVariantAttribute = function (valueRef, attributeName, attributeValueRef) {
              var stack = Module.stackSave();

              var attributeNameStackPointer = Module.coreHelpers.writeJSStringToStack(attributeName);
              var eggShellResult = Module._EggShell_SetVariantAttribute(Module.eggShell.v_userShell, valueRef.typeRef, valueRef.dataRef, attributeNameStackPointer, attributeValueRef.typeRef, attributeValueRef.dataRef);
              if (eggShellResult !== EGGSHELL_RESULT.SUCCESS) {
                  throw new Error('Could not set variant attribute for the following reason: ' + eggShellResultEnum[eggShellResult] +
                      ' (error code: ' + eggShellResult + ')' +
                      ' (type name: ' + Module.typeHelpers.typeName(valueRef.typeRef) + ')' +
                      ' (subpath: ' + attributeName + ')');
              }
              Module.stackRestore(stack);
          };

          Module.eggShell.setVariantAttributeAsString = publicAPI.eggShell.setVariantAttributeAsString = function (valueRef, attributeName, attributeValueString) {
              var stringTypeRef = Module.typeHelpers.findType('String');
              var attributeValueRef = Module.eggShell.allocateData(stringTypeRef);
              Module.eggShell.writeString(attributeValueRef, attributeValueString);
              Module.eggShell.setVariantAttribute(valueRef, attributeName, attributeValueRef);
              Module.eggShell.deallocateData(attributeValueRef);
          };

          Module.eggShell.deleteVariantAttribute = publicAPI.eggShell.deleteVariantAttribute = function (valueRef, attributeName) {
              var stack = Module.stackSave();

              var attributeNameStackPointer = Module.coreHelpers.writeJSStringToStack(attributeName);
              var eggShellResult = Module._EggShell_DeleteVariantAttribute(Module.eggShell.v_userShell, valueRef.typeRef, valueRef.dataRef, attributeNameStackPointer);
              if (eggShellResult !== EGGSHELL_RESULT.SUCCESS && eggShellResult !== EGGSHELL_RESULT.OBJECT_NOT_FOUND_AT_PATH) {
                  throw new Error('Could not delete variant attribute for the following reason: ' + eggShellResultEnum[eggShellResult] +
                      ' (error code: ' + eggShellResult + ')' +
                      ' (type name: ' + Module.typeHelpers.typeName(valueRef.typeRef) + ')' +
                      ' (subpath: ' + attributeName + ')');
              }
              var found = eggShellResult !== EGGSHELL_RESULT.OBJECT_NOT_FOUND_AT_PATH;

              Module.stackRestore(stack);
              return found;
          };

          // **DEPRECATED**
          Module.eggShell.dataReadString = function (stringPointer) {
              var begin = Module._Data_GetStringBegin(stringPointer);
              var length = Module._Data_GetStringLength(stringPointer);
              var str = Module.coreHelpers.sizedUtf8ArrayToJSString(Module.HEAPU8, begin, length);
              return str;
          };

          Module.eggShell.loadVia = publicAPI.eggShell.loadVia = function (viaText) {
              if (typeof viaText !== 'string') {
                  throw new Error('Expected viaText to be a string');
              }

              if (viaText.length === 0) {
                  throw new Error('Empty viaText provided, nothing to run');
              }

              var viaTextLength = Module.lengthBytesUTF8(viaText);
              var viaTextPointer = Module.coreHelpers.writeJSStringToHeap(viaText);

              var printText = '',
                  printTextErr = '';
              var origPrint = Module.print,
                  origPrintErr = Module.printErr;

              Module.print = function (text) {
                  printText += text + '\n';
                  origPrint(text);
              };

              Module.printErr = function (textErr) {
                  printTextErr += textErr + '\n';
                  origPrintErr(textErr);
              };

              var result = Module._EggShell_REPL(Module.eggShell.v_userShell, viaTextPointer, viaTextLength);
              Module._free(viaTextPointer);
              Module.print = origPrint;
              Module.printErr = origPrintErr;

              if (result !== 0) {
                  throw new Error('Loading VIA failed for the following reason: ' + niErrorEnum[result] +
                      ' (error code: ' + result + ')' +
                      ' (stdout: ' + printText + ')' +
                      ' (stderr: ' + printTextErr + ')');
              }
          };

          // executeSlicesUntilWait
          // numSlices (optional): The minimum number of slice sets to run before checking if maxTimeMS has passed.
          //    The larger the value the less overhead for execution and the quicker the diagram progresses
          //    One slice set corresponds to 10 slices and at a minimum one slice set executes per invocation
          // millisecondsToRun (optional): The amount of time in milliseconds vireo can execute slice sets before vireo saves state and returns
          // return value (type ExecSlicesResult):
          //     returns < 0 if should be called again ASAP, 0 if nothing to run, or positive value N if okay
          //     to delay up to N milliseconds before calling again
          Module.eggShell.executeSlicesUntilWait = publicAPI.eggShell.executeSlicesUntilWait = function (numSlices, millisecondsToRun) {
              return Module._EggShell_ExecuteSlices(Module.eggShell.v_userShell, numSlices, millisecondsToRun);
          };

          // Pumps vireo asynchronously until the currently loaded via has finished all clumps
          // Runs synchronously for a maximum of 4ms at a time to cooperate with browser and node.js execution environments
          // A good starting point for most vireo uses but can be copied and modified as needed
          // Returns a Promise that is resolved when execution has completed or reject when an error has occurred
          Module.eggShell.executeSlicesUntilClumpsFinished = publicAPI.eggShell.executeSlicesUntilClumpsFinished = function (originalCallback) {
              if (originalCallback !== undefined) {
                  throw new Error('The executeSlicesUntilClumpsFinished function no longer takes a callback and instead returns a Promise');
              }
              // These numbers may still need tuning.  They should also match the numbers in native
              // in CommandLine/main.cpp.  SLICE_SETS was lowered from 100000 because that was starving
              // other clumps and running too long before checking the timer.
              var SLICE_SETS_PER_TIME_CHECK = 10000;
              var MAXIMUM_VIREO_EXECUTION_TIME_MS = 4;
              var origExecuteSlicesWakeUpCallback = Module.eggShell.executeSlicesWakeUpCallback;

              var vireoResolve, vireoReject;
              var executionFinishedPromise = new Promise(function (resolve, reject) {
                  var cleanup = function () {
                      Module.eggShell.executeSlicesWakeUpCallback = origExecuteSlicesWakeUpCallback;
                  };

                  vireoResolve = function () {
                      cleanup();
                      resolve.apply(undefined, arguments);
                  };

                  vireoReject = function () {
                      cleanup();
                      reject.apply(undefined, arguments);
                  };
              });

              var timerToken;
              var runExecuteSlicesAsync = function () {
                  var execSlicesResult;
                  try {
                      execSlicesResult = Module.eggShell.executeSlicesUntilWait(SLICE_SETS_PER_TIME_CHECK, MAXIMUM_VIREO_EXECUTION_TIME_MS);
                  } catch (ex) {
                      timerToken = undefined;
                      setTimeout(vireoReject, 0, ex);
                      return;
                  }

                  if (execSlicesResult > 0) {
                      timerToken = setTimeout(runExecuteSlicesAsync, execSlicesResult);
                  } else if (execSlicesResult < 0) {
                      timerToken = setTimeout(runExecuteSlicesAsync, 0);
                  } else {
                      timerToken = undefined;
                      setTimeout(vireoResolve, 0);
                  }
              };

              Module.eggShell.executeSlicesWakeUpCallback = function () {
                  origExecuteSlicesWakeUpCallback();
                  if (timerToken === undefined) {
                      console.error('Attempted to wake up Vireo runtime but Vireo is not waiting');
                  } else {
                      clearTimeout(timerToken);
                      timerToken = undefined;
                      runExecuteSlicesAsync();
                  }
              };

              // Queue a microtask for starting execution
              Promise.resolve().then(function () {
                  runExecuteSlicesAsync();
              });

              return executionFinishedPromise;
          };

          Module.eggShell.setOccurrenceAsync = function (occurrence) {
              // TODO mraj currently setOccurrenceAsync is only called
              // by relatively slow operation, may need to change from setTimeout
              // to improve performance in the future
              setTimeout(function () {
                  Module._Occurrence_Set(occurrence);
                  Module.eggShell.executeSlicesWakeUpCallback.call(undefined);
              }, 0);
          };

          Module.eggShell.setOccurrence = function (occurrence) {
              Module._Occurrence_Set(occurrence);
          };
      };
  }());
  var assignEggShell$1 = assignEggShell;

  var assignHttpClient;
  (function () {
      // Static Private Variables (all vireo instances)
      var TRUE = 1;
      var FALSE = 0;

      var NULL = 0;

      var DEFAULT_INVALID_HANDLE = 0;

      var ERRORS = {
          // Shared
          NO_ERROR: {
              CODE: 0,
              MESSAGE: ''
          },

          // penguin\lvaddon\errors\osnetwork\trunk\17.0\source\errors.nimxl
          InvalidRefnum: {
              CODE: -1967362020,
              MESSAGE: 'The provided refnum is invalid.'
          },

          // penguin\lvaddon\errors\lv\trunk\17.0\source\errors.nimxl
          mgArgErr: {
              CODE: 1,
              MESSAGE: 'An input parameter is invalid. For example if the input is a path, the path might contain a character not allowed by the OS such as ? or @.'
          },
          ncTimeOutErr: {
              CODE: 56,
              MESSAGE: 'The network operation exceeded the user-specified or system time limit.'
          },
          kNIHttpResultCouldNotConnect: {
              CODE: 363500,
              MESSAGE: 'Failed to connect to the specified hostname.  Be sure the specified hostname is correct, the server is running and configured to accept remote requests.'
          },
          kNIHttpResultAbortedByCallback: {
              CODE: 363508,
              MESSAGE: 'The request was aborted by the caller.'
          },
          kNIHttpResultRequestHeaderDoesNotExist: {
              CODE: 363528,
              MESSAGE: 'The specified request header does not exist.'
          },

          kNIHttpWebVINetworkError: {
              CODE: 363650,
              MESSAGE: 'A network error has occurred. Possible reasons for this error include Cross-Origin Resource Sharing (CORS) configuration issues between the client and the target server or that the client cannot reach the target server. Due to browser security restrictions, detailed information about the cause of the network error cannot be provided. You may find specific details about the cause of the network error in the browser development tools console or in the LabVIEW output window.'
          },
          kNIHttpWebVIHeaderInvalid: {
              CODE: 363651,
              MESSAGE: 'Setting a header or header value resulted in an error, possibly due to an invalid character in a header or header value. Verify that each header and header value contains only valid characters.'
          },
          kNIHttpWebVICookieFileUnsupported: {
              CODE: 363652,
              MESSAGE: 'This target does not support modification of the cookie file input. The browser manages saving cookies from an HTTP response and including cookies in HTTP requests on behalf of the user. The HTTP Client VIs cannot manipulate cookies directly. Set the cookie file input as either Not a path or an empty path for this target.'
          },
          kNIHttpWebVIVerifyServerUnsupported: {
              CODE: 363653,
              MESSAGE: 'This target does not support modification of the verify server input. The browser manages settings related to validation of a server\'s identity and establishing secure connections. Set the verify server input to True for this target.'
          },
          kNIHttpWebVIOutputFileUnsupported: {
              CODE: 363654,
              MESSAGE: 'This target does not support usage of an output file. Set output file as either Not a path or an empty path for this target.'
          },
          kNIHttpCORSNotRequired: {
              CODE: 363655,
              MESSAGE: 'This target is not subject to Cross-Origin Resource Sharing (CORS) restrictions and cannot perform CORS configuration. Do not attempt to perform CORS configuration on this target.'
          },
          kNIHttpWebVIProxyConfigUnsupported: {
              CODE: 363656,
              MESSAGE: 'This target does not support proxy server configuration using the HTTP Client VIs. The host browser or environment must be configured directly to change proxy server settings. Do not attempt to perform proxy server configuration on this target.'
          },
          kNIHttpWebVISSLConfigUnsupported: {
              CODE: 363657,
              MESSAGE: 'This target does not support SSL configuration using the HTTP Client VIs. The host browser or environment must be configured directly to change SSL settings. Do not attempt to perform SSL configuration on this target.'
          },

          kNIHttpResultInternalUndefinedError: {
              CODE: 363798,
              MESSAGE: 'The HTTP client produced an unknown error.'
          }
      };

      var DEFAULT_TIMEOUT_MS = 10000;
      var TIMEOUT_IMMEDIATELY_MS = 1;

      var RunningRequestsTracker;
      (function () {
          // Static private reference aliases
          // None

          // Constructor Function
          RunningRequestsTracker = function () {
              // Public Instance Properties
              // None

              // Private Instance Properties
              this._runningRequests = [];
          };

          // Static Public Variables
          // None

          // Static Public Functions
          // None

          // Prototype creation
          var child = RunningRequestsTracker;
          var proto = child.prototype;

          // Static Private Variables
          // None

          // Static Private Functions
          // None

          // Public Prototype Methods
          proto.addRequest = function (request) {
              this._runningRequests.push(request);
          };

          proto.removeRequest = function (request) {
              var index = this._runningRequests.indexOf(request);
              if (index > -1) {
                  this._runningRequests.splice(index, 1);
              }
          };

          proto.abortAllRunningRequests = function () {
              // Abort event handlers seem to run synchronously
              // So run on a copy to prevent mutating while aborting
              var runningRequestsCopy = this._runningRequests.slice();
              runningRequestsCopy.forEach(function (request) {
                  request.abort();
              });
          };
      }());

      var HttpClient;
      (function () {
          // Static private reference aliases
          // None

          // Constructor Function
          HttpClient = function (username, password, requestTracker, xmlHttpRequestImplementation) {
              // Public Instance Properties
              // None

              // Private Instance Properties
              this._username = username;
              this._password = password;
              this._headers = new Map();
              this._includeCredentialsDuringCORS = false;
              this._requestTracker = requestTracker;
              this._xmlHttpRequestImplementation = xmlHttpRequestImplementation;
          };

          // Static Public Variables
          // None

          // Static Public Functions
          // None

          // Prototype creation
          var child = HttpClient;
          var proto = child.prototype;

          // Static Private Variables
          // None

          // Static Private Functions
          // None

          // Public Prototype Methods
          proto.addHeader = function (header, value) {
              this._headers.set(header, value);
          };

          proto.removeHeader = function (header) {
              this._headers.delete(header);
          };

          // Returns the header with whitespace trimmed if found or undefined if not found
          proto.getHeaderValue = function (header) {
              var ret;

              if (this._headers.has(header)) {
                  ret = this._headers.get(header).trim();
              }

              return ret;
          };

          proto.listHeaders = function () {
              var outputHeaders = [];

              this._headers.forEach(function (value, header) {
                  outputHeaders.push(header.trim() + ': ' + value.trim());
              });

              // Avoid a trailing \r\n append
              return outputHeaders.join('\r\n');
          };

          proto.createRequest = function (requestData, cb) {
              var that = this;
              var XMLHttpRequestImplementation = that._xmlHttpRequestImplementation;
              var errorMessage;
              var emptyBody = new Uint8Array(0);
              var request = new XMLHttpRequestImplementation();

              // Save a reference to the request
              that._requestTracker.addRequest(request);

              // Create event listeners
              var eventListeners = {};

              // Even though we are rigorous with removing event listeners there is at least one case where completeRequest will be run twice
              // In legacy browsers if a bad url is provided the send() function will throw an error triggering a catch statement in addition to the error event handler
              // However, only in legacy browsers will the error event handler run before the catch statement
              // So while most browsers will completeRequest in the catch statement and remove the event handlers to prevent further triggers,
              // legacy browsers will run the error event handler first to completeRequest and then attempt to completeRequest again in the catch statement
              // So begrudgingly a requestCompleted flag is added to prevent multiple calls of completeRequest.
              // This flag is no longer required.
              var requestCompleted = false;

              var completeRequest = function (responseData) {
                  // Make sure completeRequest is not called twice
                  if (requestCompleted === true) {
                      return;
                  }
                  requestCompleted = true;

                  // Unregister event listeners
                  Object.keys(eventListeners).forEach(function (eventName) {
                      request.removeEventListener(eventName, eventListeners[eventName]);
                  });

                  // Remove reference to complete request
                  that._requestTracker.removeRequest(request);

                  cb(responseData);
              };

              // load, error, timeout, and abort are mutually exclusive and one will fire after send
              // See https://xhr.spec.whatwg.org/#suggested-names-for-events-using-the-progressevent-interface
              eventListeners.load = function () {
                  // A status code of 0 is an invalid status code and indicative of a failure
                  // So far only legacy browsers return a status codes of 0, so this check is no longer needed.
                  if (request.status === 0) {
                      completeRequest({
                          header: '',
                          body: emptyBody,
                          status: 0,
                          labviewCode: ERRORS.kNIHttpResultInternalUndefinedError.CODE,
                          errorMessage: ERRORS.kNIHttpResultInternalUndefinedError.MESSAGE,
                          requestException: undefined
                      });
                      return;
                  }

                  // TODO mraj is there a way to get the HTTP version from the request?
                  var httpVersion = 'HTTP/1.1';
                  var statusLine = httpVersion + ' ' + request.status + ' ' + request.statusText + '\r\n';
                  var allResponseHeaders = request.getAllResponseHeaders();

                  var header = statusLine + allResponseHeaders;
                  var body = new Uint8Array(request.response);
                  completeRequest({
                      header: header,
                      body: body,
                      status: request.status,
                      labviewCode: ERRORS.NO_ERROR.CODE,
                      errorMessage: ERRORS.NO_ERROR.MESSAGE,
                      requestException: undefined
                  });
              };

              eventListeners.error = function () {
                  completeRequest({
                      header: '',
                      body: emptyBody,
                      status: 0,
                      labviewCode: ERRORS.kNIHttpWebVINetworkError.CODE,
                      errorMessage: ERRORS.kNIHttpWebVINetworkError.MESSAGE,
                      requestException: undefined
                  });
              };

              // Desktop does not try and return partial response data in timeout scenarios so do not attempt to here
              eventListeners.timeout = function () {
                  completeRequest({
                      header: '',
                      body: emptyBody,
                      status: 0,
                      labviewCode: ERRORS.ncTimeOutErr.CODE,
                      errorMessage: ERRORS.ncTimeOutErr.MESSAGE,
                      requestException: undefined
                  });
              };

              eventListeners.abort = function () {
                  completeRequest({
                      header: '',
                      body: emptyBody,
                      status: 0,
                      labviewCode: ERRORS.kNIHttpResultAbortedByCallback.CODE,
                      errorMessage: ERRORS.kNIHttpResultAbortedByCallback.MESSAGE,
                      requestException: undefined
                  });
              };

              // Register event listeners
              Object.keys(eventListeners).forEach(function (eventName) {
                  request.addEventListener(eventName, eventListeners[eventName]);
              });

              // Open request to set properties
              try {
                  request.open(requestData.method, requestData.url, true, that._username, that._password);
              } catch (ex) {
                  // Spec says open should throw SyntaxError but some browsers seem to throw DOMException.
                  // Instead of trying to detect, always say invalid url and add message to source
                  completeRequest({
                      header: '',
                      body: emptyBody,
                      status: 0,
                      labviewCode: ERRORS.kNIHttpResultCouldNotConnect.CODE,
                      errorMessage: ERRORS.kNIHttpResultCouldNotConnect.MESSAGE,
                      requestException: ex
                  });
                  return;
              }

              // Add request headers
              var currentHeaderName, currentHeaderValue;
              var hasContentType = false;

              try {
                  that._headers.forEach(function (value, header) {
                      currentHeaderName = header;
                      currentHeaderValue = value;

                      request.setRequestHeader(header, value);

                      if (header.toLowerCase() === 'content-type') {
                          hasContentType = true;
                      }
                  });
              } catch (ex) {
                  errorMessage = ERRORS.kNIHttpWebVIHeaderInvalid.MESSAGE + '\nheader:' + currentHeaderName + '\nvalue:' + currentHeaderValue;
                  completeRequest({
                      header: '',
                      body: emptyBody,
                      status: 0,
                      labviewCode: ERRORS.kNIHttpWebVIHeaderInvalid.CODE,
                      errorMessage: errorMessage,
                      requestException: ex
                  });
                  return;
              }

              // Set the Content-Type to application/x-www-form-urlencoded to match the default on Desktop
              // User can add a Content-Type header to override this default
              // Only add the default Content-Type header to requests that include a buffer
              if (hasContentType === false && requestData.buffer !== undefined) {
                  request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
              }

              // withCredentials allows cookies (to be sent / set), HTTP Auth, and TLS Client certs when sending requests Cross Origin
              // See https://w3c.github.io/webappsec-cors-for-developers/#anonymous-requests-or-access-control-allow-origin
              request.withCredentials = that._includeCredentialsDuringCORS;

              // Receive the response as an ArrayBuffer. Relies on the server to send data as UTF-8 encoded text for text transmission.
              request.responseType = 'arraybuffer';

              // In legacy browsers timeout property may only be set after calling open and before calling send, no longer required
              request.timeout = requestData.xhrTimeout;

              // Send request
              // Legacy browsers throw on send() if an invalid url is provided. Spec compliant browsers throw on open() for invalid urls.
              // Not sure if this is the only reason for send to throw, so using more generic network error
              // The exception handling is likely no longer required.
              try {
                  if (requestData.buffer === undefined) {
                      request.send();
                  } else {
                      request.send(requestData.buffer);
                  }
              } catch (ex) {
                  completeRequest({
                      header: '',
                      body: emptyBody,
                      status: 0,
                      labviewCode: ERRORS.kNIHttpWebVINetworkError.CODE,
                      errorMessage: ERRORS.kNIHttpWebVINetworkError.MESSAGE,
                      requestException: ex
                  });
                  return;
              }
          };

          proto.setIncludeCredentialsDuringCORS = function (includeCredentialsDuringCORS) {
              this._includeCredentialsDuringCORS = includeCredentialsDuringCORS;
          };
      }());

      var HttpClientManager;
      (function () {
          // Static private reference aliases
          // None

          // Constructor Function
          HttpClientManager = function () {
              // Public Instance Properties
              // None

              // Private Instance Properties
              this._httpClients = new Map();
              this._runningRequestsTracker = new RunningRequestsTracker();

              if (typeof XMLHttpRequest === 'undefined') {
                  this._xmlHttpRequestImplementation = function () {
                      throw new Error('Vireo could not find a global implementation of XMLHttpRequest Level 2. Please provide one to vireo.httpClient.setXMLHttpRequestImplementation to use the Vireo HTTP Client');
                  };
              } else {
                  this._xmlHttpRequestImplementation = XMLHttpRequest;
              }
          };

          // Static Public Variables
          // None

          // Static Public Functions
          // None

          // Prototype creation
          var child = HttpClientManager;
          var proto = child.prototype;

          // Static Private Variables
          // None

          // Static Private Functions
          var createHandle = (function () {
              // A handle of zero implies an invalid handle
              var currentHandle = 1;

              return function () {
                  var handle = currentHandle;
                  currentHandle += 1;
                  return handle;
              };
          }());

          // Public Prototype Methods
          proto.create = function (username, password) {
              var httpClient = new HttpClient(username, password, this._runningRequestsTracker, this._xmlHttpRequestImplementation);
              var handle = createHandle();

              this._httpClients.set(handle, httpClient);
              return handle;
          };

          proto.createHttpClientWithoutHandle = function (username, password) {
              var httpClient = new HttpClient(username, password, this._runningRequestsTracker, this._xmlHttpRequestImplementation);
              return httpClient;
          };

          proto.destroy = function (handle) {
              var httpClient = this._httpClients.get(handle);
              if (httpClient === undefined) {
                  return;
              }

              // Currently we do not abort any existing requests that were made with this handle
              this._httpClients.delete(handle);
          };

          proto.get = function (handle) {
              return this._httpClients.get(handle);
          };

          proto.abortAllRunningRequests = function () {
              this._runningRequestsTracker.abortAllRunningRequests();
          };

          proto.setXMLHttpRequestImplementation = function (fn) {
              if (typeof fn !== 'function') {
                  throw new Error('A valid function must be provided');
              }

              // This does not have an effect on already instanced HttpClients or running requests, only on new HttpClient instances
              this._xmlHttpRequestImplementation = fn;
          };
      }());

      // Vireo Core Mixin Function
      assignHttpClient = function (Module, publicAPI) {
          Module.httpClient = {};
          publicAPI.httpClient = {};

          // Private Instance Variables (per vireo instance)
          var httpClientManager = new HttpClientManager();

          var METHOD_NAMES = ['GET', 'HEAD', 'PUT', 'POST', 'DELETE'];

          var findhttpClientOrWriteError = function (handle, errorValueRef) {
              var httpClient = httpClientManager.get(handle);
              var newError;

              if (httpClient === undefined) {
                  newError = {
                      status: true,
                      code: ERRORS.mgArgErr.CODE,
                      source: Module.coreHelpers.createSourceFromMessage(ERRORS.mgArgErr.MESSAGE)
                  };

                  Module.coreHelpers.mergeErrors(errorValueRef, newError);
              }

              return httpClient;
          };

          // Exported functions
          publicAPI.httpClient.abortAllRunningRequests = function () {
              httpClientManager.abortAllRunningRequests();
          };

          publicAPI.httpClient.setXMLHttpRequestImplementation = function (fn) {
              httpClientManager.setXMLHttpRequestImplementation(fn);
          };

          // NOTE: All of the Module.js* functions  in this file should be called from Vireo only if there is not an existing error
          // unless otherwise stated in the function below
          Module.httpClient.jsHttpClientOpen = function (
              cookieFileTypeRef, cookieFileDataRef,
              usernameTypeRef, usernameDataRef,
              passwordTypeRef, passwordDataRef,
              verifyServerTypeRef, verifyServerDataRef,
              handleTypeRef, handleDataRef,
              errorTypeRef, errorDataRef) {
              var cookieFileValueRef = Module.eggShell.createValueRef(cookieFileTypeRef, cookieFileDataRef);
              var usernameValueRef = Module.eggShell.createValueRef(usernameTypeRef, usernameDataRef);
              var passwordValueRef = Module.eggShell.createValueRef(passwordTypeRef, passwordDataRef);
              var verifyServerValueRef = Module.eggShell.createValueRef(verifyServerTypeRef, verifyServerDataRef);
              var handleValueRef = Module.eggShell.createValueRef(handleTypeRef, handleDataRef);
              var errorValueRef = Module.eggShell.createValueRef(errorTypeRef, errorDataRef);

              var setDefaultOutputs = function () {
                  Module.eggShell.writeDouble(handleValueRef, DEFAULT_INVALID_HANDLE);
              };

              var newError;
              var cookieFile = Module.eggShell.readString(cookieFileValueRef);
              if (cookieFile !== '') {
                  newError = {
                      status: true,
                      code: ERRORS.kNIHttpWebVICookieFileUnsupported.CODE,
                      source: Module.coreHelpers.createSourceFromMessage(ERRORS.kNIHttpWebVICookieFileUnsupported.MESSAGE)
                  };

                  Module.coreHelpers.mergeErrors(errorValueRef, newError);
                  setDefaultOutputs();
                  return;
              }

              var verifyServer = Module.eggShell.readDouble(verifyServerValueRef) !== FALSE;
              if (verifyServer !== true) {
                  newError = {
                      status: true,
                      code: ERRORS.kNIHttpWebVIVerifyServerUnsupported.CODE,
                      source: Module.coreHelpers.createSourceFromMessage(ERRORS.kNIHttpWebVIVerifyServerUnsupported.MESSAGE)
                  };

                  Module.coreHelpers.mergeErrors(errorValueRef, newError);
                  setDefaultOutputs();
                  return;
              }

              var username = Module.eggShell.readString(usernameValueRef);
              var password = Module.eggShell.readString(passwordValueRef);
              var newHandle = httpClientManager.create(username, password);
              Module.eggShell.writeDouble(handleValueRef, newHandle);
          };

          Module.httpClient.jsHttpClientClose = function (
              handleTypeRef, handleDataRef,
              errorTypeRef, errorDataRef) {
              // This function should be called irregardless of an existing error to clean-up resources
              var newError;
              var handleValueRef = Module.eggShell.createValueRef(handleTypeRef, handleDataRef);
              var errorValueRef = Module.eggShell.createValueRef(errorTypeRef, errorDataRef);
              var handle = Module.eggShell.readDouble(handleValueRef);
              var handleExists = httpClientManager.get(handle) !== undefined;

              if (handleExists === false) {
                  newError = {
                      status: true,
                      code: ERRORS.InvalidRefnum.CODE,
                      source: Module.coreHelpers.createSourceFromMessage(ERRORS.InvalidRefnum.MESSAGE)
                  };

                  Module.coreHelpers.mergeErrors(errorValueRef, newError);
                  // Do not return if an error is written, need to still destroy any existing handles
              }

              // Always destroy the handle
              httpClientManager.destroy(handle);
          };

          Module.httpClient.jsHttpClientAddHeader = function (
              handleTypeRef, handleDataRef,
              headerTypeRef, headerDataRef,
              valueTypeRef, valueDataRef,
              errorTypeRef, errorDataRef) {
              var handleValueRef = Module.eggShell.createValueRef(handleTypeRef, handleDataRef);
              var headerValueRef = Module.eggShell.createValueRef(headerTypeRef, headerDataRef);
              var valueValueRef = Module.eggShell.createValueRef(valueTypeRef, valueDataRef);
              var errorValueRef = Module.eggShell.createValueRef(errorTypeRef, errorDataRef);

              var handle = Module.eggShell.readDouble(handleValueRef);
              var httpClient = findhttpClientOrWriteError(handle, errorValueRef);
              if (httpClient === undefined) {
                  return;
              }

              var header = Module.eggShell.readString(headerValueRef);
              var value = Module.eggShell.readString(valueValueRef);
              httpClient.addHeader(header, value);
          };

          Module.httpClient.jsHttpClientRemoveHeader = function (
              handleTypeRef, handleDataRef,
              headerTypeRef, headerDataRef,
              errorTypeRef, errorDataRef) {
              var handleValueRef = Module.eggShell.createValueRef(handleTypeRef, handleDataRef);
              var headerValueRef = Module.eggShell.createValueRef(headerTypeRef, headerDataRef);
              var errorValueRef = Module.eggShell.createValueRef(errorTypeRef, errorDataRef);
              var handle = Module.eggShell.readDouble(handleValueRef);
              var httpClient = findhttpClientOrWriteError(handle, errorValueRef);
              if (httpClient === undefined) {
                  return;
              }

              var header = Module.eggShell.readString(headerValueRef);
              httpClient.removeHeader(header);
          };

          Module.httpClient.jsHttpClientGetHeader = function (
              handleTypeRef, handleDataRef,
              headerTypeRef, headerDataRef,
              valueTypeRef, valueDataRef,
              errorTypeRef, errorDataRef) {
              var handleValueRef = Module.eggShell.createValueRef(handleTypeRef, handleDataRef);
              var headerValueRef = Module.eggShell.createValueRef(headerTypeRef, headerDataRef);
              var valueValueRef = Module.eggShell.createValueRef(valueTypeRef, valueDataRef);
              var errorValueRef = Module.eggShell.createValueRef(errorTypeRef, errorDataRef);
              var setDefaultOutputs = function () {
                  Module.eggShell.writeString(valueValueRef, '');
              };
              var handle = Module.eggShell.readDouble(handleValueRef);
              var httpClient = findhttpClientOrWriteError(handle, errorValueRef);
              if (httpClient === undefined) {
                  setDefaultOutputs();
                  return;
              }

              var newError;
              var header = Module.eggShell.readString(headerValueRef);
              var value = httpClient.getHeaderValue(header);
              if (value === undefined) {
                  newError = {
                      status: true,
                      code: ERRORS.kNIHttpResultRequestHeaderDoesNotExist.CODE,
                      source: Module.coreHelpers.createSourceFromMessage(ERRORS.kNIHttpResultRequestHeaderDoesNotExist.MESSAGE + '\nheader:' + header)
                  };

                  Module.coreHelpers.mergeErrors(errorValueRef, newError);
                  setDefaultOutputs();
                  return;
              }

              Module.eggShell.writeString(valueValueRef, value);
          };

          Module.httpClient.jsHttpClientHeaderExists = function (
              handleTypeRef, handleDataRef,
              headerTypeRef, headerDataRef,
              headerExistsTypeRef, headerExistsDataRef,
              valueTypeRef, valueDataRef,
              errorTypeRef, errorDataRef) {
              var handleValueRef = Module.eggShell.createValueRef(handleTypeRef, handleDataRef);
              var headerValueRef = Module.eggShell.createValueRef(headerTypeRef, headerDataRef);
              var headerExistsValueRef = Module.eggShell.createValueRef(headerExistsTypeRef, headerExistsDataRef);
              var valueValueRef = Module.eggShell.createValueRef(valueTypeRef, valueDataRef);
              var errorValueRef = Module.eggShell.createValueRef(errorTypeRef, errorDataRef);
              var setDefaultOutputs = function () {
                  Module.eggShell.writeDouble(headerExistsValueRef, FALSE);
                  Module.eggShell.writeString(valueValueRef, '');
              };
              var handle = Module.eggShell.readDouble(handleValueRef);
              var httpClient = findhttpClientOrWriteError(handle, errorValueRef);
              if (httpClient === undefined) {
                  setDefaultOutputs();
                  return;
              }

              var header = Module.eggShell.readString(headerValueRef);
              var valueOrUndefined = httpClient.getHeaderValue(header);
              var headerExists = valueOrUndefined !== undefined;
              if (headerExists === false) {
                  setDefaultOutputs();
                  return;
              }

              Module.eggShell.writeDouble(headerExistsValueRef, TRUE);
              Module.eggShell.writeString(valueValueRef, valueOrUndefined);
          };

          Module.httpClient.jsHttpClientListHeaders = function (
              handleTypeRef, handleDataRef,
              headerListTypeRef, headerListDataRef,
              errorTypeRef, errorDataRef) {
              var handleValueRef = Module.eggShell.createValueRef(handleTypeRef, handleDataRef);
              var headerListValueRef = Module.eggShell.createValueRef(headerListTypeRef, headerListDataRef);
              var errorValueRef = Module.eggShell.createValueRef(errorTypeRef, errorDataRef);
              var setDefaultOutputs = function () {
                  Module.eggShell.writeString(headerListValueRef, '');
              };
              var handle = Module.eggShell.readDouble(handleValueRef);
              var httpClient = findhttpClientOrWriteError(handle, errorValueRef);
              if (httpClient === undefined) {
                  setDefaultOutputs();
                  return;
              }

              var list = httpClient.listHeaders();
              Module.eggShell.writeString(headerListValueRef, list);
          };

          Module.httpClient.jsHttpClientMethod = function (
              methodId,
              handleTypeRef, handleDataRef,
              urlTypeRef, urlDataRef,
              outputFilePathTypeRef, outputFilePathDataRef,
              bufferTypeRef, bufferDataRef,
              timeoutTypeRef, timeoutDataRef,
              headersTypeRef, headersDataRef,
              bodyTypeRef, bodyDataRef,
              statusCodeTypeRef, statusCodeDataRef,
              errorTypeRef, errorDataRef,
              occurrencePointer) {
              var handleValueRef = Module.eggShell.createValueRef(handleTypeRef, handleDataRef);
              var urlValueRef = Module.eggShell.createValueRef(urlTypeRef, urlDataRef);
              var outputFilePathValueRef = Module.eggShell.createValueRef(outputFilePathTypeRef, outputFilePathDataRef);
              var timeoutValueRef = Module.eggShell.createValueRef(timeoutTypeRef, timeoutDataRef);
              var headersValueRef = Module.eggShell.createValueRef(headersTypeRef, headersDataRef);
              var bodyValueRef = Module.eggShell.createValueRef(bodyTypeRef, bodyDataRef);
              var statusCodeValueRef = Module.eggShell.createValueRef(statusCodeTypeRef, statusCodeDataRef);
              var errorValueRef = Module.eggShell.createValueRef(errorTypeRef, errorDataRef);
              var handle = Module.eggShell.readDouble(handleValueRef);
              var setDefaultOutputs = function () {
                  Module.eggShell.writeString(headersValueRef, '');
                  Module.eggShell.writeDouble(statusCodeValueRef, 0);

                  if (bodyValueRef !== undefined) {
                      Module.eggShell.writeString(bodyValueRef, '');
                  }

                  Module.eggShell.setOccurrenceAsync(occurrencePointer);
              };

              var newError;
              var method = METHOD_NAMES[methodId];

              // Nullable input parameters: handle, outputFile, buffer
              // Nullable output parameter: body

              var outputFile;
              if (outputFilePathValueRef !== undefined) {
                  outputFile = Module.eggShell.readString(outputFilePathValueRef);

                  if (outputFile !== '') {
                      newError = {
                          status: true,
                          code: ERRORS.kNIHttpWebVIOutputFileUnsupported.CODE,
                          source: Module.coreHelpers.createSourceFromMessage(ERRORS.kNIHttpWebVIOutputFileUnsupported.MESSAGE)
                      };

                      Module.coreHelpers.mergeErrors(errorValueRef, newError);
                      setDefaultOutputs();
                      return;
                  }
              }

              var valueRef, buffer, typedArrayBuffer;
              if (bufferDataRef !== NULL) {
                  valueRef = Module.eggShell.createValueRef(bufferTypeRef, bufferDataRef);
                  typedArrayBuffer = Module.eggShell.readTypedArray(valueRef);

                  // Blob API does not exist in node.js
                  if (typeof Blob === 'undefined') {
                      buffer = typedArrayBuffer;
                  } else {
                      // TODO(mraj) would like to use the typed array in all browsers but not supported in iOS with XHR.send
                      // Blob type property not set to determine Content-Type for XHR as Edge seem to ignore it.
                      buffer = new Blob([typedArrayBuffer]);
                  }
              }

              var httpClient;
              if (handle === NULL) {
                  httpClient = httpClientManager.createHttpClientWithoutHandle('', '');
              } else {
                  httpClient = findhttpClientOrWriteError(handle, errorValueRef);
                  if (httpClient === undefined) {
                      setDefaultOutputs();
                      return;
                  }
              }

              var xhrTimeout;
              var timeout;

              if (timeoutValueRef === undefined) {
                  xhrTimeout = DEFAULT_TIMEOUT_MS;
              } else {
                  timeout = Module.eggShell.readDouble(timeoutValueRef);

                  // In LabVIEW timeout -1 means wait forever, in xhr timeout 0 means wait forever
                  if (timeout < 0) {
                      xhrTimeout = 0;
                  } else if (timeout === 0) {
                      xhrTimeout = TIMEOUT_IMMEDIATELY_MS;
                  } else {
                      xhrTimeout = timeout;
                  }
              }

              var url = Module.eggShell.readString(urlValueRef);
              var requestData = {
                  method: method,
                  url: url,
                  xhrTimeout: xhrTimeout,
                  buffer: buffer
              };

              httpClient.createRequest(requestData, function (responseData) {
                  Module.eggShell.writeString(headersValueRef, responseData.header);
                  Module.eggShell.writeDouble(statusCodeValueRef, responseData.status);

                  if (bodyValueRef !== undefined) {
                      Module.eggShell.resizeArray(bodyValueRef, [responseData.body.length]);
                      Module.eggShell.writeTypedArray(bodyValueRef, responseData.body);
                  }

                  var errorMessage = Module.coreHelpers.formatMessageWithException(responseData.errorMessage, responseData.requestException);
                  var newError = {
                      status: responseData.labviewCode !== ERRORS.NO_ERROR.CODE,
                      code: responseData.labviewCode,
                      source: Module.coreHelpers.createSourceFromMessage(errorMessage)
                  };

                  Module.coreHelpers.mergeErrors(errorValueRef, newError);
                  Module.eggShell.setOccurrenceAsync(occurrencePointer);
              });
          };

          Module.httpClient.jsHttpClientConfigCORS = function (
              handleTypeRef, handleDataRef,
              includeCredentialsDuringCORSTypeRef, includeCredentialsDuringCORSDataRef,
              errorTypeRef, errorDataRef) {
              var handleValueRef = Module.eggShell.createValueRef(handleTypeRef, handleDataRef);
              var includeCredentialsDuringCORSValueRef = Module.eggShell.createValueRef(includeCredentialsDuringCORSTypeRef, includeCredentialsDuringCORSDataRef);
              var errorValueRef = Module.eggShell.createValueRef(errorTypeRef, errorDataRef);
              var handle = Module.eggShell.readDouble(handleValueRef);
              var includeCredentialsDuringCORS = Module.eggShell.readDouble(includeCredentialsDuringCORSValueRef) !== FALSE;
              var httpClient = findhttpClientOrWriteError(handle, errorValueRef);
              if (httpClient === undefined) {
                  return;
              }
              httpClient.setIncludeCredentialsDuringCORS(includeCredentialsDuringCORS);
          };
      };
  }());
  var assignHttpClient$1 = assignHttpClient;

  var assignJavaScriptInvoke;
  (function () {
      // Static Private Variables (all vireo instances)
      var ERRORS = {
          // Shared
          NO_ERROR: {
              CODE: 0,
              MESSAGE: ''
          },

          kNIUnableToInvokeAJavaScriptFunction: {
              CODE: 44300,
              MESSAGE: 'An exception occurred within the external JavaScript function called by a JavaScript Library Interface node. Verify your JavaScript code is valid.'
          },

          kNIUnsupportedParameterTypeInJavaScriptInvoke: undefined, // Code 44301 no longer used. Unsupported LabVIEW parameter types now result in runtime exception.

          kNIUnableToFindFunctionForJavaScriptInvoke: {
              CODE: 44302,
              MESSAGE: 'Function not found. Verify the function name in the external JavaScript file matches the function name in the JavaScript Library Interface.'
          },

          kNIUnableToSetReturnValueInJavaScriptInvoke: {
              CODE: 44303,
              MESSAGE: 'Unable to set return value for JavaScript Library Interface node parameter.'
          },

          kNIUnsupportedLabVIEWReturnTypeInJavaScriptInvoke: undefined, // Code 44305 no longer used. Unsupported LabVIEW return types now result in runtime exception.

          kNITypeMismatchForReturnTypeInJavaScriptInvoke: {
              CODE: 44306,
              MESSAGE: 'Return type mismatch. Verify the return type in the JavaScript Library Interface matches the return type in the external JavaScript function.'
          },

          kNIUnableToHandlePromise: {
              CODE: 44307,
              MESSAGE: 'Unable to use Promise. Verify that the getCompletionCallback API function is not used in the external JavaScript function with a Promise return value.'
          },

          kNIUnableToAcceptReturnValueDuringAsync: {
              CODE: 44308,
              MESSAGE: 'Unable to set return value after call to getCompletionCallback API function. Verify return value is provided to the completion callback and not returned.'
          }
      };

      // Vireo Core Mixin Function
      assignJavaScriptInvoke = function (Module, publicAPI) {
          Module.javaScriptInvoke = {};
          publicAPI.javaScriptInvoke = {};

          // Private Instance Variables (per vireo instance)
          var internalFunctionsMap = new Map();

          var mergeNewError = function (errorValueRef, functionName, errorToSet, exception) {
              var newError = {
                  status: true,
                  code: undefined,
                  source: undefined
              };
              var messageWithException = Module.coreHelpers.formatMessageWithException(errorToSet.MESSAGE + '\nfunction: ' + functionName, exception);
              newError.source = Module.coreHelpers.createSourceFromMessage(messageWithException);
              newError.code = errorToSet.CODE;
              Module.coreHelpers.mergeErrors(errorValueRef, newError);
          };

          var createValueRefFromPointerArray = function (pointerArray, index) {
              var typeRef = Module._JavaScriptInvoke_GetParameterTypeRef(pointerArray, index);
              var dataRef = Module._JavaScriptInvoke_GetParameterDataRef(pointerArray, index);
              var returnValueRef = Module.eggShell.createValueRef(typeRef, dataRef);
              return returnValueRef;
          };

          var cookieToJsValueMap = new Map();
          var jsValueToCookieCache = new Map();
          var jsRefNumCookieCounter = 0;

          var cacheRefNum = function (cookie, jsValue) {
              cookieToJsValueMap.set(cookie, jsValue);
              jsValueToCookieCache.set(jsValue, cookie);
          };

          var hasCachedRefNum = function (cookie) {
              var refNumExists = cookieToJsValueMap.has(cookie);
              if (!refNumExists && cookie !== 0) {
                  throw new Error('RefNum cookie should be 0 if refnum has not been set yet.');
              }
              return refNumExists;
          };

          var getCachedRefNumCookie = function (jsValue) {
              return jsValueToCookieCache.get(jsValue);
          };

          var generateUniqueRefNumCookie = function () {
              jsRefNumCookieCounter += 1;
              return jsRefNumCookieCounter;
          };

          Module.javaScriptInvoke.readJavaScriptRefNum = function (javaScriptValueRef) {
              var cookie = Module.eggShell.readDouble(javaScriptValueRef);
              return cookieToJsValueMap.get(cookie);
          };

          /**
           * Write JS value to a JS reference local
           * @param javaScriptValueRef VIA local for this JS reference
           * @param jsValue the JS value to associate with an existing or new cookie
           * Static reference (Static control reference) shares cookie for the same jsValue.
           * Dynamic reference (JS opaque reference from JSLI) always creates a new cookie even for the same jsValue.
           */
          Module.javaScriptInvoke.writeJavaScriptRefNum = function (javaScriptValueRef, jsValue) {
              var isStaticReference = Module.typeHelpers.isJSObjectStaticRefnum(javaScriptValueRef.typeRef);
              if (isStaticReference) { // static reference (ie, control reference) shares cookie for the same jsValue
                  var cachedCookie = getCachedRefNumCookie(jsValue);
                  if (cachedCookie !== undefined) {
                      Module.eggShell.writeDouble(javaScriptValueRef, cachedCookie); // set the VIA local to be this cookie value
                      return;
                  }
              }

              var newCookie = generateUniqueRefNumCookie();
              Module.eggShell.writeDouble(javaScriptValueRef, newCookie);
              cacheRefNum(newCookie, jsValue);
          };

          var createJavaScriptInvokeParameterValueVisitor = function () {
              var visitNumeric = function (valueRef) {
                  return Module.eggShell.readDouble(valueRef);
              };

              return {
                  visitInt8: visitNumeric,
                  visitInt16: visitNumeric,
                  visitInt32: visitNumeric,
                  visitUInt8: visitNumeric,
                  visitUInt16: visitNumeric,
                  visitUInt32: visitNumeric,
                  visitSingle: visitNumeric,
                  visitDouble: visitNumeric,
                  visitBoolean: function (valueRef) {
                      return Module.eggShell.readDouble(valueRef) !== 0;
                  },

                  visitString: function (valueRef) {
                      return Module.eggShell.readString(valueRef);
                  },

                  visitArray: function (valueRef) {
                      return Module.eggShell.readTypedArray(valueRef);
                  },

                  visitJSObjectRefnum: function (valueRef) {
                      return Module.eggShell.readJavaScriptRefNum(valueRef);
                  }
              };
          };

          var parameterValueVisitor = createJavaScriptInvokeParameterValueVisitor();

          var createJavaScriptInvokeReturnValueVisitor = function () {
              var reportReturnSetException = function (fn) {
                  return function (valueRef, data) {
                      try {
                          fn(valueRef, data);
                      } catch (ex) {
                          // Internal check not needed because poker is not used for internal calls
                          mergeNewError(data.errorValueRef, data.functionName, ERRORS.kNIUnableToSetReturnValueInJavaScriptInvoke, ex);
                      }
                  };
              };

              var reportTypeMismatch = function (data) {
                  // Internal check not needed because poker is not used for internal calls
                  mergeNewError(data.errorValueRef, data.functionName, ERRORS.kNITypeMismatchForReturnTypeInJavaScriptInvoke);
              };

              var visitNumeric = reportReturnSetException(function (valueRef, data) {
                  if (typeof data.returnValue !== 'number') {
                      reportTypeMismatch(data);
                      return;
                  }
                  Module.eggShell.writeDouble(valueRef, data.returnValue);
              });

              return {
                  visitInt8: visitNumeric,
                  visitInt16: visitNumeric,
                  visitInt32: visitNumeric,
                  visitUInt8: visitNumeric,
                  visitUInt16: visitNumeric,
                  visitUInt32: visitNumeric,
                  visitSingle: visitNumeric,
                  visitDouble: visitNumeric,
                  visitBoolean: reportReturnSetException(function (valueRef, data) {
                      if (typeof data.returnValue !== 'boolean') {
                          reportTypeMismatch(data);
                          return;
                      }
                      Module.eggShell.writeDouble(valueRef, data.returnValue ? 1 : 0);
                  }),

                  visitString: reportReturnSetException(function (valueRef, data) {
                      if (typeof data.returnValue !== 'string') {
                          reportTypeMismatch(data);
                          return;
                      }
                      Module.eggShell.writeString(valueRef, data.returnValue);
                  }),

                  visitArray: reportReturnSetException(function (valueRef, data) {
                      if (!Module.eggShell.isSupportedAndCompatibleArrayType(valueRef, data.returnValue)) {
                          reportTypeMismatch(data);
                          return;
                      }
                      Module.eggShell.resizeArray(valueRef, [data.returnValue.length]);
                      Module.eggShell.writeTypedArray(valueRef, data.returnValue);
                  }),

                  visitJSObjectRefnum: reportReturnSetException(function (valueRef, data) {
                      Module.eggShell.writeJavaScriptRefNum(valueRef, data.returnValue);
                  })
              };
          };

          var returnValueVisitor = createJavaScriptInvokeReturnValueVisitor();

          var findJavaScriptFunctionToCall = function (functionName, isInternalFunction) {
              if (isInternalFunction) {
                  return {
                      functionToCall: internalFunctionsMap.get(functionName),
                      context: undefined
                  };
              }
              var names = functionName.split('.');
              var jsSelfScope = typeof self !== 'undefined' ? self : {};
              var jsGlobalScope = typeof global !== 'undefined' ? global : jsSelfScope;
              var context = typeof window !== 'undefined' ? window : jsGlobalScope;
              var functionToCall = context[names[0]];
              var namesIndex;
              for (namesIndex = 1; namesIndex < names.length; namesIndex += 1) {
                  if (functionToCall === undefined) {
                      break;
                  }

                  context = functionToCall;
                  functionToCall = context[names[namesIndex]];
              }
              if (typeof functionToCall !== 'function') {
                  functionToCall = undefined;
                  context = undefined;
              }
              return {
                  functionToCall: functionToCall,
                  context: context
              };
          };

          var addToJavaScriptParametersArray = function (parameters, isInternalFunction, parametersPointer, parametersCount) {
              var parametersArraySize = parameters.length;
              for (var index = 0; index < parametersCount; index += 1) {
                  var parameterValueRef = createValueRefFromPointerArray(parametersPointer, index);
                  if (isInternalFunction) {
                      parameters[parametersArraySize + index] = parameterValueRef;
                  } else {
                      // Inputs are always wired for user calls so if this errors because parameterValueRef is undefined then we have DFIR issues
                      parameters[parametersArraySize + index] = Module.eggShell.reflectOnValueRef(parameterValueVisitor, parameterValueRef);
                  }
              }
              return parameters;
          };

          var completionCallbackRetrievalEnum = {
              AVAILABLE: 'AVAILABLE',
              RETRIEVED: 'RETRIEVED',
              UNRETRIEVABLE: 'UNRETRIEVABLE'
          };
          var completionCallbackInvocationEnum = {
              PENDING: 'PENDING',
              FULFILLED: 'FULFILLED',
              REJECTED: 'REJECTED'
          };

          var coerceToError = function (returnValue) {
              if (returnValue instanceof Error === false) {
                  return new Error(returnValue);
              }
              return returnValue;
          };

          var hasExecutionError = function (returnValue) {
              return returnValue instanceof Error;
          };

          var reportExecutionError = function (functionName, returnValue, errorValueRef, completionCallbackStatus, isInternalFunction) {
              if (!hasExecutionError(returnValue)) {
                  return;
              }
              if (isInternalFunction) {
                  // TODO mraj because this can happen asynchronously we may end up not actually
                  // stopping the runtime on throw. It would be helpful to have JS api function
                  // to abort the runtime at this point. https://github.com/ni/VireoSDK/issues/521
                  throw returnValue;
              }

              mergeNewError(errorValueRef, functionName, ERRORS.kNIUnableToInvokeAJavaScriptFunction, returnValue);
              completionCallbackStatus.retrievalState = completionCallbackRetrievalEnum.UNRETRIEVABLE;
              completionCallbackStatus.invocationState = completionCallbackInvocationEnum.REJECTED;
          };

          var updateReturnValue = function (functionName, returnValueRef, returnValue, errorValueRef, completionCallbackStatus, isInternalFunction) {
              if (isInternalFunction) {
                  if (returnValue !== undefined) {
                      throw new Error('Unexpected return value, internal functions should update return values through api functions instead of relying on return values');
                  }
                  return;
              }

              // The returnValueRef is undefined if we're passing '*' for return parameter in VIA code
              var data;
              if (returnValueRef !== undefined) {
                  data = {
                      returnValue: returnValue,
                      errorValueRef: errorValueRef,
                      functionName: functionName
                  };
                  Module.eggShell.reflectOnValueRef(returnValueVisitor, returnValueRef, data);
              }

              // We don't reflect write errors back on the completionCallbackStatus,
              // so regardless of write errors at this point the completionCallback is fullfilled
              completionCallbackStatus.retrievalState = completionCallbackRetrievalEnum.UNRETRIEVABLE;
              completionCallbackStatus.invocationState = completionCallbackInvocationEnum.FULFILLED;
          };

          var generateCompletionCallback = function (occurrencePointer, functionName, returnValueRef, errorValueRef, completionCallbackStatus, isInternalFunction) {
              var completionCallback = function (returnValue) {
                  // The following checks are not LabVIEW errors because they may happen after JavaScriptInvoke completion finishes if user holds reference
                  if (completionCallbackStatus.invocationState === completionCallbackInvocationEnum.FULFILLED) {
                      throw new Error(`The completion callback was invoked more than once for ${functionName}.`);
                  }
                  if (completionCallbackStatus.invocationState === completionCallbackInvocationEnum.REJECTED) {
                      throw new Error(`The call to ${functionName} threw an error, so this callback cannot be invoked.`);
                  }

                  if (hasExecutionError(returnValue)) {
                      reportExecutionError(functionName, returnValue, errorValueRef, completionCallbackStatus, isInternalFunction);
                      Module.eggShell.setOccurrenceAsync(occurrencePointer);
                      return;
                  }

                  updateReturnValue(functionName, returnValueRef, returnValue, errorValueRef, completionCallbackStatus, isInternalFunction);
                  Module.eggShell.setOccurrenceAsync(occurrencePointer);
                  return;
              };
              return completionCallback;
          };

          var generateAPI = function (occurrencePointer, functionName, returnValueRef, errorValueRef, completionCallbackStatus, isInternalFunction) {
              var api = {};
              api.getCompletionCallback = function () {
                  // The following checks are not LabVIEW errors because they may happen after JavaScriptInvoke completion finishes if user holds reference
                  if (completionCallbackStatus.retrievalState === completionCallbackRetrievalEnum.RETRIEVED) {
                      throw new Error(`The completion callback was retrieved more than once for ${functionName}.`);
                  }
                  if (completionCallbackStatus.retrievalState === completionCallbackRetrievalEnum.UNRETRIEVABLE) {
                      throw new Error(`The API being accessed for ${functionName} is not valid anymore.`);
                  }
                  completionCallbackStatus.retrievalState = completionCallbackRetrievalEnum.RETRIEVED;
                  return generateCompletionCallback(occurrencePointer, functionName, returnValueRef, errorValueRef, completionCallbackStatus, isInternalFunction);
              };

              if (isInternalFunction) {
                  api.setLabVIEWError = function (status, code, source) {
                      var newError = {
                          status: status,
                          code: code,
                          source: source
                      };
                      Module.coreHelpers.mergeErrors(errorValueRef, newError);
                  };
              }
              return api;
          };

          publicAPI.javaScriptInvoke.registerInternalFunctions = function (functionsToAdd) {
              Object.keys(functionsToAdd).forEach(function (name) {
                  if (internalFunctionsMap.has(name)) {
                      throw new Error(`Internal function already registered for name:${name}`);
                  }
                  if (typeof functionsToAdd[name] !== 'function') {
                      throw new Error(`Cannot add non-function ${name} as a function.`);
                  }
                  internalFunctionsMap.set(name, functionsToAdd[name]);
              });
          };

          Module.javaScriptInvoke.jsJavaScriptInvoke = function (
              occurrencePointer,
              functionNameTypeRef,
              functionNameDataRef,
              returnPointer,
              parametersPointer,
              parametersCount,
              isInternalFunctionIn,
              errorTypeRef,
              errorDataRef) {
              var isInternalFunction = isInternalFunctionIn !== 0;
              var errorValueRef = Module.eggShell.createValueRef(errorTypeRef, errorDataRef);
              var functionNameValueRef = Module.eggShell.createValueRef(functionNameTypeRef, functionNameDataRef);
              var functionName = Module.eggShell.readString(functionNameValueRef);
              var parameters = [];

              var returnValueRef = createValueRefFromPointerArray(returnPointer, 0);
              if (isInternalFunction) {
                  parameters.push(returnValueRef);
              }

              addToJavaScriptParametersArray(parameters, isInternalFunction, parametersPointer, parametersCount);

              var functionAndContext = findJavaScriptFunctionToCall(functionName, isInternalFunction);
              var functionToCall = functionAndContext.functionToCall;
              var context = functionAndContext.context;
              if (functionToCall === undefined) {
                  if (isInternalFunction) {
                      throw new Error(`Unable to find internal JS function: ${functionName}`);
                  }
                  mergeNewError(errorValueRef, functionName, ERRORS.kNIUnableToFindFunctionForJavaScriptInvoke);
                  Module.eggShell.setOccurrence(occurrencePointer);
                  return;
              }

              var completionCallbackStatus = {
                  retrievalState: completionCallbackRetrievalEnum.AVAILABLE,
                  invocationState: completionCallbackInvocationEnum.PENDING
              };

              var jsapi;
              if (isInternalFunction || functionToCall.length === parameters.length + 1) {
                  jsapi = generateAPI(occurrencePointer, functionName, returnValueRef, errorValueRef, completionCallbackStatus, isInternalFunction);
                  parameters.push(jsapi);
              }

              var returnValue;
              try {
                  returnValue = functionToCall.apply(context, parameters);
              } catch (ex) {
                  returnValue = coerceToError(ex);
              }

              if (hasExecutionError(returnValue)) {
                  reportExecutionError(functionName, returnValue, errorValueRef, completionCallbackStatus, isInternalFunction);
                  Module.eggShell.setOccurrence(occurrencePointer);
                  return;
              }

              var completionCallback;
              if (returnValue instanceof Promise) {
                  if (completionCallbackStatus.retrievalState !== completionCallbackRetrievalEnum.AVAILABLE) {
                      if (isInternalFunction) {
                          throw new Error('Promise returned but completionCallback unavailable. Possible reason is using getCompletionCallback when returning a promise');
                      }
                      mergeNewError(errorValueRef, functionName, ERRORS.kNIUnableToHandlePromise);
                      completionCallbackStatus.retrievalState = completionCallbackRetrievalEnum.UNRETRIEVABLE;
                      completionCallbackStatus.invocationState = completionCallbackInvocationEnum.FULFILLED;
                      Module.eggShell.setOccurrence(occurrencePointer);
                      return;
                  }

                  if (jsapi === undefined) {
                      jsapi = generateAPI(occurrencePointer, functionName, returnValueRef, errorValueRef, completionCallbackStatus, isInternalFunction);
                  }

                  completionCallback = jsapi.getCompletionCallback();
                  returnValue.then(completionCallback).catch((returnValue) => completionCallback(coerceToError(returnValue)));
                  // Do not setOccurrence when returning here since waiting asynchronously for user Promise to resolve
                  return;
              }

              // synchronous invocation since the completion callback was never retrieved by the user
              if (completionCallbackStatus.retrievalState === completionCallbackRetrievalEnum.AVAILABLE) {
                  updateReturnValue(functionName, returnValueRef, returnValue, errorValueRef, completionCallbackStatus, isInternalFunction);
                  Module.eggShell.setOccurrence(occurrencePointer);
                  return;
              }

              // for async execution check that user did not provide a return value
              if (returnValue !== undefined) {
                  if (isInternalFunction) {
                      throw new Error('Unexpected return value for function requiring asynchronous completion');
                  }
                  mergeNewError(errorValueRef, functionName, ERRORS.kNIUnableToAcceptReturnValueDuringAsync);
                  completionCallbackStatus.retrievalState = completionCallbackRetrievalEnum.UNRETRIEVABLE;
                  completionCallbackStatus.invocationState = completionCallbackInvocationEnum.FULFILLED;
                  Module.eggShell.setOccurrence(occurrencePointer);
                  return;
              }

              // at this point user retrieved getCompletionCallback so we wait for completion
          };

          Module.javaScriptInvoke.jsIsNotAJavaScriptRefnum = function (javaScriptRefnumTypeRef, javaScriptRefnumDataRef, returnTypeRef, returnDataRef) {
              var javaScriptRefNumValueRef = Module.eggShell.createValueRef(javaScriptRefnumTypeRef, javaScriptRefnumDataRef);
              var returnValueRef = Module.eggShell.createValueRef(returnTypeRef, returnDataRef);
              var cookie = Module.eggShell.readDouble(javaScriptRefNumValueRef);
              var isNotAJavaScriptRefnum = !hasCachedRefNum(cookie);
              Module.eggShell.writeDouble(returnValueRef, isNotAJavaScriptRefnum ? 1 : 0);
          };
      };
  }());
  var assignJavaScriptInvoke$1 = assignJavaScriptInvoke;

  var assignPropertyNode;
  (function () {
      // Static Private Variables (all vireo instances)
      var ERRORS = {
          // Shared
          NO_ERROR: {
              CODE: 0,
              MESSAGE: ''
          },

          kNIObjectReferenceIsInvalid: {
              CODE: 1055,
              MESSAGE: 'Object reference is invalid.'
          }
      };

      // Vireo Core Mixin Function
      assignPropertyNode = function (Module, publicAPI) {
          Module.propertyNode = {};
          publicAPI.propertyNode = {};

          var readProperty = function () {
              // Dummy no-op function.
          };

          var writeProperty = function () {
              // Dummy no-op function.
          };

          // Private Instance Variables (per vireo instance)
          Module.propertyNode.jsPropertyNodeWrite = function (
              viNamePointer,
              controlIdPointer,
              propertyNamePointer,
              tempVariableTypePointer,
              tempVariableDataPointer,
              errorTypePointer,
              errorDataPointer) {
              var newError = {
                  status: false,
                  code: ERRORS.NO_ERROR.CODE,
                  source: ERRORS.NO_ERROR.MESSAGE
              };

              var viName = Module.eggShell.dataReadString(viNamePointer);
              var controlId = Module.eggShell.dataReadString(controlIdPointer);
              var propertyName = Module.eggShell.dataReadString(propertyNamePointer);
              var valueRef = Module.eggShell.createValueRef(tempVariableTypePointer, tempVariableDataPointer);
              var errorValueRef = Module.eggShell.createValueRef(errorTypePointer, errorDataPointer);

              try {
                  writeProperty(viName, controlId, propertyName, valueRef);
              } catch (ex) {
                  newError.status = true;
                  newError.code = ERRORS.kNIObjectReferenceIsInvalid.CODE;
                  newError.source = Module.coreHelpers.formatMessageWithException(ERRORS.kNIObjectReferenceIsInvalid.MESSAGE, ex);
                  newError.source = Module.coreHelpers.createSourceFromMessage(newError.source);
                  Module.coreHelpers.mergeErrors(errorValueRef, newError);
                  return;
              }
          };

          Module.propertyNode.jsPropertyNodeRead = function (
              viNamePointer,
              controlIdPointer,
              propertyNamePointer,
              tempVariableTypePointer,
              tempVariableDataPointer,
              errorTypePointer,
              errorDataPointer) {
              var newError = {
                  status: false,
                  code: ERRORS.NO_ERROR.CODE,
                  source: ERRORS.NO_ERROR.MESSAGE
              };

              var viName = Module.eggShell.dataReadString(viNamePointer);
              var controlId = Module.eggShell.dataReadString(controlIdPointer);
              var propertyName = Module.eggShell.dataReadString(propertyNamePointer);
              var valueRef = Module.eggShell.createValueRef(tempVariableTypePointer, tempVariableDataPointer);
              var errorValueRef = Module.eggShell.createValueRef(errorTypePointer, errorDataPointer);

              try {
                  readProperty(viName, controlId, propertyName, valueRef);
              } catch (ex) {
                  newError.status = true;
                  newError.code = ERRORS.kNIObjectReferenceIsInvalid.CODE;
                  newError.source = Module.coreHelpers.formatMessageWithException(ERRORS.kNIObjectReferenceIsInvalid.MESSAGE, ex);
                  newError.source = Module.coreHelpers.createSourceFromMessage(newError.source);
                  Module.coreHelpers.mergeErrors(errorValueRef, newError);
                  return;
              }
          };

          publicAPI.propertyNode.setPropertyReadFunction = Module.propertyNode.setPropertyReadFunction = function (fn) {
              if (typeof fn !== 'function') {
                  throw new Error('PropertyRead must be a callable function');
              }

              readProperty = fn;
          };

          publicAPI.propertyNode.setPropertyWriteFunction = Module.propertyNode.setPropertyWriteFunction = function (fn) {
              if (typeof fn !== 'function') {
                  throw new Error('PropertyWrite must be a callable function');
              }

              writeProperty = fn;
          };
      };
  }());
  var assignPropertyNode$1 = assignPropertyNode;

  var assignEventHelpers;
  (function () {
      // Static Private Variables (all vireo instances)
      assignEventHelpers = function (Module, publicAPI) {
          Module.eventHelpers = {};
          publicAPI.eventHelpers = {};

          var registerForControlEvent = function () {
              throw new Error('No event registration callback was supplied');
          };
          var unRegisterForControlEvent = function () {
              throw new Error('No event un-registration callback was supplied');
          };

          Module.eventHelpers.jsRegisterForControlEvent = function (
              viNamePointer,
              controlId,
              eventId,
              eventOracleIndex
          ) {
              var viName = Module.eggShell.dataReadString(viNamePointer);
              registerForControlEvent(viName, controlId, eventId, eventOracleIndex);
          };

          Module.eventHelpers.jsUnRegisterForControlEvent = function (
              viNamePointer,
              controlId,
              eventId,
              eventOracleIndex
          ) {
              var viName = Module.eggShell.dataReadString(viNamePointer);
              unRegisterForControlEvent(viName, controlId, eventId, eventOracleIndex);
          };

          publicAPI.eventHelpers.setRegisterForControlEventsFunction = Module.eventHelpers.setRegisterForControlEventsFunction = function (fn) {
              if (typeof fn !== 'function') {
                  throw new Error('RegisterForControlEvents must be a callable function');
              }

              registerForControlEvent = fn;
          };

          publicAPI.eventHelpers.setUnRegisterForControlEventsFunction = Module.eventHelpers.setUnRegisterForControlEventsFunction = function (fn) {
              if (typeof fn !== 'function') {
                  throw new Error('UnRegisterForControlEvents must be a callable function');
              }

              unRegisterForControlEvent = fn;
          };

          publicAPI.eventHelpers.occurEvent = Module.eventHelpers.occurEvent = function (eventOracleIndex, controlId, eventType, writeCallback, eventDataTypeValueRef, eventData) {
              // Allocate space for the event data using the type information passed in to occurEvent
              var allocatedDataValueRef = Module.eggShell.allocateData(eventDataTypeValueRef.typeRef);
              writeCallback(allocatedDataValueRef, eventData);
              Module._OccurEvent(Module.eggShell.v_userShell, eventOracleIndex, controlId, eventType, allocatedDataValueRef.typeRef, allocatedDataValueRef.dataRef);
              // Now that the data has been passed to Vireo, which should copy it, deallocate the memory
              Module.eggShell.deallocateData(allocatedDataValueRef);
          };
      };
  }());
  var assignEventHelpers$1 = assignEventHelpers;

  const moduleBuilders = [
      assignCoreHelpers$1,
      assignTypeHelpers$1,
      assignEggShell$1,
      assignHttpClient$1,
      assignJavaScriptInvoke$1,
      assignPropertyNode$1,
      assignEventHelpers$1
  ];

  class Vireo {
      constructor (Module) {
          let that = this;
          moduleBuilders.forEach(function (currBuilder) {
              currBuilder(Module, that);
          });
      }
  }

  const isObject = function (obj) {
      return typeof obj === 'object' && obj !== null;
  };

  const createModuleBase = function (config) {
      const Module = (isObject(config) && isObject(config.customModule)) ? config.customModule : {};

      // If the size of TOTAL_MEMORY does not match compile size then Emscripten aborts asynchronously
      // Because the asynchronous abort can be observed but the default behavior cannot be stopped
      // we instead detect this case early to provide a better message
      if (Module.TOTAL_MEMORY !== undefined) {
          throw new Error('Vireo no longer supports configuration of TOTAL_MEMORY. As growable memory is always enabled, configuration of TOTAL_MEMORY is no longer allowed.');
      }

      if (isObject(config)) {
          if (typeof config.wasmUrl === 'string') {
              Module.locateFile = function (path, prefix) {
                  if (path.endsWith('.wasm')) {
                      return config.wasmUrl;
                  }
                  return prefix + path;
              };
          }
      }

      Module.vireoPrint = function (text) {
          console.log(text);
      };

      Module.vireoPrintErr = function (text) {
          console.error(text);
      };

      // Module.print and Module.printErr references are saved internally by Emscripten JS code
      // So we forward to our own functions so that the target can be replaced as needed
      Module.print = function (text) {
          Module.vireoPrint(text);
      };

      Module.printErr = function (text) {
          Module.vireoPrintErr(text);
      };

      Module.vireoWasmReady = new Promise(function (resolve, reject) {
          Module.onRuntimeInitialized = function () {
              Module.onAbort = undefined;
              // DO NOT resolve with the Module object. The default behavior will cause an infinite Promise resolve loop
              // https://github.com/kripken/emscripten/issues/5820#issuecomment-390946487
              resolve();
          };

          // The lifetime of this abort handler is only until onRuntimeInitialized
          // After onRuntimeInitialized different operations should register their own onAbort handler as needed
          Module.onAbort = function () {
              reject();
          };
      });

      // Block creation of the then method
      // When createVireoCore is run on Module it tries to set a then method
      // The then method when used with Promises can easily get stuck in a loop:
      // See https://github.com/kripken/emscripten/issues/5820
      // We avoid resolving promises with the Module object so this shouldn't be necessary
      // but added as a guard to prevent the behavior from being introduced unexpectedly
      Object.defineProperty(Module, 'then', {
          set: function () {
              // intentionally blank
          },
          get: function () {
              return undefined;
          }
      });

      return Module;
  };

  const createInstance = function (createVireoCore, config) {
      if (config !== undefined && !isObject(config)) {
          throw new Error('The createInstance config parameter must be a valid configuration object or ommitted altogether, received: ' + config);
      }

      const Module = createModuleBase(config);
      createVireoCore(Module);

      return Module.vireoWasmReady.then(function () {
          return new Vireo(Module);
      });
  };

  const createInstance$1 = createInstance.bind(undefined, VireoCreateCoreModule);
  var vireo_loader_wasm32UnknownEmscripten_profile = {
      createInstance: createInstance$1,
      staticHelpers
  };

  return vireo_loader_wasm32UnknownEmscripten_profile;

}));
